(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("cdcts-sipjs", [], factory);
	else if(typeof exports === 'object')
		exports["cdcts-sipjs"] = factory();
	else
		root["cdcts-sipjs"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/cdcts-sipjs.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/weak-map.js":
/*!********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/weak-map.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/weak-map */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/weak-map.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/weak-map.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/weak-map.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.weak-map */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.weak-map.js");
__webpack_require__(/*! ../modules/es7.weak-map.of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.of.js");
__webpack_require__(/*! ../modules/es7.weak-map.from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.from.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").WeakMap;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-weak.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-weak.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").getWeak;
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js");
var $has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js")(0);
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.weak-map.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.weak-map.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js")(0);
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js");
var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js");
var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-weak.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.from.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.from.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js")('WeakMap');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.of.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.of.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js")('WeakMap');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "./node_modules/es6-event-emitter/dist/emitter.js":
/*!********************************************************!*\
  !*** ./node_modules/es6-event-emitter/dist/emitter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = __webpack_require__(/*! babel-runtime/core-js/weak-map */ "./node_modules/babel-runtime/core-js/weak-map.js");

var _weakMap2 = _interopRequireDefault(_weakMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _weakMap2.default();

var Emitter = function () {
	function Emitter() {
		(0, _classCallCheck3.default)(this, Emitter);

		emitter.set(this, {
			events: {}
		});

		this.eventLength = 0;
	}

	(0, _createClass3.default)(Emitter, [{
		key: 'on',
		value: function on(event, cb) {
			var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

			if (typeof cb === 'undefined') {
				throw new Error('You must provide a callback method.');
			}

			if (typeof cb !== 'function') {
				throw new TypeError('Listener must be a function');
			}

			this.events[event] = this.events[event] || [];
			this.events[event].push({
				cb: cb,
				once: once
			});

			this.eventLength++;

			return this;
		}
	}, {
		key: 'off',
		value: function off(event, cb) {
			if (typeof cb === 'undefined') {
				throw new Error('You must provide a callback method.');
			}

			if (typeof cb !== 'function') {
				throw new TypeError('Listener must be a function');
			}

			if (typeof this.events[event] === 'undefined') {
				throw new Error('Event not found - the event you provided is: ' + event);
			}

			var listeners = this.events[event];

			listeners.forEach(function (v, i) {
				if (v.cb === cb) {
					listeners.splice(i, 1);
				}
			});

			if (listeners.length === 0) {
				delete this.events[event];

				this.eventLength--;
			}

			return this;
		}
	}, {
		key: 'trigger',
		value: function trigger(event) {
			var _this = this;

			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			if (typeof event === 'undefined') {
				throw new Error('You must provide an event to trigger.');
			}

			var listeners = this.events[event];
			var onceListeners = [];

			if (typeof listeners !== 'undefined') {
				listeners.forEach(function (v, k) {
					v.cb.apply(_this, args);

					if (v.once) onceListeners.unshift(k);

					onceListeners.forEach(function (v, k) {
						listeners.splice(k, 1);
					});
				});
			}

			return this;
		}
	}, {
		key: 'once',
		value: function once(event, cb) {
			this.on(event, cb, true);
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			emitter.delete(this);

			this.eventLength = 0;
		}
	}, {
		key: 'events',
		get: function get() {
			return emitter.get(this).events;
		}
	}]);
	return Emitter;
}();

exports.default = Emitter;

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/sip.js/lib/ClientContext.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/ClientContext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
var ClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(ClientContext, _super);
    function ClientContext(ua, method, target, options) {
        var _this = _super.call(this) || this;
        _this.data = {};
        ClientContext.initializer(_this, ua, method, target, options);
        return _this;
    }
    ClientContext.initializer = function (objToConstruct, ua, method, originalTarget, options) {
        objToConstruct.type = Enums_1.TypeStrings.ClientContext;
        // Validate arguments
        if (originalTarget === undefined) {
            throw new TypeError("Not enough arguments");
        }
        objToConstruct.ua = ua;
        objToConstruct.logger = ua.getLogger("sip.clientcontext");
        objToConstruct.method = method;
        var target = ua.normalizeTarget(originalTarget);
        if (!target) {
            throw new TypeError("Invalid target: " + originalTarget);
        }
        var fromURI = ua.userAgentCore.configuration.aor;
        if (options && options.params && options.params.fromUri) {
            fromURI =
                (typeof options.params.fromUri === "string") ?
                    core_1.Grammar.URIParse(options.params.fromUri) :
                    options.params.fromUri;
            if (!fromURI) {
                throw new TypeError("Invalid from URI: " + options.params.fromUri);
            }
        }
        var toURI = target;
        if (options && options.params && options.params.toUri) {
            toURI =
                (typeof options.params.toUri === "string") ?
                    core_1.Grammar.URIParse(options.params.toUri) :
                    options.params.toUri;
            if (!toURI) {
                throw new TypeError("Invalid to URI: " + options.params.toUri);
            }
        }
        /* Options
        * - extraHeaders
        * - params
        * - contentType
        * - body
        */
        options = Object.create(options || Object.prototype);
        options = options || {};
        var extraHeaders = (options.extraHeaders || []).slice();
        var params = options.params || {};
        var bodyObj;
        if (options.body) {
            bodyObj = {
                body: options.body,
                contentType: options.contentType ? options.contentType : "application/sdp"
            };
            objToConstruct.body = bodyObj;
        }
        var body;
        if (bodyObj) {
            body = Utils_1.Utils.fromBodyObj(bodyObj);
        }
        // Build the request
        objToConstruct.request = ua.userAgentCore.makeOutgoingRequestMessage(method, target, fromURI, toURI, params, extraHeaders, body);
        /* Set other properties from the request */
        if (objToConstruct.request.from) {
            objToConstruct.localIdentity = objToConstruct.request.from;
        }
        if (objToConstruct.request.to) {
            objToConstruct.remoteIdentity = objToConstruct.request.to;
        }
    };
    ClientContext.prototype.send = function () {
        var _this = this;
        this.ua.userAgentCore.request(this.request, {
            onAccept: function (response) { return _this.receiveResponse(response.message); },
            onProgress: function (response) { return _this.receiveResponse(response.message); },
            onRedirect: function (response) { return _this.receiveResponse(response.message); },
            onReject: function (response) { return _this.receiveResponse(response.message); },
            onTrying: function (response) { return _this.receiveResponse(response.message); }
        });
        return this;
    };
    ClientContext.prototype.receiveResponse = function (response) {
        var statusCode = response.statusCode || 0;
        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
        switch (true) {
            case /^1[0-9]{2}$/.test(statusCode.toString()):
                this.emit("progress", response, cause);
                break;
            case /^2[0-9]{2}$/.test(statusCode.toString()):
                if (this.ua.applicants[this.toString()]) {
                    delete this.ua.applicants[this.toString()];
                }
                this.emit("accepted", response, cause);
                break;
            default:
                if (this.ua.applicants[this.toString()]) {
                    delete this.ua.applicants[this.toString()];
                }
                this.emit("rejected", response, cause);
                this.emit("failed", response, cause);
                break;
        }
    };
    ClientContext.prototype.onRequestTimeout = function () {
        this.emit("failed", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
    };
    ClientContext.prototype.onTransportError = function () {
        this.emit("failed", undefined, Constants_1.C.causes.CONNECTION_ERROR);
    };
    return ClientContext;
}(events_1.EventEmitter));
exports.ClientContext = ClientContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/Constants.js":
/*!**********************************************!*\
  !*** ./node_modules/sip.js/lib/Constants.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var version_1 = __webpack_require__(/*! ./version */ "./node_modules/sip.js/lib/version.js");
var C;
(function (C) {
    C.version = version_1.LIBRARY_VERSION;
    C.USER_AGENT = "SIP.js/" + version_1.LIBRARY_VERSION;
    // SIP scheme
    C.SIP = "sip";
    C.SIPS = "sips";
    // End and Failure causes
    var causes;
    (function (causes) {
        // Generic error causes
        causes["CONNECTION_ERROR"] = "Connection Error";
        causes["INTERNAL_ERROR"] = "Internal Error";
        causes["REQUEST_TIMEOUT"] = "Request Timeout";
        causes["SIP_FAILURE_CODE"] = "SIP Failure Code";
        // SIP error causes
        causes["ADDRESS_INCOMPLETE"] = "Address Incomplete";
        causes["AUTHENTICATION_ERROR"] = "Authentication Error";
        causes["BUSY"] = "Busy";
        causes["DIALOG_ERROR"] = "Dialog Error";
        causes["INCOMPATIBLE_SDP"] = "Incompatible SDP";
        causes["NOT_FOUND"] = "Not Found";
        causes["REDIRECTED"] = "Redirected";
        causes["REJECTED"] = "Rejected";
        causes["UNAVAILABLE"] = "Unavailable";
        // Session error causes
        causes["BAD_MEDIA_DESCRIPTION"] = "Bad Media Description";
        causes["CANCELED"] = "Canceled";
        causes["EXPIRES"] = "Expires";
        causes["NO_ACK"] = "No ACK";
        causes["NO_ANSWER"] = "No Answer";
        causes["NO_PRACK"] = "No PRACK";
        causes["RTP_TIMEOUT"] = "RTP Timeout";
        causes["USER_DENIED_MEDIA_ACCESS"] = "User Denied Media Access";
        causes["WEBRTC_ERROR"] = "WebRTC Error";
        causes["WEBRTC_NOT_SUPPORTED"] = "WebRTC Not Supported";
    })(causes = C.causes || (C.causes = {}));
    var supported;
    (function (supported) {
        supported["REQUIRED"] = "required";
        supported["SUPPORTED"] = "supported";
        supported["UNSUPPORTED"] = "none";
    })(supported = C.supported || (C.supported = {}));
    C.SIP_ERROR_CAUSES = {
        ADDRESS_INCOMPLETE: [484],
        AUTHENTICATION_ERROR: [401, 407],
        BUSY: [486, 600],
        INCOMPATIBLE_SDP: [488, 606],
        NOT_FOUND: [404, 604],
        REDIRECTED: [300, 301, 302, 305, 380],
        REJECTED: [403, 603],
        UNAVAILABLE: [480, 410, 408, 430]
    };
    // SIP Methods
    C.ACK = "ACK";
    C.BYE = "BYE";
    C.CANCEL = "CANCEL";
    C.INFO = "INFO";
    C.INVITE = "INVITE";
    C.MESSAGE = "MESSAGE";
    C.NOTIFY = "NOTIFY";
    C.OPTIONS = "OPTIONS";
    C.REGISTER = "REGISTER";
    C.UPDATE = "UPDATE";
    C.SUBSCRIBE = "SUBSCRIBE";
    C.PUBLISH = "PUBLISH";
    C.REFER = "REFER";
    C.PRACK = "PRACK";
    /* SIP Response Reasons
     * DOC: http://www.iana.org/assignments/sip-parameters
     * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
     */
    C.REASON_PHRASE = {
        100: "Trying",
        180: "Ringing",
        181: "Call Is Being Forwarded",
        182: "Queued",
        183: "Session Progress",
        199: "Early Dialog Terminated",
        200: "OK",
        202: "Accepted",
        204: "No Notification",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        305: "Use Proxy",
        380: "Alternative Service",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        410: "Gone",
        412: "Conditional Request Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Long",
        415: "Unsupported Media Type",
        416: "Unsupported URI Scheme",
        417: "Unknown Resource-Priority",
        420: "Bad Extension",
        421: "Extension Required",
        422: "Session Interval Too Small",
        423: "Interval Too Brief",
        428: "Use Identity Header",
        429: "Provide Referrer Identity",
        430: "Flow Failed",
        433: "Anonymity Disallowed",
        436: "Bad Identity-Info",
        437: "Unsupported Certificate",
        438: "Invalid Identity Header",
        439: "First Hop Lacks Outbound Support",
        440: "Max-Breadth Exceeded",
        469: "Bad Info Package",
        470: "Consent Needed",
        478: "Unresolvable Destination",
        480: "Temporarily Unavailable",
        481: "Call/Transaction Does Not Exist",
        482: "Loop Detected",
        483: "Too Many Hops",
        484: "Address Incomplete",
        485: "Ambiguous",
        486: "Busy Here",
        487: "Request Terminated",
        488: "Not Acceptable Here",
        489: "Bad Event",
        491: "Request Pending",
        493: "Undecipherable",
        494: "Security Agreement Required",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Server Time-out",
        505: "Version Not Supported",
        513: "Message Too Large",
        580: "Precondition Failure",
        600: "Busy Everywhere",
        603: "Decline",
        604: "Does Not Exist Anywhere",
        606: "Not Acceptable"
    };
    /* SIP Option Tags
     * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
     */
    C.OPTION_TAGS = {
        "100rel": true,
        "199": true,
        "answermode": true,
        "early-session": true,
        "eventlist": true,
        "explicitsub": true,
        "from-change": true,
        "geolocation-http": true,
        "geolocation-sip": true,
        "gin": true,
        "gruu": true,
        "histinfo": true,
        "ice": true,
        "join": true,
        "multiple-refer": true,
        "norefersub": true,
        "nosub": true,
        "outbound": true,
        "path": true,
        "policy": true,
        "precondition": true,
        "pref": true,
        "privacy": true,
        "recipient-list-invite": true,
        "recipient-list-message": true,
        "recipient-list-subscribe": true,
        "replaces": true,
        "resource-priority": true,
        "sdp-anat": true,
        "sec-agree": true,
        "tdialog": true,
        "timer": true,
        "uui": true // RFC 7433
    };
    var dtmfType;
    (function (dtmfType) {
        dtmfType["INFO"] = "info";
        dtmfType["RTP"] = "rtp";
    })(dtmfType = C.dtmfType || (C.dtmfType = {}));
})(C = exports.C || (exports.C = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/Enums.js":
/*!******************************************!*\
  !*** ./node_modules/sip.js/lib/Enums.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// enums can't really be declared, so they are set here.
// pulled out of individual files to avoid circular dependencies
Object.defineProperty(exports, "__esModule", { value: true });
var DialogStatus;
(function (DialogStatus) {
    DialogStatus[DialogStatus["STATUS_EARLY"] = 1] = "STATUS_EARLY";
    DialogStatus[DialogStatus["STATUS_CONFIRMED"] = 2] = "STATUS_CONFIRMED";
})(DialogStatus = exports.DialogStatus || (exports.DialogStatus = {}));
var SessionStatus;
(function (SessionStatus) {
    // Session states
    SessionStatus[SessionStatus["STATUS_NULL"] = 0] = "STATUS_NULL";
    SessionStatus[SessionStatus["STATUS_INVITE_SENT"] = 1] = "STATUS_INVITE_SENT";
    SessionStatus[SessionStatus["STATUS_1XX_RECEIVED"] = 2] = "STATUS_1XX_RECEIVED";
    SessionStatus[SessionStatus["STATUS_INVITE_RECEIVED"] = 3] = "STATUS_INVITE_RECEIVED";
    SessionStatus[SessionStatus["STATUS_WAITING_FOR_ANSWER"] = 4] = "STATUS_WAITING_FOR_ANSWER";
    SessionStatus[SessionStatus["STATUS_ANSWERED"] = 5] = "STATUS_ANSWERED";
    SessionStatus[SessionStatus["STATUS_WAITING_FOR_PRACK"] = 6] = "STATUS_WAITING_FOR_PRACK";
    SessionStatus[SessionStatus["STATUS_WAITING_FOR_ACK"] = 7] = "STATUS_WAITING_FOR_ACK";
    SessionStatus[SessionStatus["STATUS_CANCELED"] = 8] = "STATUS_CANCELED";
    SessionStatus[SessionStatus["STATUS_TERMINATED"] = 9] = "STATUS_TERMINATED";
    SessionStatus[SessionStatus["STATUS_ANSWERED_WAITING_FOR_PRACK"] = 10] = "STATUS_ANSWERED_WAITING_FOR_PRACK";
    SessionStatus[SessionStatus["STATUS_EARLY_MEDIA"] = 11] = "STATUS_EARLY_MEDIA";
    SessionStatus[SessionStatus["STATUS_CONFIRMED"] = 12] = "STATUS_CONFIRMED";
})(SessionStatus = exports.SessionStatus || (exports.SessionStatus = {}));
var TypeStrings;
(function (TypeStrings) {
    TypeStrings[TypeStrings["ClientContext"] = 0] = "ClientContext";
    TypeStrings[TypeStrings["ConfigurationError"] = 1] = "ConfigurationError";
    TypeStrings[TypeStrings["Dialog"] = 2] = "Dialog";
    TypeStrings[TypeStrings["DigestAuthentication"] = 3] = "DigestAuthentication";
    TypeStrings[TypeStrings["DTMF"] = 4] = "DTMF";
    TypeStrings[TypeStrings["IncomingMessage"] = 5] = "IncomingMessage";
    TypeStrings[TypeStrings["IncomingRequest"] = 6] = "IncomingRequest";
    TypeStrings[TypeStrings["IncomingResponse"] = 7] = "IncomingResponse";
    TypeStrings[TypeStrings["InvalidStateError"] = 8] = "InvalidStateError";
    TypeStrings[TypeStrings["InviteClientContext"] = 9] = "InviteClientContext";
    TypeStrings[TypeStrings["InviteServerContext"] = 10] = "InviteServerContext";
    TypeStrings[TypeStrings["Logger"] = 11] = "Logger";
    TypeStrings[TypeStrings["LoggerFactory"] = 12] = "LoggerFactory";
    TypeStrings[TypeStrings["MethodParameterError"] = 13] = "MethodParameterError";
    TypeStrings[TypeStrings["NameAddrHeader"] = 14] = "NameAddrHeader";
    TypeStrings[TypeStrings["NotSupportedError"] = 15] = "NotSupportedError";
    TypeStrings[TypeStrings["OutgoingRequest"] = 16] = "OutgoingRequest";
    TypeStrings[TypeStrings["Parameters"] = 17] = "Parameters";
    TypeStrings[TypeStrings["PublishContext"] = 18] = "PublishContext";
    TypeStrings[TypeStrings["ReferClientContext"] = 19] = "ReferClientContext";
    TypeStrings[TypeStrings["ReferServerContext"] = 20] = "ReferServerContext";
    TypeStrings[TypeStrings["RegisterContext"] = 21] = "RegisterContext";
    TypeStrings[TypeStrings["RenegotiationError"] = 22] = "RenegotiationError";
    TypeStrings[TypeStrings["RequestSender"] = 23] = "RequestSender";
    TypeStrings[TypeStrings["ServerContext"] = 24] = "ServerContext";
    TypeStrings[TypeStrings["Session"] = 25] = "Session";
    TypeStrings[TypeStrings["SessionDescriptionHandler"] = 26] = "SessionDescriptionHandler";
    TypeStrings[TypeStrings["SessionDescriptionHandlerError"] = 27] = "SessionDescriptionHandlerError";
    TypeStrings[TypeStrings["SessionDescriptionHandlerObserver"] = 28] = "SessionDescriptionHandlerObserver";
    TypeStrings[TypeStrings["Subscription"] = 29] = "Subscription";
    TypeStrings[TypeStrings["Transport"] = 30] = "Transport";
    TypeStrings[TypeStrings["UA"] = 31] = "UA";
    TypeStrings[TypeStrings["URI"] = 32] = "URI";
})(TypeStrings = exports.TypeStrings || (exports.TypeStrings = {}));
// UA status codes
var UAStatus;
(function (UAStatus) {
    UAStatus[UAStatus["STATUS_INIT"] = 0] = "STATUS_INIT";
    UAStatus[UAStatus["STATUS_STARTING"] = 1] = "STATUS_STARTING";
    UAStatus[UAStatus["STATUS_READY"] = 2] = "STATUS_READY";
    UAStatus[UAStatus["STATUS_USER_CLOSED"] = 3] = "STATUS_USER_CLOSED";
    UAStatus[UAStatus["STATUS_NOT_READY"] = 4] = "STATUS_NOT_READY";
})(UAStatus = exports.UAStatus || (exports.UAStatus = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/Exceptions.js":
/*!***********************************************!*\
  !*** ./node_modules/sip.js/lib/Exceptions.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
// tslint:disable:max-classes-per-file
var Exceptions;
(function (Exceptions) {
    /**
     * Indicates the session description handler has closed.
     * Occurs when getDescription() or setDescription() are called after close() has been called.
     * Occurs when close() is called while getDescription() or setDescription() are in progress.
     */
    var ClosedSessionDescriptionHandlerError = /** @class */ (function (_super) {
        tslib_1.__extends(ClosedSessionDescriptionHandlerError, _super);
        function ClosedSessionDescriptionHandlerError() {
            return _super.call(this, "The session description handler has closed.") || this;
        }
        return ClosedSessionDescriptionHandlerError;
    }(core_1.Exception));
    Exceptions.ClosedSessionDescriptionHandlerError = ClosedSessionDescriptionHandlerError;
    /**
     * Indicates the session terminated before the action completed.
     */
    var TerminatedSessionError = /** @class */ (function (_super) {
        tslib_1.__extends(TerminatedSessionError, _super);
        function TerminatedSessionError() {
            return _super.call(this, "The session has terminated.") || this;
        }
        return TerminatedSessionError;
    }(core_1.Exception));
    Exceptions.TerminatedSessionError = TerminatedSessionError;
    /**
     * Unsupported session description content type.
     */
    var UnsupportedSessionDescriptionContentTypeError = /** @class */ (function (_super) {
        tslib_1.__extends(UnsupportedSessionDescriptionContentTypeError, _super);
        function UnsupportedSessionDescriptionContentTypeError(message) {
            return _super.call(this, message ? message : "Unsupported session description content type.") || this;
        }
        return UnsupportedSessionDescriptionContentTypeError;
    }(core_1.Exception));
    Exceptions.UnsupportedSessionDescriptionContentTypeError = UnsupportedSessionDescriptionContentTypeError;
})(Exceptions = exports.Exceptions || (exports.Exceptions = {}));
/**
 * DEPRECATED: The original implementation of exceptions in this library attempted to
 * deal with the lack of type checking in JavaScript by adding a "type" attribute
 * to objects and using that to discriminate. On top of that it layered allcoated
 * "code" numbers and constant "name" strings. All of that is unnecessary when using
 * TypeScript, inheriting from Error and properly setting up the prototype chain...
 */
var LegacyException = /** @class */ (function (_super) {
    tslib_1.__extends(LegacyException, _super);
    function LegacyException(code, name, message) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.name = name;
        _this.message = message;
        return _this;
    }
    return LegacyException;
}(core_1.Exception));
(function (Exceptions) {
    var ConfigurationError = /** @class */ (function (_super) {
        tslib_1.__extends(ConfigurationError, _super);
        function ConfigurationError(parameter, value) {
            var _this = _super.call(this, 1, "CONFIGURATION_ERROR", (!value) ? "Missing parameter: " + parameter :
                "Invalid value " + JSON.stringify(value) + " for parameter '" + parameter + "'") || this;
            _this.type = Enums_1.TypeStrings.ConfigurationError;
            _this.parameter = parameter;
            _this.value = value;
            return _this;
        }
        return ConfigurationError;
    }(LegacyException));
    Exceptions.ConfigurationError = ConfigurationError;
    var InvalidStateError = /** @class */ (function (_super) {
        tslib_1.__extends(InvalidStateError, _super);
        function InvalidStateError(status) {
            var _this = _super.call(this, 2, "INVALID_STATE_ERROR", "Invalid status: " + status) || this;
            _this.type = Enums_1.TypeStrings.InvalidStateError;
            _this.status = status;
            return _this;
        }
        return InvalidStateError;
    }(LegacyException));
    Exceptions.InvalidStateError = InvalidStateError;
    var NotSupportedError = /** @class */ (function (_super) {
        tslib_1.__extends(NotSupportedError, _super);
        function NotSupportedError(message) {
            var _this = _super.call(this, 3, "NOT_SUPPORTED_ERROR", message) || this;
            _this.type = Enums_1.TypeStrings.NotSupportedError;
            return _this;
        }
        return NotSupportedError;
    }(LegacyException));
    Exceptions.NotSupportedError = NotSupportedError;
    // 4 was GetDescriptionError, which was deprecated and now removed
    var RenegotiationError = /** @class */ (function (_super) {
        tslib_1.__extends(RenegotiationError, _super);
        function RenegotiationError(message) {
            var _this = _super.call(this, 5, "RENEGOTIATION_ERROR", message) || this;
            _this.type = Enums_1.TypeStrings.RenegotiationError;
            return _this;
        }
        return RenegotiationError;
    }(LegacyException));
    Exceptions.RenegotiationError = RenegotiationError;
    var MethodParameterError = /** @class */ (function (_super) {
        tslib_1.__extends(MethodParameterError, _super);
        function MethodParameterError(method, parameter, value) {
            var _this = _super.call(this, 6, "METHOD_PARAMETER_ERROR", (!value) ?
                "Missing parameter: " + parameter :
                "Invalid value " + JSON.stringify(value) + " for parameter '" + parameter + "'") || this;
            _this.type = Enums_1.TypeStrings.MethodParameterError;
            _this.method = method;
            _this.parameter = parameter;
            _this.value = value;
            return _this;
        }
        return MethodParameterError;
    }(LegacyException));
    Exceptions.MethodParameterError = MethodParameterError;
    // 7 was TransportError, which was replaced
    var SessionDescriptionHandlerError = /** @class */ (function (_super) {
        tslib_1.__extends(SessionDescriptionHandlerError, _super);
        function SessionDescriptionHandlerError(method, error, message) {
            var _this = _super.call(this, 8, "SESSION_DESCRIPTION_HANDLER_ERROR", message || "Error with Session Description Handler") || this;
            _this.type = Enums_1.TypeStrings.SessionDescriptionHandlerError;
            _this.method = method;
            _this.error = error;
            return _this;
        }
        return SessionDescriptionHandlerError;
    }(LegacyException));
    Exceptions.SessionDescriptionHandlerError = SessionDescriptionHandlerError;
})(Exceptions = exports.Exceptions || (exports.Exceptions = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/PublishContext.js":
/*!***************************************************!*\
  !*** ./node_modules/sip.js/lib/PublishContext.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/**
 * SIP Publish (SIP Extension for Event State Publication RFC3903)
 * @class Class creating a SIP PublishContext.
 */
var PublishContext = /** @class */ (function (_super) {
    tslib_1.__extends(PublishContext, _super);
    function PublishContext(ua, target, event, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        options.extraHeaders = (options.extraHeaders || []).slice();
        options.contentType = (options.contentType || "text/plain");
        if (typeof options.expires !== "number" || (options.expires % 1) !== 0) {
            options.expires = 3600;
        }
        else {
            options.expires = Number(options.expires);
        }
        if (typeof (options.unpublishOnClose) !== "boolean") {
            options.unpublishOnClose = true;
        }
        if (target === undefined || target === null || target === "") {
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Target", target);
        }
        else {
            target = ua.normalizeTarget(target);
            if (target === undefined) {
                throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Target", target);
            }
        }
        _this = _super.call(this, ua, Constants_1.C.PUBLISH, target, options) || this;
        _this.type = Enums_1.TypeStrings.PublishContext;
        _this.options = options;
        _this.target = target;
        if (event === undefined || event === null || event === "") {
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Event", event);
        }
        else {
            _this.event = event;
        }
        _this.logger = ua.getLogger("sip.publish");
        _this.pubRequestExpires = _this.options.expires;
        return _this;
    }
    /**
     * Publish
     * @param {string} Event body to publish, optional
     */
    PublishContext.prototype.publish = function (body) {
        // Clean up before the run
        if (this.publishRefreshTimer) {
            clearTimeout(this.publishRefreshTimer);
            this.publishRefreshTimer = undefined;
        }
        // is Inital or Modify request
        this.options.body = body;
        this.pubRequestBody = this.options.body;
        if (this.pubRequestExpires === 0) {
            // This is Initial request after unpublish
            this.pubRequestExpires = this.options.expires;
            this.pubRequestEtag = undefined;
        }
        if (!(this.ua.publishers[this.target.toString() + ":" + this.event])) {
            this.ua.publishers[this.target.toString() + ":" + this.event] = this;
        }
        this.sendPublishRequest();
    };
    /**
     * Unpublish
     */
    PublishContext.prototype.unpublish = function () {
        // Clean up before the run
        if (this.publishRefreshTimer) {
            clearTimeout(this.publishRefreshTimer);
            this.publishRefreshTimer = undefined;
        }
        this.pubRequestBody = undefined;
        this.pubRequestExpires = 0;
        if (this.pubRequestEtag !== undefined) {
            this.sendPublishRequest();
        }
    };
    /**
     * Close
     */
    PublishContext.prototype.close = function () {
        // Send unpublish, if requested
        if (this.options.unpublishOnClose) {
            this.unpublish();
        }
        else {
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            this.pubRequestBody = undefined;
            this.pubRequestExpires = 0;
            this.pubRequestEtag = undefined;
        }
        if (this.ua.publishers[this.target.toString() + ":" + this.event]) {
            delete this.ua.publishers[this.target.toString() + ":" + this.event];
        }
    };
    PublishContext.prototype.onRequestTimeout = function () {
        _super.prototype.onRequestTimeout.call(this);
        this.emit("unpublished", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
    };
    PublishContext.prototype.onTransportError = function () {
        _super.prototype.onTransportError.call(this);
        this.emit("unpublished", undefined, Constants_1.C.causes.CONNECTION_ERROR);
    };
    PublishContext.prototype.receiveResponse = function (response) {
        var _this = this;
        var statusCode = response.statusCode || 0;
        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
        switch (true) {
            case /^1[0-9]{2}$/.test(statusCode.toString()):
                this.emit("progress", response, cause);
                break;
            case /^2[0-9]{2}$/.test(statusCode.toString()):
                // Set SIP-Etag
                if (response.hasHeader("SIP-ETag")) {
                    this.pubRequestEtag = response.getHeader("SIP-ETag");
                }
                else {
                    this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH");
                }
                // Update Expire
                if (response.hasHeader("Expires")) {
                    var expires = Number(response.getHeader("Expires"));
                    if (typeof expires === "number" && expires >= 0 && expires <= this.pubRequestExpires) {
                        this.pubRequestExpires = expires;
                    }
                    else {
                        this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
                    }
                }
                else {
                    this.logger.warn("Expires header missing in a 200-class response to PUBLISH");
                }
                if (this.pubRequestExpires !== 0) {
                    // Schedule refresh
                    this.publishRefreshTimer = setTimeout(function () { return _this.refreshRequest(); }, this.pubRequestExpires * 900);
                    this.emit("published", response, cause);
                }
                else {
                    this.emit("unpublished", response, cause);
                }
                break;
            case /^412$/.test(statusCode.toString()):
                // 412 code means no matching ETag - possibly the PUBLISH expired
                // Resubmit as new request, if the current request is not a "remove"
                if (this.pubRequestEtag !== undefined && this.pubRequestExpires !== 0) {
                    this.logger.warn("412 response to PUBLISH, recovering");
                    this.pubRequestEtag = undefined;
                    this.emit("progress", response, cause);
                    this.publish(this.options.body);
                }
                else {
                    this.logger.warn("412 response to PUBLISH, recovery failed");
                    this.pubRequestExpires = 0;
                    this.emit("failed", response, cause);
                    this.emit("unpublished", response, cause);
                }
                break;
            case /^423$/.test(statusCode.toString()):
                // 423 code means we need to adjust the Expires interval up
                if (this.pubRequestExpires !== 0 && response.hasHeader("Min-Expires")) {
                    var minExpires = Number(response.getHeader("Min-Expires"));
                    if (typeof minExpires === "number" || minExpires > this.pubRequestExpires) {
                        this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover");
                        this.pubRequestExpires = minExpires;
                        this.emit("progress", response, cause);
                        this.publish(this.options.body);
                    }
                    else {
                        this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH");
                        this.pubRequestExpires = 0;
                        this.emit("failed", response, cause);
                        this.emit("unpublished", response, cause);
                    }
                }
                else {
                    this.logger.warn("423 response to PUBLISH, recovery failed");
                    this.pubRequestExpires = 0;
                    this.emit("failed", response, cause);
                    this.emit("unpublished", response, cause);
                }
                break;
            default:
                this.pubRequestExpires = 0;
                this.emit("failed", response, cause);
                this.emit("unpublished", response, cause);
                break;
        }
        // Do the cleanup
        if (this.pubRequestExpires === 0) {
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            this.pubRequestBody = undefined;
            this.pubRequestEtag = undefined;
        }
    };
    PublishContext.prototype.send = function () {
        var _this = this;
        this.ua.userAgentCore.publish(this.request, {
            onAccept: function (response) { return _this.receiveResponse(response.message); },
            onProgress: function (response) { return _this.receiveResponse(response.message); },
            onRedirect: function (response) { return _this.receiveResponse(response.message); },
            onReject: function (response) { return _this.receiveResponse(response.message); },
            onTrying: function (response) { return _this.receiveResponse(response.message); }
        });
        return this;
    };
    PublishContext.prototype.refreshRequest = function () {
        // Clean up before the run
        if (this.publishRefreshTimer) {
            clearTimeout(this.publishRefreshTimer);
            this.publishRefreshTimer = undefined;
        }
        // This is Refresh request
        this.pubRequestBody = undefined;
        if (this.pubRequestEtag === undefined) {
            // Request not valid
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Body", undefined);
        }
        if (this.pubRequestExpires === 0) {
            // Request not valid
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Expire", this.pubRequestExpires);
        }
        this.sendPublishRequest();
    };
    PublishContext.prototype.sendPublishRequest = function () {
        var reqOptions = Object.create(this.options || Object.prototype);
        reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();
        reqOptions.extraHeaders.push("Event: " + this.event);
        reqOptions.extraHeaders.push("Expires: " + this.pubRequestExpires);
        if (this.pubRequestEtag !== undefined) {
            reqOptions.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
        }
        var ruri = this.target instanceof core_1.URI ? this.target : this.ua.normalizeTarget(this.target);
        if (!ruri) {
            throw new Error("ruri undefined.");
        }
        var params = this.options.params || {};
        var bodyObj;
        if (this.pubRequestBody !== undefined) {
            bodyObj = {
                body: this.pubRequestBody,
                contentType: this.options.contentType
            };
        }
        var body;
        if (bodyObj) {
            body = Utils_1.Utils.fromBodyObj(bodyObj);
        }
        this.request = this.ua.userAgentCore.makeOutgoingRequestMessage(Constants_1.C.PUBLISH, ruri, params.fromUri ? params.fromUri : this.ua.userAgentCore.configuration.aor, params.toUri ? params.toUri : this.target, params, reqOptions.extraHeaders, body);
        this.send();
    };
    return PublishContext;
}(ClientContext_1.ClientContext));
exports.PublishContext = PublishContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/ReferContext.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/ReferContext.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
// tslint:disable-next-line:max-classes-per-file
var ReferClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(ReferClientContext, _super);
    function ReferClientContext(ua, applicant, target, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        if (ua === undefined || applicant === undefined || target === undefined) {
            throw new TypeError("Not enough arguments");
        }
        _this = _super.call(this, ua, Constants_1.C.REFER, applicant.remoteIdentity.uri.toString(), options) || this;
        _this.type = Enums_1.TypeStrings.ReferClientContext;
        _this.options = options;
        _this.extraHeaders = (_this.options.extraHeaders || []).slice();
        _this.applicant = applicant;
        _this.target = _this.initReferTo(target);
        if (_this.ua) {
            _this.extraHeaders.push("Referred-By: <" + _this.ua.configuration.uri + ">");
        }
        // TODO: Check that this is correct isc/icc
        _this.extraHeaders.push("Contact: " + applicant.contact);
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        _this.extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        _this.extraHeaders.push("Refer-To: " + _this.target);
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        return _this;
    }
    ReferClientContext.prototype.refer = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var extraHeaders = (this.extraHeaders || []).slice();
        if (options.extraHeaders) {
            extraHeaders.concat(options.extraHeaders);
        }
        this.applicant.sendRequest(Constants_1.C.REFER, {
            extraHeaders: this.extraHeaders,
            receiveResponse: function (response) {
                var statusCode = response && response.statusCode ? response.statusCode.toString() : "";
                if (/^1[0-9]{2}$/.test(statusCode)) {
                    _this.emit("referRequestProgress", _this);
                }
                else if (/^2[0-9]{2}$/.test(statusCode)) {
                    _this.emit("referRequestAccepted", _this);
                }
                else if (/^[4-6][0-9]{2}$/.test(statusCode)) {
                    _this.emit("referRequestRejected", _this);
                }
                if (options.receiveResponse) {
                    options.receiveResponse(response);
                }
            }
        });
        return this;
    };
    ReferClientContext.prototype.receiveNotify = function (request) {
        // If we can correctly handle this, then we need to send a 200 OK!
        var contentType = request.message.hasHeader("Content-Type") ?
            request.message.getHeader("Content-Type") : undefined;
        if (contentType && contentType.search(/^message\/sipfrag/) !== -1) {
            var messageBody = core_1.Grammar.parse(request.message.body, "sipfrag");
            if (messageBody === -1) {
                request.reject({
                    statusCode: 489,
                    reasonPhrase: "Bad Event"
                });
                return;
            }
            switch (true) {
                case (/^1[0-9]{2}$/.test(messageBody.status_code)):
                    this.emit("referProgress", this);
                    break;
                case (/^2[0-9]{2}$/.test(messageBody.status_code)):
                    this.emit("referAccepted", this);
                    if (!this.options.activeAfterTransfer && this.applicant.terminate) {
                        this.applicant.terminate();
                    }
                    break;
                default:
                    this.emit("referRejected", this);
                    break;
            }
            request.accept();
            this.emit("notify", request.message);
            return;
        }
        request.reject({
            statusCode: 489,
            reasonPhrase: "Bad Event"
        });
    };
    ReferClientContext.prototype.initReferTo = function (target) {
        var stringOrURI;
        if (typeof target === "string") {
            // REFER without Replaces (Blind Transfer)
            var targetString = core_1.Grammar.parse(target, "Refer_To");
            stringOrURI = targetString && targetString.uri ? targetString.uri : target;
            // Check target validity
            var targetUri = this.ua.normalizeTarget(target);
            if (!targetUri) {
                throw new TypeError("Invalid target: " + target);
            }
            stringOrURI = targetUri;
        }
        else {
            // REFER with Replaces (Attended Transfer)
            if (!target.session) {
                throw new Error("Session undefined.");
            }
            var displayName = target.remoteIdentity.friendlyName;
            var remoteTarget = target.session.remoteTarget.toString();
            var callId = target.session.callId;
            var remoteTag = target.session.remoteTag;
            var localTag = target.session.localTag;
            var replaces = encodeURIComponent(callId + ";to-tag=" + remoteTag + ";from-tag=" + localTag);
            stringOrURI = "\"" + displayName + "\" <" + remoteTarget + "?Replaces=" + replaces + ">";
        }
        return stringOrURI;
    };
    return ReferClientContext;
}(ClientContext_1.ClientContext));
exports.ReferClientContext = ReferClientContext;
// tslint:disable-next-line:max-classes-per-file
var ReferServerContext = /** @class */ (function (_super) {
    tslib_1.__extends(ReferServerContext, _super);
    function ReferServerContext(ua, incomingRequest, session) {
        var _this = _super.call(this, ua, incomingRequest) || this;
        _this.session = session;
        _this.type = Enums_1.TypeStrings.ReferServerContext;
        _this.ua = ua;
        _this.status = Enums_1.SessionStatus.STATUS_INVITE_RECEIVED;
        _this.fromTag = _this.request.fromTag;
        _this.id = _this.request.callId + _this.fromTag;
        _this.contact = _this.ua.contact.toString();
        _this.logger = ua.getLogger("sip.referservercontext", _this.id);
        // Needed to send the NOTIFY's
        _this.cseq = Math.floor(Math.random() * 10000);
        _this.callId = _this.request.callId;
        _this.fromUri = _this.request.to.uri;
        _this.fromTag = _this.request.to.parameters.tag;
        _this.remoteTarget = _this.request.headers.Contact[0].parsed.uri;
        _this.toUri = _this.request.from.uri;
        _this.toTag = _this.request.fromTag;
        _this.routeSet = _this.request.getHeaders("record-route");
        // RFC 3515 2.4.1
        if (!_this.request.hasHeader("refer-to")) {
            _this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting refer.");
            _this.reject();
            return _this;
        }
        _this.referTo = _this.request.parseHeader("refer-to");
        // TODO: Must set expiration timer and send 202 if there is no response by then
        _this.referredSession = _this.ua.findSession(_this.request);
        if (_this.request.hasHeader("referred-by")) {
            _this.referredBy = _this.request.getHeader("referred-by");
        }
        if (_this.referTo.uri.hasHeader("replaces")) {
            _this.replaces = _this.referTo.uri.getHeader("replaces");
        }
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER;
        return _this;
    }
    ReferServerContext.prototype.progress = function () {
        if (this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.incomingRequest.trying();
    };
    ReferServerContext.prototype.reject = function (options) {
        if (options === void 0) { options = {}; }
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.logger.log("Rejecting refer");
        this.status = Enums_1.SessionStatus.STATUS_TERMINATED;
        _super.prototype.reject.call(this, options);
        this.emit("referRequestRejected", this);
    };
    ReferServerContext.prototype.accept = function (options, modifiers) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
            this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
        }
        else {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.incomingRequest.accept({
            statusCode: 202,
            reasonPhrase: "Accepted"
        });
        this.emit("referRequestAccepted", this);
        if (options.followRefer) {
            this.logger.log("Accepted refer, attempting to automatically follow it");
            var target = this.referTo.uri;
            if (!target.scheme || !target.scheme.match("^sips?$")) {
                this.logger.error("SIP.js can only automatically follow SIP refer target");
                this.reject();
                return;
            }
            var inviteOptions = options.inviteOptions || {};
            var extraHeaders = (inviteOptions.extraHeaders || []).slice();
            if (this.replaces) {
                // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
                extraHeaders.push("Replaces: " + decodeURIComponent(this.replaces));
            }
            if (this.referredBy) {
                extraHeaders.push("Referred-By: " + this.referredBy);
            }
            inviteOptions.extraHeaders = extraHeaders;
            target.clearHeaders();
            this.targetSession = this.ua.invite(target.toString(), inviteOptions, modifiers);
            this.emit("referInviteSent", this);
            if (this.targetSession) {
                this.targetSession.once("progress", function (response) {
                    var statusCode = response.statusCode || 100;
                    var reasonPhrase = response.reasonPhrase;
                    _this.sendNotify(("SIP/2.0 " + statusCode + " " + reasonPhrase).trim());
                    _this.emit("referProgress", _this);
                    if (_this.referredSession) {
                        _this.referredSession.emit("referProgress", _this);
                    }
                });
                this.targetSession.once("accepted", function () {
                    _this.logger.log("Successfully followed the refer");
                    _this.sendNotify("SIP/2.0 200 OK");
                    _this.emit("referAccepted", _this);
                    if (_this.referredSession) {
                        _this.referredSession.emit("referAccepted", _this);
                    }
                });
                var referFailed = function (response) {
                    if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return; // No throw here because it is possible this gets called multiple times
                    }
                    _this.logger.log("Refer was not successful. Resuming session");
                    if (response && response.statusCode === 429) {
                        _this.logger.log("Alerting referrer that identity is required.");
                        _this.sendNotify("SIP/2.0 429 Provide Referrer Identity");
                        return;
                    }
                    _this.sendNotify("SIP/2.0 603 Declined");
                    // Must change the status after sending the final Notify or it will not send due to check
                    _this.status = Enums_1.SessionStatus.STATUS_TERMINATED;
                    _this.emit("referRejected", _this);
                    if (_this.referredSession) {
                        _this.referredSession.emit("referRejected");
                    }
                };
                this.targetSession.once("rejected", referFailed);
                this.targetSession.once("failed", referFailed);
            }
        }
        else {
            this.logger.log("Accepted refer, but did not automatically follow it");
            this.sendNotify("SIP/2.0 200 OK");
            this.emit("referAccepted", this);
            if (this.referredSession) {
                this.referredSession.emit("referAccepted", this);
            }
        }
    };
    ReferServerContext.prototype.sendNotify = function (bodyStr) {
        // FIXME: Ported this. Clean it up. Session knows its state.
        if (this.status !== Enums_1.SessionStatus.STATUS_ANSWERED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (core_1.Grammar.parse(bodyStr, "sipfrag") === -1) {
            throw new Error("sipfrag body is required to send notify for refer");
        }
        var body = {
            contentDisposition: "render",
            contentType: "message/sipfrag",
            content: bodyStr
        };
        // NOTIFY requests sent in same dialog as in dialog REFER.
        if (this.session) {
            this.session.notify(undefined, {
                extraHeaders: [
                    "Event: refer",
                    "Subscription-State: terminated",
                ],
                body: body
            });
            return;
        }
        // The implicit subscription created by a REFER is the same as a
        // subscription created with a SUBSCRIBE request.  The agent issuing the
        // REFER can terminate this subscription prematurely by unsubscribing
        // using the mechanisms described in [2].  Terminating a subscription,
        // either by explicitly unsubscribing or rejecting NOTIFY, is not an
        // indication that the referenced request should be withdrawn or
        // abandoned.
        // https://tools.ietf.org/html/rfc3515#section-2.4.4
        // NOTIFY requests sent in new dialog for out of dialog REFER.
        // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.
        var request = this.ua.userAgentCore.makeOutgoingRequestMessage(Constants_1.C.NOTIFY, this.remoteTarget, this.fromUri, this.toUri, {
            cseq: this.cseq += 1,
            callId: this.callId,
            fromTag: this.fromTag,
            toTag: this.toTag,
            routeSet: this.routeSet
        }, [
            "Event: refer",
            "Subscription-State: terminated",
            "Content-Type: message/sipfrag"
        ], body);
        var transport = this.ua.transport;
        if (!transport) {
            throw new Error("Transport undefined.");
        }
        var user = {
            loggerFactory: this.ua.getLoggerFactory()
        };
        var nic = new core_1.NonInviteClientTransaction(request, transport, user);
    };
    ReferServerContext.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    return ReferServerContext;
}(ServerContext_1.ServerContext));
exports.ReferServerContext = ReferServerContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/RegisterContext.js":
/*!****************************************************!*\
  !*** ./node_modules/sip.js/lib/RegisterContext.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/**
 * Configuration load.
 * @private
 * returns {any}
 */
function loadConfig(configuration) {
    var settings = {
        expires: 600,
        extraContactHeaderParams: [],
        instanceId: undefined,
        params: {},
        regId: undefined,
        registrar: undefined,
    };
    var configCheck = getConfigurationCheck();
    // Check Mandatory parameters
    for (var parameter in configCheck.mandatory) {
        if (!configuration.hasOwnProperty(parameter)) {
            throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
        }
        else {
            var value = configuration[parameter];
            var checkedValue = configCheck.mandatory[parameter](value);
            if (checkedValue !== undefined) {
                settings[parameter] = checkedValue;
            }
            else {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
            }
        }
    }
    // Check Optional parameters
    for (var parameter in configCheck.optional) {
        if (configuration.hasOwnProperty(parameter)) {
            var value = configuration[parameter];
            // If the parameter value is an empty array, but shouldn't be, apply its default value.
            if (value instanceof Array && value.length === 0) {
                continue;
            }
            // If the parameter value is null, empty string, or undefined then apply its default value.
            // If it's a number with NaN value then also apply its default value.
            // NOTE: JS does not allow "value === NaN", the following does the work:
            if (value === null || value === "" || value === undefined ||
                (typeof (value) === "number" && isNaN(value))) {
                continue;
            }
            var checkedValue = configCheck.optional[parameter](value);
            if (checkedValue !== undefined) {
                settings[parameter] = checkedValue;
            }
            else {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
            }
        }
    }
    return settings;
}
function getConfigurationCheck() {
    return {
        mandatory: {},
        optional: {
            expires: function (expires) {
                if (Utils_1.Utils.isDecimal(expires)) {
                    var value = Number(expires);
                    if (value >= 0) {
                        return value;
                    }
                }
            },
            extraContactHeaderParams: function (extraContactHeaderParams) {
                if (extraContactHeaderParams instanceof Array) {
                    return extraContactHeaderParams.filter(function (contactHeaderParam) { return (typeof contactHeaderParam === "string"); });
                }
            },
            instanceId: function (instanceId) {
                if (typeof instanceId !== "string") {
                    return;
                }
                if ((/^uuid:/i.test(instanceId))) {
                    instanceId = instanceId.substr(5);
                }
                if (core_1.Grammar.parse(instanceId, "uuid") === -1) {
                    return;
                }
                else {
                    return instanceId;
                }
            },
            params: function (params) {
                if (typeof params === "object") {
                    return params;
                }
            },
            regId: function (regId) {
                if (Utils_1.Utils.isDecimal(regId)) {
                    var value = Number(regId);
                    if (value >= 0) {
                        return value;
                    }
                }
            },
            registrar: function (registrar) {
                if (typeof registrar !== "string") {
                    return;
                }
                if (!/^sip:/i.test(registrar)) {
                    registrar = Constants_1.C.SIP + ":" + registrar;
                }
                var parsed = core_1.Grammar.URIParse(registrar);
                if (!parsed) {
                    return;
                }
                else if (parsed.user) {
                    return;
                }
                else {
                    return parsed;
                }
            }
        }
    };
}
var RegisterContext = /** @class */ (function (_super) {
    tslib_1.__extends(RegisterContext, _super);
    function RegisterContext(ua, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        var settings = loadConfig(options);
        if (settings.regId && !settings.instanceId) {
            settings.instanceId = Utils_1.Utils.newUUID();
        }
        else if (!settings.regId && settings.instanceId) {
            settings.regId = 1;
        }
        settings.params.toUri = settings.params.toUri || ua.configuration.uri;
        settings.params.toDisplayName = settings.params.toDisplayName || ua.configuration.displayName;
        settings.params.callId = settings.params.callId || Utils_1.Utils.createRandomToken(22);
        settings.params.cseq = settings.params.cseq || Math.floor(Math.random() * 10000);
        /* If no 'registrarServer' is set use the 'uri' value without user portion. */
        if (!settings.registrar) {
            var registrarServer = {};
            if (typeof ua.configuration.uri === "object") {
                registrarServer = ua.configuration.uri.clone();
                registrarServer.user = undefined;
            }
            else {
                registrarServer = ua.configuration.uri;
            }
            settings.registrar = registrarServer;
        }
        _this = _super.call(this, ua, Constants_1.C.REGISTER, settings.registrar, settings) || this;
        _this.type = Enums_1.TypeStrings.RegisterContext;
        _this.options = settings;
        _this.logger = ua.getLogger("sip.registercontext");
        _this.logger.log("configuration parameters for RegisterContext after validation:");
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                _this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
            }
        }
        // Registration expires
        _this.expires = settings.expires;
        // Contact header
        _this.contact = ua.contact.toString();
        // Set status
        _this.registered = false;
        ua.transport.on("disconnected", function () { return _this.onTransportDisconnected(); });
        return _this;
    }
    RegisterContext.prototype.register = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Handle Options
        this.options = tslib_1.__assign(tslib_1.__assign({}, this.options), options);
        var extraHeaders = (this.options.extraHeaders || []).slice();
        extraHeaders.push("Contact: " + this.generateContactHeader(this.expires));
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        // Save original extraHeaders to be used in .close
        this.closeHeaders = this.options.closeWithHeaders ?
            (this.options.extraHeaders || []).slice() : [];
        this.receiveResponse = function (response) {
            // Discard responses to older REGISTER/un-REGISTER requests.
            if (response.cseq !== _this.request.cseq) {
                return;
            }
            // Clear registration timer
            if (_this.registrationTimer !== undefined) {
                clearTimeout(_this.registrationTimer);
                _this.registrationTimer = undefined;
            }
            var statusCode = (response.statusCode || 0).toString();
            switch (true) {
                case /^1[0-9]{2}$/.test(statusCode):
                    _this.emit("progress", response);
                    break;
                case /^2[0-9]{2}$/.test(statusCode):
                    _this.emit("accepted", response);
                    var expires = void 0;
                    if (response.hasHeader("expires")) {
                        expires = Number(response.getHeader("expires"));
                    }
                    if (_this.registrationExpiredTimer !== undefined) {
                        clearTimeout(_this.registrationExpiredTimer);
                        _this.registrationExpiredTimer = undefined;
                    }
                    // Search the Contact pointing to us and update the expires value accordingly.
                    var contacts = response.getHeaders("contact").length;
                    if (!contacts) {
                        _this.logger.warn("no Contact header in response to REGISTER, response ignored");
                        break;
                    }
                    var contact = void 0;
                    while (contacts--) {
                        contact = response.parseHeader("contact", contacts);
                        if (contact.uri.user === _this.ua.contact.uri.user) {
                            expires = contact.getParam("expires");
                            break;
                        }
                        else {
                            contact = undefined;
                        }
                    }
                    if (!contact) {
                        _this.logger.warn("no Contact header pointing to us, response ignored");
                        break;
                    }
                    if (expires === undefined) {
                        expires = _this.expires;
                    }
                    // Re-Register before the expiration interval has elapsed.
                    // For that, decrease the expires value. ie: 3 seconds
                    _this.registrationTimer = setTimeout(function () {
                        _this.registrationTimer = undefined;
                        _this.register(_this.options);
                    }, (expires * 1000) - 3000);
                    _this.registrationExpiredTimer = setTimeout(function () {
                        _this.logger.warn("registration expired");
                        if (_this.registered) {
                            _this.unregistered(undefined, Constants_1.C.causes.EXPIRES);
                        }
                    }, expires * 1000);
                    // Save gruu values
                    if (contact.hasParam("temp-gruu")) {
                        _this.ua.contact.tempGruu = core_1.Grammar.URIParse(contact.getParam("temp-gruu").replace(/"/g, ""));
                    }
                    if (contact.hasParam("pub-gruu")) {
                        _this.ua.contact.pubGruu = core_1.Grammar.URIParse(contact.getParam("pub-gruu").replace(/"/g, ""));
                    }
                    _this.registered = true;
                    _this.emit("registered", response || undefined);
                    break;
                // Interval too brief RFC3261 10.2.8
                case /^423$/.test(statusCode):
                    if (response.hasHeader("min-expires")) {
                        // Increase our registration interval to the suggested minimum
                        _this.expires = Number(response.getHeader("min-expires"));
                        // Attempt the registration again immediately
                        _this.register(_this.options);
                    }
                    else { // This response MUST contain a Min-Expires header field
                        _this.logger.warn("423 response received for REGISTER without Min-Expires");
                        _this.registrationFailure(response, Constants_1.C.causes.SIP_FAILURE_CODE);
                    }
                    break;
                default:
                    _this.registrationFailure(response, Utils_1.Utils.sipErrorCause(response.statusCode || 0));
            }
        };
        this.onRequestTimeout = function () {
            _this.registrationFailure(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        };
        this.onTransportError = function () {
            _this.registrationFailure(undefined, Constants_1.C.causes.CONNECTION_ERROR);
        };
        this.request.cseq++;
        this.request.setHeader("cseq", this.request.cseq + " REGISTER");
        this.request.extraHeaders = extraHeaders;
        this.send();
    };
    RegisterContext.prototype.close = function () {
        var options = {
            all: false,
            extraHeaders: this.closeHeaders
        };
        this.registeredBefore = this.registered;
        if (this.registered) {
            this.unregister(options);
        }
    };
    RegisterContext.prototype.unregister = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.registered && !options.all) {
            this.logger.warn("Already unregistered, but sending an unregister anyways.");
        }
        var extraHeaders = (options.extraHeaders || []).slice();
        this.registered = false;
        // Clear the registration timer.
        if (this.registrationTimer !== undefined) {
            clearTimeout(this.registrationTimer);
            this.registrationTimer = undefined;
        }
        if (options.all) {
            extraHeaders.push("Contact: *");
            extraHeaders.push("Expires: 0");
        }
        else {
            extraHeaders.push("Contact: " + this.generateContactHeader(0));
        }
        this.receiveResponse = function (response) {
            var statusCode = (response && response.statusCode) ? response.statusCode.toString() : "";
            switch (true) {
                case /^1[0-9]{2}$/.test(statusCode):
                    _this.emit("progress", response);
                    break;
                case /^2[0-9]{2}$/.test(statusCode):
                    _this.emit("accepted", response);
                    if (_this.registrationExpiredTimer !== undefined) {
                        clearTimeout(_this.registrationExpiredTimer);
                        _this.registrationExpiredTimer = undefined;
                    }
                    _this.unregistered(response);
                    break;
                default:
                    _this.unregistered(response, Utils_1.Utils.sipErrorCause(response.statusCode || 0));
            }
        };
        this.onRequestTimeout = function () {
            // Not actually unregistered...
            // this.unregistered(undefined, SIP.C.causes.REQUEST_TIMEOUT);
        };
        this.request.cseq++;
        this.request.setHeader("cseq", this.request.cseq + " REGISTER");
        this.request.extraHeaders = extraHeaders;
        this.send();
    };
    RegisterContext.prototype.unregistered = function (response, cause) {
        this.registered = false;
        this.emit("unregistered", response || undefined, cause || undefined);
    };
    RegisterContext.prototype.send = function () {
        var _this = this;
        this.ua.userAgentCore.register(this.request, {
            onAccept: function (response) { return _this.receiveResponse(response.message); },
            onProgress: function (response) { return _this.receiveResponse(response.message); },
            onRedirect: function (response) { return _this.receiveResponse(response.message); },
            onReject: function (response) { return _this.receiveResponse(response.message); },
            onTrying: function (response) { return _this.receiveResponse(response.message); }
        });
        return this;
    };
    RegisterContext.prototype.registrationFailure = function (response, cause) {
        this.emit("failed", response || undefined, cause || undefined);
    };
    RegisterContext.prototype.onTransportDisconnected = function () {
        this.registeredBefore = this.registered;
        if (this.registrationTimer !== undefined) {
            clearTimeout(this.registrationTimer);
            this.registrationTimer = undefined;
        }
        if (this.registrationExpiredTimer !== undefined) {
            clearTimeout(this.registrationExpiredTimer);
            this.registrationExpiredTimer = undefined;
        }
        if (this.registered) {
            this.unregistered(undefined, Constants_1.C.causes.CONNECTION_ERROR);
        }
    };
    /**
     * Helper Function to generate Contact Header
     * @private
     * returns {String}
     */
    RegisterContext.prototype.generateContactHeader = function (expires) {
        if (expires === void 0) { expires = 0; }
        var contact = this.contact;
        if (this.options.regId && this.options.instanceId) {
            contact += ";reg-id=" + this.options.regId;
            contact += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
        }
        if (this.options.extraContactHeaderParams) {
            this.options.extraContactHeaderParams.forEach(function (header) {
                contact += ";" + header;
            });
        }
        contact += ";expires=" + expires;
        return contact;
    };
    return RegisterContext;
}(ClientContext_1.ClientContext));
exports.RegisterContext = RegisterContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/ServerContext.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/ServerContext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
var ServerContext = /** @class */ (function (_super) {
    tslib_1.__extends(ServerContext, _super);
    function ServerContext(ua, incomingRequest) {
        var _this = _super.call(this) || this;
        _this.incomingRequest = incomingRequest;
        _this.data = {};
        ServerContext.initializer(_this, ua, incomingRequest);
        return _this;
    }
    // hack to get around our multiple inheritance issues
    ServerContext.initializer = function (objectToConstruct, ua, incomingRequest) {
        var request = incomingRequest.message;
        objectToConstruct.type = Enums_1.TypeStrings.ServerContext;
        objectToConstruct.ua = ua;
        objectToConstruct.logger = ua.getLogger("sip.servercontext");
        objectToConstruct.request = request;
        if (request.body) {
            objectToConstruct.body = request.body;
        }
        if (request.hasHeader("Content-Type")) {
            objectToConstruct.contentType = request.getHeader("Content-Type");
        }
        objectToConstruct.method = request.method;
        objectToConstruct.localIdentity = request.to;
        objectToConstruct.remoteIdentity = request.from;
        var hasAssertedIdentity = request.hasHeader("P-Asserted-Identity");
        if (hasAssertedIdentity) {
            var assertedIdentity = request.getHeader("P-Asserted-Identity");
            if (assertedIdentity) {
                objectToConstruct.assertedIdentity = core_1.Grammar.nameAddrHeaderParse(assertedIdentity);
            }
        }
    };
    ServerContext.prototype.progress = function (options) {
        if (options === void 0) { options = {}; }
        options.statusCode = options.statusCode || 180;
        options.minCode = 100;
        options.maxCode = 199;
        options.events = ["progress"];
        return this.reply(options);
    };
    ServerContext.prototype.accept = function (options) {
        if (options === void 0) { options = {}; }
        options.statusCode = options.statusCode || 200;
        options.minCode = 200;
        options.maxCode = 299;
        options.events = ["accepted"];
        return this.reply(options);
    };
    ServerContext.prototype.reject = function (options) {
        if (options === void 0) { options = {}; }
        options.statusCode = options.statusCode || 480;
        options.minCode = 300;
        options.maxCode = 699;
        options.events = ["rejected", "failed"];
        return this.reply(options);
    };
    ServerContext.prototype.reply = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 100;
        var minCode = options.minCode || 100;
        var maxCode = options.maxCode || 699;
        var reasonPhrase = Utils_1.Utils.getReasonPhrase(statusCode, options.reasonPhrase);
        var extraHeaders = options.extraHeaders || [];
        var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
        var events = options.events || [];
        if (statusCode < minCode || statusCode > maxCode) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var responseOptions = {
            statusCode: statusCode,
            reasonPhrase: reasonPhrase,
            extraHeaders: extraHeaders,
            body: body
        };
        var response;
        var statusCodeString = statusCode.toString();
        switch (true) {
            case /^100$/.test(statusCodeString):
                response = this.incomingRequest.trying(responseOptions).message;
                break;
            case /^1[0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.progress(responseOptions).message;
                break;
            case /^2[0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.accept(responseOptions).message;
                break;
            case /^3[0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.redirect([], responseOptions).message;
                break;
            case /^[4-6][0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.reject(responseOptions).message;
                break;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
        events.forEach(function (event) {
            _this.emit(event, response, reasonPhrase);
        });
        return this;
    };
    ServerContext.prototype.onRequestTimeout = function () {
        this.emit("failed", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
    };
    ServerContext.prototype.onTransportError = function () {
        this.emit("failed", undefined, Constants_1.C.causes.CONNECTION_ERROR);
    };
    return ServerContext;
}(events_1.EventEmitter));
exports.ServerContext = ServerContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/Session.js":
/*!********************************************!*\
  !*** ./node_modules/sip.js/lib/Session.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var ReferContext_1 = __webpack_require__(/*! ./ReferContext */ "./node_modules/sip.js/lib/ReferContext.js");
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
var DTMF_1 = __webpack_require__(/*! ./Session/DTMF */ "./node_modules/sip.js/lib/Session/DTMF.js");
var DTMFValidator_1 = __webpack_require__(/*! ./Session/DTMFValidator */ "./node_modules/sip.js/lib/Session/DTMFValidator.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/*
 * @param {function returning SIP.sessionDescriptionHandler} [sessionDescriptionHandlerFactory]
 *        (See the documentation for the sessionDescriptionHandlerFactory argument of the UA constructor.)
 */
var Session = /** @class */ (function (_super) {
    tslib_1.__extends(Session, _super);
    function Session(sessionDescriptionHandlerFactory) {
        var _this = _super.call(this) || this;
        _this.data = {};
        _this.type = Enums_1.TypeStrings.Session;
        if (!sessionDescriptionHandlerFactory) {
            throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("A session description handler is required for the session to function");
        }
        _this.status = Session.C.STATUS_NULL;
        _this.pendingReinvite = false;
        _this.sessionDescriptionHandlerFactory = sessionDescriptionHandlerFactory;
        _this.hasOffer = false;
        _this.hasAnswer = false;
        // Session Timers
        _this.timers = {
            ackTimer: undefined,
            expiresTimer: undefined,
            invite2xxTimer: undefined,
            userNoAnswerTimer: undefined,
            rel1xxTimer: undefined,
            prackTimer: undefined
        };
        // Session info
        _this.startTime = undefined;
        _this.endTime = undefined;
        _this.tones = undefined;
        // Hold state
        _this.localHold = false;
        _this.earlySdp = undefined;
        _this.rel100 = Constants_1.C.supported.UNSUPPORTED;
        return _this;
    }
    Session.prototype.dtmf = function (tones, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED && this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        // Check tones' validity
        DTMFValidator_1.DTMFValidator.validate(tones);
        var sendDTMF = function () {
            if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED || !_this.tones || _this.tones.length === 0) {
                // Stop sending DTMF
                _this.tones = undefined;
                return;
            }
            var dtmf = _this.tones.shift();
            var timeout;
            if (dtmf.tone === ",") {
                timeout = 2000;
            }
            else {
                dtmf.on("failed", function () { _this.tones = undefined; });
                dtmf.send(options);
                timeout = dtmf.duration + dtmf.interToneGap;
            }
            // Set timeout for the next tone
            setTimeout(sendDTMF, timeout);
        };
        tones = tones.toString();
        var dtmfType = this.ua.configuration.dtmfType;
        if (this.sessionDescriptionHandler && dtmfType === Constants_1.C.dtmfType.RTP) {
            var sent = this.sessionDescriptionHandler.sendDtmf(tones, options);
            if (!sent) {
                this.logger.warn("Attempt to use dtmfType 'RTP' has failed, falling back to INFO packet method");
                dtmfType = Constants_1.C.dtmfType.INFO;
            }
        }
        if (dtmfType === Constants_1.C.dtmfType.INFO) {
            var dtmfs = [];
            var tonesArray = tones.split("");
            while (tonesArray.length > 0) {
                dtmfs.push(new DTMF_1.DTMF(this, tonesArray.shift(), options));
            }
            if (Array.isArray(this.tones) && this.tones.length) {
                // Tones are already queued, just add to the queue
                this.tones = this.tones.concat(dtmfs);
                return this;
            }
            this.tones = dtmfs;
            sendDTMF();
        }
        return this;
    };
    Session.prototype.bye = function (options) {
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.logger.error("Error: Attempted to send BYE in a terminated session.");
            return this;
        }
        this.logger.log("terminating Session");
        var statusCode = options.statusCode;
        if (statusCode && (statusCode < 200 || statusCode >= 700)) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        options.receiveResponse = function () { };
        return this.sendRequest(Constants_1.C.BYE, options).terminated();
    };
    Session.prototype.refer = function (target, options) {
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.referContext = new ReferContext_1.ReferClientContext(this.ua, this, target, options);
        this.emit("referRequested", this.referContext);
        this.referContext.refer(options);
        return this.referContext;
    };
    /**
     * Sends in dialog request.
     * @param method Request method.
     * @param options Options bucket.
     */
    Session.prototype.sendRequest = function (method, options) {
        if (options === void 0) { options = {}; }
        if (!this.session) {
            throw new Error("Session undefined.");
        }
        // Convert any "body" option to a Body.
        if (options.body) {
            options.body = Utils_1.Utils.fromBodyObj(options.body);
        }
        // Convert any "receiveResponse" callback option passed to an OutgoingRequestDelegate.
        var delegate;
        var callback = options.receiveResponse;
        if (callback) {
            delegate = {
                onAccept: function (response) { return callback(response.message); },
                onProgress: function (response) { return callback(response.message); },
                onRedirect: function (response) { return callback(response.message); },
                onReject: function (response) { return callback(response.message); },
                onTrying: function (response) { return callback(response.message); }
            };
        }
        var request;
        var requestOptions = options;
        switch (method) {
            case Constants_1.C.BYE:
                request = this.session.bye(delegate, requestOptions);
                break;
            case Constants_1.C.INVITE:
                request = this.session.invite(delegate, requestOptions);
                break;
            case Constants_1.C.MESSAGE:
                request = this.session.message(delegate, requestOptions);
                break;
            case Constants_1.C.REFER:
                request = this.session.refer(delegate, requestOptions);
                break;
            default:
                throw new Error("Unexpected " + method + ". Method not implemented by user agent core.");
        }
        // Ported - Emit the request event
        this.emit(method.toLowerCase(), request.message);
        return this;
    };
    Session.prototype.close = function () {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        this.logger.log("closing INVITE session " + this.id);
        // 1st Step. Terminate media.
        if (this.sessionDescriptionHandler) {
            this.sessionDescriptionHandler.close();
        }
        // 2nd Step. Terminate signaling.
        // Clear session timers
        for (var timer in this.timers) {
            if (this.timers[timer]) {
                clearTimeout(this.timers[timer]);
            }
        }
        this.status = Enums_1.SessionStatus.STATUS_TERMINATED;
        if (this.ua.transport) {
            this.ua.transport.removeListener("transportError", this.errorListener);
        }
        delete this.ua.sessions[this.id];
        return this;
    };
    Session.prototype.hold = function (options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK && this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (this.localHold) {
            this.logger.log("Session is already on hold, cannot put it on hold again");
            return;
        }
        options.modifiers = modifiers;
        if (this.sessionDescriptionHandler) {
            options.modifiers.push(this.sessionDescriptionHandler.holdModifier);
        }
        this.localHold = true;
        this.sendReinvite(options);
    };
    Session.prototype.unhold = function (options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK && this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (!this.localHold) {
            this.logger.log("Session is not on hold, cannot unhold it");
            return;
        }
        options.modifiers = modifiers;
        this.localHold = false;
        this.sendReinvite(options);
    };
    Session.prototype.reinvite = function (options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        options.modifiers = modifiers;
        return this.sendReinvite(options);
    };
    Session.prototype.terminate = function (options) {
        // here for types and to be overridden
        return this;
    };
    Session.prototype.onTransportError = function () {
        if (this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED && this.status !== Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.failed(undefined, Constants_1.C.causes.CONNECTION_ERROR);
        }
    };
    Session.prototype.onRequestTimeout = function () {
        if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            this.terminated(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        }
        else if (this.status !== Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.failed(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
            this.terminated(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        }
    };
    Session.prototype.onDialogError = function (response) {
        if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            this.terminated(response, Constants_1.C.causes.DIALOG_ERROR);
        }
        else if (this.status !== Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.failed(response, Constants_1.C.causes.DIALOG_ERROR);
            this.terminated(response, Constants_1.C.causes.DIALOG_ERROR);
        }
    };
    Session.prototype.on = function (name, callback) {
        return _super.prototype.on.call(this, name, callback);
    };
    Session.prototype.onAck = function (incomingRequest) {
        var _this = this;
        var confirmSession = function () {
            clearTimeout(_this.timers.ackTimer);
            clearTimeout(_this.timers.invite2xxTimer);
            _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
            var contentDisp = incomingRequest.message.getHeader("Content-Disposition");
            if (contentDisp && contentDisp.type === "render") {
                _this.renderbody = incomingRequest.message.body;
                _this.rendertype = incomingRequest.message.getHeader("Content-Type");
            }
            _this.emit("confirmed", incomingRequest.message);
        };
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            if (this.sessionDescriptionHandler &&
                this.sessionDescriptionHandler.hasDescription(incomingRequest.message.getHeader("Content-Type") || "")) {
                this.hasAnswer = true;
                this.sessionDescriptionHandler.setDescription(incomingRequest.message.body, this.sessionDescriptionHandlerOptions, this.modifiers).catch(function (e) {
                    _this.logger.warn(e);
                    _this.terminate({
                        statusCode: "488",
                        reasonPhrase: "Bad Media Description"
                    });
                    _this.failed(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    _this.terminated(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    throw e;
                }).then(function () { return confirmSession(); });
            }
            else {
                confirmSession();
            }
        }
    };
    Session.prototype.receiveRequest = function (incomingRequest) {
        switch (incomingRequest.message.method) { // TODO: This needs a default case
            case Constants_1.C.BYE:
                incomingRequest.accept();
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
                    this.emit("bye", incomingRequest.message);
                    this.terminated(incomingRequest.message, Constants_1.C.BYE);
                }
                break;
            case Constants_1.C.INVITE:
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
                    this.logger.log("re-INVITE received");
                    this.receiveReinvite(incomingRequest);
                }
                break;
            case Constants_1.C.INFO:
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED || this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
                    if (this.onInfo) {
                        return this.onInfo(incomingRequest.message);
                    }
                    var contentType = incomingRequest.message.getHeader("content-type");
                    if (contentType) {
                        if (contentType.match(/^application\/dtmf-relay/i)) {
                            if (incomingRequest.message.body) {
                                var body = incomingRequest.message.body.split("\r\n", 2);
                                if (body.length === 2) {
                                    var tone = void 0;
                                    var duration = void 0;
                                    var regTone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;
                                    if (regTone.test(body[0])) {
                                        tone = body[0].replace(regTone, "$2");
                                    }
                                    var regDuration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
                                    if (regDuration.test(body[1])) {
                                        duration = parseInt(body[1].replace(regDuration, "$2"), 10);
                                    }
                                    if (tone && duration) {
                                        new DTMF_1.DTMF(this, tone, { duration: duration }).init_incoming(incomingRequest);
                                    }
                                }
                            }
                        }
                        else {
                            incomingRequest.reject({
                                statusCode: 415,
                                extraHeaders: ["Accept: application/dtmf-relay"]
                            });
                        }
                    }
                }
                break;
            case Constants_1.C.REFER:
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
                    this.logger.log("REFER received");
                    this.referContext = new ReferContext_1.ReferServerContext(this.ua, incomingRequest, this.session);
                    if (this.listeners("referRequested").length) {
                        this.emit("referRequested", this.referContext);
                    }
                    else {
                        this.logger.log("No referRequested listeners, automatically accepting and following the refer");
                        var options = { followRefer: true };
                        if (this.passedOptions) {
                            options.inviteOptions = this.passedOptions;
                        }
                        this.referContext.accept(options, this.modifiers);
                    }
                }
                break;
            case Constants_1.C.NOTIFY:
                if (this.referContext &&
                    this.referContext.type === Enums_1.TypeStrings.ReferClientContext &&
                    incomingRequest.message.hasHeader("event") &&
                    /^refer(;.*)?$/.test(incomingRequest.message.getHeader("event"))) {
                    this.referContext.receiveNotify(incomingRequest);
                    return;
                }
                incomingRequest.accept();
                this.emit("notify", incomingRequest.message);
                break;
            case Constants_1.C.MESSAGE:
                incomingRequest.accept();
                this.emit("message", incomingRequest.message);
                break;
        }
    };
    // In dialog INVITE Reception
    Session.prototype.receiveReinvite = function (incomingRequest) {
        // TODO: Should probably check state of the session
        var _this = this;
        this.emit("reinvite", this, incomingRequest.message);
        if (incomingRequest.message.hasHeader("P-Asserted-Identity")) {
            this.assertedIdentity =
                core_1.Grammar.nameAddrHeaderParse(incomingRequest.message.getHeader("P-Asserted-Identity"));
        }
        var promise;
        if (!this.sessionDescriptionHandler) {
            this.logger.warn("No SessionDescriptionHandler to reinvite");
            return;
        }
        if (incomingRequest.message.getHeader("Content-Length") === "0" &&
            !incomingRequest.message.getHeader("Content-Type")) { // Invite w/o SDP
            promise = this.sessionDescriptionHandler.getDescription(this.sessionDescriptionHandlerOptions, this.modifiers);
        }
        else if (this.sessionDescriptionHandler.hasDescription(incomingRequest.message.getHeader("Content-Type") || "")) {
            // Invite w/ SDP
            promise = this.sessionDescriptionHandler.setDescription(incomingRequest.message.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(this.sessionDescriptionHandler.getDescription.bind(this.sessionDescriptionHandler, this.sessionDescriptionHandlerOptions, this.modifiers));
        }
        else { // Bad Packet (should never get hit)
            incomingRequest.reject({ statusCode: 415 });
            this.emit("reinviteFailed", this);
            return;
        }
        promise.catch(function (e) {
            var statusCode;
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                statusCode = 500;
            }
            else if (e.type === Enums_1.TypeStrings.RenegotiationError) {
                _this.emit("renegotiationError", e);
                _this.logger.warn(e.toString());
                statusCode = 488;
            }
            else {
                _this.logger.error(e);
                statusCode = 488;
            }
            incomingRequest.reject({ statusCode: statusCode });
            _this.emit("reinviteFailed", _this);
            // TODO: This could be better
            throw e;
        }).then(function (description) {
            var extraHeaders = ["Contact: " + _this.contact];
            incomingRequest.accept({
                statusCode: 200,
                extraHeaders: extraHeaders,
                body: Utils_1.Utils.fromBodyObj(description)
            });
            _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK;
            _this.emit("reinviteAccepted", _this);
        });
    };
    Session.prototype.sendReinvite = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.pendingReinvite) {
            this.logger.warn("Reinvite in progress. Please wait until complete, then try again.");
            return;
        }
        if (!this.sessionDescriptionHandler) {
            this.logger.warn("No SessionDescriptionHandler, can't reinvite..");
            return;
        }
        this.pendingReinvite = true;
        options.modifiers = options.modifiers || [];
        var extraHeaders = (options.extraHeaders || []).slice();
        extraHeaders.push("Contact: " + this.contact);
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
            .then(function (description) {
            if (!_this.session) {
                throw new Error("Session undefined.");
            }
            var delegate = {
                onAccept: function (response) {
                    if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        _this.logger.error("Received reinvite response, but in STATUS_TERMINATED");
                        // TODO: Do we need to send a SIP response?
                        return;
                    }
                    if (!_this.pendingReinvite) {
                        _this.logger.error("Received reinvite response, but have no pending reinvite");
                        // TODO: Do we need to send a SIP response?
                        return;
                    }
                    // FIXME: Why is this set here?
                    _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                    // 17.1.1.1 - For each final response that is received at the client transaction,
                    // the client transaction sends an ACK,
                    _this.emit("ack", response.ack());
                    _this.pendingReinvite = false;
                    // TODO: All of these timers should move into the Transaction layer
                    clearTimeout(_this.timers.invite2xxTimer);
                    if (!_this.sessionDescriptionHandler ||
                        !_this.sessionDescriptionHandler.hasDescription(response.message.getHeader("Content-Type") || "")) {
                        _this.logger.error("2XX response received to re-invite but did not have a description");
                        _this.emit("reinviteFailed", _this);
                        _this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("2XX response received to re-invite but did not have a description"));
                        return;
                    }
                    _this.sessionDescriptionHandler
                        .setDescription(response.message.body, _this.sessionDescriptionHandlerOptions, _this.modifiers)
                        .catch(function (e) {
                        _this.logger.error("Could not set the description in 2XX response");
                        _this.logger.error(e);
                        _this.emit("reinviteFailed", _this);
                        _this.emit("renegotiationError", e);
                        _this.sendRequest(Constants_1.C.BYE, {
                            extraHeaders: ["Reason: " + Utils_1.Utils.getReasonHeaderValue(488, "Not Acceptable Here")]
                        });
                        _this.terminated(undefined, Constants_1.C.causes.INCOMPATIBLE_SDP);
                        throw e;
                    })
                        .then(function () {
                        _this.emit("reinviteAccepted", _this);
                    });
                },
                onProgress: function (response) {
                    return;
                },
                onRedirect: function (response) {
                    // FIXME: Does ACK need to be sent?
                    _this.pendingReinvite = false;
                    _this.logger.log("Received a non 1XX or 2XX response to a re-invite");
                    _this.emit("reinviteFailed", _this);
                    _this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("Invalid response to a re-invite"));
                },
                onReject: function (response) {
                    // FIXME: Does ACK need to be sent?
                    _this.pendingReinvite = false;
                    _this.logger.log("Received a non 1XX or 2XX response to a re-invite");
                    _this.emit("reinviteFailed", _this);
                    _this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("Invalid response to a re-invite"));
                },
                onTrying: function (response) {
                    return;
                }
            };
            var requestOptions = {
                extraHeaders: extraHeaders,
                body: Utils_1.Utils.fromBodyObj(description)
            };
            _this.session.invite(delegate, requestOptions);
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.RenegotiationError) {
                _this.pendingReinvite = false;
                _this.emit("renegotiationError", e);
                _this.logger.warn("Renegotiation Error");
                _this.logger.warn(e.toString());
                throw e;
            }
            _this.logger.error("sessionDescriptionHandler error");
            _this.logger.error(e);
            throw e;
        });
    };
    Session.prototype.failed = function (response, cause) {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        this.emit("failed", response, cause);
        return this;
    };
    Session.prototype.rejected = function (response, cause) {
        this.emit("rejected", response, cause);
        return this;
    };
    Session.prototype.canceled = function () {
        if (this.sessionDescriptionHandler) {
            this.sessionDescriptionHandler.close();
        }
        this.emit("cancel");
        return this;
    };
    Session.prototype.accepted = function (response, cause) {
        if (!(response instanceof String)) {
            cause = Utils_1.Utils.getReasonPhrase((response && response.statusCode) || 0, cause);
        }
        this.startTime = new Date();
        if (this.replacee) {
            this.replacee.emit("replaced", this);
            this.replacee.terminate();
        }
        this.emit("accepted", response, cause);
        return this;
    };
    Session.prototype.terminated = function (message, cause) {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        this.endTime = new Date();
        this.close();
        this.emit("terminated", message, cause);
        return this;
    };
    Session.prototype.connecting = function (request) {
        this.emit("connecting", { request: request });
        return this;
    };
    Session.C = Enums_1.SessionStatus;
    return Session;
}(events_1.EventEmitter));
exports.Session = Session;
// tslint:disable-next-line:max-classes-per-file
var InviteServerContext = /** @class */ (function (_super) {
    tslib_1.__extends(InviteServerContext, _super);
    function InviteServerContext(ua, incomingInviteRequest) {
        var _this = this;
        if (!ua.configuration.sessionDescriptionHandlerFactory) {
            ua.logger.warn("Can't build ISC without SDH Factory");
            throw new Error("ISC Constructor Failed");
        }
        _this = _super.call(this, ua.configuration.sessionDescriptionHandlerFactory) || this;
        _this._canceled = false;
        _this.rseq = Math.floor(Math.random() * 10000);
        _this.incomingRequest = incomingInviteRequest;
        var request = incomingInviteRequest.message;
        ServerContext_1.ServerContext.initializer(_this, ua, incomingInviteRequest);
        _this.type = Enums_1.TypeStrings.InviteServerContext;
        var contentDisp = request.parseHeader("Content-Disposition");
        if (contentDisp && contentDisp.type === "render") {
            _this.renderbody = request.body;
            _this.rendertype = request.getHeader("Content-Type");
        }
        _this.status = Enums_1.SessionStatus.STATUS_INVITE_RECEIVED;
        _this.fromTag = request.fromTag;
        _this.id = request.callId + _this.fromTag;
        _this.request = request;
        _this.contact = _this.ua.contact.toString();
        _this.logger = ua.getLogger("sip.inviteservercontext", _this.id);
        // Save the session into the ua sessions collection.
        _this.ua.sessions[_this.id] = _this;
        // Set 100rel if necessary
        var set100rel = function (header, relSetting) {
            if (request.hasHeader(header) && request.getHeader(header).toLowerCase().indexOf("100rel") >= 0) {
                _this.rel100 = relSetting;
            }
        };
        set100rel("require", Constants_1.C.supported.REQUIRED);
        set100rel("supported", Constants_1.C.supported.SUPPORTED);
        // Set the toTag on the incoming request to the toTag which
        // will be used in the response to the incoming request!!!
        // FIXME: HACK: This is a hack to port an existing behavior.
        // The behavior being ported appears to be a hack itself,
        // so this is a hack to port a hack. At least one test spec
        // relies on it (which is yet another hack).
        _this.request.toTag = incomingInviteRequest.toTag;
        _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER;
        // Set userNoAnswerTimer
        _this.timers.userNoAnswerTimer = setTimeout(function () {
            incomingInviteRequest.reject({ statusCode: 408 });
            _this.failed(request, Constants_1.C.causes.NO_ANSWER);
            _this.terminated(request, Constants_1.C.causes.NO_ANSWER);
        }, _this.ua.configuration.noAnswerTimeout || 60);
        /* Set expiresTimer
        * RFC3261 13.3.1
        */
        // Get the Expires header value if exists
        if (request.hasHeader("expires")) {
            var expires = Number(request.getHeader("expires") || 0) * 1000;
            _this.timers.expiresTimer = setTimeout(function () {
                if (_this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
                    incomingInviteRequest.reject({ statusCode: 487 });
                    _this.failed(request, Constants_1.C.causes.EXPIRES);
                    _this.terminated(request, Constants_1.C.causes.EXPIRES);
                }
            }, expires);
        }
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        return _this;
    }
    Object.defineProperty(InviteServerContext.prototype, "autoSendAnInitialProvisionalResponse", {
        /**
         * If true, a first provisional response after the 100 Trying
         * will be sent automatically. This is false it the UAC required
         * reliable provisional responses (100rel in Require header),
         * otherwise it is true. The provisional is sent by calling
         * `progress()` without any options.
         *
         * FIXME: TODO: It seems reasonable that the ISC user should
         * be able to optionally disable this behavior. As the provisional
         * is sent prior to the "invite" event being emitted, it's a known
         * issue that the ISC user cannot register listeners or do any other
         * setup prior to the call to `progress()`. As an example why this is
         * an issue, setting `ua.configuration.rel100` to REQUIRED will result
         * in an attempt by `progress()` to send a 183 with SDP produced by
         * calling `getDescription()` on a session description handler, but
         * the ISC user cannot perform any potentially required session description
         * handler initialization (thus preventing the utilization of setting
         * `ua.configuration.rel100` to REQUIRED). That begs the question of
         * why this behavior is disabled when the UAC requires 100rel but not
         * when the UAS requires 100rel? But ignoring that, it's just one example
         * of a class of cases where the ISC user needs to do something prior
         * to the first call to `progress()` and is unable to do so.
         */
        get: function () {
            return this.rel100 === Constants_1.C.supported.REQUIRED ? false : true;
        },
        enumerable: true,
        configurable: true
    });
    // type hack for servercontext interface
    InviteServerContext.prototype.reply = function (options) {
        if (options === void 0) { options = {}; }
        return this;
    };
    // typing note: this was the only function using its super in ServerContext
    // so the bottom half of this function is copied and paired down from that
    InviteServerContext.prototype.reject = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.logger.log("rejecting RTCSession");
        var statusCode = options.statusCode || 480;
        var reasonPhrase = Utils_1.Utils.getReasonPhrase(statusCode, options.reasonPhrase);
        var extraHeaders = options.extraHeaders || [];
        if (statusCode < 300 || statusCode > 699) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
        // FIXME: Need to redirect to someplae
        var response = statusCode < 400 ?
            this.incomingRequest.redirect([], { statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }) :
            this.incomingRequest.reject({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
        (["rejected", "failed"]).forEach(function (event) {
            _this.emit(event, response.message, reasonPhrase);
        });
        return this.terminated();
    };
    /**
     * Accept the incoming INVITE request to start a Session.
     * Replies to the INVITE request with a 200 Ok response.
     * @param options Options bucket.
     */
    InviteServerContext.prototype.accept = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // FIXME: Need guard against calling more than once.
        this._accept(options)
            .then(function (_a) {
            var message = _a.message, session = _a.session;
            session.delegate = {
                onAck: function (ackRequest) { return _this.onAck(ackRequest); },
                onAckTimeout: function () { return _this.onAckTimeout(); },
                onBye: function (byeRequest) { return _this.receiveRequest(byeRequest); },
                onInfo: function (infoRequest) { return _this.receiveRequest(infoRequest); },
                onInvite: function (inviteRequest) { return _this.receiveRequest(inviteRequest); },
                onMessage: function (messageRequest) { return _this.receiveRequest(messageRequest); },
                onNotify: function (notifyRequest) { return _this.receiveRequest(notifyRequest); },
                onPrack: function (prackRequest) { return _this.receiveRequest(prackRequest); },
                onRefer: function (referRequest) { return _this.receiveRequest(referRequest); },
            };
            _this.session = session;
            _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK;
            _this.accepted(message, Utils_1.Utils.getReasonPhrase(200));
        })
            .catch(function (error) {
            _this.onContextError(error);
            // FIXME: Assuming error due to async race on CANCEL and eating error.
            if (!_this._canceled) {
                throw error;
            }
        });
        return this;
    };
    /**
     * Report progress to the the caller.
     * Replies to the INVITE request with a 1xx provisional response.
     * @param options Options bucket.
     */
    InviteServerContext.prototype.progress = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Ported
        var statusCode = options.statusCode || 180;
        if (statusCode < 100 || statusCode > 199) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        // Ported
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.logger.warn("Unexpected call for progress while terminated, ignoring");
            return this;
        }
        // Added
        if (this.status === Enums_1.SessionStatus.STATUS_ANSWERED) {
            this.logger.warn("Unexpected call for progress while answered, ignoring");
            return this;
        }
        // Added
        if (this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
            this.logger.warn("Unexpected call for progress while answered (waiting for prack), ignoring");
            return this;
        }
        // After the first reliable provisional response for a request has been
        // acknowledged, the UAS MAY send additional reliable provisional
        // responses.  The UAS MUST NOT send a second reliable provisional
        // response until the first is acknowledged.  After the first, it is
        // RECOMMENDED that the UAS not send an additional reliable provisional
        // response until the previous is acknowledged.  The first reliable
        // provisional response receives special treatment because it conveys
        // the initial sequence number.  If additional reliable provisional
        // responses were sent before the first was acknowledged, the UAS could
        // not be certain these were received in order.
        // https://tools.ietf.org/html/rfc3262#section-3
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK) {
            this.logger.warn("Unexpected call for progress while waiting for prack, ignoring");
            return this;
        }
        // Ported
        if (options.statusCode === 100) {
            try {
                this.incomingRequest.trying();
            }
            catch (error) {
                this.onContextError(error);
                // FIXME: Assuming error due to async race on CANCEL and eating error.
                if (!this._canceled) {
                    throw error;
                }
            }
            return this;
        }
        // Standard provisional response.
        if (!(this.rel100 === Constants_1.C.supported.REQUIRED) &&
            !(this.rel100 === Constants_1.C.supported.SUPPORTED && options.rel100) &&
            !(this.rel100 === Constants_1.C.supported.SUPPORTED && this.ua.configuration.rel100 === Constants_1.C.supported.REQUIRED)) {
            this._progress(options)
                .catch(function (error) {
                _this.onContextError(error);
                // FIXME: Assuming error due to async race on CANCEL and eating error.
                if (!_this._canceled) {
                    throw error;
                }
            });
            return this;
        }
        // Reliable provisional response.
        this._reliableProgressWaitForPrack(options)
            .catch(function (error) {
            _this.onContextError(error);
            // FIXME: Assuming error due to async race on CANCEL and eating error.
            if (!_this._canceled) {
                throw error;
            }
        });
        return this;
    };
    /**
     * Reject an unaccepted incoming INVITE request or send BYE if established session.
     * @param options Options bucket. FIXME: This options bucket needs to be typed.
     */
    InviteServerContext.prototype.terminate = function (options) {
        // The caller's UA MAY send a BYE for either confirmed or early dialogs,
        // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT
        // send a BYE on early dialogs. However, the callee's UA MUST NOT send a
        // BYE on a confirmed dialog until it has received an ACK for its 2xx
        // response or until the server transaction times out.
        // https://tools.ietf.org/html/rfc3261#section-15
        var _this = this;
        if (options === void 0) { options = {}; }
        // We don't yet have a dialog, so reject request.
        if (!this.session) {
            this.reject(options);
            return this;
        }
        switch (this.session.sessionState) {
            case core_1.SessionState.Initial:
                this.reject(options);
                return this;
            case core_1.SessionState.Early:
                this.reject(options);
                return this;
            case core_1.SessionState.AckWait:
                this.session.delegate = {
                    // When ACK shows up, say BYE.
                    onAck: function () {
                        _this.sendRequest(Constants_1.C.BYE, options);
                    },
                    // Or the server transaction times out before the ACK arrives.
                    onAckTimeout: function () {
                        _this.sendRequest(Constants_1.C.BYE, options);
                    }
                };
                // Ported
                this.emit("bye", this.request);
                this.terminated();
                return this;
            case core_1.SessionState.Confirmed:
                this.bye(options);
                return this;
            case core_1.SessionState.Terminated:
                return this;
            default:
                return this;
        }
    };
    InviteServerContext.prototype.onCancel = function (message) {
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER ||
            this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK ||
            this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK ||
            this.status === Enums_1.SessionStatus.STATUS_EARLY_MEDIA ||
            this.status === Enums_1.SessionStatus.STATUS_ANSWERED) {
            this.status = Enums_1.SessionStatus.STATUS_CANCELED;
            this.incomingRequest.reject({ statusCode: 487 });
            this.canceled();
            this.rejected(message, Constants_1.C.causes.CANCELED);
            this.failed(message, Constants_1.C.causes.CANCELED);
            this.terminated(message, Constants_1.C.causes.CANCELED);
        }
    };
    InviteServerContext.prototype.receiveRequest = function (incomingRequest) {
        var _this = this;
        switch (incomingRequest.message.method) {
            case Constants_1.C.PRACK:
                if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK ||
                    this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
                    if (!this.hasAnswer) {
                        this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
                        this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
                        if (this.sessionDescriptionHandler.hasDescription(incomingRequest.message.getHeader("Content-Type") || "")) {
                            this.hasAnswer = true;
                            this.sessionDescriptionHandler.setDescription(incomingRequest.message.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () {
                                clearTimeout(_this.timers.rel1xxTimer);
                                clearTimeout(_this.timers.prackTimer);
                                incomingRequest.accept();
                                if (_this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
                                    _this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                                    _this.accept();
                                }
                                _this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                            }, function (e) {
                                _this.logger.warn(e);
                                _this.terminate({
                                    statusCode: "488",
                                    reasonPhrase: "Bad Media Description"
                                });
                                _this.failed(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                                _this.terminated(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                            });
                        }
                        else {
                            this.terminate({
                                statusCode: "488",
                                reasonPhrase: "Bad Media Description"
                            });
                            this.failed(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                            this.terminated(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                        }
                    }
                    else {
                        clearTimeout(this.timers.rel1xxTimer);
                        clearTimeout(this.timers.prackTimer);
                        incomingRequest.accept();
                        if (this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
                            this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                            this.accept();
                        }
                        this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                    }
                }
                else if (this.status === Enums_1.SessionStatus.STATUS_EARLY_MEDIA) {
                    incomingRequest.accept();
                }
                break;
            default:
                _super.prototype.receiveRequest.call(this, incomingRequest);
                break;
        }
    };
    // Internal Function to setup the handler consistently
    InviteServerContext.prototype.setupSessionDescriptionHandler = function () {
        if (this.sessionDescriptionHandler) {
            return this.sessionDescriptionHandler;
        }
        return this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions);
    };
    InviteServerContext.prototype.generateResponseOfferAnswer = function (options) {
        if (!this.session) {
            var body = core_1.getBody(this.incomingRequest.message);
            if (!body || body.contentDisposition !== "session") {
                return this.getOffer(options);
            }
            else {
                return this.setOfferAndGetAnswer(body, options);
            }
        }
        else {
            switch (this.session.signalingState) {
                case core_1.SignalingState.Initial:
                    return this.getOffer(options);
                case core_1.SignalingState.Stable:
                    return Promise.resolve(undefined);
                case core_1.SignalingState.HaveLocalOffer:
                    // o  Once the UAS has sent or received an answer to the initial
                    // offer, it MUST NOT generate subsequent offers in any responses
                    // to the initial INVITE.  This means that a UAS based on this
                    // specification alone can never generate subsequent offers until
                    // completion of the initial transaction.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    return Promise.resolve(undefined);
                case core_1.SignalingState.HaveRemoteOffer:
                    if (!this.session.offer) {
                        throw new Error("Session offer undefined");
                    }
                    return this.setOfferAndGetAnswer(this.session.offer, options);
                case core_1.SignalingState.Closed:
                    throw new Error("Invalid signaling state " + this.session.signalingState + ".");
                default:
                    throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            }
        }
    };
    InviteServerContext.prototype.handlePrackOfferAnswer = function (request, options) {
        if (!this.session) {
            throw new Error("Session undefined.");
        }
        // If the PRACK doesn't have an offer/answer, nothing to be done.
        var body = core_1.getBody(request.message);
        if (!body || body.contentDisposition !== "session") {
            return Promise.resolve(undefined);
        }
        // If the UAC receives a reliable provisional response with an offer
        // (this would occur if the UAC sent an INVITE without an offer, in
        // which case the first reliable provisional response will contain the
        // offer), it MUST generate an answer in the PRACK.  If the UAC receives
        // a reliable provisional response with an answer, it MAY generate an
        // additional offer in the PRACK.  If the UAS receives a PRACK with an
        // offer, it MUST place the answer in the 2xx to the PRACK.
        // https://tools.ietf.org/html/rfc3262#section-5
        switch (this.session.signalingState) {
            case core_1.SignalingState.Initial:
                // State should never be reached as first reliable provisional response must have answer/offer.
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            case core_1.SignalingState.Stable:
                // Receved answer.
                return this.setAnswer(body, options).then(function () { return undefined; });
            case core_1.SignalingState.HaveLocalOffer:
                // State should never be reached as local offer would be answered by this PRACK
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            case core_1.SignalingState.HaveRemoteOffer:
                // Receved offer, generate answer.
                return this.setOfferAndGetAnswer(body, options);
            case core_1.SignalingState.Closed:
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            default:
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
        }
    };
    /**
     * Called when session canceled.
     */
    InviteServerContext.prototype.canceled = function () {
        this._canceled = true;
        return _super.prototype.canceled.call(this);
    };
    /**
     * Called when session terminated.
     * Using it here just for the PRACK timeout.
     */
    InviteServerContext.prototype.terminated = function (message, cause) {
        this.prackNeverArrived();
        return _super.prototype.terminated.call(this, message, cause);
    };
    /**
     * A version of `accept` which resolves a session when the 200 Ok response is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `accept()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._accept = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // FIXME: Ported - callback for in dialog INFO requests.
        // Turns out accept() can be called more than once if we are waiting
        // for a PRACK in which case "options" get completely tossed away.
        // So this is broken in that case (and potentially other uses of options).
        // Tempted to just try to fix it now, but leaving it broken for the moment.
        this.onInfo = options.onInfo;
        // The UAS MAY send a final response to the initial request before
        // having received PRACKs for all unacknowledged reliable provisional
        // responses, unless the final response is 2xx and any of the
        // unacknowledged reliable provisional responses contained a session
        // description.  In that case, it MUST NOT send a final response until
        // those provisional responses are acknowledged.  If the UAS does send a
        // final response when reliable responses are still unacknowledged, it
        // SHOULD NOT continue to retransmit the unacknowledged reliable
        // provisional responses, but it MUST be prepared to process PRACK
        // requests for those outstanding responses.  A UAS MUST NOT send new
        // reliable provisional responses (as opposed to retransmissions of
        // unacknowledged ones) after sending a final response to a request.
        // https://tools.ietf.org/html/rfc3262#section-3
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK) {
            this.status = Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK;
            return this.waitForArrivalOfPrack()
                .then(function () {
                _this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
                clearTimeout(_this.timers.userNoAnswerTimer); // Ported
            })
                .then(function () { return _this.generateResponseOfferAnswer(options); })
                .then(function (body) { return _this.incomingRequest.accept({ statusCode: 200, body: body }); });
        }
        // Ported
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
            this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
        }
        else {
            return Promise.reject(new Exceptions_1.Exceptions.InvalidStateError(this.status));
        }
        this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
        clearTimeout(this.timers.userNoAnswerTimer); // Ported
        return this.generateResponseOfferAnswer(options)
            .then(function (body) { return _this.incomingRequest.accept({ statusCode: 200, body: body }); });
    };
    /**
     * A version of `progress` which resolves when the provisional response is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._progress = function (options) {
        if (options === void 0) { options = {}; }
        // Ported
        var statusCode = options.statusCode || 180;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
        // The 183 (Session Progress) response is used to convey information
        // about the progress of the call that is not otherwise classified.  The
        // Reason-Phrase, header fields, or message body MAY be used to convey
        // more details about the call progress.
        // https://tools.ietf.org/html/rfc3261#section-21.1.5
        // It is the de facto industry standard to utilize 183 with SDP to provide "early media".
        // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.
        if (statusCode === 183 && !body) {
            return this._progressWithSDP(options);
        }
        try {
            var progressResponse = this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
            this.emit("progress", progressResponse.message, reasonPhrase); // Ported
            this.session = progressResponse.session;
            return Promise.resolve(progressResponse);
        }
        catch (error) {
            return Promise.reject(error);
        }
    };
    /**
     * A version of `progress` which resolves when the provisional response with sdp is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._progressWithSDP = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 183;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        // Get an offer/answer and send a reply.
        return this.generateResponseOfferAnswer(options)
            .then(function (body) { return _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }); })
            .then(function (progressResponse) {
            _this.emit("progress", progressResponse.message, reasonPhrase); // Ported
            _this.session = progressResponse.session;
            return progressResponse;
        });
    };
    /**
     * A version of `progress` which resolves when the reliable provisional response is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._reliableProgress = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 183;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        extraHeaders.push("Require: 100rel");
        extraHeaders.push("RSeq: " + Math.floor(Math.random() * 10000));
        // Get an offer/answer and send a reply.
        return this.generateResponseOfferAnswer(options)
            .then(function (body) { return _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }); })
            .then(function (progressResponse) {
            _this.emit("progress", progressResponse.message, reasonPhrase); // Ported
            _this.session = progressResponse.session;
            return progressResponse;
        });
    };
    /**
     * A version of `progress` which resolves when the reliable provisional response is acknowledged.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._reliableProgressWaitForPrack = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 183;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        extraHeaders.push("Require: 100rel");
        extraHeaders.push("RSeq: " + this.rseq++);
        var body;
        // Ported - set status.
        this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK;
        return new Promise(function (resolve, reject) {
            var waitingForPrack = true;
            return _this.generateResponseOfferAnswer(options)
                .then(function (offerAnswer) {
                body = offerAnswer;
                return _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
            })
                .then(function (progressResponse) {
                _this.emit("progress", progressResponse.message, reasonPhrase); // Ported
                _this.session = progressResponse.session;
                var prackRequest;
                var prackResponse;
                progressResponse.session.delegate = {
                    onPrack: function (request) {
                        prackRequest = request;
                        clearTimeout(prackWaitTimeoutTimer);
                        clearTimeout(rel1xxRetransmissionTimer);
                        if (!waitingForPrack) {
                            return;
                        }
                        waitingForPrack = false;
                        _this.handlePrackOfferAnswer(prackRequest, options)
                            .then(function (prackResponseBody) {
                            try {
                                prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });
                                // Ported - set status.
                                if (_this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK) {
                                    _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER;
                                }
                                _this.prackArrived();
                                resolve({ prackRequest: prackRequest, prackResponse: prackResponse, progressResponse: progressResponse });
                            }
                            catch (error) {
                                reject(error);
                            }
                        });
                    }
                };
                // https://tools.ietf.org/html/rfc3262#section-3
                var prackWaitTimeout = function () {
                    if (!waitingForPrack) {
                        return;
                    }
                    waitingForPrack = false;
                    _this.logger.warn("No PRACK received, rejecting INVITE.");
                    clearTimeout(rel1xxRetransmissionTimer);
                    try {
                        _this.incomingRequest.reject({ statusCode: 504 });
                        _this.terminated(undefined, Constants_1.C.causes.NO_PRACK);
                        reject(new Exceptions_1.Exceptions.TerminatedSessionError());
                    }
                    catch (error) {
                        reject(error);
                    }
                };
                var prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, core_1.Timers.T1 * 64);
                // https://tools.ietf.org/html/rfc3262#section-3
                var rel1xxRetransmission = function () {
                    try {
                        _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
                    }
                    catch (error) {
                        waitingForPrack = false;
                        reject(error);
                        return;
                    }
                    rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);
                };
                var timeout = core_1.Timers.T1;
                var rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);
            });
        });
    };
    /**
     * Callback for when ACK for a 2xx response is never received.
     * @param session Session the ACK never arrived for
     */
    InviteServerContext.prototype.onAckTimeout = function () {
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            this.logger.log("no ACK received for an extended period of time, terminating the call");
            if (!this.session) {
                throw new Error("Session undefined.");
            }
            this.session.bye();
            this.terminated(undefined, Constants_1.C.causes.NO_ACK);
        }
    };
    /**
     * FIXME: TODO: The current library interface presents async methods without a
     * proper async error handling mechanism. Arguably a promise based interface
     * would be an improvement over the pattern of returning `this`. The approach has
     * been generally along the lines of log a error and terminate.
     */
    InviteServerContext.prototype.onContextError = function (error) {
        var statusCode = 480;
        if (error instanceof core_1.Exception) { // There might be interest in catching these Exceptions.
            if (error instanceof Exceptions_1.Exceptions.SessionDescriptionHandlerError) {
                this.logger.error(error.message);
                if (error.error) {
                    this.logger.error(error.error);
                }
            }
            else if (error instanceof Exceptions_1.Exceptions.TerminatedSessionError) {
                // PRACK never arrived, so we timed out waiting for it.
                this.logger.warn("Incoming session terminated while waiting for PRACK.");
            }
            else if (error instanceof Exceptions_1.Exceptions.UnsupportedSessionDescriptionContentTypeError) {
                statusCode = 415;
            }
            else if (error instanceof core_1.Exception) {
                this.logger.error(error.message);
            }
        }
        else if (error instanceof Error) { // Other Errors hould go uncaught.
            this.logger.error(error.message);
        }
        else {
            // We don't actually know what a session description handler implementation might throw
            // our way, so as a last resort, just assume we are getting an "any" and log it.
            this.logger.error("An error occurred in the session description handler.");
            this.logger.error(error);
        }
        try {
            this.incomingRequest.reject({ statusCode: statusCode }); // "Temporarily Unavailable"
            this.failed(this.incomingRequest.message, error.message);
            this.terminated(this.incomingRequest.message, error.message);
        }
        catch (error) {
            return;
        }
    };
    InviteServerContext.prototype.prackArrived = function () {
        if (this.waitingForPrackResolve) {
            this.waitingForPrackResolve();
        }
        this.waitingForPrackPromise = undefined;
        this.waitingForPrackResolve = undefined;
        this.waitingForPrackReject = undefined;
    };
    InviteServerContext.prototype.prackNeverArrived = function () {
        if (this.waitingForPrackReject) {
            this.waitingForPrackReject(new Exceptions_1.Exceptions.TerminatedSessionError());
        }
        this.waitingForPrackPromise = undefined;
        this.waitingForPrackResolve = undefined;
        this.waitingForPrackReject = undefined;
    };
    /**
     * @throws {Exceptions.TerminatedSessionError} The session terminated before being accepted (i.e. cancel arrived).
     */
    InviteServerContext.prototype.waitForArrivalOfPrack = function () {
        var _this = this;
        if (this.waitingForPrackPromise) {
            throw new Error("Already waiting for PRACK");
        }
        this.waitingForPrackPromise = new Promise(function (resolve, reject) {
            _this.waitingForPrackResolve = resolve;
            _this.waitingForPrackReject = reject;
        });
        return this.waitingForPrackPromise;
    };
    InviteServerContext.prototype.getOffer = function (options) {
        this.hasOffer = true;
        var sdh = this.getSessionDescriptionHandler();
        return sdh
            .getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
            .then(function (bodyObj) { return Utils_1.Utils.fromBodyObj(bodyObj); });
    };
    InviteServerContext.prototype.setAnswer = function (answer, options) {
        this.hasAnswer = true;
        var sdh = this.getSessionDescriptionHandler();
        if (!sdh.hasDescription(answer.contentType)) {
            return Promise.reject(new Exceptions_1.Exceptions.UnsupportedSessionDescriptionContentTypeError());
        }
        return sdh
            .setDescription(answer.content, options.sessionDescriptionHandlerOptions, options.modifiers);
    };
    InviteServerContext.prototype.setOfferAndGetAnswer = function (offer, options) {
        this.hasOffer = true;
        this.hasAnswer = true;
        var sdh = this.getSessionDescriptionHandler();
        if (!sdh.hasDescription(offer.contentType)) {
            return Promise.reject(new Exceptions_1.Exceptions.UnsupportedSessionDescriptionContentTypeError());
        }
        return sdh
            .setDescription(offer.content, options.sessionDescriptionHandlerOptions, options.modifiers)
            .then(function () { return sdh.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers); })
            .then(function (bodyObj) { return Utils_1.Utils.fromBodyObj(bodyObj); });
    };
    InviteServerContext.prototype.getSessionDescriptionHandler = function () {
        // Create our session description handler if not already done so...
        var sdh = this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
        // FIXME: Ported - this can get emitted multiple times even when only created once... don't we care?
        this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
        // Return.
        return sdh;
    };
    return InviteServerContext;
}(Session));
exports.InviteServerContext = InviteServerContext;
// tslint:disable-next-line:max-classes-per-file
var InviteClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(InviteClientContext, _super);
    function InviteClientContext(ua, target, options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        var _this = this;
        if (!ua.configuration.sessionDescriptionHandlerFactory) {
            ua.logger.warn("Can't build ISC without SDH Factory");
            throw new Error("ICC Constructor Failed");
        }
        options.params = options.params || {};
        var anonymous = options.anonymous || false;
        var fromTag = Utils_1.Utils.newTag();
        options.params.fromTag = fromTag;
        /* Do not add ;ob in initial forming dialog requests if the registration over
        *  the current connection got a GRUU URI.
        */
        var contact = ua.contact.toString({
            anonymous: anonymous,
            outbound: anonymous ? !ua.contact.tempGruu : !ua.contact.pubGruu
        });
        var extraHeaders = (options.extraHeaders || []).slice();
        if (anonymous && ua.configuration.uri) {
            options.params.fromDisplayName = "Anonymous";
            options.params.fromUri = "sip:anonymous@anonymous.invalid";
            extraHeaders.push("P-Preferred-Identity: " + ua.configuration.uri.toString());
            extraHeaders.push("Privacy: id");
        }
        extraHeaders.push("Contact: " + contact);
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        if (ua.configuration.rel100 === Constants_1.C.supported.REQUIRED) {
            extraHeaders.push("Require: 100rel");
        }
        if (ua.configuration.replaces === Constants_1.C.supported.REQUIRED) {
            extraHeaders.push("Require: replaces");
        }
        options.extraHeaders = extraHeaders;
        _this = _super.call(this, ua.configuration.sessionDescriptionHandlerFactory) || this;
        ClientContext_1.ClientContext.initializer(_this, ua, Constants_1.C.INVITE, target, options);
        _this.earlyMediaSessionDescriptionHandlers = new Map();
        _this.type = Enums_1.TypeStrings.InviteClientContext;
        _this.passedOptions = options; // Save for later to use with refer
        _this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions || {};
        _this.modifiers = modifiers;
        _this.inviteWithoutSdp = options.inviteWithoutSdp || false;
        // Set anonymous property
        _this.anonymous = options.anonymous || false;
        // Custom data to be sent either in INVITE or in ACK
        _this.renderbody = options.renderbody || undefined;
        _this.rendertype = options.rendertype || "text/plain";
        // Session parameter initialization
        _this.fromTag = fromTag;
        _this.contact = contact;
        // Check Session Status
        if (_this.status !== Enums_1.SessionStatus.STATUS_NULL) {
            throw new Exceptions_1.Exceptions.InvalidStateError(_this.status);
        }
        // OutgoingSession specific parameters
        _this.isCanceled = false;
        _this.received100 = false;
        _this.method = Constants_1.C.INVITE;
        _this.logger = ua.getLogger("sip.inviteclientcontext");
        ua.applicants[_this.toString()] = _this;
        _this.id = _this.request.callId + _this.fromTag;
        _this.onInfo = options.onInfo;
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        return _this;
    }
    InviteClientContext.prototype.receiveResponse = function (response) {
        throw new Error("Unimplemented.");
    };
    // hack for getting around ClientContext interface
    InviteClientContext.prototype.send = function () {
        this.sendInvite();
        return this;
    };
    InviteClientContext.prototype.invite = function () {
        var _this = this;
        // Save the session into the ua sessions collection.
        // Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
        this.ua.sessions[this.id] = this;
        // This should allow the function to return so that listeners can be set up for these events
        Promise.resolve().then(function () {
            // FIXME: There is a race condition where cancel (or terminate) can be called synchronously after invite.
            if (_this.isCanceled || _this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                return;
            }
            if (_this.inviteWithoutSdp) {
                // just send an invite with no sdp...
                if (_this.renderbody && _this.rendertype) {
                    _this.request.body = {
                        body: _this.renderbody,
                        contentType: _this.rendertype
                    };
                }
                _this.status = Enums_1.SessionStatus.STATUS_INVITE_SENT;
                _this.send();
            }
            else {
                // Initialize Media Session
                _this.sessionDescriptionHandler = _this.sessionDescriptionHandlerFactory(_this, _this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
                _this.emit("SessionDescriptionHandler-created", _this.sessionDescriptionHandler);
                _this.sessionDescriptionHandler.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers)
                    .then(function (description) {
                    // FIXME: There is a race condition where cancel (or terminate) can be called (a)synchronously after invite.
                    if (_this.isCanceled || _this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return;
                    }
                    _this.hasOffer = true;
                    _this.request.body = description;
                    _this.status = Enums_1.SessionStatus.STATUS_INVITE_SENT;
                    _this.send();
                }, function (err) {
                    if (err.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                        _this.logger.log(err.message);
                        if (err.error) {
                            _this.logger.log(err.error);
                        }
                    }
                    if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return;
                    }
                    _this.failed(undefined, Constants_1.C.causes.WEBRTC_ERROR);
                    _this.terminated(undefined, Constants_1.C.causes.WEBRTC_ERROR);
                });
            }
        });
        return this;
    };
    InviteClientContext.prototype.cancel = function (options) {
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED || this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (this.isCanceled) {
            throw new Exceptions_1.Exceptions.InvalidStateError(Enums_1.SessionStatus.STATUS_CANCELED);
        }
        this.isCanceled = true;
        this.logger.log("Canceling session");
        var cancelReason = Utils_1.Utils.getCancelReason(options.statusCode, options.reasonPhrase);
        options.extraHeaders = (options.extraHeaders || []).slice();
        if (this.outgoingInviteRequest) {
            this.logger.warn("Canceling session before it was created");
            this.outgoingInviteRequest.cancel(cancelReason, options);
        }
        return this.canceled();
    };
    InviteClientContext.prototype.terminate = function (options) {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK || this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            this.bye(options);
        }
        else {
            this.cancel(options);
        }
        return this;
    };
    /**
     * 13.2.1 Creating the Initial INVITE
     *
     * Since the initial INVITE represents a request outside of a dialog,
     * its construction follows the procedures of Section 8.1.1.  Additional
     * processing is required for the specific case of INVITE.
     *
     * An Allow header field (Section 20.5) SHOULD be present in the INVITE.
     * It indicates what methods can be invoked within a dialog, on the UA
     * sending the INVITE, for the duration of the dialog.  For example, a
     * UA capable of receiving INFO requests within a dialog [34] SHOULD
     * include an Allow header field listing the INFO method.
     *
     * A Supported header field (Section 20.37) SHOULD be present in the
     * INVITE.  It enumerates all the extensions understood by the UAC.
     *
     * An Accept (Section 20.1) header field MAY be present in the INVITE.
     * It indicates which Content-Types are acceptable to the UA, in both
     * the response received by it, and in any subsequent requests sent to
     * it within dialogs established by the INVITE.  The Accept header field
     * is especially useful for indicating support of various session
     * description formats.
     *
     * The UAC MAY add an Expires header field (Section 20.19) to limit the
     * validity of the invitation.  If the time indicated in the Expires
     * header field is reached and no final answer for the INVITE has been
     * received, the UAC core SHOULD generate a CANCEL request for the
     * INVITE, as per Section 9.
     *
     * A UAC MAY also find it useful to add, among others, Subject (Section
     * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)
     * header fields.  They all contain information related to the INVITE.
     *
     * The UAC MAY choose to add a message body to the INVITE.  Section
     * 8.1.1.10 deals with how to construct the header fields -- Content-
     * Type among others -- needed to describe the message body.
     *
     * https://tools.ietf.org/html/rfc3261#section-13.2.1
     */
    InviteClientContext.prototype.sendInvite = function () {
        //    There are special rules for message bodies that contain a session
        //    description - their corresponding Content-Disposition is "session".
        //    SIP uses an offer/answer model where one UA sends a session
        //    description, called the offer, which contains a proposed description
        //    of the session.  The offer indicates the desired communications means
        //    (audio, video, games), parameters of those means (such as codec
        //    types) and addresses for receiving media from the answerer.  The
        //    other UA responds with another session description, called the
        //    answer, which indicates which communications means are accepted, the
        //    parameters that apply to those means, and addresses for receiving
        //    media from the offerer. An offer/answer exchange is within the
        //    context of a dialog, so that if a SIP INVITE results in multiple
        //    dialogs, each is a separate offer/answer exchange.  The offer/answer
        //    model defines restrictions on when offers and answers can be made
        //    (for example, you cannot make a new offer while one is in progress).
        //    This results in restrictions on where the offers and answers can
        //    appear in SIP messages.  In this specification, offers and answers
        //    can only appear in INVITE requests and responses, and ACK.  The usage
        //    of offers and answers is further restricted.  For the initial INVITE
        //    transaction, the rules are:
        //
        //       o  The initial offer MUST be in either an INVITE or, if not there,
        //          in the first reliable non-failure message from the UAS back to
        //          the UAC.  In this specification, that is the final 2xx
        //          response.
        //
        //       o  If the initial offer is in an INVITE, the answer MUST be in a
        //          reliable non-failure message from UAS back to UAC which is
        //          correlated to that INVITE.  For this specification, that is
        //          only the final 2xx response to that INVITE.  That same exact
        //          answer MAY also be placed in any provisional responses sent
        //          prior to the answer.  The UAC MUST treat the first session
        //          description it receives as the answer, and MUST ignore any
        //          session descriptions in subsequent responses to the initial
        //          INVITE.
        //
        //       o  If the initial offer is in the first reliable non-failure
        //          message from the UAS back to UAC, the answer MUST be in the
        //          acknowledgement for that message (in this specification, ACK
        //          for a 2xx response).
        //
        //       o  After having sent or received an answer to the first offer, the
        //          UAC MAY generate subsequent offers in requests based on rules
        //          specified for that method, but only if it has received answers
        //          to any previous offers, and has not sent any offers to which it
        //          hasn't gotten an answer.
        //
        //       o  Once the UAS has sent or received an answer to the initial
        //          offer, it MUST NOT generate subsequent offers in any responses
        //          to the initial INVITE.  This means that a UAS based on this
        //          specification alone can never generate subsequent offers until
        //          completion of the initial transaction.
        //
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        var _this = this;
        // 5 The Offer/Answer Model and PRACK
        //
        //    RFC 3261 describes guidelines for the sets of messages in which
        //    offers and answers [3] can appear.  Based on those guidelines, this
        //    extension provides additional opportunities for offer/answer
        //    exchanges.
        //    If the INVITE contained an offer, the UAS MAY generate an answer in a
        //    reliable provisional response (assuming these are supported by the
        //    UAC).  That results in the establishment of the session before
        //    completion of the call.  Similarly, if a reliable provisional
        //    response is the first reliable message sent back to the UAC, and the
        //    INVITE did not contain an offer, one MUST appear in that reliable
        //    provisional response.
        //    If the UAC receives a reliable provisional response with an offer
        //    (this would occur if the UAC sent an INVITE without an offer, in
        //    which case the first reliable provisional response will contain the
        //    offer), it MUST generate an answer in the PRACK.  If the UAC receives
        //    a reliable provisional response with an answer, it MAY generate an
        //    additional offer in the PRACK.  If the UAS receives a PRACK with an
        //    offer, it MUST place the answer in the 2xx to the PRACK.
        //    Once an answer has been sent or received, the UA SHOULD establish the
        //    session based on the parameters of the offer and answer, even if the
        //    original INVITE itself has not been responded to.
        //    If the UAS had placed a session description in any reliable
        //    provisional response that is unacknowledged when the INVITE is
        //    accepted, the UAS MUST delay sending the 2xx until the provisional
        //    response is acknowledged.  Otherwise, the reliability of the 1xx
        //    cannot be guaranteed, and reliability is needed for proper operation
        //    of the offer/answer exchange.
        //    All user agents that support this extension MUST support all
        //    offer/answer exchanges that are possible based on the rules in
        //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK
        //    as requests, and 2xx and reliable 1xx as non-failure reliable
        //    responses.
        //
        // https://tools.ietf.org/html/rfc3262#section-5
        ////
        // The Offer/Answer Model Implementation
        //
        // The offer/answer model is straight forward, but one MUST READ the specifications...
        //
        // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // 5 The Offer/Answer Model and PRACK
        // https://tools.ietf.org/html/rfc3262#section-5
        //
        // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model
        // https://tools.ietf.org/html/rfc6337
        //
        // *** IMPORTANT IMPLEMENTATION CHOICES ***
        //
        // TLDR...
        //
        //  1) Only one offer/answer exchange permitted during initial INVITE.
        //  2) No "early media" if the initial offer is in an INVITE.
        //
        //
        // 1) Initial Offer/Answer Restriction.
        //
        // Our implementation replaces the following bullet point...
        //
        // o  After having sent or received an answer to the first offer, the
        //    UAC MAY generate subsequent offers in requests based on rules
        //    specified for that method, but only if it has received answers
        //    to any previous offers, and has not sent any offers to which it
        //    hasn't gotten an answer.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // ...with...
        //
        // o  After having sent or received an answer to the first offer, the
        //    UAC MUST NOT generate subsequent offers in requests based on rules
        //    specified for that method.
        //
        // ...which in combination with this bullet point...
        //
        // o  Once the UAS has sent or received an answer to the initial
        //    offer, it MUST NOT generate subsequent offers in any responses
        //    to the initial INVITE.  This means that a UAS based on this
        //    specification alone can never generate subsequent offers until
        //    completion of the initial transaction.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // ...ensures that EXACTLY ONE offer/answer exchange will occur
        // during an initial out of dialog INVITE request made by our UAC.
        //
        //
        // 2) Early Media Restriction.
        //
        // While our implementation adheres to the following bullet point...
        //
        // o  If the initial offer is in an INVITE, the answer MUST be in a
        //    reliable non-failure message from UAS back to UAC which is
        //    correlated to that INVITE.  For this specification, that is
        //    only the final 2xx response to that INVITE.  That same exact
        //    answer MAY also be placed in any provisional responses sent
        //    prior to the answer.  The UAC MUST treat the first session
        //    description it receives as the answer, and MUST ignore any
        //    session descriptions in subsequent responses to the initial
        //    INVITE.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // We have made the following implementation decision with regard to early media...
        //
        // o  If the initial offer is in the INVITE, the answer from the
        //    UAS back to the UAC will establish a media session only
        //    only after the final 2xx response to that INVITE is received.
        //
        // The reason for this decision is rooted in a restriction currently
        // inherent in WebRTC. Specifically, while a SIP INVITE request with an
        // initial offer may fork resulting in more than one provisional answer,
        // there is currently no easy/good way to to "fork" an offer generated
        // by a peer connection. In particular, a WebRTC offer currently may only
        // be matched with one answer and we have no good way to know which
        // "provisional answer" is going to be the "final answer". So we have
        // decided to punt and not create any "early media" sessions in this case.
        //
        // The upshot is that if you want "early media", you must not put the
        // initial offer in the INVITE. Instead, force the UAS to provide the
        // initial offer by sending an INVITE without an offer. In the WebRTC
        // case this allows us to create a unique peer connection with a unique
        // answer for every provisional offer with "early media" on all of them.
        ////
        ////
        // ROADMAP: The Offer/Answer Model Implementation
        //
        // The "no early media if offer in INVITE" implementation is not a
        // welcome one. The masses want it. The want it and they want it
        // to work for WebRTC (so they want to have their cake and eat too).
        //
        // So while we currently cannot make the offer in INVITE+forking+webrtc
        // case work, we decided to do the following...
        //
        // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...
        // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...
        // 3) ask SDH Factory if it supports "earlyRemoteAnswer"
        //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)
        //   b) if false, defer getting a SDH until 2xx response is received
        //
        // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)
        // early media if initial offer is in the INVITE). We will, however, provide an "inviteWillNotFork"
        // option which if set to "true" will have our supplied WebRTC SDH behave in the 3a manner.
        // That will result in
        //  - early media working with initial offer in the INVITE, and...
        //  - if the INVITE forks, the session terminating with an ERROR that reads like
        //    "You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too."
        //  - furthermore, we accept that users will report that error to us as "bug" regardless
        //
        // So, SDH Factory is going to end up with a new interface along the lines of...
        //
        // interface SessionDescriptionHandlerFactory {
        //   makeLocalOffer(): Promise<ContentTypeAndBody>;
        //   makeSessionDescriptionHandler(
        //     initialOffer: ContentTypeAndBody, offerType: "local" | "remote"
        //   ): Promise<SessionDescriptionHandler>;
        //   supportsEarlyRemoteAnswer: boolean;
        //   supportsContentType(contentType: string): boolean;
        //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>
        //   setDescription(description: ContentTypeAndBody): Promise<void>
        // }
        //
        // We should be able to get rid of all the hasOffer/hasAnswer tracking code and otherwise code
        // it up to the same interaction with the SDH Factory and SDH regardless of signaling scenario.
        ////
        // Send the INVITE request.
        this.outgoingInviteRequest = this.ua.userAgentCore.invite(this.request, {
            onAccept: function (inviteResponse) { return _this.onAccept(inviteResponse); },
            onProgress: function (inviteResponse) { return _this.onProgress(inviteResponse); },
            onRedirect: function (inviteResponse) { return _this.onRedirect(inviteResponse); },
            onReject: function (inviteResponse) { return _this.onReject(inviteResponse); },
            onTrying: function (inviteResponse) { return _this.onTrying(inviteResponse); }
        });
    };
    InviteClientContext.prototype.ackAndBye = function (inviteResponse, session, statusCode, reasonPhrase) {
        if (!this.ua.userAgentCore) {
            throw new Error("Method requires user agent core.");
        }
        var extraHeaders = [];
        if (statusCode) {
            extraHeaders.push("Reason: " + Utils_1.Utils.getReasonHeaderValue(statusCode, reasonPhrase));
        }
        var outgoingAckRequest = inviteResponse.ack();
        this.emit("ack", outgoingAckRequest.message);
        var outgoingByeRequest = session.bye(undefined, { extraHeaders: extraHeaders });
        this.emit("bye", outgoingByeRequest.message);
    };
    InviteClientContext.prototype.disposeEarlyMedia = function () {
        if (!this.earlyMediaSessionDescriptionHandlers) {
            throw new Error("Early media session description handlers undefined.");
        }
        this.earlyMediaSessionDescriptionHandlers.forEach(function (sessionDescriptionHandler) {
            sessionDescriptionHandler.close();
        });
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 2xx response.
     */
    InviteClientContext.prototype.onAccept = function (inviteResponse) {
        var _this = this;
        if (!this.earlyMediaSessionDescriptionHandlers) {
            throw new Error("Early media session description handlers undefined.");
        }
        var response = inviteResponse.message;
        var session = inviteResponse.session;
        // Our transaction layer is "non-standard" in that it will only
        // pass us a 2xx response once per branch, so there is no need to
        // worry about dealing with 2xx retransmissions. However, we can
        // and do still get 2xx responses for multiple branches (when an
        // INVITE is forked) which may create multiple confirmed dialogs.
        // Herein we are acking and sending a bye to any confirmed dialogs
        // which arrive beyond the first one. This is the desired behavior
        // for most applications (but certainly not all).
        // If we already received a confirmed dialog, ack & bye this session.
        if (this.session) {
            this.ackAndBye(inviteResponse, session);
            return;
        }
        // If the user requested cancellation, ack & bye this session.
        if (this.isCanceled) {
            this.ackAndBye(inviteResponse, session);
            this.emit("bye", this.request); // FIXME: Ported this odd second "bye" emit
            return;
        }
        // Ported behavior.
        if (response.hasHeader("P-Asserted-Identity")) {
            this.assertedIdentity = core_1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
        }
        // We have a confirmed dialog.
        this.session = session;
        this.session.delegate = {
            onAck: function (ackRequest) { return _this.onAck(ackRequest); },
            onBye: function (byeRequest) { return _this.receiveRequest(byeRequest); },
            onInfo: function (infoRequest) { return _this.receiveRequest(infoRequest); },
            onInvite: function (inviteRequest) { return _this.receiveRequest(inviteRequest); },
            onMessage: function (messageRequest) { return _this.receiveRequest(messageRequest); },
            onNotify: function (notifyRequest) { return _this.receiveRequest(notifyRequest); },
            onPrack: function (prackRequest) { return _this.receiveRequest(prackRequest); },
            onRefer: function (referRequest) { return _this.receiveRequest(referRequest); },
        };
        switch (session.signalingState) {
            case core_1.SignalingState.Initial:
                // INVITE without Offer, so MUST have Offer at this point, so invalid state.
                this.ackAndBye(inviteResponse, session, 400, "Missing session description");
                this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                break;
            case core_1.SignalingState.HaveLocalOffer:
                // INVITE with Offer, so MUST have Answer at this point, so invalid state.
                this.ackAndBye(inviteResponse, session, 400, "Missing session description");
                this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                break;
            case core_1.SignalingState.HaveRemoteOffer:
                // INVITE without Offer, received offer in 2xx, so MUST send Answer in ACK.
                var sdh_1 = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
                this.sessionDescriptionHandler = sdh_1;
                this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
                if (!sdh_1.hasDescription(response.getHeader("Content-Type") || "")) {
                    this.ackAndBye(inviteResponse, session, 400, "Missing session description");
                    this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    break;
                }
                this.hasOffer = true;
                sdh_1
                    .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)
                    .then(function () { return sdh_1.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers); })
                    .then(function (description) {
                    if (_this.isCanceled || _this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return;
                    }
                    _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                    _this.hasAnswer = true;
                    var body = {
                        contentDisposition: "session", contentType: description.contentType, content: description.body
                    };
                    var ackRequest = inviteResponse.ack({ body: body });
                    _this.emit("ack", ackRequest.message);
                    _this.accepted(response);
                })
                    .catch(function (e) {
                    if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                        _this.logger.warn("invalid description");
                        _this.logger.warn(e.toString());
                        // TODO: This message is inconsistent
                        _this.ackAndBye(inviteResponse, session, 488, "Invalid session description");
                        _this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    }
                    else {
                        throw e;
                    }
                });
                break;
            case core_1.SignalingState.Stable:
                // This session has completed an initial offer/answer exchange...
                var options_1;
                if (this.renderbody && this.rendertype) {
                    options_1 = { body: { contentDisposition: "render", contentType: this.rendertype, content: this.renderbody } };
                }
                // If INVITE with Offer and we have been waiting till now to apply the answer.
                if (this.hasOffer && !this.hasAnswer) {
                    if (!this.sessionDescriptionHandler) {
                        throw new Error("Session description handler undefined.");
                    }
                    var answer = session.answer;
                    if (!answer) {
                        throw new Error("Answer is undefined.");
                    }
                    this.sessionDescriptionHandler
                        .setDescription(answer.content, this.sessionDescriptionHandlerOptions, this.modifiers)
                        .then(function () {
                        _this.hasAnswer = true;
                        _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                        var ackRequest = inviteResponse.ack(options_1);
                        _this.emit("ack", ackRequest.message);
                        _this.accepted(response);
                    })
                        .catch(function (error) {
                        _this.logger.error(error);
                        _this.ackAndBye(inviteResponse, session, 488, "Not Acceptable Here");
                        _this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                        // FIME: DON'T EAT UNHANDLED ERRORS!
                    });
                }
                else {
                    // Otherwise INVITE with or without Offer and we have already completed the initial exchange.
                    this.sessionDescriptionHandler = this.earlyMediaSessionDescriptionHandlers.get(session.id);
                    if (!this.sessionDescriptionHandler) {
                        throw new Error("Session description handler undefined.");
                    }
                    this.earlyMediaSessionDescriptionHandlers.delete(session.id);
                    this.hasOffer = true;
                    this.hasAnswer = true;
                    this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                    var ackRequest = inviteResponse.ack();
                    this.emit("ack", ackRequest.message);
                    this.accepted(response);
                }
                break;
            case core_1.SignalingState.Closed:
                // Dialog has terminated.
                break;
            default:
                throw new Error("Unknown session signaling state.");
        }
        this.disposeEarlyMedia();
    };
    /**
     * Handle provisional response to initial INVITE.
     * @param inviteResponse 1xx response.
     */
    InviteClientContext.prototype.onProgress = function (inviteResponse) {
        var _this = this;
        // Ported - User requested cancellation.
        if (this.isCanceled) {
            return;
        }
        if (!this.outgoingInviteRequest) {
            throw new Error("Outgoing INVITE request undefined.");
        }
        if (!this.earlyMediaSessionDescriptionHandlers) {
            throw new Error("Early media session description handlers undefined.");
        }
        var response = inviteResponse.message;
        var session = inviteResponse.session;
        // Ported - Set status.
        this.status = Enums_1.SessionStatus.STATUS_1XX_RECEIVED;
        // Ported - Set assertedIdentity.
        if (response.hasHeader("P-Asserted-Identity")) {
            this.assertedIdentity = core_1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
        }
        // The provisional response MUST establish a dialog if one is not yet created.
        // https://tools.ietf.org/html/rfc3262#section-4
        if (!session) {
            // A response with a to tag MUST create a session (should never get here).
            throw new Error("Session undefined.");
        }
        // If a provisional response is received for an initial request, and
        // that response contains a Require header field containing the option
        // tag 100rel, the response is to be sent reliably.  If the response is
        // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
        // ignored, and the procedures below MUST NOT be used.
        // https://tools.ietf.org/html/rfc3262#section-4
        var requireHeader = response.getHeader("require");
        var rseqHeader = response.getHeader("rseq");
        var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
        var responseReliable = !!rseq;
        var extraHeaders = [];
        if (responseReliable) {
            extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
        }
        // INVITE without Offer and session still has no offer (and no answer).
        if (session.signalingState === core_1.SignalingState.Initial) {
            // Similarly, if a reliable provisional
            // response is the first reliable message sent back to the UAC, and the
            // INVITE did not contain an offer, one MUST appear in that reliable
            // provisional response.
            // https://tools.ietf.org/html/rfc3262#section-5
            if (responseReliable) {
                this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.");
                // FIXME: Known popular UA's currently end up here...
                inviteResponse.prack({ extraHeaders: extraHeaders });
            }
            this.emit("progress", response);
            return;
        }
        // INVITE with Offer and session only has that initial local offer.
        if (session.signalingState === core_1.SignalingState.HaveLocalOffer) {
            if (responseReliable) {
                inviteResponse.prack({ extraHeaders: extraHeaders });
            }
            this.emit("progress", response);
            return;
        }
        // INVITE without Offer and received initial offer in provisional response
        if (session.signalingState === core_1.SignalingState.HaveRemoteOffer) {
            // The initial offer MUST be in either an INVITE or, if not there,
            // in the first reliable non-failure message from the UAS back to
            // the UAC.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // According to Section 13.2.1 of [RFC3261], 'The first reliable
            // non-failure message' must have an offer if there is no offer in the
            // INVITE request.  This means that the User Agent (UA) that receives
            // the INVITE request without an offer must include an offer in the
            // first reliable response with 100rel extension.  If no reliable
            // provisional response has been sent, the User Agent Server (UAS) must
            // include an offer when sending 2xx response.
            // https://tools.ietf.org/html/rfc6337#section-2.2
            if (!responseReliable) {
                this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response.");
                return;
            }
            // If the initial offer is in the first reliable non-failure
            // message from the UAS back to UAC, the answer MUST be in the
            // acknowledgement for that message
            var sdh_2 = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
            this.emit("SessionDescriptionHandler-created", sdh_2);
            this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh_2);
            sdh_2
                .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)
                .then(function () { return sdh_2.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers); })
                .then(function (description) {
                var body = {
                    contentDisposition: "session", contentType: description.contentType, content: description.body
                };
                inviteResponse.prack({ extraHeaders: extraHeaders, body: body });
                _this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                _this.emit("progress", response);
            })
                .catch(function (error) {
                if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                    return;
                }
                _this.failed(undefined, Constants_1.C.causes.WEBRTC_ERROR);
                _this.terminated(undefined, Constants_1.C.causes.WEBRTC_ERROR);
            });
            return;
        }
        // This session has completed an initial offer/answer exchange, so...
        // - INVITE with SDP and this provisional response MAY be reliable
        // - INVITE without SDP and this provisional response MAY be reliable
        if (session.signalingState === core_1.SignalingState.Stable) {
            if (responseReliable) {
                inviteResponse.prack({ extraHeaders: extraHeaders });
            }
            // Note: As documented, no early media if offer was in INVITE, so nothing to be done.
            // FIXME: TODO: Add a flag/hack to allow early media in this case. There are people
            //              in non-forking environments (think straight to FreeSWITCH) who want
            //              early media on a 183. Not sure how to actually make it work, basically
            //              something like...
            if (false) {}
            this.emit("progress", response);
            return;
        }
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 3xx response.
     */
    InviteClientContext.prototype.onRedirect = function (inviteResponse) {
        this.disposeEarlyMedia();
        var response = inviteResponse.message;
        var statusCode = response.statusCode;
        var cause = Utils_1.Utils.sipErrorCause(statusCode || 0);
        this.rejected(response, cause);
        this.failed(response, cause);
        this.terminated(response, cause);
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 4xx, 5xx, or 6xx response.
     */
    InviteClientContext.prototype.onReject = function (inviteResponse) {
        this.disposeEarlyMedia();
        var response = inviteResponse.message;
        var statusCode = response.statusCode;
        var cause = Utils_1.Utils.sipErrorCause(statusCode || 0);
        this.rejected(response, cause);
        this.failed(response, cause);
        this.terminated(response, cause);
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 100 response.
     */
    InviteClientContext.prototype.onTrying = function (inviteResponse) {
        this.received100 = true;
        this.emit("progress", inviteResponse.message);
    };
    return InviteClientContext;
}(Session));
exports.InviteClientContext = InviteClientContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/Session/DTMF.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/Session/DTMF.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ../Constants */ "./node_modules/sip.js/lib/Constants.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ../Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/sip.js/lib/Utils.js");
var DTMFValidator_1 = __webpack_require__(/*! ./DTMFValidator */ "./node_modules/sip.js/lib/Session/DTMFValidator.js");
/**
 * @class DTMF
 * @param {SIP.Session} session
 */
var DTMF = /** @class */ (function (_super) {
    tslib_1.__extends(DTMF, _super);
    function DTMF(session, tone, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.C = {
            MIN_DURATION: 70,
            MAX_DURATION: 6000,
            DEFAULT_DURATION: 100,
            MIN_INTER_TONE_GAP: 50,
            DEFAULT_INTER_TONE_GAP: 500
        };
        _this.type = Enums_1.TypeStrings.DTMF;
        if (tone === undefined) {
            throw new TypeError("Not enough arguments");
        }
        _this.logger = session.ua.getLogger("sip.invitecontext.dtmf", session.id);
        _this.owner = session;
        var moreThanOneTone = false;
        // If tone is invalid, it will automatically generate an exception.
        // Otherwise, it will return the tone in the correct format.
        _this.tone = DTMFValidator_1.DTMFValidator.validate(tone, moreThanOneTone);
        var duration = options.duration;
        var interToneGap = options.interToneGap;
        // Check duration
        if (duration && !Utils_1.Utils.isDecimal(duration)) {
            throw new TypeError("Invalid tone duration: " + duration);
        }
        else if (!duration) {
            duration = _this.C.DEFAULT_DURATION;
        }
        else if (duration < _this.C.MIN_DURATION) {
            _this.logger.warn("'duration' value is lower than the minimum allowed, setting it to " +
                _this.C.MIN_DURATION + " milliseconds");
            duration = _this.C.MIN_DURATION;
        }
        else if (duration > _this.C.MAX_DURATION) {
            _this.logger.warn("'duration' value is greater than the maximum allowed, setting it to " +
                _this.C.MAX_DURATION + " milliseconds");
            duration = _this.C.MAX_DURATION;
        }
        else {
            duration = Math.abs(duration);
        }
        _this.duration = duration;
        // Check interToneGap
        if (interToneGap && !Utils_1.Utils.isDecimal(interToneGap)) {
            throw new TypeError("Invalid interToneGap: " + interToneGap);
        }
        else if (!interToneGap) {
            interToneGap = _this.C.DEFAULT_INTER_TONE_GAP;
        }
        else if (interToneGap < _this.C.MIN_INTER_TONE_GAP) {
            _this.logger.warn("'interToneGap' value is lower than the minimum allowed, setting it to " +
                _this.C.MIN_INTER_TONE_GAP + " milliseconds");
            interToneGap = _this.C.MIN_INTER_TONE_GAP;
        }
        else {
            interToneGap = Math.abs(interToneGap);
        }
        _this.interToneGap = interToneGap;
        return _this;
    }
    DTMF.prototype.send = function (options) {
        if (options === void 0) { options = {}; }
        // Check RTCSession Status
        if (this.owner.status !== Enums_1.SessionStatus.STATUS_CONFIRMED &&
            this.owner.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.owner.status);
        }
        // Get DTMF options
        var extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
        var body = {
            contentType: "application/dtmf-relay",
            body: "Signal= " + this.tone + "\r\nDuration= " + this.duration
        };
        if (this.owner.session) {
            var request = this.owner.session.info(undefined, {
                extraHeaders: extraHeaders,
                body: Utils_1.Utils.fromBodyObj(body)
            });
            this.owner.emit("dtmf", request.message, this);
            return;
        }
    };
    DTMF.prototype.init_incoming = function (request) {
        request.accept();
        if (!this.tone || !this.duration) {
            this.logger.warn("invalid INFO DTMF received, discarded");
        }
        else {
            this.owner.emit("dtmf", request.message, this);
        }
    };
    DTMF.prototype.receiveResponse = function (response) {
        var statusCode = response && response.statusCode ? response.statusCode : 0;
        switch (true) {
            case /^1[0-9]{2}$/.test(statusCode.toString()):
                // Ignore provisional responses.
                break;
            case /^2[0-9]{2}$/.test(statusCode.toString()):
                this.emit("succeeded", {
                    originator: "remote",
                    response: response
                });
                break;
            default:
                var cause = Utils_1.Utils.sipErrorCause(statusCode);
                this.emit("failed", response, cause);
                break;
        }
    };
    DTMF.prototype.onRequestTimeout = function () {
        this.emit("failed", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        this.owner.onRequestTimeout();
    };
    DTMF.prototype.onTransportError = function () {
        this.emit("failed", undefined, Constants_1.C.causes.CONNECTION_ERROR);
        this.owner.onTransportError();
    };
    DTMF.prototype.onDialogError = function (response) {
        this.emit("failed", response, Constants_1.C.causes.DIALOG_ERROR);
        this.owner.onDialogError(response);
    };
    return DTMF;
}(events_1.EventEmitter));
exports.DTMF = DTMF;


/***/ }),

/***/ "./node_modules/sip.js/lib/Session/DTMFValidator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sip.js/lib/Session/DTMFValidator.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DTMFValidator = /** @class */ (function () {
    function DTMFValidator() {
    }
    DTMFValidator.validate = function (tone, moreThanOneTone) {
        if (moreThanOneTone === void 0) { moreThanOneTone = true; }
        // Check tone type
        if (typeof tone === "string") {
            tone = tone.toUpperCase();
        }
        else if (typeof tone === "number") {
            tone = tone.toString();
        }
        else {
            DTMFValidator.generateInvalidToneError(tone);
        }
        var regex = moreThanOneTone ? /^[0-9A-D#*,]+$/i : /^[0-9A-D#*]$/i;
        // Check tone value
        if (!tone.match(regex)) {
            DTMFValidator.generateInvalidToneError(tone);
        }
        return tone;
    };
    DTMFValidator.generateInvalidToneError = function (tone) {
        var toneForMsg = (!!tone && typeof tone !== "boolean" ? tone.toString().toLowerCase() : tone);
        throw new TypeError("Invalid tone(s): " + toneForMsg);
    };
    return DTMFValidator;
}());
exports.DTMFValidator = DTMFValidator;


/***/ }),

/***/ "./node_modules/sip.js/lib/Subscription.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/Subscription.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var allowed_methods_1 = __webpack_require__(/*! ./core/user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/**
 * While this class is named `Subscription`, it is closer to
 * an implementation of a "subscriber" as defined in RFC 6665
 * "SIP-Specific Event Notifications".
 * https://tools.ietf.org/html/rfc6665
 * @class Class creating a SIP Subscriber.
 */
var Subscription = /** @class */ (function (_super) {
    tslib_1.__extends(Subscription, _super);
    /**
     * Constructor.
     * @param ua User agent.
     * @param target Subscription target.
     * @param event Subscription event.
     * @param options Options bucket.
     */
    function Subscription(ua, target, event, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.data = {};
        _this.method = Constants_1.C.SUBSCRIBE;
        _this.body = undefined;
        // ClientContext interface
        _this.type = Enums_1.TypeStrings.Subscription;
        _this.ua = ua;
        _this.logger = ua.getLogger("sip.subscription");
        if (options.body) {
            _this.body = {
                body: options.body,
                contentType: options.contentType ? options.contentType : "application/sdp"
            };
        }
        // Target URI
        var uri = ua.normalizeTarget(target);
        if (!uri) {
            throw new TypeError("Invalid target: " + target);
        }
        _this.uri = uri;
        // Subscription event
        _this.event = event;
        // Subscription expires
        if (options.expires === undefined) {
            _this.expires = 3600;
        }
        else if (typeof options.expires !== "number") { // pre-typescript type guard
            ua.logger.warn("Option \"expires\" must be a number. Using default of 3600.");
            _this.expires = 3600;
        }
        else {
            _this.expires = options.expires;
        }
        // Subscription extra headers
        _this.extraHeaders = (options.extraHeaders || []).slice();
        // Subscription context.
        _this.context = _this.initContext();
        _this.disposed = false;
        // ClientContext interface
        _this.request = _this.context.message;
        if (!_this.request.from) {
            throw new Error("From undefined.");
        }
        if (!_this.request.to) {
            throw new Error("From undefined.");
        }
        _this.localIdentity = _this.request.from;
        _this.remoteIdentity = _this.request.to;
        // Add to UA's collection
        _this.id = _this.request.callId + _this.request.from.parameters.tag + _this.event;
        _this.ua.subscriptions[_this.id] = _this;
        return _this;
    }
    /**
     * Destructor.
     */
    Subscription.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        if (this.retryAfterTimer) {
            clearTimeout(this.retryAfterTimer);
            this.retryAfterTimer = undefined;
        }
        this.context.dispose();
        this.disposed = true;
        // Remove from UA's collection
        delete this.ua.subscriptions[this.id];
    };
    Subscription.prototype.on = function (name, callback) {
        return _super.prototype.on.call(this, name, callback);
    };
    Subscription.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return _super.prototype.emit.apply(this, tslib_1.__spreadArrays([event], args));
    };
    /**
     * Gracefully terminate.
     */
    Subscription.prototype.close = function () {
        if (this.disposed) {
            return;
        }
        this.dispose();
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                this.onTerminated();
                break;
            case core_1.SubscriptionState.NotifyWait:
                this.onTerminated();
                break;
            case core_1.SubscriptionState.Pending:
                this.unsubscribe();
                break;
            case core_1.SubscriptionState.Active:
                this.unsubscribe();
                break;
            case core_1.SubscriptionState.Terminated:
                this.onTerminated();
                break;
            default:
                break;
        }
    };
    /**
     * Send a re-SUBSCRIBE request if there is an "active" subscription.
     */
    Subscription.prototype.refresh = function () {
        var _this = this;
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                break;
            case core_1.SubscriptionState.NotifyWait:
                break;
            case core_1.SubscriptionState.Pending:
                break;
            case core_1.SubscriptionState.Active:
                if (this.subscription) {
                    var request = this.subscription.refresh();
                    request.delegate = {
                        onAccept: (function (response) { return _this.onAccepted(response); }),
                        onRedirect: (function (response) { return _this.onFailed(response); }),
                        onReject: (function (response) { return _this.onFailed(response); }),
                    };
                }
                break;
            case core_1.SubscriptionState.Terminated:
                break;
            default:
                break;
        }
    };
    /**
     * Send an initial SUBSCRIBE request if no subscription.
     * Send a re-SUBSCRIBE request if there is an "active" subscription.
     */
    Subscription.prototype.subscribe = function () {
        var _this = this;
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                this.context.subscribe().then(function (result) {
                    if (result.success) {
                        if (result.success.subscription) {
                            _this.subscription = result.success.subscription;
                            _this.subscription.delegate = {
                                onNotify: function (request) { return _this.onNotify(request); },
                                onRefresh: function (request) { return _this.onRefresh(request); },
                                onTerminated: function () { return _this.close(); }
                            };
                        }
                        _this.onNotify(result.success.request);
                    }
                    else if (result.failure) {
                        _this.onFailed(result.failure.response);
                    }
                });
                break;
            case core_1.SubscriptionState.NotifyWait:
                break;
            case core_1.SubscriptionState.Pending:
                break;
            case core_1.SubscriptionState.Active:
                this.refresh();
                break;
            case core_1.SubscriptionState.Terminated:
                break;
            default:
                break;
        }
        return this;
    };
    /**
     * Send a re-SUBSCRIBE request if there is a "pending" or "active" subscription.
     */
    Subscription.prototype.unsubscribe = function () {
        this.dispose();
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                break;
            case core_1.SubscriptionState.NotifyWait:
                break;
            case core_1.SubscriptionState.Pending:
                if (this.subscription) {
                    this.subscription.unsubscribe();
                    // responses intentionally ignored
                }
                break;
            case core_1.SubscriptionState.Active:
                if (this.subscription) {
                    this.subscription.unsubscribe();
                    // responses intentionally ignored
                }
                break;
            case core_1.SubscriptionState.Terminated:
                break;
            default:
                break;
        }
        this.onTerminated();
    };
    Subscription.prototype.onAccepted = function (response) {
        var statusCode = response.message.statusCode ? response.message.statusCode : 0;
        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
        this.emit("accepted", response.message, cause);
    };
    Subscription.prototype.onFailed = function (response) {
        this.close();
        if (response) {
            var statusCode = response.message.statusCode ? response.message.statusCode : 0;
            var cause = Utils_1.Utils.getReasonPhrase(statusCode);
            this.emit("failed", response.message, cause);
            this.emit("rejected", response.message, cause);
        }
    };
    Subscription.prototype.onNotify = function (request) {
        var _this = this;
        request.accept(); // Send 200 response.
        this.emit("notify", { request: request.message });
        // If we've set state to done, no further processing should take place
        // and we are only interested in cleaning up after the appropriate NOTIFY.
        if (this.disposed) {
            return;
        }
        //  If the "Subscription-State" value is "terminated", the subscriber
        //  MUST consider the subscription terminated.  The "expires" parameter
        //  has no semantics for "terminated" -- notifiers SHOULD NOT include an
        //  "expires" parameter on a "Subscription-State" header field with a
        //  value of "terminated", and subscribers MUST ignore any such
        //  parameter, if present.  If a reason code is present, the client
        //  should behave as described below.  If no reason code or an unknown
        //  reason code is present, the client MAY attempt to re-subscribe at any
        //  time (unless a "retry-after" parameter is present, in which case the
        //  client SHOULD NOT attempt re-subscription until after the number of
        //  seconds specified by the "retry-after" parameter).  The reason codes
        //  defined by this document are:
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var subscriptionState = request.message.parseHeader("Subscription-State");
        if (subscriptionState && subscriptionState.state) {
            switch (subscriptionState.state) {
                case "terminated":
                    if (subscriptionState.reason) {
                        this.logger.log("Terminated subscription with reason " + subscriptionState.reason);
                        switch (subscriptionState.reason) {
                            case "deactivated":
                            case "timeout":
                                this.initContext();
                                this.subscribe();
                                return;
                            case "probation":
                            case "giveup":
                                this.initContext();
                                if (subscriptionState.params && subscriptionState.params["retry-after"]) {
                                    this.retryAfterTimer = setTimeout(function () { return _this.subscribe(); }, subscriptionState.params["retry-after"]);
                                }
                                else {
                                    this.subscribe();
                                }
                                return;
                            case "rejected":
                            case "noresource":
                            case "invariant":
                                break;
                        }
                    }
                    this.close();
                    break;
                default:
                    break;
            }
        }
    };
    Subscription.prototype.onRefresh = function (request) {
        var _this = this;
        request.delegate = {
            onAccept: function (response) { return _this.onAccepted(response); }
        };
    };
    Subscription.prototype.onTerminated = function () {
        this.emit("terminated");
    };
    Subscription.prototype.initContext = function () {
        var _this = this;
        var options = {
            extraHeaders: this.extraHeaders,
            body: this.body ? Utils_1.Utils.fromBodyObj(this.body) : undefined
        };
        this.context = new SubscribeClientContext(this.ua.userAgentCore, this.uri, this.event, this.expires, options);
        this.context.delegate = {
            onAccept: (function (response) { return _this.onAccepted(response); })
        };
        return this.context;
    };
    return Subscription;
}(events_1.EventEmitter));
exports.Subscription = Subscription;
// tslint:disable-next-line:max-classes-per-file
var SubscribeClientContext = /** @class */ (function () {
    function SubscribeClientContext(core, target, event, expires, options, delegate) {
        this.core = core;
        this.target = target;
        this.event = event;
        this.expires = expires;
        this.subscribed = false;
        this.logger = core.loggerFactory.getLogger("sip.subscription");
        this.delegate = delegate;
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        var extraHeaders = (options && options.extraHeaders || []).slice();
        extraHeaders.push(allowHeader);
        extraHeaders.push("Event: " + this.event);
        extraHeaders.push("Expires: " + this.expires);
        extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
        var body = options && options.body;
        this.message = core.makeOutgoingRequestMessage(Constants_1.C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);
    }
    /** Destructor. */
    SubscribeClientContext.prototype.dispose = function () {
        if (this.subscription) {
            this.subscription.dispose();
        }
        if (this.request) {
            this.request.waitNotifyStop();
            this.request.dispose();
        }
    };
    Object.defineProperty(SubscribeClientContext.prototype, "state", {
        /** Subscription state. */
        get: function () {
            if (this.subscription) {
                return this.subscription.subscriptionState;
            }
            else if (this.subscribed) {
                return core_1.SubscriptionState.NotifyWait;
            }
            else {
                return core_1.SubscriptionState.Initial;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Establish subscription.
     * @param options Options bucket.
     */
    SubscribeClientContext.prototype.subscribe = function () {
        var _this = this;
        if (this.subscribed) {
            return Promise.reject(new Error("Not in initial state. Did you call subscribe more than once?"));
        }
        this.subscribed = true;
        return new Promise(function (resolve, reject) {
            if (!_this.message) {
                throw new Error("Message undefined.");
            }
            _this.request = _this.core.subscribe(_this.message, {
                // This SUBSCRIBE request will be confirmed with a final response.
                // 200-class responses indicate that the subscription has been accepted
                // and that a NOTIFY request will be sent immediately.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                onAccept: function (response) {
                    if (_this.delegate && _this.delegate.onAccept) {
                        _this.delegate.onAccept(response);
                    }
                },
                // Due to the potential for out-of-order messages, packet loss, and
                // forking, the subscriber MUST be prepared to receive NOTIFY requests
                // before the SUBSCRIBE transaction has completed.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
                onNotify: function (requestWithSubscription) {
                    _this.subscription = requestWithSubscription.subscription;
                    if (_this.subscription) {
                        _this.subscription.autoRefresh = true;
                    }
                    resolve({ success: requestWithSubscription });
                },
                // If this Timer N expires prior to the receipt of a NOTIFY request,
                // the subscriber considers the subscription failed, and cleans up
                // any state associated with the subscription attempt.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
                onNotifyTimeout: function () {
                    resolve({ failure: {} });
                },
                // This SUBSCRIBE request will be confirmed with a final response.
                // Non-200-class final responses indicate that no subscription or new
                // dialog usage has been created, and no subsequent NOTIFY request will
                // be sent.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                onRedirect: function (response) {
                    resolve({ failure: { response: response } });
                },
                // This SUBSCRIBE request will be confirmed with a final response.
                // Non-200-class final responses indicate that no subscription or new
                // dialog usage has been created, and no subsequent NOTIFY request will
                // be sent.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                onReject: function (response) {
                    resolve({ failure: { response: response } });
                }
            });
        });
    };
    return SubscribeClientContext;
}());


/***/ }),

/***/ "./node_modules/sip.js/lib/Transport.js":
/*!**********************************************!*\
  !*** ./node_modules/sip.js/lib/Transport.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/**
 * Legacy Transport.
 * @remarks
 * Abstract transport layer base class.
 * @public
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    /**
     * Constructor
     * @param logger - Logger.
     * @param options - Options bucket. Deprecated.
     */
    function Transport(logger, options) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        return _this;
    }
    Object.defineProperty(Transport.prototype, "protocol", {
        /**
         * The protocol.
         *
         * @remarks
         * Formatted as defined for the Via header sent-protocol transport.
         * https://tools.ietf.org/html/rfc3261#section-20.42
         */
        get: function () {
            return this.server && this.server.scheme ? this.server.scheme : "WSS";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the promise designated by the child layer then emits a connected event.
     * Automatically emits an event upon resolution, unless overrideEvent is set. If you
     * override the event in this fashion, you should emit it in your implementation of connectPromise
     * @param options - Options bucket.
     */
    Transport.prototype.connect = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return this.connectPromise(options).then(function (data) {
            if (!data.overrideEvent) {
                _this.emit("connected");
            }
        });
    };
    /**
     * Sends a message then emits a 'messageSent' event. Automatically emits an
     * event upon resolution, unless data.overrideEvent is set. If you override
     * the event in this fashion, you should emit it in your implementation of sendPromise
     * Rejects with an Error if message fails to send.
     * @param message - Message.
     * @param options - Options bucket.
     */
    Transport.prototype.send = function (message, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Error handling is independent of whether the message was a request or
        // response.
        //
        // If the transport user asks for a message to be sent over an
        // unreliable transport, and the result is an ICMP error, the behavior
        // depends on the type of ICMP error.  Host, network, port or protocol
        // unreachable errors, or parameter problem errors SHOULD cause the
        // transport layer to inform the transport user of a failure in sending.
        // Source quench and TTL exceeded ICMP errors SHOULD be ignored.
        //
        // If the transport user asks for a request to be sent over a reliable
        // transport, and the result is a connection failure, the transport
        // layer SHOULD inform the transport user of a failure in sending.
        // https://tools.ietf.org/html/rfc3261#section-18.4
        return this.sendPromise(message).then(function (result) {
            if (!result.overrideEvent) {
                _this.emit("messageSent", result.msg);
            }
        });
    };
    /**
     * Returns the promise designated by the child layer then emits a
     * disconnected event. Automatically emits an event upon resolution,
     * unless overrideEvent is set. If you override the event in this fashion,
     * you should emit it in your implementation of disconnectPromise
     * @param options - Options bucket
     */
    Transport.prototype.disconnect = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return this.disconnectPromise(options).then(function (data) {
            if (!data.overrideEvent) {
                _this.emit("disconnected");
            }
        });
    };
    Transport.prototype.afterConnected = function (callback) {
        if (this.isConnected()) {
            callback();
        }
        else {
            this.once("connected", callback);
        }
    };
    /**
     * Returns a promise which resolves once the UA is connected. DEPRECATION WARNING: just use afterConnected()
     */
    Transport.prototype.waitForConnected = function () {
        var _this = this;
        // tslint:disable-next-line:no-console
        console.warn("DEPRECATION WARNING Transport.waitForConnected(): use afterConnected() instead");
        return new Promise(function (resolve) {
            _this.afterConnected(resolve);
        });
    };
    return Transport;
}(events_1.EventEmitter));
exports.Transport = Transport;


/***/ }),

/***/ "./node_modules/sip.js/lib/UA.js":
/*!***************************************!*\
  !*** ./node_modules/sip.js/lib/UA.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var PublishContext_1 = __webpack_require__(/*! ./PublishContext */ "./node_modules/sip.js/lib/PublishContext.js");
var ReferContext_1 = __webpack_require__(/*! ./ReferContext */ "./node_modules/sip.js/lib/ReferContext.js");
var RegisterContext_1 = __webpack_require__(/*! ./RegisterContext */ "./node_modules/sip.js/lib/RegisterContext.js");
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
var Session_1 = __webpack_require__(/*! ./Session */ "./node_modules/sip.js/lib/Session.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/sip.js/lib/Subscription.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
var SessionDescriptionHandler_1 = __webpack_require__(/*! ./Web/SessionDescriptionHandler */ "./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js");
var Transport_1 = __webpack_require__(/*! ./Web/Transport */ "./node_modules/sip.js/lib/Web/Transport.js");
/**
 * @class Class creating a SIP User Agent.
 * @param {function returning SIP.sessionDescriptionHandler} [configuration.sessionDescriptionHandlerFactory]
 *  A function will be invoked by each of the UA's Sessions to build the sessionDescriptionHandler for that Session.
 *  If no (or a falsy) value is provided, each Session will use a default (WebRTC) sessionDescriptionHandler.
 */
var UA = /** @class */ (function (_super) {
    tslib_1.__extends(UA, _super);
    function UA(configuration) {
        var _this = _super.call(this) || this;
        /** Unload listener. */
        _this.unloadListener = (function () { _this.stop(); });
        _this.type = Enums_1.TypeStrings.UA;
        _this.log = new core_1.LoggerFactory();
        _this.logger = _this.getLogger("sip.ua");
        _this.configuration = {};
        // User actions outside any session/dialog (MESSAGE)
        _this.applicants = {};
        _this.data = {};
        _this.sessions = {};
        _this.subscriptions = {};
        _this.publishers = {};
        _this.status = Enums_1.UAStatus.STATUS_INIT;
        /**
         * Load configuration
         *
         * @throws {SIP.Exceptions.ConfigurationError}
         * @throws {TypeError}
         */
        if (configuration === undefined) {
            configuration = {};
        }
        else if (typeof configuration === "string" || configuration instanceof String) {
            configuration = {
                uri: configuration
            };
        }
        // Apply log configuration if present
        if (configuration.log) {
            _this.log.builtinEnabled = configuration.log.builtinEnabled;
            if (configuration.log.hasOwnProperty("connector")) {
                _this.log.connector = configuration.log.connector;
            }
            if (configuration.log.hasOwnProperty("level")) {
                var level = configuration.log.level;
                var normalized = void 0;
                if (typeof level === "string") {
                    switch (level) {
                        case "error":
                            normalized = core_1.Levels.error;
                            break;
                        case "warn":
                            normalized = core_1.Levels.warn;
                            break;
                        case "log":
                            normalized = core_1.Levels.log;
                            break;
                        case "debug":
                            normalized = core_1.Levels.debug;
                            break;
                        default:
                            break;
                    }
                }
                else {
                    switch (level) {
                        case 0:
                            normalized = core_1.Levels.error;
                            break;
                        case 1:
                            normalized = core_1.Levels.warn;
                            break;
                        case 2:
                            normalized = core_1.Levels.log;
                            break;
                        case 3:
                            normalized = core_1.Levels.debug;
                            break;
                        default:
                            break;
                    }
                }
                // avoid setting level when invalid, use default level instead
                if (normalized === undefined) {
                    _this.logger.error("Invalid \"level\" parameter value: " + JSON.stringify(level));
                }
                else {
                    _this.log.level = normalized;
                }
            }
        }
        var deprecatedMessage = "The UA class has been deprecated and will no longer be available starting with SIP.js release 0.16.0. " +
            "The UA has been replaced by the UserAgent class. Please update accordingly.";
        _this.logger.warn(deprecatedMessage);
        try {
            _this.loadConfig(configuration);
        }
        catch (e) {
            _this.status = Enums_1.UAStatus.STATUS_NOT_READY;
            _this.error = UA.C.CONFIGURATION_ERROR;
            throw e;
        }
        if (!_this.configuration.transportConstructor) {
            throw new core_1.TransportError("Transport constructor not set");
        }
        _this.transport = new _this.configuration.transportConstructor(_this.getLogger("sip.transport"), _this.configuration.transportOptions);
        var userAgentCoreConfiguration = makeUserAgentCoreConfigurationFromUA(_this);
        // The Replaces header contains information used to match an existing
        // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE
        // with a Replaces header, the User Agent (UA) attempts to match this
        // information with a confirmed or early dialog.
        // https://tools.ietf.org/html/rfc3891#section-3
        var handleInviteWithReplacesHeader = function (context, request) {
            if (_this.configuration.replaces !== Constants_1.C.supported.UNSUPPORTED) {
                var replaces = request.parseHeader("replaces");
                if (replaces) {
                    var targetSession = _this.sessions[replaces.call_id + replaces.replaces_from_tag] ||
                        _this.sessions[replaces.call_id + replaces.replaces_to_tag] ||
                        undefined;
                    if (!targetSession) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 481 });
                        return;
                    }
                    if (targetSession.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 603 });
                        return;
                    }
                    var targetDialogId = replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag;
                    var targetDialog = _this.userAgentCore.dialogs.get(targetDialogId);
                    if (!targetDialog) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 481 });
                        return;
                    }
                    if (!targetDialog.early && replaces.early_only) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 486 });
                        return;
                    }
                    context.replacee = targetSession;
                }
            }
        };
        var userAgentCoreDelegate = {
            onInvite: function (incomingInviteRequest) {
                // FIXME: Ported - 100 Trying send should be configurable.
                // Only required if TU will not respond in 200ms.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                incomingInviteRequest.trying();
                incomingInviteRequest.delegate = {
                    onCancel: function (cancel) {
                        context.onCancel(cancel);
                    },
                    onTransportError: function (error) {
                        context.onTransportError();
                    }
                };
                var context = new Session_1.InviteServerContext(_this, incomingInviteRequest);
                // Ported - handling of out of dialog INVITE with Replaces.
                handleInviteWithReplacesHeader(context, incomingInviteRequest.message);
                // Ported - make the first call to progress automatically.
                if (context.autoSendAnInitialProvisionalResponse) {
                    context.progress();
                }
                _this.emit("invite", context);
            },
            onMessage: function (incomingMessageRequest) {
                // Ported - handling of out of dialog MESSAGE.
                var serverContext = new ServerContext_1.ServerContext(_this, incomingMessageRequest);
                serverContext.body = incomingMessageRequest.message.body;
                serverContext.contentType = incomingMessageRequest.message.getHeader("Content-Type") || "text/plain";
                incomingMessageRequest.accept();
                _this.emit("message", serverContext); // TODO: Review. Why is a "ServerContext" emitted? What use it is?
            },
            onNotify: function (incomingNotifyRequest) {
                // DEPRECATED: Out of dialog NOTIFY is an obsolete usage.
                // Ported - handling of out of dialog NOTIFY.
                if (_this.configuration.allowLegacyNotifications && _this.listeners("notify").length > 0) {
                    incomingNotifyRequest.accept();
                    _this.emit("notify", { request: incomingNotifyRequest.message });
                }
                else {
                    incomingNotifyRequest.reject({ statusCode: 481 });
                }
            },
            onRefer: function (incomingReferRequest) {
                // Ported - handling of out of dialog REFER.
                _this.logger.log("Received an out of dialog refer");
                if (!_this.configuration.allowOutOfDialogRefers) {
                    incomingReferRequest.reject({ statusCode: 405 });
                }
                _this.logger.log("Allow out of dialog refers is enabled on the UA");
                var referContext = new ReferContext_1.ReferServerContext(_this, incomingReferRequest);
                if (_this.listeners("outOfDialogReferRequested").length) {
                    _this.emit("outOfDialogReferRequested", referContext);
                }
                else {
                    _this.logger.log("No outOfDialogReferRequest listeners, automatically accepting and following the out of dialog refer");
                    referContext.accept({ followRefer: true });
                }
            },
            onSubscribe: function (incomingSubscribeRequest) {
                _this.emit("subscribe", incomingSubscribeRequest);
            },
        };
        _this.userAgentCore = new core_1.UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);
        // Initialize registerContext
        _this.registerContext = new RegisterContext_1.RegisterContext(_this, configuration.registerOptions);
        _this.registerContext.on("failed", _this.emit.bind(_this, "registrationFailed"));
        _this.registerContext.on("registered", _this.emit.bind(_this, "registered"));
        _this.registerContext.on("unregistered", _this.emit.bind(_this, "unregistered"));
        if (_this.configuration.autostart) {
            _this.start();
        }
        return _this;
    }
    // =================
    //  High Level API
    // =================
    UA.prototype.register = function (options) {
        if (options === void 0) { options = {}; }
        if (options.register) {
            this.configuration.register = true;
        }
        this.registerContext.register(options);
        return this;
    };
    /**
     * Unregister.
     *
     * @param {Boolean} [all] unregister all user bindings.
     *
     */
    UA.prototype.unregister = function (options) {
        var _this = this;
        this.configuration.register = false;
        this.transport.afterConnected(function () {
            _this.registerContext.unregister(options);
        });
        return this;
    };
    UA.prototype.isRegistered = function () {
        return this.registerContext.registered;
    };
    /**
     * Make an outgoing call.
     *
     * @param {String} target
     * @param {Object} views
     * @param {Object} [options.media] gets passed to SIP.sessionDescriptionHandler.getDescription as mediaHint
     *
     * @throws {TypeError}
     *
     */
    UA.prototype.invite = function (target, options, modifiers) {
        var _this = this;
        var context = new Session_1.InviteClientContext(this, target, options, modifiers);
        // Delay sending actual invite until the next 'tick' if we are already
        // connected, so that API consumers can register to events fired by the
        // the session.
        this.transport.afterConnected(function () {
            context.invite();
            _this.emit("inviteSent", context);
        });
        return context;
    };
    UA.prototype.subscribe = function (target, event, options) {
        var sub = new Subscription_1.Subscription(this, target, event, options);
        this.transport.afterConnected(function () { return sub.subscribe(); });
        return sub;
    };
    /**
     * Send PUBLISH Event State Publication (RFC3903)
     *
     * @param {String} target
     * @param {String} event
     * @param {String} body
     * @param {Object} [options]
     *
     * @throws {SIP.Exceptions.MethodParameterError}
     */
    UA.prototype.publish = function (target, event, body, options) {
        var pub = new PublishContext_1.PublishContext(this, target, event, options);
        this.transport.afterConnected(function () {
            pub.publish(body);
        });
        return pub;
    };
    /**
     * Send a message.
     *
     * @param {String} target
     * @param {String} body
     * @param {Object} [options]
     *
     * @throws {TypeError}
     */
    UA.prototype.message = function (target, body, options) {
        if (options === void 0) { options = {}; }
        if (body === undefined) {
            throw new TypeError("Not enough arguments");
        }
        // There is no Message module, so it is okay that the UA handles defaults here.
        options.contentType = options.contentType || "text/plain";
        options.body = body;
        return this.request(Constants_1.C.MESSAGE, target, options);
    };
    UA.prototype.request = function (method, target, options) {
        var req = new ClientContext_1.ClientContext(this, method, target, options);
        this.transport.afterConnected(function () { return req.send(); });
        return req;
    };
    /**
     * Gracefully close.
     */
    UA.prototype.stop = function () {
        this.logger.log("user requested closure...");
        if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED) {
            this.logger.warn("UA already closed");
            return this;
        }
        // Close registerContext
        this.logger.log("closing registerContext");
        this.registerContext.close();
        // Run terminate on every Session
        for (var session in this.sessions) {
            if (this.sessions[session]) {
                this.logger.log("closing session " + session);
                this.sessions[session].terminate();
            }
        }
        // Run unsubscribe on every Subscription
        for (var subscription in this.subscriptions) {
            if (this.subscriptions[subscription]) {
                this.logger.log("unsubscribe " + subscription);
                this.subscriptions[subscription].unsubscribe();
            }
        }
        // Run close on every Publisher
        for (var publisher in this.publishers) {
            if (this.publishers[publisher]) {
                this.logger.log("unpublish " + publisher);
                this.publishers[publisher].close();
            }
        }
        // Run close on every applicant
        for (var applicant in this.applicants) {
            if (this.applicants[applicant]) {
                this.applicants[applicant].close();
            }
        }
        this.status = Enums_1.UAStatus.STATUS_USER_CLOSED;
        // Disconnect the transport and reset user agent core
        this.transport.disconnect();
        this.userAgentCore.reset();
        if (this.configuration.autostop) {
            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
            var googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
            if (typeof window !== "undefined" &&
                typeof window.removeEventListener === "function" &&
                !googleChromePackagedApp) {
                window.removeEventListener("unload", this.unloadListener);
            }
        }
        return this;
    };
    /**
     * Connect to the WS server if status = STATUS_INIT.
     * Resume UA after being closed.
     *
     */
    UA.prototype.start = function () {
        this.logger.log("user requested startup...");
        if (this.status === Enums_1.UAStatus.STATUS_INIT) {
            this.status = Enums_1.UAStatus.STATUS_STARTING;
            this.setTransportListeners();
            this.emit("transportCreated", this.transport);
            this.transport.connect();
        }
        else if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED) {
            this.logger.log("resuming");
            this.status = Enums_1.UAStatus.STATUS_READY;
            this.transport.connect();
        }
        else if (this.status === Enums_1.UAStatus.STATUS_STARTING) {
            this.logger.log("UA is in STARTING status, not opening new connection");
        }
        else if (this.status === Enums_1.UAStatus.STATUS_READY) {
            this.logger.log("UA is in READY status, not resuming");
        }
        else {
            this.logger.error("Connection is down. Auto-Recovery system is trying to connect");
        }
        if (this.configuration.autostop) {
            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
            var googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
            if (typeof window !== "undefined" &&
                typeof window.addEventListener === "function" &&
                !googleChromePackagedApp) {
                window.addEventListener("unload", this.unloadListener);
            }
        }
        return this;
    };
    /**
     * Normalize a string into a valid SIP request URI
     *
     * @param {String} target
     *
     * @returns {SIP.URI|undefined}
     */
    UA.prototype.normalizeTarget = function (target) {
        return Utils_1.Utils.normalizeTarget(target, this.configuration.hostportParams);
    };
    UA.prototype.getLogger = function (category, label) {
        return this.log.getLogger(category, label);
    };
    UA.prototype.getLoggerFactory = function () {
        return this.log;
    };
    UA.prototype.getSupportedResponseOptions = function () {
        var optionTags = [];
        if (this.contact.pubGruu || this.contact.tempGruu) {
            optionTags.push("gruu");
        }
        if (this.configuration.rel100 === Constants_1.C.supported.SUPPORTED) {
            optionTags.push("100rel");
        }
        if (this.configuration.replaces === Constants_1.C.supported.SUPPORTED) {
            optionTags.push("replaces");
        }
        optionTags.push("outbound");
        optionTags = optionTags.concat(this.configuration.extraSupported || []);
        var allowUnregistered = this.configuration.hackAllowUnregisteredOptionTags || false;
        var optionTagSet = {};
        optionTags = optionTags.filter(function (optionTag) {
            var registered = Constants_1.C.OPTION_TAGS[optionTag];
            var unique = !optionTagSet[optionTag];
            optionTagSet[optionTag] = true;
            return (registered || allowUnregistered) && unique;
        });
        return optionTags;
    };
    /**
     * Get the session to which the request belongs to, if any.
     * @param {SIP.IncomingRequest} request.
     * @returns {SIP.OutgoingSession|SIP.IncomingSession|undefined}
     */
    UA.prototype.findSession = function (request) {
        return this.sessions[request.callId + request.fromTag] ||
            this.sessions[request.callId + request.toTag] ||
            undefined;
    };
    UA.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    // ==============================
    // Event Handlers
    // ==============================
    UA.prototype.onTransportError = function () {
        if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED) {
            return;
        }
        if (!this.error || this.error !== UA.C.NETWORK_ERROR) {
            this.status = Enums_1.UAStatus.STATUS_NOT_READY;
            this.error = UA.C.NETWORK_ERROR;
        }
    };
    /**
     * Helper function. Sets transport listeners
     */
    UA.prototype.setTransportListeners = function () {
        var _this = this;
        this.transport.on("connected", function () { return _this.onTransportConnected(); });
        this.transport.on("message", function (message) { return _this.onTransportReceiveMsg(message); });
        this.transport.on("transportError", function () { return _this.onTransportError(); });
    };
    /**
     * Transport connection event.
     * @event
     * @param {SIP.Transport} transport.
     */
    UA.prototype.onTransportConnected = function () {
        var _this = this;
        if (this.configuration.register) {
            // In an effor to maintain behavior from when we "initialized" an
            // authentication factory, this is in a Promise.then
            Promise.resolve().then(function () { return _this.registerContext.register(); });
        }
    };
    /**
     * Handle SIP message received from the transport.
     * @param messageString The message.
     */
    UA.prototype.onTransportReceiveMsg = function (messageString) {
        var _this = this;
        var message = core_1.Parser.parseMessage(messageString, this.getLogger("sip.parser"));
        if (!message) {
            this.logger.warn("UA failed to parse incoming SIP message - discarding.");
            return;
        }
        if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED && message instanceof core_1.IncomingRequestMessage) {
            this.logger.warn("UA received message when status = USER_CLOSED - aborting");
            return;
        }
        // A valid SIP request formulated by a UAC MUST, at a minimum, contain
        // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,
        // and Via; all of these header fields are mandatory in all SIP
        // requests.
        // https://tools.ietf.org/html/rfc3261#section-8.1.1
        var hasMinimumHeaders = function () {
            var mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];
            for (var _i = 0, mandatoryHeaders_1 = mandatoryHeaders; _i < mandatoryHeaders_1.length; _i++) {
                var header = mandatoryHeaders_1[_i];
                if (!message.hasHeader(header)) {
                    _this.logger.warn("Missing mandatory header field : " + header + ".");
                    return false;
                }
            }
            return true;
        };
        // Request Checks
        if (message instanceof core_1.IncomingRequestMessage) {
            // This is port of SanityCheck.minimumHeaders().
            if (!hasMinimumHeaders()) {
                this.logger.warn("Request missing mandatory header field. Dropping.");
                return;
            }
            // FIXME: This is non-standard and should be a configruable behavior (desirable regardless).
            // Custom SIP.js check to reject request from ourself (this instance of SIP.js).
            // This is port of SanityCheck.rfc3261_16_3_4().
            if (!message.toTag && message.callId.substr(0, 5) === this.configuration.sipjsId) {
                this.userAgentCore.replyStateless(message, { statusCode: 482 });
                return;
            }
            // FIXME: This should be Transport check before we get here (Section 18).
            // Custom SIP.js check to reject requests if body length wrong.
            // This is port of SanityCheck.rfc3261_18_3_request().
            var len = Utils_1.Utils.str_utf8_length(message.body);
            var contentLength = message.getHeader("content-length");
            if (contentLength && len < Number(contentLength)) {
                this.userAgentCore.replyStateless(message, { statusCode: 400 });
                return;
            }
        }
        // Reponse Checks
        if (message instanceof core_1.IncomingResponseMessage) {
            // This is port of SanityCheck.minimumHeaders().
            if (!hasMinimumHeaders()) {
                this.logger.warn("Response missing mandatory header field. Dropping.");
                return;
            }
            // Custom SIP.js check to drop responses if multiple Via headers.
            // This is port of SanityCheck.rfc3261_8_1_3_3().
            if (message.getHeaders("via").length > 1) {
                this.logger.warn("More than one Via header field present in the response. Dropping.");
                return;
            }
            // FIXME: This should be Transport check before we get here (Section 18).
            // Custom SIP.js check to drop responses if bad Via header.
            // This is port of SanityCheck.rfc3261_18_1_2().
            if (message.via.host !== this.configuration.viaHost || message.via.port !== undefined) {
                this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
                return;
            }
            // FIXME: This should be Transport check before we get here (Section 18).
            // Custom SIP.js check to reject requests if body length wrong.
            // This is port of SanityCheck.rfc3261_18_3_response().
            var len = Utils_1.Utils.str_utf8_length(message.body);
            var contentLength = message.getHeader("content-length");
            if (contentLength && len < Number(contentLength)) {
                this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
                return;
            }
        }
        // Handle Request
        if (message instanceof core_1.IncomingRequestMessage) {
            this.userAgentCore.receiveIncomingRequestFromTransport(message);
            return;
        }
        // Handle Response
        if (message instanceof core_1.IncomingResponseMessage) {
            this.userAgentCore.receiveIncomingResponseFromTransport(message);
            return;
        }
        throw new Error("Invalid message type.");
    };
    // =================
    // Utils
    // =================
    UA.prototype.checkAuthenticationFactory = function (authenticationFactory) {
        if (!(authenticationFactory instanceof Function)) {
            return;
        }
        if (!authenticationFactory.initialize) {
            authenticationFactory.initialize = function () {
                return Promise.resolve();
            };
        }
        return authenticationFactory;
    };
    /**
     * Configuration load.
     * returns {void}
     */
    UA.prototype.loadConfig = function (configuration) {
        var _this = this;
        // Settings and default values
        var settings = {
            /* Host address
             * Value to be set in Via sent_by and host part of Contact FQDN
             */
            viaHost: Utils_1.Utils.createRandomToken(12) + ".invalid",
            uri: new core_1.URI("sip", "anonymous." + Utils_1.Utils.createRandomToken(6), "anonymous.invalid", undefined, undefined),
            // Custom Configuration Settings
            custom: {},
            // Display name
            displayName: "",
            // Password
            password: undefined,
            register: true,
            // Registration parameters
            registerOptions: {},
            // Transport related parameters
            transportConstructor: Transport_1.Transport,
            transportOptions: {},
            usePreloadedRoute: false,
            // string to be inserted into User-Agent request header
            userAgentString: Constants_1.C.USER_AGENT,
            // Session parameters
            noAnswerTimeout: 60,
            // Hacks
            hackViaTcp: false,
            hackIpInContact: false,
            hackWssInTransport: false,
            hackAllowUnregisteredOptionTags: false,
            // Session Description Handler Options
            sessionDescriptionHandlerFactoryOptions: {
                constraints: {},
                peerConnectionOptions: {}
            },
            extraSupported: [],
            contactName: Utils_1.Utils.createRandomToken(8),
            contactTransport: "ws",
            forceRport: false,
            // autostarting
            autostart: true,
            autostop: true,
            // Reliable Provisional Responses
            rel100: Constants_1.C.supported.UNSUPPORTED,
            // DTMF type: 'info' or 'rtp' (RFC 4733)
            // RTP Payload Spec: https://tools.ietf.org/html/rfc4733
            // WebRTC Audio Spec: https://tools.ietf.org/html/rfc7874
            dtmfType: Constants_1.C.dtmfType.INFO,
            // Replaces header (RFC 3891)
            // http://tools.ietf.org/html/rfc3891
            replaces: Constants_1.C.supported.UNSUPPORTED,
            sessionDescriptionHandlerFactory: SessionDescriptionHandler_1.SessionDescriptionHandler.defaultFactory,
            authenticationFactory: this.checkAuthenticationFactory(function (ua) {
                return new core_1.DigestAuthentication(ua.getLoggerFactory(), _this.configuration.authorizationUser, _this.configuration.password);
            }),
            allowLegacyNotifications: false,
            allowOutOfDialogRefers: false,
            experimentalFeatures: false
        };
        var configCheck = this.getConfigurationCheck();
        // Check Mandatory parameters
        for (var parameter in configCheck.mandatory) {
            if (!configuration.hasOwnProperty(parameter)) {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
            }
            else {
                var value = configuration[parameter];
                var checkedValue = configCheck.mandatory[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        // Check Optional parameters
        for (var parameter in configCheck.optional) {
            if (configuration.hasOwnProperty(parameter)) {
                var value = configuration[parameter];
                // If the parameter value is an empty array, but shouldn't be, apply its default value.
                // If the parameter value is null, empty string, or undefined then apply its default value.
                // If it's a number with NaN value then also apply its default value.
                // NOTE: JS does not allow "value === NaN", the following does the work:
                if ((value instanceof Array && value.length === 0) ||
                    (value === null || value === "" || value === undefined) ||
                    (typeof (value) === "number" && isNaN(value))) {
                    continue;
                }
                var checkedValue = configCheck.optional[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        // Post Configuration Process
        // Allow passing 0 number as displayName.
        if (settings.displayName === 0) {
            settings.displayName = "0";
        }
        // sipjsId instance parameter. Static random tag of length 5
        settings.sipjsId = Utils_1.Utils.createRandomToken(5);
        // String containing settings.uri without scheme and user.
        var hostportParams = settings.uri.clone();
        hostportParams.user = undefined;
        settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, "");
        /* Check whether authorizationUser is explicitly defined.
         * Take 'settings.uri.user' value if not.
         */
        if (!settings.authorizationUser) {
            settings.authorizationUser = settings.uri.user;
        }
        // User noAnswerTimeout
        settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
        // Via Host
        if (settings.hackIpInContact) {
            if (typeof settings.hackIpInContact === "boolean") {
                var from = 1;
                var to = 254;
                var octet = Math.floor(Math.random() * (to - from + 1) + from);
                // random Test-Net IP (http://tools.ietf.org/html/rfc5735)
                settings.viaHost = "192.0.2." + octet;
            }
            else if (typeof settings.hackIpInContact === "string") {
                settings.viaHost = settings.hackIpInContact;
            }
        }
        // Contact transport parameter
        if (settings.hackWssInTransport) {
            settings.contactTransport = "wss";
        }
        this.contact = {
            pubGruu: undefined,
            tempGruu: undefined,
            uri: new core_1.URI("sip", settings.contactName, settings.viaHost, undefined, { transport: settings.contactTransport }),
            toString: function (options) {
                if (options === void 0) { options = {}; }
                var anonymous = options.anonymous || false;
                var outbound = options.outbound || false;
                var contact = "<";
                if (anonymous) {
                    contact += (_this.contact.tempGruu ||
                        ("sip:anonymous@anonymous.invalid;transport=" + settings.contactTransport)).toString();
                }
                else {
                    contact += (_this.contact.pubGruu || _this.contact.uri).toString();
                }
                if (outbound) {
                    contact += ";ob";
                }
                contact += ">";
                return contact;
            }
        };
        var skeleton = {};
        // Fill the value of the configuration_skeleton
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                skeleton[parameter] = settings[parameter];
            }
        }
        Object.assign(this.configuration, skeleton);
        this.logger.log("configuration parameters after validation:");
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                switch (parameter) {
                    case "uri":
                    case "sessionDescriptionHandlerFactory":
                        this.logger.log("· " + parameter + ": " + settings[parameter]);
                        break;
                    case "password":
                        this.logger.log("· " + parameter + ": " + "NOT SHOWN");
                        break;
                    case "transportConstructor":
                        this.logger.log("· " + parameter + ": " + settings[parameter].name);
                        break;
                    default:
                        this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
                }
            }
        }
        return;
    };
    /**
     * Configuration checker.
     * @return {Boolean}
     */
    UA.prototype.getConfigurationCheck = function () {
        return {
            mandatory: {},
            optional: {
                uri: function (uri) {
                    if (!(/^sip:/i).test(uri)) {
                        uri = Constants_1.C.SIP + ":" + uri;
                    }
                    var parsed = core_1.Grammar.URIParse(uri);
                    if (!parsed || !parsed.user) {
                        return;
                    }
                    else {
                        return parsed;
                    }
                },
                transportConstructor: function (transportConstructor) {
                    if (transportConstructor instanceof Function) {
                        return transportConstructor;
                    }
                },
                transportOptions: function (transportOptions) {
                    if (typeof transportOptions === "object") {
                        return transportOptions;
                    }
                },
                authorizationUser: function (authorizationUser) {
                    if (core_1.Grammar.parse('"' + authorizationUser + '"', "quoted_string") === -1) {
                        return;
                    }
                    else {
                        return authorizationUser;
                    }
                },
                displayName: function (displayName) {
                    if (core_1.Grammar.parse('"' + displayName + '"', "displayName") === -1) {
                        return;
                    }
                    else {
                        return displayName;
                    }
                },
                dtmfType: function (dtmfType) {
                    switch (dtmfType) {
                        case Constants_1.C.dtmfType.RTP:
                            return Constants_1.C.dtmfType.RTP;
                        case Constants_1.C.dtmfType.INFO:
                        // Fall through
                        default:
                            return Constants_1.C.dtmfType.INFO;
                    }
                },
                hackViaTcp: function (hackViaTcp) {
                    if (typeof hackViaTcp === "boolean") {
                        return hackViaTcp;
                    }
                },
                hackIpInContact: function (hackIpInContact) {
                    if (typeof hackIpInContact === "boolean") {
                        return hackIpInContact;
                    }
                    else if (typeof hackIpInContact === "string" && core_1.Grammar.parse(hackIpInContact, "host") !== -1) {
                        return hackIpInContact;
                    }
                },
                hackWssInTransport: function (hackWssInTransport) {
                    if (typeof hackWssInTransport === "boolean") {
                        return hackWssInTransport;
                    }
                },
                hackAllowUnregisteredOptionTags: function (hackAllowUnregisteredOptionTags) {
                    if (typeof hackAllowUnregisteredOptionTags === "boolean") {
                        return hackAllowUnregisteredOptionTags;
                    }
                },
                contactTransport: function (contactTransport) {
                    if (typeof contactTransport === "string") {
                        return contactTransport;
                    }
                },
                extraSupported: function (optionTags) {
                    if (!(optionTags instanceof Array)) {
                        return;
                    }
                    for (var _i = 0, optionTags_1 = optionTags; _i < optionTags_1.length; _i++) {
                        var tag = optionTags_1[_i];
                        if (typeof tag !== "string") {
                            return;
                        }
                    }
                    return optionTags;
                },
                forceRport: function (forceRport) {
                    if (typeof forceRport === "boolean") {
                        return forceRport;
                    }
                },
                noAnswerTimeout: function (noAnswerTimeout) {
                    if (Utils_1.Utils.isDecimal(noAnswerTimeout)) {
                        var value = Number(noAnswerTimeout);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                password: function (password) {
                    return String(password);
                },
                rel100: function (rel100) {
                    if (rel100 === Constants_1.C.supported.REQUIRED) {
                        return Constants_1.C.supported.REQUIRED;
                    }
                    else if (rel100 === Constants_1.C.supported.SUPPORTED) {
                        return Constants_1.C.supported.SUPPORTED;
                    }
                    else {
                        return Constants_1.C.supported.UNSUPPORTED;
                    }
                },
                replaces: function (replaces) {
                    if (replaces === Constants_1.C.supported.REQUIRED) {
                        return Constants_1.C.supported.REQUIRED;
                    }
                    else if (replaces === Constants_1.C.supported.SUPPORTED) {
                        return Constants_1.C.supported.SUPPORTED;
                    }
                    else {
                        return Constants_1.C.supported.UNSUPPORTED;
                    }
                },
                register: function (register) {
                    if (typeof register === "boolean") {
                        return register;
                    }
                },
                registerOptions: function (registerOptions) {
                    if (typeof registerOptions === "object") {
                        return registerOptions;
                    }
                },
                usePreloadedRoute: function (usePreloadedRoute) {
                    if (typeof usePreloadedRoute === "boolean") {
                        return usePreloadedRoute;
                    }
                },
                userAgentString: function (userAgentString) {
                    if (typeof userAgentString === "string") {
                        return userAgentString;
                    }
                },
                autostart: function (autostart) {
                    if (typeof autostart === "boolean") {
                        return autostart;
                    }
                },
                autostop: function (autostop) {
                    if (typeof autostop === "boolean") {
                        return autostop;
                    }
                },
                sessionDescriptionHandlerFactory: function (sessionDescriptionHandlerFactory) {
                    if (sessionDescriptionHandlerFactory instanceof Function) {
                        return sessionDescriptionHandlerFactory;
                    }
                },
                sessionDescriptionHandlerFactoryOptions: function (options) {
                    if (typeof options === "object") {
                        return options;
                    }
                },
                authenticationFactory: this.checkAuthenticationFactory,
                allowLegacyNotifications: function (allowLegacyNotifications) {
                    if (typeof allowLegacyNotifications === "boolean") {
                        return allowLegacyNotifications;
                    }
                },
                custom: function (custom) {
                    if (typeof custom === "object") {
                        return custom;
                    }
                },
                contactName: function (contactName) {
                    if (typeof contactName === "string") {
                        return contactName;
                    }
                },
                experimentalFeatures: function (experimentalFeatures) {
                    if (typeof experimentalFeatures === "boolean") {
                        return experimentalFeatures;
                    }
                },
            }
        };
    };
    UA.C = {
        // UA status codes
        STATUS_INIT: 0,
        STATUS_STARTING: 1,
        STATUS_READY: 2,
        STATUS_USER_CLOSED: 3,
        STATUS_NOT_READY: 4,
        // UA error codes
        CONFIGURATION_ERROR: 1,
        NETWORK_ERROR: 2,
        ALLOWED_METHODS: [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ],
        ACCEPTED_BODY_TYPES: [
            "application/sdp",
            "application/dtmf-relay"
        ],
        MAX_FORWARDS: 70,
        TAG_LENGTH: 10
    };
    return UA;
}(events_1.EventEmitter));
exports.UA = UA;
(function (UA) {
    var DtmfType;
    (function (DtmfType) {
        DtmfType["RTP"] = "rtp";
        DtmfType["INFO"] = "info";
    })(DtmfType = UA.DtmfType || (UA.DtmfType = {}));
})(UA = exports.UA || (exports.UA = {}));
exports.UA = UA;
/**
 * Factory function to generate configuration give a UA.
 * @param ua UA
 */
function makeUserAgentCoreConfigurationFromUA(ua) {
    // FIXME: Configuration URI is a bad mix of types currently. It also needs to exist.
    if (!(ua.configuration.uri instanceof core_1.URI)) {
        throw new Error("Configuration URI not instance of URI.");
    }
    var aor = ua.configuration.uri;
    var contact = ua.contact;
    var displayName = ua.configuration.displayName ? ua.configuration.displayName : "";
    var hackViaTcp = ua.configuration.hackViaTcp ? true : false;
    var routeSet = ua.configuration.usePreloadedRoute && ua.transport.server && ua.transport.server.sipUri ?
        [ua.transport.server.sipUri] :
        [];
    var sipjsId = ua.configuration.sipjsId || Utils_1.Utils.createRandomToken(5);
    var supportedOptionTags = [];
    supportedOptionTags.push("outbound"); // TODO: is this really supported?
    if (ua.configuration.rel100 === Constants_1.C.supported.SUPPORTED) {
        supportedOptionTags.push("100rel");
    }
    if (ua.configuration.replaces === Constants_1.C.supported.SUPPORTED) {
        supportedOptionTags.push("replaces");
    }
    if (ua.configuration.extraSupported) {
        supportedOptionTags.push.apply(supportedOptionTags, ua.configuration.extraSupported);
    }
    if (!ua.configuration.hackAllowUnregisteredOptionTags) {
        supportedOptionTags = supportedOptionTags.filter(function (optionTag) { return Constants_1.C.OPTION_TAGS[optionTag]; });
    }
    supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values
    var supportedOptionTagsResponse = ua.getSupportedResponseOptions();
    var userAgentHeaderFieldValue = ua.configuration.userAgentString || "sipjs";
    if (!(ua.configuration.viaHost)) {
        throw new Error("Configuration via host undefined");
    }
    var viaForceRport = ua.configuration.forceRport ? true : false;
    var viaHost = ua.configuration.viaHost;
    var configuration = {
        aor: aor,
        contact: contact,
        displayName: displayName,
        hackViaTcp: hackViaTcp,
        loggerFactory: ua.getLoggerFactory(),
        routeSet: routeSet,
        sipjsId: sipjsId,
        supportedOptionTags: supportedOptionTags,
        supportedOptionTagsResponse: supportedOptionTagsResponse,
        userAgentHeaderFieldValue: userAgentHeaderFieldValue,
        viaForceRport: viaForceRport,
        viaHost: viaHost,
        authenticationFactory: function () {
            if (ua.configuration.authenticationFactory) {
                return ua.configuration.authenticationFactory(ua);
            }
            return undefined;
        },
        transportAccessor: function () { return ua.transport; }
    };
    return configuration;
}
exports.makeUserAgentCoreConfigurationFromUA = makeUserAgentCoreConfigurationFromUA;


/***/ }),

/***/ "./node_modules/sip.js/lib/Utils.js":
/*!******************************************!*\
  !*** ./node_modules/sip.js/lib/Utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var grammar_1 = __webpack_require__(/*! ./core/messages/grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js");
var uri_1 = __webpack_require__(/*! ./core/messages/uri */ "./node_modules/sip.js/lib/core/messages/uri.js");
var Utils;
(function (Utils) {
    function defer() {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    }
    Utils.defer = defer;
    function reducePromises(arr, val) {
        return arr.reduce(function (acc, fn) {
            acc = acc.then(fn);
            return acc;
        }, Promise.resolve(val));
    }
    Utils.reducePromises = reducePromises;
    function str_utf8_length(str) {
        return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
    }
    Utils.str_utf8_length = str_utf8_length;
    function generateFakeSDP(body) {
        if (!body) {
            return;
        }
        var start = body.indexOf("o=");
        var end = body.indexOf("\r\n", start);
        return "v=0\r\n" + body.slice(start, end) + "\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0";
    }
    Utils.generateFakeSDP = generateFakeSDP;
    function isDecimal(num) {
        var numAsNum = parseInt(num, 10);
        return !isNaN(numAsNum) && (parseFloat(num) === numAsNum);
    }
    Utils.isDecimal = isDecimal;
    function createRandomToken(size, base) {
        if (base === void 0) { base = 32; }
        var token = "";
        for (var i = 0; i < size; i++) {
            var r = Math.floor(Math.random() * base);
            token += r.toString(base);
        }
        return token;
    }
    Utils.createRandomToken = createRandomToken;
    function newTag() {
        // used to use the constant in UA
        return Utils.createRandomToken(10);
    }
    Utils.newTag = newTag;
    // http://stackoverflow.com/users/109538/broofa
    function newUUID() {
        var UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = Math.floor(Math.random() * 16);
            var v = c === "x" ? r : (r % 4 + 8);
            return v.toString(16);
        });
        return UUID;
    }
    Utils.newUUID = newUUID;
    /*
     * Normalize SIP URI.
     * NOTE: It does not allow a SIP URI without username.
     * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
     * Detects the domain part (if given) and properly hex-escapes the user portion.
     * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
     * @private
     * @param {String} target
     * @param {String} [domain]
     */
    function normalizeTarget(target, domain) {
        // If no target is given then raise an error.
        if (!target) {
            return;
            // If a SIP.URI instance is given then return it.
        }
        else if (target instanceof uri_1.URI) {
            return target;
            // If a string is given split it by '@':
            // - Last fragment is the desired domain.
            // - Otherwise append the given domain argument.
        }
        else if (typeof target === "string") {
            var targetArray = target.split("@");
            var targetUser = void 0;
            var targetDomain = void 0;
            switch (targetArray.length) {
                case 1:
                    if (!domain) {
                        return;
                    }
                    targetUser = target;
                    targetDomain = domain;
                    break;
                case 2:
                    targetUser = targetArray[0];
                    targetDomain = targetArray[1];
                    break;
                default:
                    targetUser = targetArray.slice(0, targetArray.length - 1).join("@");
                    targetDomain = targetArray[targetArray.length - 1];
            }
            // Remove the URI scheme (if present).
            targetUser = targetUser.replace(/^(sips?|tel):/i, "");
            // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
            if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(targetUser)) {
                targetUser = targetUser.replace(/[\-\.\(\)]/g, "");
            }
            // Build the complete SIP URI.
            target = Constants_1.C.SIP + ":" + Utils.escapeUser(targetUser) + "@" + targetDomain;
            // Finally parse the resulting URI.
            return grammar_1.Grammar.URIParse(target);
        }
        else {
            return;
        }
    }
    Utils.normalizeTarget = normalizeTarget;
    /*
     * Hex-escape a SIP URI user.
     * @private
     * @param {String} user
     */
    function escapeUser(user) {
        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
        return encodeURIComponent(decodeURIComponent(user))
            .replace(/%3A/ig, ":")
            .replace(/%2B/ig, "+")
            .replace(/%3F/ig, "?")
            .replace(/%2F/ig, "/");
    }
    Utils.escapeUser = escapeUser;
    function headerize(str) {
        var exceptions = {
            "Call-Id": "Call-ID",
            "Cseq": "CSeq",
            "Min-Se": "Min-SE",
            "Rack": "RAck",
            "Rseq": "RSeq",
            "Www-Authenticate": "WWW-Authenticate",
        };
        var name = str.toLowerCase().replace(/_/g, "-").split("-");
        var parts = name.length;
        var hname = "";
        for (var part = 0; part < parts; part++) {
            if (part !== 0) {
                hname += "-";
            }
            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
        }
        if (exceptions[hname]) {
            hname = exceptions[hname];
        }
        return hname;
    }
    Utils.headerize = headerize;
    function sipErrorCause(statusCode) {
        for (var cause in Constants_1.C.SIP_ERROR_CAUSES) {
            if (Constants_1.C.SIP_ERROR_CAUSES[cause].indexOf(statusCode) !== -1) {
                return Constants_1.C.causes[cause];
            }
        }
        return Constants_1.C.causes.SIP_FAILURE_CODE;
    }
    Utils.sipErrorCause = sipErrorCause;
    function getReasonPhrase(code, specific) {
        return specific || Constants_1.C.REASON_PHRASE[code] || "";
    }
    Utils.getReasonPhrase = getReasonPhrase;
    function getReasonHeaderValue(code, reason) {
        reason = Utils.getReasonPhrase(code, reason);
        return "SIP;cause=" + code + ';text="' + reason + '"';
    }
    Utils.getReasonHeaderValue = getReasonHeaderValue;
    function getCancelReason(code, reason) {
        if (code && code < 200 || code > 699) {
            throw new TypeError("Invalid statusCode: " + code);
        }
        else if (code) {
            return Utils.getReasonHeaderValue(code, reason);
        }
    }
    Utils.getCancelReason = getCancelReason;
    function buildStatusLine(code, reason) {
        // Validate code and reason values
        if (!code || (code < 100 || code > 699)) {
            throw new TypeError("Invalid statusCode: " + code);
        }
        else if (reason && typeof reason !== "string" && !(reason instanceof String)) {
            throw new TypeError("Invalid reason: " + reason);
        }
        reason = Utils.getReasonPhrase(code, reason);
        return "SIP/2.0 " + code + " " + reason + "\r\n";
    }
    Utils.buildStatusLine = buildStatusLine;
    /**
     * Create a Body given a BodyObj.
     * @param bodyObj Body Object
     */
    function fromBodyObj(bodyObj) {
        var content = bodyObj.body;
        var contentType = bodyObj.contentType;
        var contentDisposition = contentTypeToContentDisposition(contentType);
        var body = { contentDisposition: contentDisposition, contentType: contentType, content: content };
        return body;
    }
    Utils.fromBodyObj = fromBodyObj;
    /**
     * Create a BodyObj given a Body.
     * @param bodyObj Body Object
     */
    function toBodyObj(body) {
        var bodyObj = {
            body: body.content,
            contentType: body.contentType
        };
        return bodyObj;
    }
    Utils.toBodyObj = toBodyObj;
    // If the Content-Disposition header field is missing, bodies of
    // Content-Type application/sdp imply the disposition "session", while
    // other content types imply "render".
    // https://tools.ietf.org/html/rfc3261#section-13.2.1
    function contentTypeToContentDisposition(contentType) {
        if (contentType === "application/sdp") {
            return "session";
        }
        else {
            return "render";
        }
    }
})(Utils = exports.Utils || (exports.Utils = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/Modifiers.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/Modifiers.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var stripPayload = function (sdp, payload) {
    var mediaDescs = [];
    var lines = sdp.split(/\r\n/);
    var currentMediaDesc;
    for (var i = 0; i < lines.length;) {
        var line = lines[i];
        if (/^m=(?:audio|video)/.test(line)) {
            currentMediaDesc = {
                index: i,
                stripped: []
            };
            mediaDescs.push(currentMediaDesc);
        }
        else if (currentMediaDesc) {
            var rtpmap = /^a=rtpmap:(\d+) ([^/]+)\//.exec(line);
            if (rtpmap && payload === rtpmap[2]) {
                lines.splice(i, 1);
                currentMediaDesc.stripped.push(rtpmap[1]);
                continue; // Don't increment 'i'
            }
        }
        i++;
    }
    for (var _i = 0, mediaDescs_1 = mediaDescs; _i < mediaDescs_1.length; _i++) {
        var mediaDesc = mediaDescs_1[_i];
        var mline = lines[mediaDesc.index].split(" ");
        // Ignore the first 3 parameters of the mline. The codec information is after that
        for (var j = 3; j < mline.length;) {
            if (mediaDesc.stripped.indexOf(mline[j]) !== -1) {
                mline.splice(j, 1);
                continue;
            }
            j++;
        }
        lines[mediaDesc.index] = mline.join(" ");
    }
    return lines.join("\r\n");
};
var stripMediaDescription = function (sdp, description) {
    var descriptionRegExp = new RegExp("m=" + description + ".*$", "gm");
    var groupRegExp = new RegExp("^a=group:.*$", "gm");
    if (descriptionRegExp.test(sdp)) {
        var midLineToRemove_1;
        sdp = sdp.split(/^m=/gm).filter(function (section) {
            if (section.substr(0, description.length) === description) {
                midLineToRemove_1 = section.match(/^a=mid:.*$/gm);
                if (midLineToRemove_1) {
                    var step = midLineToRemove_1[0].match(/:.+$/g);
                    if (step) {
                        midLineToRemove_1 = step[0].substr(1);
                    }
                }
                return false;
            }
            return true;
        }).join("m=");
        var groupLine = sdp.match(groupRegExp);
        if (groupLine && groupLine.length === 1) {
            var groupLinePortion = groupLine[0];
            var groupRegExpReplace = new RegExp("\ *" + midLineToRemove_1 + "[^\ ]*", "g");
            groupLinePortion = groupLinePortion.replace(groupRegExpReplace, "");
            sdp = sdp.split(groupRegExp).join(groupLinePortion);
        }
    }
    return sdp;
};
function stripTcpCandidates(description) {
    description.sdp = (description.sdp || "").replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/img, "");
    return Promise.resolve(description);
}
exports.stripTcpCandidates = stripTcpCandidates;
function stripTelephoneEvent(description) {
    description.sdp = stripPayload(description.sdp || "", "telephone-event");
    return Promise.resolve(description);
}
exports.stripTelephoneEvent = stripTelephoneEvent;
function cleanJitsiSdpImageattr(description) {
    description.sdp = (description.sdp || "").replace(/^(a=imageattr:.*?)(x|y)=\[0-/gm, "$1$2=[1:");
    return Promise.resolve(description);
}
exports.cleanJitsiSdpImageattr = cleanJitsiSdpImageattr;
function stripG722(description) {
    description.sdp = stripPayload(description.sdp || "", "G722");
    return Promise.resolve(description);
}
exports.stripG722 = stripG722;
function stripRtpPayload(payload) {
    return function (description) {
        description.sdp = stripPayload(description.sdp || "", payload);
        return Promise.resolve(description);
    };
}
exports.stripRtpPayload = stripRtpPayload;
function stripVideo(description) {
    description.sdp = stripMediaDescription(description.sdp || "", "video");
    return Promise.resolve(description);
}
exports.stripVideo = stripVideo;
function addMidLines(description) {
    var sdp = description.sdp || "";
    if (sdp.search(/^a=mid.*$/gm) === -1) {
        var mlines_1 = sdp.match(/^m=.*$/gm);
        var sdpArray_1 = sdp.split(/^m=.*$/gm);
        if (mlines_1) {
            mlines_1.forEach(function (elem, idx) {
                mlines_1[idx] = elem + "\na=mid:" + idx;
            });
        }
        sdpArray_1.forEach(function (elem, idx) {
            if (mlines_1 && mlines_1[idx]) {
                sdpArray_1[idx] = elem + mlines_1[idx];
            }
        });
        sdp = sdpArray_1.join("");
        description.sdp = sdp;
    }
    return Promise.resolve(description);
}
exports.addMidLines = addMidLines;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js":
/*!******************************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var session_1 = __webpack_require__(/*! ../api/session */ "./node_modules/sip.js/lib/api/session.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ../Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/sip.js/lib/Utils.js");
var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./Modifiers */ "./node_modules/sip.js/lib/Web/Modifiers.js"));
var SessionDescriptionHandlerObserver_1 = __webpack_require__(/*! ./SessionDescriptionHandlerObserver */ "./node_modules/sip.js/lib/Web/SessionDescriptionHandlerObserver.js");
/* SessionDescriptionHandler
 * @class PeerConnection helper Class.
 * @param {SIP.Session} session
 * @param {Object} [options]
 */
var SessionDescriptionHandler = /** @class */ (function (_super) {
    tslib_1.__extends(SessionDescriptionHandler, _super);
    function SessionDescriptionHandler(logger, observer, options) {
        var _this = _super.call(this) || this;
        _this.type = Enums_1.TypeStrings.SessionDescriptionHandler;
        // TODO: Validate the options
        _this.options = options || {};
        _this.logger = logger;
        _this.observer = observer;
        _this.dtmfSender = undefined;
        _this.shouldAcquireMedia = true;
        _this.CONTENT_TYPE = "application/sdp";
        _this.C = {
            DIRECTION: {
                NULL: null,
                SENDRECV: "sendrecv",
                SENDONLY: "sendonly",
                RECVONLY: "recvonly",
                INACTIVE: "inactive"
            }
        };
        _this.logger.log("SessionDescriptionHandlerOptions: " + JSON.stringify(_this.options));
        _this.direction = _this.C.DIRECTION.NULL;
        _this.modifiers = _this.options.modifiers || [];
        if (!Array.isArray(_this.modifiers)) {
            _this.modifiers = [_this.modifiers];
        }
        _this.iceGatheringTimeout = false;
        _this.initPeerConnection(_this.options.peerConnectionOptions);
        _this.constraints = _this.checkAndDefaultConstraints(_this.options.constraints);
        return _this;
    }
    /**
     * @param {SIP.Session} session
     * @param {Object} [options]
     */
    SessionDescriptionHandler.defaultFactory = function (session, options) {
        var logger = (session instanceof session_1.Session) ?
            session.userAgent.getLogger("sip.sessionDescriptionHandler", session.id) :
            session.ua.getLogger("sip.invitecontext.sessionDescriptionHandler", session.id);
        var observer = new SessionDescriptionHandlerObserver_1.SessionDescriptionHandlerObserver(session, options);
        return new SessionDescriptionHandler(logger, observer, options);
    };
    // Functions the sesssion can use
    /**
     * Destructor
     */
    SessionDescriptionHandler.prototype.close = function () {
        this.logger.log("closing PeerConnection");
        // have to check signalingState since this.close() gets called multiple times
        if (this.peerConnection && this.peerConnection.signalingState !== "closed") {
            if (this.peerConnection.getSenders) {
                this.peerConnection.getSenders().forEach(function (sender) {
                    if (sender.track) {
                        sender.track.stop();
                    }
                });
            }
            else {
                this.logger.warn("Using getLocalStreams which is deprecated");
                this.peerConnection.getLocalStreams().forEach(function (stream) {
                    stream.getTracks().forEach(function (track) {
                        track.stop();
                    });
                });
            }
            if (this.peerConnection.getReceivers) {
                this.peerConnection.getReceivers().forEach(function (receiver) {
                    if (receiver.track) {
                        receiver.track.stop();
                    }
                });
            }
            else {
                this.logger.warn("Using getRemoteStreams which is deprecated");
                this.peerConnection.getRemoteStreams().forEach(function (stream) {
                    stream.getTracks().forEach(function (track) {
                        track.stop();
                    });
                });
            }
            this.resetIceGatheringComplete();
            this.peerConnection.close();
        }
    };
    /**
     * Gets the local description from the underlying media implementation
     * @param {Object} [options] Options object to be used by getDescription
     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints
     *   https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer
     *   connection with the new options
     * @param {Array} [modifiers] Array with one time use description modifiers
     * @returns {Promise} Promise that resolves with the local description to be used for the session
     */
    SessionDescriptionHandler.prototype.getDescription = function (options, modifiers) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (options.peerConnectionOptions) {
            this.initPeerConnection(options.peerConnectionOptions);
        }
        // Merge passed constraints with saved constraints and save
        var newConstraints = Object.assign({}, this.constraints, options.constraints);
        newConstraints = this.checkAndDefaultConstraints(newConstraints);
        if (JSON.stringify(newConstraints) !== JSON.stringify(this.constraints)) {
            this.constraints = newConstraints;
            this.shouldAcquireMedia = true;
        }
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers = modifiers.concat(this.modifiers);
        return Promise.resolve().then(function () {
            if (_this.shouldAcquireMedia) {
                return _this.acquire(_this.constraints).then(function () {
                    _this.shouldAcquireMedia = false;
                });
            }
        }).then(function () { return _this.createOfferOrAnswer(options.RTCOfferOptions, modifiers); })
            .then(function (description) {
            if (description.sdp === undefined) {
                throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("getDescription", undefined, "SDP undefined");
            }
            _this.emit("getDescription", description);
            return {
                body: description.sdp,
                contentType: _this.CONTENT_TYPE
            };
        });
    };
    /**
     * Check if the Session Description Handler can handle the Content-Type described by a SIP Message
     * @param {String} contentType The content type that is in the SIP Message
     * @returns {boolean}
     */
    SessionDescriptionHandler.prototype.hasDescription = function (contentType) {
        return contentType === this.CONTENT_TYPE;
    };
    /**
     * The modifier that should be used when the session would like to place the call on hold
     * @param {String} [sdp] The description that will be modified
     * @returns {Promise} Promise that resolves with modified SDP
     */
    SessionDescriptionHandler.prototype.holdModifier = function (description) {
        if (!description.sdp) {
            return Promise.resolve(description);
        }
        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(description.sdp)) {
            description.sdp = description.sdp.replace(/(m=[^\r]*\r\n)/g, "$1a=sendonly\r\n");
        }
        else {
            description.sdp = description.sdp.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n");
            description.sdp = description.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n");
        }
        return Promise.resolve(description);
    };
    /**
     * Set the remote description to the underlying media implementation
     * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation
     * @param {Object} [options] Options object to be used by getDescription
     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints
     *   https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer
     *   connection with the new options
     * @param {Array} [modifiers] Array with one time use description modifiers
     * @returns {Promise} Promise that resolves once the description is set
     */
    SessionDescriptionHandler.prototype.setDescription = function (sessionDescription, options, modifiers) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (options.peerConnectionOptions) {
            this.initPeerConnection(options.peerConnectionOptions);
        }
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers = modifiers.concat(this.modifiers);
        var description = {
            type: this.hasOffer("local") ? "answer" : "offer",
            sdp: sessionDescription
        };
        return Promise.resolve().then(function () {
            // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)
            if (_this.shouldAcquireMedia && _this.options.alwaysAcquireMediaFirst) {
                return _this.acquire(_this.constraints).then(function () {
                    _this.shouldAcquireMedia = false;
                });
            }
        }).then(function () { return Utils_1.Utils.reducePromises(modifiers, description); })
            .catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("setDescription", e, "The modifiers did not resolve successfully");
            _this.logger.error(error.message);
            _this.emit("peerConnection-setRemoteDescriptionFailed", error);
            throw error;
        }).then(function (modifiedDescription) {
            _this.emit("setDescription", modifiedDescription);
            return _this.peerConnection.setRemoteDescription(modifiedDescription);
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            // Check the original SDP for video, and ensure that we have want to do audio fallback
            if ((/^m=video.+$/gm).test(sessionDescription) && !options.disableAudioFallback) {
                // Do not try to audio fallback again
                options.disableAudioFallback = true;
                // Remove video first, then do the other modifiers
                return _this.setDescription(sessionDescription, options, [Modifiers.stripVideo].concat(modifiers));
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("setDescription", e);
            if (error.error) {
                _this.logger.error(error.error);
            }
            _this.emit("peerConnection-setRemoteDescriptionFailed", error);
            throw error;
        }).then(function () {
            if (_this.peerConnection.getReceivers) {
                _this.emit("setRemoteDescription", _this.peerConnection.getReceivers());
            }
            else {
                _this.emit("setRemoteDescription", _this.peerConnection.getRemoteStreams());
            }
            _this.emit("confirmed", _this);
        });
    };
    /**
     * Send DTMF via RTP (RFC 4733)
     * @param {String} tones A string containing DTMF digits
     * @param {Object} [options] Options object to be used by sendDtmf
     * @returns {boolean} true if DTMF send is successful, false otherwise
     */
    SessionDescriptionHandler.prototype.sendDtmf = function (tones, options) {
        if (options === void 0) { options = {}; }
        if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {
            var senders = this.peerConnection.getSenders();
            if (senders.length > 0) {
                this.dtmfSender = senders[0].dtmf;
            }
        }
        if (!this.dtmfSender && this.hasBrowserTrackSupport()) {
            var streams = this.peerConnection.getLocalStreams();
            if (streams.length > 0) {
                var audioTracks = streams[0].getAudioTracks();
                if (audioTracks.length > 0) {
                    this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);
                }
            }
        }
        if (!this.dtmfSender) {
            return false;
        }
        try {
            this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);
        }
        catch (e) {
            if (e.type === "InvalidStateError" || e.type === "InvalidCharacterError") {
                this.logger.error(e);
                return false;
            }
            else {
                throw e;
            }
        }
        this.logger.log("DTMF sent via RTP: " + tones.toString());
        return true;
    };
    /**
     * Get the direction of the session description
     * @returns {String} direction of the description
     */
    SessionDescriptionHandler.prototype.getDirection = function () {
        return this.direction;
    };
    SessionDescriptionHandler.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    SessionDescriptionHandler.prototype.getMediaStream = function (constraints) {
        return navigator.mediaDevices.getUserMedia(constraints);
    };
    // Internal functions
    SessionDescriptionHandler.prototype.createOfferOrAnswer = function (RTCOfferOptions, modifiers) {
        var _this = this;
        if (RTCOfferOptions === void 0) { RTCOfferOptions = {}; }
        if (modifiers === void 0) { modifiers = []; }
        var methodName = this.hasOffer("remote") ? "createAnswer" : "createOffer";
        var pc = this.peerConnection;
        this.logger.log(methodName);
        var method = this.hasOffer("remote") ? pc.createAnswer : pc.createOffer;
        return method.apply(pc, RTCOfferOptions).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e, "peerConnection-" + methodName + "Failed");
            _this.emit("peerConnection-" + methodName + "Failed", error);
            throw error;
        }).then(function (sdp) {
            return Utils_1.Utils.reducePromises(modifiers, _this.createRTCSessionDescriptionInit(sdp));
        }).then(function (sdp) {
            _this.resetIceGatheringComplete();
            _this.logger.log("Setting local sdp.");
            _this.logger.log("sdp is " + sdp.sdp || false);
            return pc.setLocalDescription(sdp);
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e, "peerConnection-SetLocalDescriptionFailed");
            _this.emit("peerConnection-SetLocalDescriptionFailed", error);
            throw error;
        }).then(function () { return _this.waitForIceGatheringComplete(); })
            .then(function () {
            if (!_this.peerConnection.localDescription) {
                throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("Missing local description");
            }
            var localDescription = _this.createRTCSessionDescriptionInit(_this.peerConnection.localDescription);
            return Utils_1.Utils.reducePromises(modifiers, localDescription);
        }).then(function (localDescription) {
            _this.setDirection(localDescription.sdp || "");
            return localDescription;
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e);
            _this.logger.error(error.toString());
            throw error;
        });
    };
    // Creates an RTCSessionDescriptionInit from an RTCSessionDescription
    SessionDescriptionHandler.prototype.createRTCSessionDescriptionInit = function (RTCSessionDescription) {
        return {
            type: RTCSessionDescription.type,
            sdp: RTCSessionDescription.sdp
        };
    };
    SessionDescriptionHandler.prototype.addDefaultIceCheckingTimeout = function (peerConnectionOptions) {
        if (peerConnectionOptions.iceCheckingTimeout === undefined) {
            peerConnectionOptions.iceCheckingTimeout = 5000;
        }
        return peerConnectionOptions;
    };
    SessionDescriptionHandler.prototype.addDefaultIceServers = function (rtcConfiguration) {
        if (!rtcConfiguration.iceServers) {
            rtcConfiguration.iceServers = [{ urls: "stun:stun.l.google.com:19302" }];
        }
        return rtcConfiguration;
    };
    SessionDescriptionHandler.prototype.checkAndDefaultConstraints = function (constraints) {
        var defaultConstraints = { audio: true, video: !this.options.alwaysAcquireMediaFirst };
        constraints = constraints || defaultConstraints;
        // Empty object check
        if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {
            return defaultConstraints;
        }
        return constraints;
    };
    SessionDescriptionHandler.prototype.hasBrowserTrackSupport = function () {
        return Boolean(this.peerConnection.addTrack);
    };
    SessionDescriptionHandler.prototype.hasBrowserGetSenderSupport = function () {
        return Boolean(this.peerConnection.getSenders);
    };
    SessionDescriptionHandler.prototype.initPeerConnection = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        options = this.addDefaultIceCheckingTimeout(options);
        options.rtcConfiguration = options.rtcConfiguration || {};
        options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);
        this.logger.log("initPeerConnection");
        if (this.peerConnection) {
            this.logger.log("Already have a peer connection for this session. Tearing down.");
            this.resetIceGatheringComplete();
            this.peerConnection.close();
        }
        this.peerConnection = new RTCPeerConnection(options.rtcConfiguration);
        this.logger.log("New peer connection created");
        if ("ontrack" in this.peerConnection) {
            this.peerConnection.addEventListener("track", function (e) {
                _this.logger.log("track added");
                _this.observer.trackAdded();
                _this.emit("addTrack", e);
            });
        }
        else {
            this.logger.warn("Using onaddstream which is deprecated");
            this.peerConnection.onaddstream = function (e) {
                _this.logger.log("stream added");
                _this.emit("addStream", e);
            };
        }
        this.peerConnection.onicecandidate = function (e) {
            _this.emit("iceCandidate", e);
            if (e.candidate) {
                _this.logger.log("ICE candidate received: " +
                    (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
            }
            else if (e.candidate === null) {
                // indicates the end of candidate gathering
                _this.logger.log("ICE candidate gathering complete");
                _this.triggerIceGatheringComplete();
            }
        };
        this.peerConnection.onicegatheringstatechange = function () {
            _this.logger.log("RTCIceGatheringState changed: " + _this.peerConnection.iceGatheringState);
            switch (_this.peerConnection.iceGatheringState) {
                case "gathering":
                    _this.emit("iceGathering", _this);
                    if (!_this.iceGatheringTimer && options.iceCheckingTimeout) {
                        _this.iceGatheringTimeout = false;
                        _this.iceGatheringTimer = setTimeout(function () {
                            _this.logger.log("RTCIceChecking Timeout Triggered after " + options.iceCheckingTimeout + " milliseconds");
                            _this.iceGatheringTimeout = true;
                            _this.triggerIceGatheringComplete();
                        }, options.iceCheckingTimeout);
                    }
                    break;
                case "complete":
                    _this.triggerIceGatheringComplete();
                    break;
            }
        };
        this.peerConnection.oniceconnectionstatechange = function () {
            var stateEvent;
            switch (_this.peerConnection.iceConnectionState) {
                case "new":
                    stateEvent = "iceConnection";
                    break;
                case "checking":
                    stateEvent = "iceConnectionChecking";
                    break;
                case "connected":
                    stateEvent = "iceConnectionConnected";
                    break;
                case "completed":
                    stateEvent = "iceConnectionCompleted";
                    break;
                case "failed":
                    stateEvent = "iceConnectionFailed";
                    break;
                case "disconnected":
                    stateEvent = "iceConnectionDisconnected";
                    break;
                case "closed":
                    stateEvent = "iceConnectionClosed";
                    break;
                default:
                    _this.logger.warn("Unknown iceConnection state: " + _this.peerConnection.iceConnectionState);
                    return;
            }
            _this.logger.log("ICE Connection State changed to " + stateEvent);
            _this.emit(stateEvent, _this);
        };
    };
    SessionDescriptionHandler.prototype.acquire = function (constraints) {
        var _this = this;
        // Default audio & video to true
        constraints = this.checkAndDefaultConstraints(constraints);
        return new Promise(function (resolve, reject) {
            /*
             * Make the call asynchronous, so that ICCs have a chance
             * to define callbacks to `userMediaRequest`
             */
            _this.logger.log("acquiring local media");
            _this.emit("userMediaRequest", constraints);
            if (constraints.audio || constraints.video) {
                _this.getMediaStream(constraints).then(function (streams) {
                    _this.observer.trackAdded();
                    _this.emit("userMedia", streams);
                    resolve(streams);
                }).catch(function (e) {
                    _this.emit("userMediaFailed", e);
                    reject(e);
                });
            }
            else {
                // Local streams were explicitly excluded.
                resolve([]);
            }
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "unable to acquire streams");
            _this.logger.error(error.message);
            if (error.error) {
                _this.logger.error(error.error);
            }
            throw error;
        }).then(function (streams) {
            _this.logger.log("acquired local media streams");
            // Remove old tracks
            if (_this.peerConnection.removeTrack) {
                _this.peerConnection.getSenders().forEach(function (sender) {
                    _this.peerConnection.removeTrack(sender);
                });
            }
            return streams;
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "error removing streams");
            _this.logger.error(error.message);
            if (error.error) {
                _this.logger.error(error.error);
            }
            throw error;
        }).then(function (streams) {
            var streamsArr = [].concat(streams);
            streamsArr.forEach(function (stream) {
                if (_this.peerConnection.addTrack) {
                    stream.getTracks().forEach(function (track) {
                        _this.peerConnection.addTrack(track, stream);
                    });
                }
                else {
                    // Chrome 59 does not support addTrack
                    _this.peerConnection.addStream(stream);
                }
            });
            return Promise.resolve();
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "error adding stream");
            _this.logger.error(error.message);
            if (error.error) {
                _this.logger.error(error.error);
            }
            throw error;
        });
    };
    SessionDescriptionHandler.prototype.hasOffer = function (where) {
        var offerState = "have-" + where + "-offer";
        return this.peerConnection.signalingState === offerState;
    };
    // ICE gathering state handling
    SessionDescriptionHandler.prototype.isIceGatheringComplete = function () {
        return this.peerConnection.iceGatheringState === "complete" || this.iceGatheringTimeout;
    };
    SessionDescriptionHandler.prototype.resetIceGatheringComplete = function () {
        this.iceGatheringTimeout = false;
        this.logger.log("resetIceGatheringComplete");
        if (this.iceGatheringTimer) {
            clearTimeout(this.iceGatheringTimer);
            this.iceGatheringTimer = undefined;
        }
        if (this.iceGatheringDeferred) {
            this.iceGatheringDeferred.reject();
            this.iceGatheringDeferred = undefined;
        }
    };
    SessionDescriptionHandler.prototype.setDirection = function (sdp) {
        var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
        if (match === null) {
            this.direction = this.C.DIRECTION.NULL;
            this.observer.directionChanged();
            return;
        }
        var direction = match[1];
        switch (direction) {
            case this.C.DIRECTION.SENDRECV:
            case this.C.DIRECTION.SENDONLY:
            case this.C.DIRECTION.RECVONLY:
            case this.C.DIRECTION.INACTIVE:
                this.direction = direction;
                break;
            default:
                this.direction = this.C.DIRECTION.NULL;
                break;
        }
        this.observer.directionChanged();
    };
    SessionDescriptionHandler.prototype.triggerIceGatheringComplete = function () {
        if (this.isIceGatheringComplete()) {
            this.emit("iceGatheringComplete", this);
            if (this.iceGatheringTimer) {
                clearTimeout(this.iceGatheringTimer);
                this.iceGatheringTimer = undefined;
            }
            if (this.iceGatheringDeferred) {
                this.iceGatheringDeferred.resolve();
                this.iceGatheringDeferred = undefined;
            }
        }
    };
    SessionDescriptionHandler.prototype.waitForIceGatheringComplete = function () {
        this.logger.log("waitForIceGatheringComplete");
        if (this.isIceGatheringComplete()) {
            this.logger.log("ICE is already complete. Return resolved.");
            return Promise.resolve();
        }
        else if (!this.iceGatheringDeferred) {
            this.iceGatheringDeferred = Utils_1.Utils.defer();
        }
        this.logger.log("ICE is not complete. Returning promise");
        return this.iceGatheringDeferred ? this.iceGatheringDeferred.promise : Promise.resolve();
    };
    return SessionDescriptionHandler;
}(events_1.EventEmitter));
exports.SessionDescriptionHandler = SessionDescriptionHandler;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/SessionDescriptionHandlerObserver.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/SessionDescriptionHandlerObserver.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var session_1 = __webpack_require__(/*! ../api/session */ "./node_modules/sip.js/lib/api/session.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
/* SessionDescriptionHandlerObserver
 * @class SessionDescriptionHandler Observer Class.
 * @param {SIP.Session} session
 * @param {Object} [options]
 */
var SessionDescriptionHandlerObserver = /** @class */ (function () {
    function SessionDescriptionHandlerObserver(session, options) {
        this.type = Enums_1.TypeStrings.SessionDescriptionHandlerObserver;
        this.session = session;
        this.options = options;
    }
    SessionDescriptionHandlerObserver.prototype.trackAdded = function () {
        if (this.session instanceof session_1.Session) {
            return;
        }
        this.session.emit("trackAdded");
    };
    SessionDescriptionHandlerObserver.prototype.directionChanged = function () {
        if (this.session instanceof session_1.Session) {
            return;
        }
        this.session.emit("directionChanged");
    };
    return SessionDescriptionHandlerObserver;
}());
exports.SessionDescriptionHandlerObserver = SessionDescriptionHandlerObserver;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/Simple.js":
/*!***********************************************!*\
  !*** ./node_modules/sip.js/lib/Web/Simple.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var UA_1 = __webpack_require__(/*! ../UA */ "./node_modules/sip.js/lib/UA.js");
var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./Modifiers */ "./node_modules/sip.js/lib/Web/Modifiers.js"));
/* Simple
 * @class Simple
 */
var SimpleStatus;
(function (SimpleStatus) {
    SimpleStatus[SimpleStatus["STATUS_NULL"] = 0] = "STATUS_NULL";
    SimpleStatus[SimpleStatus["STATUS_NEW"] = 1] = "STATUS_NEW";
    SimpleStatus[SimpleStatus["STATUS_CONNECTING"] = 2] = "STATUS_CONNECTING";
    SimpleStatus[SimpleStatus["STATUS_CONNECTED"] = 3] = "STATUS_CONNECTED";
    SimpleStatus[SimpleStatus["STATUS_COMPLETED"] = 4] = "STATUS_COMPLETED";
})(SimpleStatus = exports.SimpleStatus || (exports.SimpleStatus = {}));
var Simple = /** @class */ (function (_super) {
    tslib_1.__extends(Simple, _super);
    function Simple(options) {
        var _this = _super.call(this) || this;
        /*
        *  {
        *    media: {
        *      remote: {
        *        audio: <DOM element>,
        *        video: <DOM element>
        *      },
        *      local: {
        *        video: <DOM element>
        *      }
        *    },
        *    ua: {
        *       <UA Configuration Options>
        *    }
        *  }
        */
        if (options.media.remote.video) {
            _this.video = true;
        }
        else {
            _this.video = false;
        }
        if (options.media.remote.audio) {
            _this.audio = true;
        }
        else {
            _this.audio = false;
        }
        if (!_this.audio && !_this.video) {
            // Need to do at least audio or video
            // Error
            throw new Error("At least one remote audio or video element is required for Simple.");
        }
        _this.options = options;
        // https://stackoverflow.com/questions/7944460/detect-safari-browser
        var browserUa = navigator.userAgent.toLowerCase();
        var isSafari = false;
        var isFirefox = false;
        if (browserUa.indexOf("safari") > -1 && browserUa.indexOf("chrome") < 0) {
            isSafari = true;
        }
        else if (browserUa.indexOf("firefox") > -1 && browserUa.indexOf("chrome") < 0) {
            isFirefox = true;
        }
        var sessionDescriptionHandlerFactoryOptions = {};
        if (isSafari) {
            sessionDescriptionHandlerFactoryOptions.modifiers = [Modifiers.stripG722];
        }
        if (isFirefox) {
            sessionDescriptionHandlerFactoryOptions.alwaysAcquireMediaFirst = true;
        }
        if (!_this.options.ua.uri) {
            _this.anonymous = true;
        }
        else {
            _this.anonymous = false;
        }
        _this.ua = new UA_1.UA({
            // User Configurable Options
            uri: _this.options.ua.uri,
            authorizationUser: _this.options.ua.authorizationUser,
            password: _this.options.ua.password,
            displayName: _this.options.ua.displayName,
            // Undocumented "Advanced" Options
            userAgentString: _this.options.ua.userAgentString,
            // Fixed Options
            register: true,
            sessionDescriptionHandlerFactoryOptions: sessionDescriptionHandlerFactoryOptions,
            transportOptions: {
                traceSip: _this.options.ua.traceSip,
                wsServers: _this.options.ua.wsServers
            }
        });
        _this.state = SimpleStatus.STATUS_NULL;
        _this.logger = _this.ua.getLogger("sip.simple");
        _this.ua.on("registered", function () {
            _this.emit("registered", _this.ua);
        });
        _this.ua.on("unregistered", function () {
            _this.emit("unregistered", _this.ua);
        });
        _this.ua.on("registrationFailed", function () {
            _this.emit("unregistered", _this.ua);
        });
        _this.ua.on("invite", function (session) {
            // If there is already an active session reject the incoming session
            if (_this.state !== SimpleStatus.STATUS_NULL && _this.state !== SimpleStatus.STATUS_COMPLETED) {
                _this.logger.warn("Rejecting incoming call. Simple only supports 1 call at a time");
                session.reject();
                return;
            }
            _this.session = session;
            _this.setupSession();
            _this.emit("ringing", _this.session);
        });
        _this.ua.on("message", function (message) {
            _this.emit("message", message);
        });
        return _this;
    }
    Simple.prototype.call = function (destination) {
        if (!this.ua || !this.checkRegistration()) {
            this.logger.warn("A registered UA is required for calling");
            return;
        }
        if (this.state !== SimpleStatus.STATUS_NULL && this.state !== SimpleStatus.STATUS_COMPLETED) {
            this.logger.warn("Cannot make more than a single call with Simple");
            return;
        }
        // Safari hack, because you cannot call .play() from a non user action
        if (this.options.media.remote.audio) {
            this.options.media.remote.audio.autoplay = true;
        }
        if (this.options.media.remote.video) {
            this.options.media.remote.video.autoplay = true;
        }
        if (this.options.media.local && this.options.media.local.video) {
            this.options.media.local.video.autoplay = true;
            this.options.media.local.video.volume = 0;
        }
        this.session = this.ua.invite(destination, {
            sessionDescriptionHandlerOptions: {
                constraints: {
                    audio: this.audio,
                    video: this.video
                }
            }
        });
        this.setupSession();
        return this.session;
    };
    Simple.prototype.answer = function () {
        if (this.state !== SimpleStatus.STATUS_NEW && this.state !== SimpleStatus.STATUS_CONNECTING) {
            this.logger.warn("No call to answer");
            return;
        }
        // Safari hack, because you cannot call .play() from a non user action
        if (this.options.media.remote.audio) {
            this.options.media.remote.audio.autoplay = true;
        }
        if (this.options.media.remote.video) {
            this.options.media.remote.video.autoplay = true;
        }
        return this.session.accept({
            sessionDescriptionHandlerOptions: {
                constraints: {
                    audio: this.audio,
                    video: this.video
                }
            }
        });
        // emit call is active
    };
    Simple.prototype.reject = function () {
        if (this.state !== SimpleStatus.STATUS_NEW && this.state !== SimpleStatus.STATUS_CONNECTING) {
            this.logger.warn("Call is already answered");
            return;
        }
        return this.session.reject();
    };
    Simple.prototype.hangup = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED &&
            this.state !== SimpleStatus.STATUS_CONNECTING &&
            this.state !== SimpleStatus.STATUS_NEW) {
            this.logger.warn("No active call to hang up on");
            return;
        }
        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
            return this.session.cancel();
        }
        else if (this.session) {
            return this.session.bye();
        }
    };
    Simple.prototype.hold = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session || this.session.localHold) {
            this.logger.warn("Cannot put call on hold");
            return;
        }
        this.mute();
        this.logger.log("Placing session on hold");
        return this.session.hold();
    };
    Simple.prototype.unhold = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session || !this.session.localHold) {
            this.logger.warn("Cannot unhold a call that is not on hold");
            return;
        }
        this.unmute();
        this.logger.log("Placing call off hold");
        return this.session.unhold();
    };
    Simple.prototype.mute = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
            this.logger.warn("An acitve call is required to mute audio");
            return;
        }
        this.logger.log("Muting Audio");
        this.toggleMute(true);
        this.emit("mute", this);
    };
    Simple.prototype.unmute = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
            this.logger.warn("An active call is required to unmute audio");
            return;
        }
        this.logger.log("Unmuting Audio");
        this.toggleMute(false);
        this.emit("unmute", this);
    };
    Simple.prototype.sendDTMF = function (tone) {
        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session) {
            this.logger.warn("An active call is required to send a DTMF tone");
            return;
        }
        this.logger.log("Sending DTMF tone: " + tone);
        this.session.dtmf(tone);
    };
    Simple.prototype.message = function (destination, message) {
        if (!this.ua || !this.checkRegistration()) {
            this.logger.warn("A registered UA is required to send a message");
            return;
        }
        if (!destination || !message) {
            this.logger.warn("A destination and message are required to send a message");
            return;
        }
        this.ua.message(destination, message);
    };
    // Private Helpers
    Simple.prototype.checkRegistration = function () {
        return (this.anonymous || (this.ua && this.ua.isRegistered()));
    };
    Simple.prototype.setupRemoteMedia = function () {
        var _this = this;
        if (!this.session) {
            this.logger.warn("No session to set remote media on");
            return;
        }
        // If there is a video track, it will attach the video and audio to the same element
        var pc = this.session.sessionDescriptionHandler.peerConnection;
        var remoteStream;
        if (pc.getReceivers) {
            remoteStream = new MediaStream();
            pc.getReceivers().forEach(function (receiver) {
                var track = receiver.track;
                if (track) {
                    remoteStream.addTrack(track);
                }
            });
        }
        else {
            remoteStream = pc.getRemoteStreams()[0];
        }
        if (this.video) {
            this.options.media.remote.video.srcObject = remoteStream;
            this.options.media.remote.video.play().catch(function () {
                _this.logger.log("play was rejected");
            });
        }
        else if (this.audio) {
            this.options.media.remote.audio.srcObject = remoteStream;
            this.options.media.remote.audio.play().catch(function () {
                _this.logger.log("play was rejected");
            });
        }
    };
    Simple.prototype.setupLocalMedia = function () {
        if (!this.session) {
            this.logger.warn("No session to set local media on");
            return;
        }
        if (this.video && this.options.media.local && this.options.media.local.video) {
            var pc = this.session.sessionDescriptionHandler.peerConnection;
            var localStream_1;
            if (pc.getSenders) {
                localStream_1 = new MediaStream();
                pc.getSenders().forEach(function (sender) {
                    var track = sender.track;
                    if (track && track.kind === "video") {
                        localStream_1.addTrack(track);
                    }
                });
            }
            else {
                localStream_1 = pc.getLocalStreams()[0];
            }
            this.options.media.local.video.srcObject = localStream_1;
            this.options.media.local.video.volume = 0;
            this.options.media.local.video.play();
        }
    };
    Simple.prototype.cleanupMedia = function () {
        if (this.video) {
            this.options.media.remote.video.srcObject = null;
            this.options.media.remote.video.pause();
            if (this.options.media.local && this.options.media.local.video) {
                this.options.media.local.video.srcObject = null;
                this.options.media.local.video.pause();
            }
        }
        if (this.audio) {
            this.options.media.remote.audio.srcObject = null;
            this.options.media.remote.audio.pause();
        }
    };
    Simple.prototype.setupSession = function () {
        var _this = this;
        if (!this.session) {
            this.logger.warn("No session to set up");
            return;
        }
        this.state = SimpleStatus.STATUS_NEW;
        this.emit("new", this.session);
        this.session.on("progress", function () { return _this.onProgress(); });
        this.session.on("accepted", function () { return _this.onAccepted(); });
        this.session.on("rejected", function () { return _this.onEnded(); });
        this.session.on("failed", function () { return _this.onFailed(); });
        this.session.on("terminated", function () { return _this.onEnded(); });
    };
    Simple.prototype.destroyMedia = function () {
        if (this.session && this.session.sessionDescriptionHandler) {
            this.session.sessionDescriptionHandler.close();
        }
    };
    Simple.prototype.toggleMute = function (mute) {
        if (!this.session) {
            this.logger.warn("No session to toggle mute");
            return;
        }
        var pc = this.session.sessionDescriptionHandler.peerConnection;
        if (pc.getSenders) {
            pc.getSenders().forEach(function (sender) {
                if (sender.track) {
                    sender.track.enabled = !mute;
                }
            });
        }
        else {
            pc.getLocalStreams().forEach(function (stream) {
                stream.getAudioTracks().forEach(function (track) {
                    track.enabled = !mute;
                });
                stream.getVideoTracks().forEach(function (track) {
                    track.enabled = !mute;
                });
            });
        }
    };
    Simple.prototype.onAccepted = function () {
        var _this = this;
        if (!this.session) {
            this.logger.warn("No session for accepting");
            return;
        }
        this.state = SimpleStatus.STATUS_CONNECTED;
        this.emit("connected", this.session);
        this.setupLocalMedia();
        this.setupRemoteMedia();
        if (this.session.sessionDescriptionHandler) {
            this.session.sessionDescriptionHandler.on("addTrack", function () {
                _this.logger.log("A track has been added, triggering new remoteMedia setup");
                _this.setupRemoteMedia();
            });
            this.session.sessionDescriptionHandler.on("addStream", function () {
                _this.logger.log("A stream has been added, trigger new remoteMedia setup");
                _this.setupRemoteMedia();
            });
        }
        this.session.on("dtmf", function (request, dtmf) {
            _this.emit("dtmf", dtmf.tone);
        });
        this.session.on("bye", function () { return _this.onEnded(); });
    };
    Simple.prototype.onProgress = function () {
        this.state = SimpleStatus.STATUS_CONNECTING;
        this.emit("connecting", this.session);
    };
    Simple.prototype.onFailed = function () {
        this.onEnded();
    };
    Simple.prototype.onEnded = function () {
        this.state = SimpleStatus.STATUS_COMPLETED;
        this.emit("ended", this.session);
        this.cleanupMedia();
    };
    Simple.C = SimpleStatus;
    return Simple;
}(events_1.EventEmitter));
exports.Simple = Simple;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/Transport.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/Transport.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ../Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Transport_1 = __webpack_require__(/*! ../Transport */ "./node_modules/sip.js/lib/Transport.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/sip.js/lib/Utils.js");
var TransportStatus;
(function (TransportStatus) {
    TransportStatus[TransportStatus["STATUS_CONNECTING"] = 0] = "STATUS_CONNECTING";
    TransportStatus[TransportStatus["STATUS_OPEN"] = 1] = "STATUS_OPEN";
    TransportStatus[TransportStatus["STATUS_CLOSING"] = 2] = "STATUS_CLOSING";
    TransportStatus[TransportStatus["STATUS_CLOSED"] = 3] = "STATUS_CLOSED";
})(TransportStatus = exports.TransportStatus || (exports.TransportStatus = {}));
/**
 * Compute an amount of time in seconds to wait before sending another
 * keep-alive.
 * @returns {Number}
 */
var computeKeepAliveTimeout = function (upperBound) {
    var lowerBound = upperBound * 0.8;
    return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
};
/**
 * @class Transport
 * @param {Object} options
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    function Transport(logger, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, logger) || this;
        _this.type = Enums_1.TypeStrings.Transport;
        _this.reconnectionAttempts = 0;
        _this.status = TransportStatus.STATUS_CONNECTING;
        _this.configuration = _this.loadConfig(options);
        _this.server = _this.configuration.wsServers[0];
        return _this;
    }
    /**
     * @returns {Boolean}
     */
    Transport.prototype.isConnected = function () {
        return this.status === TransportStatus.STATUS_OPEN;
    };
    /**
     * Send a message.
     * @param message - Outgoing message.
     * @param options - Options bucket.
     */
    Transport.prototype.sendPromise = function (message, options) {
        if (options === void 0) { options = {}; }
        if (this.ws === undefined) {
            this.onError("unable to send message - WebSocket undefined");
            return Promise.reject(new Error("WebSocket undefined."));
        }
        // FIXME: This check is likely not necessary as WebSocket.send() will
        // throw INVALID_STATE_ERR if the connection is not currently open
        // which could happen regardless of what we thing the state is.
        if (!this.statusAssert(TransportStatus.STATUS_OPEN, options.force)) {
            this.onError("unable to send message - WebSocket not open");
            return Promise.reject(new Error("WebSocket not open."));
        }
        if (this.configuration.traceSip === true) {
            this.logger.log("sending WebSocket message:\n\n" + message + "\n");
        }
        // WebSocket.send() can throw.
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
        try {
            this.ws.send(message);
        }
        catch (error) {
            if (error instanceof error) {
                Promise.reject(error);
            }
            return Promise.reject(new Error("Failed to send message."));
        }
        return Promise.resolve({ msg: message });
    };
    /**
     * Disconnect socket.
     */
    Transport.prototype.disconnectPromise = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.disconnectionPromise) { // Already disconnecting. Just return this.
            return this.disconnectionPromise;
        }
        options.code = options.code || 1000;
        if (!this.statusTransition(TransportStatus.STATUS_CLOSING, options.force)) {
            if (this.status === TransportStatus.STATUS_CLOSED) { // Websocket is already closed
                return Promise.resolve({ overrideEvent: true });
            }
            else if (this.connectionPromise) { // Websocket is connecting, cannot move to disconneting yet
                return this.connectionPromise.then(function () { return Promise.reject("The websocket did not disconnect"); })
                    .catch(function () { return Promise.resolve({ overrideEvent: true }); });
            }
            else {
                // Cannot move to disconnecting, but not in connecting state.
                return Promise.reject("The websocket did not disconnect");
            }
        }
        this.emit("disconnecting");
        this.disconnectionPromise = new Promise(function (resolve, reject) {
            _this.disconnectDeferredResolve = resolve;
            if (_this.reconnectTimer) {
                clearTimeout(_this.reconnectTimer);
                _this.reconnectTimer = undefined;
            }
            if (_this.ws) {
                _this.stopSendingKeepAlives();
                _this.logger.log("closing WebSocket " + _this.server.wsUri);
                _this.ws.close(options.code, options.reason);
            }
            else {
                reject("Attempted to disconnect but the websocket doesn't exist");
            }
        });
        return this.disconnectionPromise;
    };
    /**
     * Connect socket.
     */
    Transport.prototype.connectPromise = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.status === TransportStatus.STATUS_CLOSING && !options.force) {
            return Promise.reject("WebSocket " + this.server.wsUri + " is closing");
        }
        if (this.connectionPromise) {
            return this.connectionPromise;
        }
        this.server = this.server || this.getNextWsServer(options.force);
        this.connectionPromise = new Promise(function (resolve, reject) {
            if ((_this.status === TransportStatus.STATUS_OPEN || _this.status === TransportStatus.STATUS_CLOSING)
                && !options.force) {
                _this.logger.warn("WebSocket " + _this.server.wsUri + " is already connected");
                reject("Failed status check - attempted to open a connection but already open/closing");
                return;
            }
            _this.connectDeferredResolve = resolve;
            _this.connectDeferredReject = reject;
            _this.status = TransportStatus.STATUS_CONNECTING;
            _this.emit("connecting");
            _this.logger.log("connecting to WebSocket " + _this.server.wsUri);
            _this.disposeWs();
            try {
                _this.ws = new WebSocket(_this.server.wsUri, "sip");
                _this.ws.binaryType = "arraybuffer"; // set data type of received binary messages
            }
            catch (e) {
                _this.ws = undefined;
                _this.statusTransition(TransportStatus.STATUS_CLOSED, true);
                _this.onError("error connecting to WebSocket " + _this.server.wsUri + ":" + e);
                reject("Failed to create a websocket");
                _this.connectDeferredResolve = undefined;
                _this.connectDeferredReject = undefined;
                return;
            }
            if (!_this.ws) {
                reject("Unexpected instance websocket not set");
                _this.connectDeferredResolve = undefined;
                _this.connectDeferredReject = undefined;
                return;
            }
            _this.connectionTimeout = setTimeout(function () {
                _this.statusTransition(TransportStatus.STATUS_CLOSED);
                _this.logger.warn("took too long to connect - exceeded time set in configuration.connectionTimeout: " +
                    _this.configuration.connectionTimeout + "s");
                _this.emit("disconnected", { code: 1000 });
                _this.connectionPromise = undefined;
                reject("Connection timeout");
                _this.connectDeferredResolve = undefined;
                _this.connectDeferredReject = undefined;
                var ws = _this.ws;
                _this.disposeWs();
                if (ws) {
                    ws.close(1000);
                }
            }, _this.configuration.connectionTimeout * 1000);
            _this.boundOnOpen = _this.onOpen.bind(_this);
            _this.boundOnMessage = _this.onMessage.bind(_this);
            _this.boundOnClose = _this.onClose.bind(_this);
            _this.boundOnError = _this.onWebsocketError.bind(_this);
            _this.ws.addEventListener("open", _this.boundOnOpen);
            _this.ws.addEventListener("message", _this.boundOnMessage);
            _this.ws.addEventListener("close", _this.boundOnClose);
            _this.ws.addEventListener("error", _this.boundOnError);
        });
        return this.connectionPromise;
    };
    /**
     * @event
     * @param {event} e
     */
    Transport.prototype.onMessage = function (e) {
        var data = e.data;
        var finishedData;
        // CRLF Keep Alive response from server. Clear our keep alive timeout.
        if (/^(\r\n)+$/.test(data)) {
            this.clearKeepAliveTimeout();
            if (this.configuration.traceSip === true) {
                this.logger.log("received WebSocket message with CRLF Keep Alive response");
            }
            return;
        }
        else if (!data) {
            this.logger.warn("received empty message, message discarded");
            return;
        }
        else if (typeof data !== "string") { // WebSocket binary message.
            try {
                // the UInt8Data was here prior to types, and doesn't check
                finishedData = String.fromCharCode.apply(null, new Uint8Array(data));
            }
            catch (err) {
                this.logger.warn("received WebSocket binary message failed to be converted into string, message discarded");
                return;
            }
            if (this.configuration.traceSip === true) {
                this.logger.log("received WebSocket binary message:\n\n" + data + "\n");
            }
        }
        else { // WebSocket text message.
            if (this.configuration.traceSip === true) {
                this.logger.log("received WebSocket text message:\n\n" + data + "\n");
            }
            finishedData = data;
        }
        this.emit("message", finishedData);
    };
    // Transport Event Handlers
    /**
     * @event
     * @param {event} e
     */
    Transport.prototype.onOpen = function () {
        if (this.status === TransportStatus.STATUS_CLOSED) { // Indicated that the transport thinks the ws is dead already
            var ws = this.ws;
            this.disposeWs();
            if (ws) {
                ws.close(1000);
            }
            return;
        }
        this.statusTransition(TransportStatus.STATUS_OPEN, true);
        this.emit("connected");
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = undefined;
        }
        this.logger.log("WebSocket " + this.server.wsUri + " connected");
        // Clear reconnectTimer since we are not disconnected
        if (this.reconnectTimer !== undefined) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = undefined;
        }
        // Reset reconnectionAttempts
        this.reconnectionAttempts = 0;
        // Reset disconnection promise so we can disconnect from a fresh state
        this.disconnectionPromise = undefined;
        this.disconnectDeferredResolve = undefined;
        // Start sending keep-alives
        this.startSendingKeepAlives();
        if (this.connectDeferredResolve) {
            this.connectDeferredResolve({ overrideEvent: true });
            this.connectDeferredResolve = undefined;
            this.connectDeferredReject = undefined;
        }
        else {
            this.logger.warn("Unexpected websocket.onOpen with no connectDeferredResolve");
        }
    };
    /**
     * @event
     * @param {event} e
     */
    Transport.prototype.onClose = function (e) {
        this.logger.log("WebSocket disconnected (code: " + e.code + (e.reason ? "| reason: " + e.reason : "") + ")");
        if (this.status !== TransportStatus.STATUS_CLOSING) {
            this.logger.warn("WebSocket closed without SIP.js requesting it");
            this.emit("transportError");
        }
        this.stopSendingKeepAlives();
        // Clean up connection variables so we can connect again from a fresh state
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
        }
        if (this.connectDeferredReject) {
            this.connectDeferredReject("Websocket Closed");
        }
        this.connectionTimeout = undefined;
        this.connectionPromise = undefined;
        this.connectDeferredResolve = undefined;
        this.connectDeferredReject = undefined;
        // Check whether the user requested to close.
        if (this.disconnectDeferredResolve) {
            this.disconnectDeferredResolve({ overrideEvent: true });
            this.statusTransition(TransportStatus.STATUS_CLOSED);
            this.disconnectDeferredResolve = undefined;
            return;
        }
        this.statusTransition(TransportStatus.STATUS_CLOSED, true);
        this.emit("disconnected", { code: e.code, reason: e.reason });
        this.disposeWs();
        this.reconnect();
    };
    /**
     * Removes event listeners and clears the instance ws
     */
    Transport.prototype.disposeWs = function () {
        if (this.ws) {
            this.ws.removeEventListener("open", this.boundOnOpen);
            this.ws.removeEventListener("message", this.boundOnMessage);
            this.ws.removeEventListener("close", this.boundOnClose);
            this.ws.removeEventListener("error", this.boundOnError);
            this.ws = undefined;
        }
    };
    /**
     * @event
     * @param {string} e
     */
    Transport.prototype.onError = function (e) {
        this.logger.warn("Transport error: " + e);
        this.emit("transportError");
    };
    /**
     * @event
     * @private
     */
    Transport.prototype.onWebsocketError = function () {
        this.onError("The Websocket had an error");
    };
    /**
     * Reconnection attempt logic.
     */
    Transport.prototype.reconnect = function () {
        var _this = this;
        if (this.reconnectionAttempts > 0) {
            this.logger.log("Reconnection attempt " + this.reconnectionAttempts + " failed");
        }
        if (this.noAvailableServers()) {
            this.logger.warn("attempted to get next ws server but there are no available ws servers left");
            this.logger.warn("no available ws servers left - going to closed state");
            this.statusTransition(TransportStatus.STATUS_CLOSED, true);
            this.emit("closed");
            this.resetServerErrorStatus();
            return;
        }
        if (this.isConnected()) {
            this.logger.warn("attempted to reconnect while connected - forcing disconnect");
            this.disconnect({ force: true });
        }
        this.reconnectionAttempts += 1;
        if (this.reconnectionAttempts > this.configuration.maxReconnectionAttempts) {
            this.logger.warn("maximum reconnection attempts for WebSocket " + this.server.wsUri);
            this.logger.log("transport " + this.server.wsUri + " failed | connection state set to 'error'");
            this.server.isError = true;
            this.emit("transportError");
            if (!this.noAvailableServers()) {
                this.server = this.getNextWsServer();
            }
            // When there are no available servers, the reconnect function ends on the next recursive call
            // after checking for no available servers again.
            this.reconnectionAttempts = 0;
            this.reconnect();
        }
        else {
            this.logger.log("trying to reconnect to WebSocket " +
                this.server.wsUri + " (reconnection attempt " + this.reconnectionAttempts + ")");
            this.reconnectTimer = setTimeout(function () {
                _this.connect();
                _this.reconnectTimer = undefined;
            }, (this.reconnectionAttempts === 1) ? 0 : this.configuration.reconnectionTimeout * 1000);
        }
    };
    /**
     * Resets the error state of all servers in the configuration
     */
    Transport.prototype.resetServerErrorStatus = function () {
        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
            var websocket = _a[_i];
            websocket.isError = false;
        }
    };
    /**
     * Retrieve the next server to which connect.
     * @param {Boolean} force allows bypass of server error status checking
     * @returns {Object} WsServer
     */
    Transport.prototype.getNextWsServer = function (force) {
        if (force === void 0) { force = false; }
        if (this.noAvailableServers()) {
            this.logger.warn("attempted to get next ws server but there are no available ws servers left");
            throw new Error("Attempted to get next ws server, but there are no available ws servers left.");
        }
        // Order servers by weight
        var candidates = [];
        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
            var wsServer = _a[_i];
            if (wsServer.isError && !force) {
                continue;
            }
            else if (candidates.length === 0) {
                candidates.push(wsServer);
            }
            else if (wsServer.weight > candidates[0].weight) {
                candidates = [wsServer];
            }
            else if (wsServer.weight === candidates[0].weight) {
                candidates.push(wsServer);
            }
        }
        var idx = Math.floor(Math.random() * candidates.length);
        return candidates[idx];
    };
    /**
     * Checks all configuration servers, returns true if all of them have isError: true and false otherwise
     * @returns {Boolean}
     */
    Transport.prototype.noAvailableServers = function () {
        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
            var server = _a[_i];
            if (!server.isError) {
                return false;
            }
        }
        return true;
    };
    // ==============================
    // KeepAlive Stuff
    // ==============================
    /**
     * Send a keep-alive (a double-CRLF sequence).
     * @returns {Boolean}
     */
    Transport.prototype.sendKeepAlive = function () {
        var _this = this;
        if (this.keepAliveDebounceTimeout) {
            // We already have an outstanding keep alive, do not send another.
            return;
        }
        this.keepAliveDebounceTimeout = setTimeout(function () {
            _this.emit("keepAliveDebounceTimeout");
            _this.clearKeepAliveTimeout();
        }, this.configuration.keepAliveDebounce * 1000);
        return this.send("\r\n\r\n");
    };
    Transport.prototype.clearKeepAliveTimeout = function () {
        if (this.keepAliveDebounceTimeout) {
            clearTimeout(this.keepAliveDebounceTimeout);
        }
        this.keepAliveDebounceTimeout = undefined;
    };
    /**
     * Start sending keep-alives.
     */
    Transport.prototype.startSendingKeepAlives = function () {
        var _this = this;
        if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
            this.keepAliveInterval = setInterval(function () {
                _this.sendKeepAlive();
                _this.startSendingKeepAlives();
            }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
        }
    };
    /**
     * Stop sending keep-alives.
     */
    Transport.prototype.stopSendingKeepAlives = function () {
        if (this.keepAliveInterval) {
            clearInterval(this.keepAliveInterval);
        }
        if (this.keepAliveDebounceTimeout) {
            clearTimeout(this.keepAliveDebounceTimeout);
        }
        this.keepAliveInterval = undefined;
        this.keepAliveDebounceTimeout = undefined;
    };
    // ==============================
    // Status Stuff
    // ==============================
    /**
     * Checks given status against instance current status. Returns true if they match
     * @param {Number} status
     * @param {Boolean} [force]
     * @returns {Boolean}
     */
    Transport.prototype.statusAssert = function (status, force) {
        if (status === this.status) {
            return true;
        }
        else {
            if (force) {
                this.logger.warn("Attempted to assert " +
                    Object.keys(TransportStatus)[this.status] + " as " +
                    Object.keys(TransportStatus)[status] + "- continuing with option: 'force'");
                return true;
            }
            else {
                this.logger.warn("Tried to assert " +
                    Object.keys(TransportStatus)[status] + " but is currently " +
                    Object.keys(TransportStatus)[this.status]);
                return false;
            }
        }
    };
    /**
     * Transitions the status. Checks for legal transition via assertion beforehand
     * @param {Number} status
     * @param {Boolean} [force]
     * @returns {Boolean}
     */
    Transport.prototype.statusTransition = function (status, force) {
        if (force === void 0) { force = false; }
        this.logger.log("Attempting to transition status from " +
            Object.keys(TransportStatus)[this.status] + " to " +
            Object.keys(TransportStatus)[status]);
        if ((status === TransportStatus.STATUS_CONNECTING && this.statusAssert(TransportStatus.STATUS_CLOSED, force)) ||
            (status === TransportStatus.STATUS_OPEN && this.statusAssert(TransportStatus.STATUS_CONNECTING, force)) ||
            (status === TransportStatus.STATUS_CLOSING && this.statusAssert(TransportStatus.STATUS_OPEN, force)) ||
            (status === TransportStatus.STATUS_CLOSED)) {
            this.status = status;
            return true;
        }
        else {
            this.logger.warn("Status transition failed - result: no-op - reason:" +
                " either gave an nonexistent status or attempted illegal transition");
            return false;
        }
    };
    // ==============================
    // Configuration Handling
    // ==============================
    /**
     * Configuration load.
     * returns {Configuration}
     */
    Transport.prototype.loadConfig = function (configuration) {
        var settings = {
            wsServers: [{
                    scheme: "WSS",
                    sipUri: "<sip:edge.sip.onsip.com;transport=ws;lr>",
                    weight: 0,
                    wsUri: "wss://edge.sip.onsip.com",
                    isError: false
                }],
            connectionTimeout: 5,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
            keepAliveInterval: 0,
            keepAliveDebounce: 10,
            // Logging
            traceSip: false
        };
        var configCheck = this.getConfigurationCheck();
        // Check Mandatory parameters
        for (var parameter in configCheck.mandatory) {
            if (!configuration.hasOwnProperty(parameter)) {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
            }
            else {
                var value = configuration[parameter];
                var checkedValue = configCheck.mandatory[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        // Check Optional parameters
        for (var parameter in configCheck.optional) {
            if (configuration.hasOwnProperty(parameter)) {
                var value = configuration[parameter];
                // If the parameter value is an empty array, but shouldn't be, apply its default value.
                // If the parameter value is null, empty string, or undefined then apply its default value.
                // If it's a number with NaN value then also apply its default value.
                // NOTE: JS does not allow "value === NaN", the following does the work:
                if ((value instanceof Array && value.length === 0) ||
                    (value === null || value === "" || value === undefined) ||
                    (typeof (value) === "number" && isNaN(value))) {
                    continue;
                }
                var checkedValue = configCheck.optional[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        var skeleton = {}; // Fill the value of the configuration_skeleton
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                skeleton[parameter] = {
                    value: settings[parameter],
                };
            }
        }
        var returnConfiguration = Object.defineProperties({}, skeleton);
        this.logger.log("configuration parameters after validation:");
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
            }
        }
        return returnConfiguration;
    };
    /**
     * Configuration checker.
     * @return {Boolean}
     */
    Transport.prototype.getConfigurationCheck = function () {
        return {
            mandatory: {},
            optional: {
                // Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
                wsServers: function (wsServers) {
                    /* Allow defining wsServers parameter as:
                     *  String: "host"
                     *  Array of Strings: ["host1", "host2"]
                     *  Array of Objects: [{wsUri:"host1", weight:1}, {wsUri:"host2", weight:0}]
                     *  Array of Objects and Strings: [{wsUri:"host1"}, "host2"]
                     */
                    if (typeof wsServers === "string") {
                        wsServers = [{ wsUri: wsServers }];
                    }
                    else if (wsServers instanceof Array) {
                        for (var idx = 0; idx < wsServers.length; idx++) {
                            if (typeof wsServers[idx] === "string") {
                                wsServers[idx] = { wsUri: wsServers[idx] };
                            }
                        }
                    }
                    else {
                        return;
                    }
                    if (wsServers.length === 0) {
                        return false;
                    }
                    for (var _i = 0, wsServers_1 = wsServers; _i < wsServers_1.length; _i++) {
                        var wsServer = wsServers_1[_i];
                        if (!wsServer.wsUri) {
                            return;
                        }
                        if (wsServer.weight && !Number(wsServer.weight)) {
                            return;
                        }
                        var url = core_1.Grammar.parse(wsServer.wsUri, "absoluteURI");
                        if (url === -1) {
                            return;
                        }
                        else if (["wss", "ws", "udp"].indexOf(url.scheme) < 0) {
                            return;
                        }
                        else {
                            wsServer.sipUri = "<sip:" + url.host +
                                (url.port ? ":" + url.port : "") + ";transport=" + url.scheme.replace(/^wss$/i, "ws") + ";lr>";
                            if (!wsServer.weight) {
                                wsServer.weight = 0;
                            }
                            wsServer.isError = false;
                            wsServer.scheme = url.scheme.toUpperCase();
                        }
                    }
                    return wsServers;
                },
                keepAliveInterval: function (keepAliveInterval) {
                    if (Utils_1.Utils.isDecimal(keepAliveInterval)) {
                        var value = Number(keepAliveInterval);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                keepAliveDebounce: function (keepAliveDebounce) {
                    if (Utils_1.Utils.isDecimal(keepAliveDebounce)) {
                        var value = Number(keepAliveDebounce);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                traceSip: function (traceSip) {
                    if (typeof traceSip === "boolean") {
                        return traceSip;
                    }
                },
                connectionTimeout: function (connectionTimeout) {
                    if (Utils_1.Utils.isDecimal(connectionTimeout)) {
                        var value = Number(connectionTimeout);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                maxReconnectionAttempts: function (maxReconnectionAttempts) {
                    if (Utils_1.Utils.isDecimal(maxReconnectionAttempts)) {
                        var value = Number(maxReconnectionAttempts);
                        if (value >= 0) {
                            return value;
                        }
                    }
                },
                reconnectionTimeout: function (reconnectionTimeout) {
                    if (Utils_1.Utils.isDecimal(reconnectionTimeout)) {
                        var value = Number(reconnectionTimeout);
                        if (value > 0) {
                            return value;
                        }
                    }
                }
            }
        };
    };
    Transport.C = TransportStatus;
    return Transport;
}(Transport_1.Transport));
exports.Transport = Transport;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sip.js/lib/Web/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./Modifiers */ "./node_modules/sip.js/lib/Web/Modifiers.js"));
exports.Modifiers = Modifiers;
var Simple_1 = __webpack_require__(/*! ./Simple */ "./node_modules/sip.js/lib/Web/Simple.js");
exports.Simple = Simple_1.Simple;
var SessionDescriptionHandler_1 = __webpack_require__(/*! ./SessionDescriptionHandler */ "./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js");
exports.SessionDescriptionHandler = SessionDescriptionHandler_1.SessionDescriptionHandler;
var Transport_1 = __webpack_require__(/*! ./Transport */ "./node_modules/sip.js/lib/Web/Transport.js");
exports.Transport = Transport_1.Transport;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/bye.js":
/*!********************************************!*\
  !*** ./node_modules/sip.js/lib/api/bye.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A request to end a {@link Session} (incoming BYE).
 * @public
 */
var Bye = /** @class */ (function () {
    /** @internal */
    function Bye(incomingByeRequest) {
        this.incomingByeRequest = incomingByeRequest;
    }
    Object.defineProperty(Bye.prototype, "request", {
        /** Incoming BYE request message. */
        get: function () {
            return this.incomingByeRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Bye.prototype.accept = function (options) {
        this.incomingByeRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Bye.prototype.reject = function (options) {
        this.incomingByeRequest.reject(options);
        return Promise.resolve();
    };
    return Bye;
}());
exports.Bye = Bye;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/emitter.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/api/emitter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Creates an {@link Emitter}.
 * @param eventEmitter - An event emitter.
 * @param eventName - Event name.
 * @internal
 */
function _makeEmitter(eventEmitter, eventName) {
    if (eventName === void 0) { eventName = "event"; }
    return {
        addListener: function (listener, options) {
            if (options === void 0) { options = {}; }
            if (options.once) {
                eventEmitter.once(eventName, listener);
            }
            else {
                eventEmitter.addListener(eventName, listener);
            }
        },
        removeListener: function (listener) {
            eventEmitter.removeListener(eventName, listener);
        },
        on: function (listener) {
            eventEmitter.on(eventName, listener);
        },
        off: function (listener) {
            eventEmitter.removeListener(eventName, listener);
        },
        once: function (listener) {
            eventEmitter.once(eventName, listener);
        }
    };
}
exports._makeEmitter = _makeEmitter;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating an unsupported content type prevented execution.
 * @public
 */
var ContentTypeUnsupportedError = /** @class */ (function (_super) {
    tslib_1.__extends(ContentTypeUnsupportedError, _super);
    function ContentTypeUnsupportedError(message) {
        return _super.call(this, message ? message : "Unsupported content type.") || this;
    }
    return ContentTypeUnsupportedError;
}(core_1.Exception));
exports.ContentTypeUnsupportedError = ContentTypeUnsupportedError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./content-type-unsupported */ "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./request-pending */ "./node_modules/sip.js/lib/api/exceptions/request-pending.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session-description-handler */ "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session-terminated */ "./node_modules/sip.js/lib/api/exceptions/session-terminated.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./state-transition */ "./node_modules/sip.js/lib/api/exceptions/state-transition.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/request-pending.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/request-pending.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating an outstanding prior request prevented execution.
 * @public
 */
var RequestPendingError = /** @class */ (function (_super) {
    tslib_1.__extends(RequestPendingError, _super);
    /** @internal */
    function RequestPendingError(message) {
        return _super.call(this, message ? message : "Request pending.") || this;
    }
    return RequestPendingError;
}(core_1.Exception));
exports.RequestPendingError = RequestPendingError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/session-description-handler.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating a session description handler error occured.
 * @public
 */
var SessionDescriptionHandlerError = /** @class */ (function (_super) {
    tslib_1.__extends(SessionDescriptionHandlerError, _super);
    function SessionDescriptionHandlerError(message) {
        return _super.call(this, message ? message : "Unspecified session description handler error.") || this;
    }
    return SessionDescriptionHandlerError;
}(core_1.Exception));
exports.SessionDescriptionHandlerError = SessionDescriptionHandlerError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/session-terminated.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/session-terminated.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating the session terminated before the action completed.
 * @public
 */
var SessionTerminatedError = /** @class */ (function (_super) {
    tslib_1.__extends(SessionTerminatedError, _super);
    function SessionTerminatedError() {
        return _super.call(this, "The session has terminated.") || this;
    }
    return SessionTerminatedError;
}(core_1.Exception));
exports.SessionTerminatedError = SessionTerminatedError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/state-transition.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/state-transition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating an invalid state transition error occured.
 * @public
 */
var StateTransitionError = /** @class */ (function (_super) {
    tslib_1.__extends(StateTransitionError, _super);
    function StateTransitionError(message) {
        return _super.call(this, message ? message : "An error occurred during state transition.") || this;
    }
    return StateTransitionError;
}(core_1.Exception));
exports.StateTransitionError = StateTransitionError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/info.js":
/*!*********************************************!*\
  !*** ./node_modules/sip.js/lib/api/info.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An exchange of information (incoming INFO).
 * @public
 */
var Info = /** @class */ (function () {
    /** @internal */
    function Info(incomingInfoRequest) {
        this.incomingInfoRequest = incomingInfoRequest;
    }
    Object.defineProperty(Info.prototype, "request", {
        /** Incoming MESSAGE request message. */
        get: function () {
            return this.incomingInfoRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Info.prototype.accept = function (options) {
        this.incomingInfoRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Info.prototype.reject = function (options) {
        this.incomingInfoRequest.reject(options);
        return Promise.resolve();
    };
    return Info;
}());
exports.Info = Info;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/message.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/api/message.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A received message (incoming MESSAGE).
 * @public
 */
var Message = /** @class */ (function () {
    /** @internal */
    function Message(incomingMessageRequest) {
        this.incomingMessageRequest = incomingMessageRequest;
    }
    Object.defineProperty(Message.prototype, "request", {
        /** Incoming MESSAGE request message. */
        get: function () {
            return this.incomingMessageRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Message.prototype.accept = function (options) {
        this.incomingMessageRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Message.prototype.reject = function (options) {
        this.incomingMessageRequest.reject(options);
        return Promise.resolve();
    };
    return Message;
}());
exports.Message = Message;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/notification.js":
/*!*****************************************************!*\
  !*** ./node_modules/sip.js/lib/api/notification.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A notification of an event (incoming NOTIFY).
 * @public
 */
var Notification = /** @class */ (function () {
    /** @internal */
    function Notification(incomingNotifyRequest) {
        this.incomingNotifyRequest = incomingNotifyRequest;
    }
    Object.defineProperty(Notification.prototype, "request", {
        /** Incoming NOTIFY request message. */
        get: function () {
            return this.incomingNotifyRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Notification.prototype.accept = function (options) {
        this.incomingNotifyRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Notification.prototype.reject = function (options) {
        this.incomingNotifyRequest.reject(options);
        return Promise.resolve();
    };
    return Notification;
}());
exports.Notification = Notification;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/referral.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/api/referral.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! ../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * A request to establish a {@link Session} elsewhere (incoming REFER).
 * @public
 */
var Referral = /** @class */ (function () {
    /** @internal */
    function Referral(incomingReferRequest, session) {
        this.incomingReferRequest = incomingReferRequest;
        this.session = session;
    }
    Object.defineProperty(Referral.prototype, "referTo", {
        get: function () {
            var referTo = this.incomingReferRequest.message.parseHeader("refer-to");
            if (!(referTo instanceof core_1.NameAddrHeader)) {
                throw new Error("Failed to parse Refer-To header.");
            }
            return referTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Referral.prototype, "referredBy", {
        get: function () {
            return this.incomingReferRequest.message.getHeader("referred-by");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Referral.prototype, "replaces", {
        get: function () {
            return this.referTo.uri.getHeader("replaces");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Referral.prototype, "request", {
        /** Incoming REFER request message. */
        get: function () {
            return this.incomingReferRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Referral.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 202 }; }
        this.incomingReferRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Referral.prototype.reject = function (options) {
        this.incomingReferRequest.reject(options);
        return Promise.resolve();
    };
    /**
     * Creates an inviter which may be used to send an out of dialog INVITE request.
     *
     * @remarks
     * This a helper method to create an Inviter which will execute the referral
     * of the `Session` which was referred. The appropriate headers are set and
     * the referred `Session` is linked to the new `Session`. Note that only a
     * single instance of the `Inviter` will be created and returned (if called
     * more than once a reference to the same `Inviter` will be returned every time).
     *
     * @param options - Options bucket.
     * @param modifiers - Session description handler modifiers.
     */
    Referral.prototype.makeInviter = function (options) {
        if (this.inviter) {
            return this.inviter;
        }
        var targetURI = this.referTo.uri.clone();
        targetURI.clearHeaders();
        options = options || {};
        var extraHeaders = (options.extraHeaders || []).slice();
        var replaces = this.replaces;
        if (replaces) {
            // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
            extraHeaders.push("Replaces: " + decodeURIComponent(replaces));
        }
        var referredBy = this.referredBy;
        if (referredBy) {
            extraHeaders.push("Referred-By: " + referredBy);
        }
        options.extraHeaders = extraHeaders;
        this.inviter = this.session.userAgent._makeInviter(targetURI, options);
        this.inviter._referred = this.session;
        this.session._referral = this.inviter;
        return this.inviter;
    };
    return Referral;
}());
exports.Referral = Referral;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/session-state.js":
/*!******************************************************!*\
  !*** ./node_modules/sip.js/lib/api/session-state.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * {@link Session} state.
 *
 * @remarks
 * The {@link Session} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                   ___________________________________________________________
 *                  |  ____________________________________________             |
 *                  | |            ____________________________    |            |
 * Session          | |           |                            v   v            v
 * Constructed -> Initial -> Establishing -> Established -> Terminating -> Terminated
 *                                |               |___________________________^   ^
 *                                |_______________________________________________|
 * ```
 * @public
 */
var SessionState;
(function (SessionState) {
    /**
     * If `Inviter`, INVITE not sent yet.
     * If `Invitation`, received INVITE (but no final response sent yet).
     */
    SessionState["Initial"] = "Initial";
    /**
     * If `Inviter`, sent INVITE and waiting for a final response.
     * If `Invitation`, received INVITE and attempting to send 200 final response (but has not sent it yet).
     */
    SessionState["Establishing"] = "Establishing";
    /**
     * If `Inviter`, sent INVITE and received 200 final response and sent ACK.
     * If `Invitation`, received INVITE and sent 200 final response.
     */
    SessionState["Established"] = "Established";
    /**
     * If `Inviter`, sent INVITE, sent CANCEL and now waiting for 487 final response to ACK (or 200 to ACK & BYE).
     * If `Invitation`, received INVITE, sent 200 final response and now waiting on ACK and upon receipt will attempt BYE
     * (as the protocol specification requires, before sending a BYE we must receive the ACK - so we are waiting).
     */
    SessionState["Terminating"] = "Terminating";
    /**
     * If `Inviter`, sent INVITE and received non-200 final response (or sent/received BYE after receiving 200).
     * If `Invitation`, received INVITE and sent non-200 final response (or sent/received BYE after sending 200).
     */
    SessionState["Terminated"] = "Terminated";
})(SessionState = exports.SessionState || (exports.SessionState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/api/session.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/api/session.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var core_1 = __webpack_require__(/*! ../core */ "./node_modules/sip.js/lib/core/index.js");
var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
var allowed_methods_1 = __webpack_require__(/*! ../core/user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var bye_1 = __webpack_require__(/*! ./bye */ "./node_modules/sip.js/lib/api/bye.js");
var emitter_1 = __webpack_require__(/*! ./emitter */ "./node_modules/sip.js/lib/api/emitter.js");
var exceptions_1 = __webpack_require__(/*! ./exceptions */ "./node_modules/sip.js/lib/api/exceptions/index.js");
var info_1 = __webpack_require__(/*! ./info */ "./node_modules/sip.js/lib/api/info.js");
var message_1 = __webpack_require__(/*! ./message */ "./node_modules/sip.js/lib/api/message.js");
var notification_1 = __webpack_require__(/*! ./notification */ "./node_modules/sip.js/lib/api/notification.js");
var referral_1 = __webpack_require__(/*! ./referral */ "./node_modules/sip.js/lib/api/referral.js");
var session_state_1 = __webpack_require__(/*! ./session-state */ "./node_modules/sip.js/lib/api/session-state.js");
/**
 * A session provides real time communication between one or more participants.
 *
 * @remarks
 * The transport behaves in a deterministic manner according to the
 * the state defined in {@link SessionState}.
 * @public
 */
var Session = /** @class */ (function () {
    /**
     * Constructor.
     * @param userAgent - User agent. See {@link UserAgent} for details.
     * @internal
     */
    function Session(userAgent, options) {
        if (options === void 0) { options = {}; }
        /** True if there is a re-INVITE request outstanding. */
        this.pendingReinvite = false;
        /** Session state. */
        this._state = session_state_1.SessionState.Initial;
        /** Session state emitter. */
        this._stateEventEmitter = new events_1.EventEmitter();
        this.delegate = options.delegate;
        this._userAgent = userAgent;
    }
    /**
     * Destructor.
     */
    Session.prototype.dispose = function () {
        var _this = this;
        this.logger.log("Session " + this.id + " in state " + this._state + " is being disposed");
        // Remove from the user agent's session collection
        delete this.userAgent._sessions[this.id];
        // Dispose of dialog media
        if (this._sessionDescriptionHandler) {
            this._sessionDescriptionHandler.close();
            // TODO: The SDH needs to remain defined as it will be called after it is closed in cases
            // where an answer/offer arrives while the session is being torn down. There are a variety
            // of circumstances where this can happen - sending a BYE during a re-INVITE for example.
            // The code is currently written such that it lazily makes a new SDH when it needs one
            // and one is not yet defined. Thus if we undefined it here, it will currently make a
            // new one which is out of sync and then never gets cleaned up.
            //
            // The downside of leaving it defined are that calls this closed SDH will continue to be
            // made (think setDescription) and those should/will fail. These failures are handled, but
            // it would be nice to have it all coded up in a way where having an undefined SDH where
            // one is expected throws an error.
            //
            // this._sessionDescriptionHandler = undefined;
        }
        switch (this.state) {
            case session_state_1.SessionState.Initial:
                break; // the Inviter/Invitation sub class dispose method handles this case
            case session_state_1.SessionState.Establishing:
                break; // the Inviter/Invitation sub class dispose method handles this case
            case session_state_1.SessionState.Established:
                return new Promise(function (resolve, reject) {
                    _this._bye({
                        onAccept: function () { return resolve(); },
                        onRedirect: function () { return resolve(); },
                        onReject: function () { return resolve(); }
                    });
                });
            case session_state_1.SessionState.Terminating:
                break; // nothing to be done
            case session_state_1.SessionState.Terminated:
                break; // nothing to be done
            default:
                throw new Error("Unknown state.");
        }
        return Promise.resolve();
    };
    Object.defineProperty(Session.prototype, "assertedIdentity", {
        /**
         * The asserted identity of the remote user.
         */
        get: function () {
            return this._assertedIdentity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "dialog", {
        /**
         * The confirmed session dialog.
         */
        get: function () {
            return this._dialog;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "id", {
        /**
         * A unique identifier for this session.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "replacee", {
        /**
         * The session being replace by this one.
         */
        get: function () {
            return this._replacee;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sessionDescriptionHandler", {
        /**
         * Session description handler.
         * @remarks
         * If `this` is an instance of `Invitation`,
         * `sessionDescriptionHandler` will be defined when the session state changes to "established".
         * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,
         * `sessionDescriptionHandler` will be defined when the session state changes to "establishing".
         * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,
         * `sessionDescriptionHandler` will be defined when the session state changes to "established".
         * Otherwise `undefined`.
         */
        get: function () {
            return this._sessionDescriptionHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sessionDescriptionHandlerFactory", {
        /**
         * Session description handler factory.
         */
        get: function () {
            return this.userAgent.configuration.sessionDescriptionHandlerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "state", {
        /**
         * Session state.
         */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "stateChange", {
        /**
         * Session state change emitter.
         */
        get: function () {
            return emitter_1._makeEmitter(this._stateEventEmitter);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "userAgent", {
        /**
         * The user agent.
         */
        get: function () {
            return this._userAgent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * End the {@link Session}. Sends a BYE.
     * @param options - Options bucket. See {@link SessionByeOptions} for details.
     */
    Session.prototype.bye = function (options) {
        if (options === void 0) { options = {}; }
        var message = "Session.bye() may only be called if established session.";
        switch (this.state) {
            case session_state_1.SessionState.Initial:
                if (typeof this.cancel === "function") {
                    message += " However Inviter.invite() has not yet been called.";
                    message += " Perhaps you should have called Inviter.cancel()?";
                }
                else if (typeof this.reject === "function") {
                    message += " However Invitation.accept() has not yet been called.";
                    message += " Perhaps you should have called Invitation.reject()?";
                }
                break;
            case session_state_1.SessionState.Establishing:
                if (typeof this.cancel === "function") {
                    message += " However a dialog does not yet exist.";
                    message += " Perhaps you should have called Inviter.cancel()?";
                }
                else if (typeof this.reject === "function") {
                    message += " However Invitation.accept() has not yet been called (or not yet resolved).";
                    message += " Perhaps you should have called Invitation.reject()?";
                }
                break;
            case session_state_1.SessionState.Established:
                var requestDelegate = options.requestDelegate;
                var requestOptions = this.copyRequestOptions(options.requestOptions);
                return this._bye(requestDelegate, requestOptions);
            case session_state_1.SessionState.Terminating:
                message += " However this session is already terminating.";
                if (typeof this.cancel === "function") {
                    message += " Perhaps you have already called Inviter.cancel()?";
                }
                else if (typeof this.reject === "function") {
                    message += " Perhaps you have already called Session.bye()?";
                }
                break;
            case session_state_1.SessionState.Terminated:
                message += " However this session is already terminated.";
                break;
            default:
                throw new Error("Unknown state");
        }
        this.logger.error(message);
        return Promise.reject(new Error("Invalid session state " + this.state));
    };
    /**
     * Share {@link Info} with peer. Sends an INFO.
     * @param options - Options bucket. See {@link SessionInfoOptions} for details.
     */
    Session.prototype.info = function (options) {
        if (options === void 0) { options = {}; }
        // guard session state
        if (this.state !== session_state_1.SessionState.Established) {
            var message = "Session.info() may only be called if established session.";
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        var requestDelegate = options.requestDelegate;
        var requestOptions = this.copyRequestOptions(options.requestOptions);
        return this._info(requestDelegate, requestOptions);
    };
    /**
     * Renegotiate the session. Sends a re-INVITE.
     * @param options - Options bucket. See {@link SessionInviteOptions} for details.
     */
    Session.prototype.invite = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.logger.log("Session.invite");
        if (this.state !== session_state_1.SessionState.Established) {
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        if (this.pendingReinvite) {
            return Promise.reject(new exceptions_1.RequestPendingError("Reinvite in progress. Please wait until complete, then try again."));
        }
        this.pendingReinvite = true;
        var delegate = {
            onAccept: function (response) {
                // A re-INVITE transaction has an offer/answer [RFC3264] exchange
                // associated with it.  The UAC (User Agent Client) generating a given
                // re-INVITE can act as the offerer or as the answerer.  A UAC willing
                // to act as the offerer includes an offer in the re-INVITE.  The UAS
                // (User Agent Server) then provides an answer in a response to the
                // re-INVITE.  A UAC willing to act as answerer does not include an
                // offer in the re-INVITE.  The UAS then provides an offer in a response
                // to the re-INVITE becoming, thus, the offerer.
                // https://tools.ietf.org/html/rfc6141#section-1
                var body = core_1.getBody(response.message);
                if (!body) {
                    // No way to recover, so terminate session and mark as failed.
                    _this.logger.error("Received 2xx response to re-INVITE without a session description");
                    _this.ackAndBye(response, 400, "Missing session description");
                    _this.stateTransition(session_state_1.SessionState.Terminated);
                    _this.pendingReinvite = false;
                    return;
                }
                if (options.withoutSdp) {
                    // INVITE without SDP - set remote offer and send an answer in the ACK
                    // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
                    //        This behavior was ported from legacy code and the issue punted down the road.
                    var answerOptions = {
                        sessionDescriptionHandlerOptions: options.sessionDescriptionHandlerOptions,
                        sessionDescriptionHandlerModifiers: options.sessionDescriptionHandlerModifiers
                    };
                    _this.setOfferAndGetAnswer(body, answerOptions)
                        .then(function (answerBody) {
                        response.ack({ body: answerBody });
                    })
                        .catch(function (error) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Failed to handle offer in 2xx response to re-INVITE");
                        _this.logger.error(error.message);
                        if (_this.state === session_state_1.SessionState.Terminated) {
                            // A BYE should not be sent if already terminated.
                            // For example, a BYE may be sent/received while re-INVITE is outstanding.
                            response.ack();
                        }
                        else {
                            _this.ackAndBye(response, 488, "Bad Media Description");
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                        }
                    })
                        .then(function () {
                        _this.pendingReinvite = false;
                        if (options.requestDelegate && options.requestDelegate.onAccept) {
                            options.requestDelegate.onAccept(response);
                        }
                    });
                }
                else {
                    // INVITE with SDP - set remote answer and send an ACK
                    // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
                    //        This behavior was ported from legacy code and the issue punted down the road.
                    var answerOptions = {
                        sessionDescriptionHandlerOptions: _this._sessionDescriptionHandlerOptions,
                        sessionDescriptionHandlerModifiers: _this._sessionDescriptionHandlerModifiers
                    };
                    _this.setAnswer(body, answerOptions)
                        .then(function () {
                        response.ack();
                    })
                        .catch(function (error) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Failed to handle answer in 2xx response to re-INVITE");
                        _this.logger.error(error.message);
                        // A BYE should only be sent if session is not already terminated.
                        // For example, a BYE may be sent/received while re-INVITE is outstanding.
                        // The ACK needs to be sent regardless as it was not handled by the transaction.
                        if (_this.state !== session_state_1.SessionState.Terminated) {
                            _this.ackAndBye(response, 488, "Bad Media Description");
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                        }
                        else {
                            response.ack();
                        }
                    })
                        .then(function () {
                        _this.pendingReinvite = false;
                        if (options.requestDelegate && options.requestDelegate.onAccept) {
                            options.requestDelegate.onAccept(response);
                        }
                    });
                }
            },
            onProgress: function (response) {
                return;
            },
            onRedirect: function (response) {
                return;
            },
            onReject: function (response) {
                _this.logger.warn("Received a non-2xx response to re-INVITE");
                _this.pendingReinvite = false;
                if (options.withoutSdp) {
                    if (options.requestDelegate && options.requestDelegate.onReject) {
                        options.requestDelegate.onReject(response);
                    }
                }
                else {
                    _this.rollbackOffer()
                        .catch(function (error) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Failed to rollback offer on non-2xx response to re-INVITE");
                        _this.logger.error(error.message);
                        // A BYE should only be sent if session is not already terminated.
                        // For example, a BYE may be sent/received while re-INVITE is outstanding.
                        // Note that the ACK was already sent by the transaction, so just need to send BYE.
                        if (_this.state !== session_state_1.SessionState.Terminated) {
                            if (!_this.dialog) {
                                throw new Error("Dialog undefined.");
                            }
                            var extraHeaders = [];
                            extraHeaders.push("Reason: " + _this.getReasonHeaderValue(500, "Internal Server Error"));
                            _this.dialog.bye(undefined, { extraHeaders: extraHeaders });
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                        }
                    })
                        .then(function () {
                        if (options.requestDelegate && options.requestDelegate.onReject) {
                            options.requestDelegate.onReject(response);
                        }
                    });
                }
            },
            onTrying: function (response) {
                return;
            }
        };
        var requestOptions = options.requestOptions || {};
        requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();
        requestOptions.extraHeaders.push("Allow: " + allowed_methods_1.AllowedMethods.toString());
        requestOptions.extraHeaders.push("Contact: " + this._contact);
        // Just send an INVITE with no sdp...
        if (options.withoutSdp) {
            if (!this.dialog) {
                this.pendingReinvite = false;
                throw new Error("Dialog undefined.");
            }
            return Promise.resolve(this.dialog.invite(delegate, requestOptions));
        }
        // Get an offer and send it in an INVITE
        // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
        //        This behavior was ported from legacy code and the issue punted down the road.
        var offerOptions = {
            sessionDescriptionHandlerOptions: options.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: options.sessionDescriptionHandlerModifiers
        };
        return this.getOffer(offerOptions)
            .then(function (offerBody) {
            if (!_this.dialog) {
                _this.pendingReinvite = false;
                throw new Error("Dialog undefined.");
            }
            requestOptions.body = offerBody;
            return _this.dialog.invite(delegate, requestOptions);
        })
            .catch(function (error) {
            _this.logger.error(error.message);
            _this.logger.error("Failed to send re-INVITE");
            _this.pendingReinvite = false;
            throw error;
        });
    };
    /**
     * Deliver a {@link Message}. Sends a MESSAGE.
     * @param options - Options bucket. See {@link SessionMessageOptions} for details.
     */
    Session.prototype.message = function (options) {
        if (options === void 0) { options = {}; }
        // guard session state
        if (this.state !== session_state_1.SessionState.Established) {
            var message = "Session.message() may only be called if established session.";
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        var requestDelegate = options.requestDelegate;
        var requestOptions = this.copyRequestOptions(options.requestOptions);
        return this._message(requestDelegate, requestOptions);
    };
    /**
     * Proffer a {@link Referral}. Send a REFER.
     * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.
     * @param options - Options bucket. See {@link SessionReferOptions} for details.
     */
    Session.prototype.refer = function (referTo, options) {
        if (options === void 0) { options = {}; }
        // guard session state
        if (this.state !== session_state_1.SessionState.Established) {
            var message = "Session.refer() may only be called if established session.";
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        var requestDelegate = options.requestDelegate;
        var requestOptions = this.copyRequestOptions(options.requestOptions);
        requestOptions.extraHeaders = requestOptions.extraHeaders ?
            requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) :
            this.referExtraHeaders(this.referToString(referTo));
        return this._refer(options.onNotify, requestDelegate, requestOptions);
    };
    /**
     * Send BYE.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._bye = function (delegate, options) {
        var _this = this;
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        var dialog = this.dialog;
        // The caller's UA MAY send a BYE for either confirmed or early dialogs,
        // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT
        // send a BYE on early dialogs. However, the callee's UA MUST NOT send a
        // BYE on a confirmed dialog until it has received an ACK for its 2xx
        // response or until the server transaction times out.
        // https://tools.ietf.org/html/rfc3261#section-15
        switch (dialog.sessionState) {
            case core_1.SessionState.Initial:
                throw new Error("Invalid dialog state " + dialog.sessionState);
            case core_1.SessionState.Early: // Implementation choice - not sending BYE for early dialogs.
                throw new Error("Invalid dialog state " + dialog.sessionState);
            case core_1.SessionState.AckWait: { // This state only occurs if we are the callee.
                this.stateTransition(session_state_1.SessionState.Terminating); // We're terminating
                return new Promise(function (resolve, reject) {
                    dialog.delegate = {
                        // When ACK shows up, say BYE.
                        onAck: function () {
                            var request = dialog.bye(delegate, options);
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                            resolve(request);
                        },
                        // Or the server transaction times out before the ACK arrives.
                        onAckTimeout: function () {
                            var request = dialog.bye(delegate, options);
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                            resolve(request);
                        }
                    };
                });
            }
            case core_1.SessionState.Confirmed: {
                var request = dialog.bye(delegate, options);
                this.stateTransition(session_state_1.SessionState.Terminated);
                return Promise.resolve(request);
            }
            case core_1.SessionState.Terminated:
                throw new Error("Invalid dialog state " + dialog.sessionState);
            default:
                throw new Error("Unrecognized state.");
        }
    };
    /**
     * Send INFO.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._info = function (delegate, options) {
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        return Promise.resolve(this.dialog.info(delegate, options));
    };
    /**
     * Send MESSAGE.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._message = function (delegate, options) {
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        return Promise.resolve(this.dialog.message(delegate, options));
    };
    /**
     * Send REFER.
     * @param onNotify - Notification callback.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._refer = function (onNotify, delegate, options) {
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        // If set, deliver any in-dialog NOTIFY requests here...
        this.onNotify = onNotify;
        return Promise.resolve(this.dialog.refer(delegate, options));
    };
    /**
     * Send ACK and then BYE. There are unrecoverable errors which can occur
     * while handling dialog forming and in-dialog INVITE responses and when
     * they occur we ACK the response and send a BYE.
     * Note that the BYE is sent in the dialog associated with the response
     * which is not necessarily `this.dialog`. And, accordingly, the
     * session state is not transitioned to terminated and session is not closed.
     * @param inviteResponse - The response causing the error.
     * @param statusCode - Status code for he reason phrase.
     * @param reasonPhrase - Reason phrase for the BYE.
     * @internal
     */
    Session.prototype.ackAndBye = function (response, statusCode, reasonPhrase) {
        response.ack();
        var extraHeaders = [];
        if (statusCode) {
            extraHeaders.push("Reason: " + this.getReasonHeaderValue(statusCode, reasonPhrase));
        }
        // Using the dialog session associate with the response (which might not be this.dialog)
        response.session.bye(undefined, { extraHeaders: extraHeaders });
    };
    /**
     * Handle in dialog ACK request.
     * @internal
     */
    Session.prototype.onAckRequest = function (request) {
        var _this = this;
        this.logger.log("Session.onAckRequest");
        if (this.state !== session_state_1.SessionState.Established && this.state !== session_state_1.SessionState.Terminating) {
            this.logger.error("ACK received while in state " + this.state + ", dropping request");
            return;
        }
        var dialog = this.dialog;
        if (!dialog) {
            throw new Error("Dialog undefined.");
        }
        switch (dialog.signalingState) {
            case core_1.SignalingState.Initial: {
                // State should never be reached as first reliable response must have answer/offer.
                // So we must have never has sent an offer.
                this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                dialog.bye(undefined, { extraHeaders: extraHeaders });
                this.stateTransition(session_state_1.SessionState.Terminated);
                return;
            }
            case core_1.SignalingState.Stable: {
                // State we should be in.
                // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.
                var body = core_1.getBody(request.message);
                // If the ACK doesn't have an answer, nothing to be done.
                if (!body) {
                    return;
                }
                if (body.contentDisposition === "render") {
                    this._renderbody = body.content;
                    this._rendertype = body.contentType;
                    return;
                }
                if (body.contentDisposition !== "session") {
                    return;
                }
                // Received answer in ACK.
                var options = {
                    sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
                    sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
                };
                this.setAnswer(body, options)
                    .catch(function (error) {
                    _this.logger.error(error.message);
                    var extraHeaders = ["Reason: " + _this.getReasonHeaderValue(488, "Bad Media Description")];
                    dialog.bye(undefined, { extraHeaders: extraHeaders });
                    _this.stateTransition(session_state_1.SessionState.Terminated);
                });
                return;
            }
            case core_1.SignalingState.HaveLocalOffer: {
                // State should never be reached as local offer would be answered by this ACK.
                // So we must have received an ACK without an answer.
                this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                dialog.bye(undefined, { extraHeaders: extraHeaders });
                this.stateTransition(session_state_1.SessionState.Terminated);
                return;
            }
            case core_1.SignalingState.HaveRemoteOffer: {
                // State should never be reached as remote offer would be answered in first reliable response.
                // So we must have never has sent an answer.
                this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                dialog.bye(undefined, { extraHeaders: extraHeaders });
                this.stateTransition(session_state_1.SessionState.Terminated);
                return;
            }
            case core_1.SignalingState.Closed:
                throw new Error("Invalid signaling state " + dialog.signalingState + ".");
            default:
                throw new Error("Invalid signaling state " + dialog.signalingState + ".");
        }
    };
    /**
     * Handle in dialog BYE request.
     * @internal
     */
    Session.prototype.onByeRequest = function (request) {
        this.logger.log("Session.onByeRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("BYE received while in state " + this.state + ", dropping request");
            return;
        }
        if (this.delegate && this.delegate.onBye) {
            var bye = new bye_1.Bye(request);
            this.delegate.onBye(bye);
        }
        else {
            request.accept();
        }
        this.stateTransition(session_state_1.SessionState.Terminated);
    };
    /**
     * Handle in dialog INFO request.
     * @internal
     */
    Session.prototype.onInfoRequest = function (request) {
        this.logger.log("Session.onInfoRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("INFO received while in state " + this.state + ", dropping request");
            return;
        }
        if (this.delegate && this.delegate.onInfo) {
            var info = new info_1.Info(request);
            this.delegate.onInfo(info);
        }
        else {
            // FIXME: TODO: We should reject request...
            //
            // If a UA receives an INFO request associated with an Info Package that
            // the UA has not indicated willingness to receive, the UA MUST send a
            // 469 (Bad Info Package) response (see Section 11.6), which contains a
            // Recv-Info header field with Info Packages for which the UA is willing
            // to receive INFO requests.
            // https://tools.ietf.org/html/rfc6086#section-4.2.2
            request.accept();
        }
    };
    /**
     * Handle in dialog INVITE request.
     * @internal
     */
    Session.prototype.onInviteRequest = function (request) {
        var _this = this;
        this.logger.log("Session.onInviteRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("INVITE received while in state " + this.state + ", dropping request");
            return;
        }
        // TODO: would be nice to have core track and set the Contact header,
        // but currently the session which is setting it is holding onto it.
        var extraHeaders = ["Contact: " + this._contact];
        // Handle P-Asserted-Identity
        if (request.message.hasHeader("P-Asserted-Identity")) {
            var header = request.message.getHeader("P-Asserted-Identity");
            if (!header) {
                throw new Error("Header undefined.");
            }
            this._assertedIdentity = core_1.Grammar.nameAddrHeaderParse(header);
        }
        // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
        //        This behavior was ported from legacy code and the issue punted down the road.
        var options = {
            sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
        };
        this.generateResponseOfferAnswerInDialog(options)
            .then(function (body) {
            var outgoingResponse = request.accept({ statusCode: 200, extraHeaders: extraHeaders, body: body });
            if (_this.delegate && _this.delegate.onInvite) {
                _this.delegate.onInvite(request.message, outgoingResponse.message, 200);
            }
        })
            .catch(function (error) {
            _this.logger.error(error.message);
            _this.logger.error("Failed to handle to re-INVITE request");
            if (!_this.dialog) {
                throw new Error("Dialog undefined.");
            }
            _this.logger.error(_this.dialog.signalingState);
            // If we don't have a local/remote offer...
            if (_this.dialog.signalingState === core_1.SignalingState.Stable) {
                var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                }
                return;
            }
            // Otherwise rollback
            _this.rollbackOffer()
                .then(function () {
                var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                }
            })
                .catch(function (errorRollback) {
                // No way to recover, so terminate session and mark as failed.
                _this.logger.error(errorRollback.message);
                _this.logger.error("Failed to rollback offer on re-INVITE request");
                var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                // A BYE should only be sent if session is not already terminated.
                // For example, a BYE may be sent/received while re-INVITE is outstanding.
                // Note that the ACK was already sent by the transaction, so just need to send BYE.
                if (_this.state !== session_state_1.SessionState.Terminated) {
                    if (!_this.dialog) {
                        throw new Error("Dialog undefined.");
                    }
                    var extraHeadersBye = [];
                    extraHeadersBye.push("Reason: " + _this.getReasonHeaderValue(500, "Internal Server Error"));
                    _this.dialog.bye(undefined, { extraHeaders: extraHeaders });
                    _this.stateTransition(session_state_1.SessionState.Terminated);
                }
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                }
            });
        });
    };
    /**
     * Handle in dialog MESSAGE request.
     * @internal
     */
    Session.prototype.onMessageRequest = function (request) {
        this.logger.log("Session.onMessageRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("MESSAGE received while in state " + this.state + ", dropping request");
            return;
        }
        if (this.delegate && this.delegate.onMessage) {
            var message = new message_1.Message(request);
            this.delegate.onMessage(message);
        }
        else {
            request.accept();
        }
    };
    /**
     * Handle in dialog NOTIFY request.
     * @internal
     */
    Session.prototype.onNotifyRequest = function (request) {
        this.logger.log("Session.onNotifyRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("NOTIFY received while in state " + this.state + ", dropping request");
            return;
        }
        // If this a NOTIFY associated with the progress of a REFER,
        // look to delegate handling to the associated callback.
        if (this.onNotify) {
            var notification = new notification_1.Notification(request);
            this.onNotify(notification);
            return;
        }
        // Otherwise accept the NOTIFY.
        if (this.delegate && this.delegate.onNotify) {
            var notification = new notification_1.Notification(request);
            this.delegate.onNotify(notification);
        }
        else {
            request.accept();
        }
    };
    /**
     * Handle in dialog PRACK request.
     * @internal
     */
    Session.prototype.onPrackRequest = function (request) {
        this.logger.log("Session.onPrackRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("PRACK received while in state " + this.state + ", dropping request");
            return;
        }
        throw new Error("Unimplemented.");
    };
    /**
     * Handle in dialog REFER request.
     * @internal
     */
    Session.prototype.onReferRequest = function (request) {
        var _this = this;
        this.logger.log("Session.onReferRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("REFER received while in state " + this.state + ", dropping request");
            return;
        }
        // REFER is a SIP request and is constructed as defined in [1].  A REFER
        // request MUST contain exactly one Refer-To header field value.
        // https://tools.ietf.org/html/rfc3515#section-2.4.1
        if (!request.message.hasHeader("refer-to")) {
            this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting.");
            request.reject();
            return;
        }
        var referral = new referral_1.Referral(request, this);
        if (this.delegate && this.delegate.onRefer) {
            this.delegate.onRefer(referral);
        }
        else {
            this.logger.log("No delegate available to handle REFER, automatically accepting and following.");
            referral
                .accept()
                .then(function () { return referral
                .makeInviter(_this._referralInviterOptions)
                .invite(); })
                .catch(function (error) {
                // FIXME: logging and eating error...
                _this.logger.error(error.message);
            });
        }
    };
    /**
     * Generate an offer or answer for a response to an INVITE request.
     * If a remote offer was provided in the request, set the remote
     * description and get a local answer. If a remote offer was not
     * provided, generates a local offer.
     * @internal
     */
    Session.prototype.generateResponseOfferAnswer = function (request, options) {
        if (this.dialog) {
            return this.generateResponseOfferAnswerInDialog(options);
        }
        var body = core_1.getBody(request.message);
        if (!body || body.contentDisposition !== "session") {
            return this.getOffer(options);
        }
        else {
            return this.setOfferAndGetAnswer(body, options);
        }
    };
    /**
     * Generate an offer or answer for a response to an INVITE request
     * when a dialog (early or otherwise) has already been established.
     * This method may NOT be called if a dialog has yet to be established.
     * @internal
     */
    Session.prototype.generateResponseOfferAnswerInDialog = function (options) {
        if (!this.dialog) {
            throw new Error("Dialog undefined.");
        }
        switch (this.dialog.signalingState) {
            case core_1.SignalingState.Initial:
                return this.getOffer(options);
            case core_1.SignalingState.HaveLocalOffer:
                // o  Once the UAS has sent or received an answer to the initial
                // offer, it MUST NOT generate subsequent offers in any responses
                // to the initial INVITE.  This means that a UAS based on this
                // specification alone can never generate subsequent offers until
                // completion of the initial transaction.
                // https://tools.ietf.org/html/rfc3261#section-13.2.1
                return Promise.resolve(undefined);
            case core_1.SignalingState.HaveRemoteOffer:
                if (!this.dialog.offer) {
                    throw new Error("Session offer undefined in signaling state " + this.dialog.signalingState + ".");
                }
                return this.setOfferAndGetAnswer(this.dialog.offer, options);
            case core_1.SignalingState.Stable:
                // o  Once the UAS has sent or received an answer to the initial
                // offer, it MUST NOT generate subsequent offers in any responses
                // to the initial INVITE.  This means that a UAS based on this
                // specification alone can never generate subsequent offers until
                // completion of the initial transaction.
                // https://tools.ietf.org/html/rfc3261#section-13.2.1
                if (this.state !== session_state_1.SessionState.Established) {
                    return Promise.resolve(undefined);
                }
                // In dialog INVITE without offer, get an offer for the response.
                return this.getOffer(options);
            case core_1.SignalingState.Closed:
                throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
            default:
                throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
        }
    };
    /**
     * Get local offer.
     * @internal
     */
    Session.prototype.getOffer = function (options) {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        var sdhOptions = options.sessionDescriptionHandlerOptions;
        var sdhModifiers = options.sessionDescriptionHandlerModifiers;
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            return sdh.getDescription(sdhOptions, sdhModifiers)
                .then(function (bodyAndContentType) { return core_1.fromBodyLegacy(bodyAndContentType); })
                .catch(function (error) {
                _this.logger.error("Session.getOffer: SDH getDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.getOffer: SDH getDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * Rollback local/remote offer.
     * @internal
     */
    Session.prototype.rollbackOffer = function () {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        if (!sdh.rollbackDescription) {
            return Promise.resolve();
        }
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            return sdh.rollbackDescription()
                .catch(function (error) {
                _this.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * Set remote answer.
     * @internal
     */
    Session.prototype.setAnswer = function (answer, options) {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        var sdhOptions = options.sessionDescriptionHandlerOptions;
        var sdhModifiers = options.sessionDescriptionHandlerModifiers;
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            if (!sdh.hasDescription(answer.contentType)) {
                return Promise.reject(new exceptions_1.ContentTypeUnsupportedError());
            }
        }
        catch (error) {
            this.logger.error("Session.setAnswer: SDH hasDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
        try {
            return sdh.setDescription(answer.content, sdhOptions, sdhModifiers)
                .catch(function (error) {
                _this.logger.error("Session.setAnswer: SDH setDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.setAnswer: SDH setDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * Set remote offer and get local answer.
     * @internal
     */
    Session.prototype.setOfferAndGetAnswer = function (offer, options) {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        var sdhOptions = options.sessionDescriptionHandlerOptions;
        var sdhModifiers = options.sessionDescriptionHandlerModifiers;
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            if (!sdh.hasDescription(offer.contentType)) {
                return Promise.reject(new exceptions_1.ContentTypeUnsupportedError());
            }
        }
        catch (error) {
            this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
        try {
            return sdh.setDescription(offer.content, sdhOptions, sdhModifiers)
                .then(function () { return sdh.getDescription(sdhOptions, sdhModifiers); })
                .then(function (bodyAndContentType) { return core_1.fromBodyLegacy(bodyAndContentType); })
                .catch(function (error) {
                _this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * SDH for confirmed dialog.
     * @internal
     */
    Session.prototype.setSessionDescriptionHandler = function (sdh) {
        if (this._sessionDescriptionHandler) {
            throw new Error("Session description handler defined.");
        }
        this._sessionDescriptionHandler = sdh;
    };
    /**
     * SDH for confirmed dialog.
     * @internal
     */
    Session.prototype.setupSessionDescriptionHandler = function () {
        if (this._sessionDescriptionHandler) {
            return this._sessionDescriptionHandler;
        }
        this._sessionDescriptionHandler =
            this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);
        return this._sessionDescriptionHandler;
    };
    /**
     * Transition session state.
     * @internal
     */
    Session.prototype.stateTransition = function (newState) {
        var _this = this;
        var invalidTransition = function () {
            throw new Error("Invalid state transition from " + _this._state + " to " + newState);
        };
        // Validate transition
        switch (this._state) {
            case session_state_1.SessionState.Initial:
                if (newState !== session_state_1.SessionState.Establishing &&
                    newState !== session_state_1.SessionState.Established &&
                    newState !== session_state_1.SessionState.Terminating &&
                    newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Establishing:
                if (newState !== session_state_1.SessionState.Established &&
                    newState !== session_state_1.SessionState.Terminating &&
                    newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Established:
                if (newState !== session_state_1.SessionState.Terminating &&
                    newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Terminating:
                if (newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Terminated:
                invalidTransition();
                break;
            default:
                throw new Error("Unrecognized state.");
        }
        // Transition
        this._state = newState;
        this.logger.log("Session " + this.id + " transitioned to state " + this._state);
        this._stateEventEmitter.emit("event", this._state);
        // Dispose
        if (newState === session_state_1.SessionState.Terminated) {
            this.dispose();
        }
    };
    Session.prototype.copyRequestOptions = function (requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        var extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;
        var body = requestOptions.body ?
            {
                contentDisposition: requestOptions.body.contentDisposition || "render",
                contentType: requestOptions.body.contentType || "text/plain",
                content: requestOptions.body.content || ""
            } : undefined;
        return {
            extraHeaders: extraHeaders,
            body: body
        };
    };
    Session.prototype.getReasonHeaderValue = function (code, reason) {
        var cause = code;
        var text = utils_1.getReasonPhrase(code);
        if (!text && reason) {
            text = reason;
        }
        return "SIP;cause=" + cause + ';text="' + text + '"';
    };
    Session.prototype.referExtraHeaders = function (referTo) {
        var extraHeaders = [];
        extraHeaders.push("Referred-By: <" + this.userAgent.configuration.uri + ">");
        extraHeaders.push("Contact: " + this._contact);
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        extraHeaders.push("Refer-To: " + referTo);
        return extraHeaders;
    };
    Session.prototype.referToString = function (target) {
        var referTo;
        if (target instanceof core_1.URI) {
            // REFER without Replaces (Blind Transfer)
            referTo = target.toString();
        }
        else {
            // REFER with Replaces (Attended Transfer)
            if (!target.dialog) {
                throw new Error("Dialog undefined.");
            }
            var displayName = target.remoteIdentity.friendlyName;
            var remoteTarget = target.dialog.remoteTarget.toString();
            var callId = target.dialog.callId;
            var remoteTag = target.dialog.remoteTag;
            var localTag = target.dialog.localTag;
            var replaces = encodeURIComponent(callId + ";to-tag=" + remoteTag + ";from-tag=" + localTag);
            referTo = "\"" + displayName + "\" <" + remoteTarget + "?Replaces=" + replaces + ">";
        }
        return referTo;
    };
    return Session;
}());
exports.Session = Session;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/dialog.js":
/*!********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/dialog.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
/**
 * Dialog.
 * @remarks
 * A key concept for a user agent is that of a dialog.  A dialog
 * represents a peer-to-peer SIP relationship between two user agents
 * that persists for some time.  The dialog facilitates sequencing of
 * messages between the user agents and proper routing of requests
 * between both of them.  The dialog represents a context in which to
 * interpret SIP messages.
 * https://tools.ietf.org/html/rfc3261#section-12
 * @public
 */
var Dialog = /** @class */ (function () {
    /**
     * Dialog constructor.
     * @param core - User agent core.
     * @param dialogState - Initial dialog state.
     */
    function Dialog(core, dialogState) {
        this.core = core;
        this.dialogState = dialogState;
        this.core.dialogs.set(this.id, this);
    }
    /**
     * When a UAC receives a response that establishes a dialog, it
     * constructs the state of the dialog.  This state MUST be maintained
     * for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.2
     * @param outgoingRequestMessage - Outgoing request message for dialog.
     * @param incomingResponseMessage - Incoming response message creating dialog.
     */
    Dialog.initialDialogStateForUserAgentClient = function (outgoingRequestMessage, incomingResponseMessage) {
        // If the request was sent over TLS, and the Request-URI contained a
        // SIPS URI, the "secure" flag is set to TRUE.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var secure = false; // FIXME: Currently no support for TLS.
        // The route set MUST be set to the list of URIs in the Record-Route
        // header field from the response, taken in reverse order and preserving
        // all URI parameters.  If no Record-Route header field is present in
        // the response, the route set MUST be set to the empty set.  This route
        // set, even if empty, overrides any pre-existing route set for future
        // requests in this dialog.  The remote target MUST be set to the URI
        // from the Contact header field of the response.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var routeSet = incomingResponseMessage.getHeaders("record-route").reverse();
        var contact = incomingResponseMessage.parseHeader("contact");
        if (!contact) { // TODO: Review to make sure this will never happen
            throw new Error("Contact undefined.");
        }
        if (!(contact instanceof messages_1.NameAddrHeader)) {
            throw new Error("Contact not instance of NameAddrHeader.");
        }
        var remoteTarget = contact.uri;
        // The local sequence number MUST be set to the value of the sequence
        // number in the CSeq header field of the request.  The remote sequence
        // number MUST be empty (it is established when the remote UA sends a
        // request within the dialog).  The call identifier component of the
        // dialog ID MUST be set to the value of the Call-ID in the request.
        // The local tag component of the dialog ID MUST be set to the tag in
        // the From field in the request, and the remote tag component of the
        // dialog ID MUST be set to the tag in the To field of the response.  A
        // UAC MUST be prepared to receive a response without a tag in the To
        // field, in which case the tag is considered to have a value of null.
        //
        //    This is to maintain backwards compatibility with RFC 2543, which
        //    did not mandate To tags.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var localSequenceNumber = outgoingRequestMessage.cseq;
        var remoteSequenceNumber = undefined;
        var callId = outgoingRequestMessage.callId;
        var localTag = outgoingRequestMessage.fromTag;
        var remoteTag = incomingResponseMessage.toTag;
        if (!callId) { // TODO: Review to make sure this will never happen
            throw new Error("Call id undefined.");
        }
        if (!localTag) { // TODO: Review to make sure this will never happen
            throw new Error("From tag undefined.");
        }
        if (!remoteTag) { // TODO: Review to make sure this will never happen
            throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
        }
        // The remote URI MUST be set to the URI in the To field, and the local
        // URI MUST be set to the URI in the From field.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        if (!outgoingRequestMessage.from) { // TODO: Review to make sure this will never happen
            throw new Error("From undefined.");
        }
        if (!outgoingRequestMessage.to) { // TODO: Review to make sure this will never happen
            throw new Error("To undefined.");
        }
        var localURI = outgoingRequestMessage.from.uri;
        var remoteURI = outgoingRequestMessage.to.uri;
        // A dialog can also be in the "early" state, which occurs when it is
        // created with a provisional response, and then transition to the
        // "confirmed" state when a 2xx final response arrives.
        // https://tools.ietf.org/html/rfc3261#section-12
        if (!incomingResponseMessage.statusCode) {
            throw new Error("Incoming response status code undefined.");
        }
        var early = incomingResponseMessage.statusCode < 200 ? true : false;
        var dialogState = {
            id: callId + localTag + remoteTag,
            early: early,
            callId: callId,
            localTag: localTag,
            remoteTag: remoteTag,
            localSequenceNumber: localSequenceNumber,
            remoteSequenceNumber: remoteSequenceNumber,
            localURI: localURI,
            remoteURI: remoteURI,
            remoteTarget: remoteTarget,
            routeSet: routeSet,
            secure: secure
        };
        return dialogState;
    };
    /**
     * The UAS then constructs the state of the dialog.  This state MUST be
     * maintained for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.1
     * @param incomingRequestMessage - Incoming request message creating dialog.
     * @param toTag - Tag in the To field in the response to the incoming request.
     */
    Dialog.initialDialogStateForUserAgentServer = function (incomingRequestMessage, toTag, early) {
        if (early === void 0) { early = false; }
        // If the request arrived over TLS, and the Request-URI contained a SIPS
        // URI, the "secure" flag is set to TRUE.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var secure = false; // FIXME: Currently no support for TLS.
        // The route set MUST be set to the list of URIs in the Record-Route
        // header field from the request, taken in order and preserving all URI
        // parameters.  If no Record-Route header field is present in the
        // request, the route set MUST be set to the empty set.  This route set,
        // even if empty, overrides any pre-existing route set for future
        // requests in this dialog.  The remote target MUST be set to the URI
        // from the Contact header field of the request.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var routeSet = incomingRequestMessage.getHeaders("record-route");
        var contact = incomingRequestMessage.parseHeader("contact");
        if (!contact) { // TODO: Review to make sure this will never happen
            throw new Error("Contact undefined.");
        }
        if (!(contact instanceof messages_1.NameAddrHeader)) {
            throw new Error("Contact not instance of NameAddrHeader.");
        }
        var remoteTarget = contact.uri;
        // The remote sequence number MUST be set to the value of the sequence
        // number in the CSeq header field of the request.  The local sequence
        // number MUST be empty.  The call identifier component of the dialog ID
        // MUST be set to the value of the Call-ID in the request.  The local
        // tag component of the dialog ID MUST be set to the tag in the To field
        // in the response to the request (which always includes a tag), and the
        // remote tag component of the dialog ID MUST be set to the tag from the
        // From field in the request.  A UAS MUST be prepared to receive a
        // request without a tag in the From field, in which case the tag is
        // considered to have a value of null.
        //
        //    This is to maintain backwards compatibility with RFC 2543, which
        //    did not mandate From tags.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var remoteSequenceNumber = incomingRequestMessage.cseq;
        var localSequenceNumber = undefined;
        var callId = incomingRequestMessage.callId;
        var localTag = toTag;
        var remoteTag = incomingRequestMessage.fromTag;
        // The remote URI MUST be set to the URI in the From field, and the
        // local URI MUST be set to the URI in the To field.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var remoteURI = incomingRequestMessage.from.uri;
        var localURI = incomingRequestMessage.to.uri;
        var dialogState = {
            id: callId + localTag + remoteTag,
            early: early,
            callId: callId,
            localTag: localTag,
            remoteTag: remoteTag,
            localSequenceNumber: localSequenceNumber,
            remoteSequenceNumber: remoteSequenceNumber,
            localURI: localURI,
            remoteURI: remoteURI,
            remoteTarget: remoteTarget,
            routeSet: routeSet,
            secure: secure
        };
        return dialogState;
    };
    /** Destructor. */
    Dialog.prototype.dispose = function () {
        this.core.dialogs.delete(this.id);
    };
    Object.defineProperty(Dialog.prototype, "id", {
        /**
         * A dialog is identified at each UA with a dialog ID, which consists of
         * a Call-ID value, a local tag and a remote tag.  The dialog ID at each
         * UA involved in the dialog is not the same.  Specifically, the local
         * tag at one UA is identical to the remote tag at the peer UA.  The
         * tags are opaque tokens that facilitate the generation of unique
         * dialog IDs.
         * https://tools.ietf.org/html/rfc3261#section-12
         */
        get: function () {
            return this.dialogState.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "early", {
        /**
         * A dialog can also be in the "early" state, which occurs when it is
         * created with a provisional response, and then it transition to the
         * "confirmed" state when a 2xx final response received or is sent.
         *
         * Note: RFC 3261 is concise on when a dialog is "confirmed", but it
         * can be a point of confusion if an INVITE dialog is "confirmed" after
         * a 2xx is sent or after receiving the ACK for the 2xx response.
         * With careful reading it can be inferred a dialog is always is
         * "confirmed" when the 2xx is sent (regardless of type of dialog).
         * However a INVITE dialog does have additional considerations
         * when it is confirmed but an ACK has not yet been received (in
         * particular with regard to a callee sending BYE requests).
         */
        get: function () {
            return this.dialogState.early;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "callId", {
        /** Call identifier component of the dialog id. */
        get: function () {
            return this.dialogState.callId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "localTag", {
        /** Local tag component of the dialog id. */
        get: function () {
            return this.dialogState.localTag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteTag", {
        /** Remote tag component of the dialog id. */
        get: function () {
            return this.dialogState.remoteTag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "localSequenceNumber", {
        /** Local sequence number (used to order requests from the UA to its peer). */
        get: function () {
            return this.dialogState.localSequenceNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteSequenceNumber", {
        /** Remote sequence number (used to order requests from its peer to the UA). */
        get: function () {
            return this.dialogState.remoteSequenceNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "localURI", {
        /** Local URI. */
        get: function () {
            return this.dialogState.localURI;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteURI", {
        /** Remote URI. */
        get: function () {
            return this.dialogState.remoteURI;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteTarget", {
        /** Remote target. */
        get: function () {
            return this.dialogState.remoteTarget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "routeSet", {
        /**
         * Route set, which is an ordered list of URIs. The route set is the
         * list of servers that need to be traversed to send a request to the peer.
         */
        get: function () {
            return this.dialogState.routeSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "secure", {
        /**
         * If the request was sent over TLS, and the Request-URI contained
         * a SIPS URI, the "secure" flag is set to true. *NOT IMPLEMENTED*
         */
        get: function () {
            return this.dialogState.secure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "userAgentCore", {
        /** The user agent core servicing this dialog. */
        get: function () {
            return this.core;
        },
        enumerable: true,
        configurable: true
    });
    /** Confirm the dialog. Only matters if dialog is currently early. */
    Dialog.prototype.confirm = function () {
        this.dialogState.early = false;
    };
    /**
     * Requests sent within a dialog, as any other requests, are atomic.  If
     * a particular request is accepted by the UAS, all the state changes
     * associated with it are performed.  If the request is rejected, none
     * of the state changes are performed.
     *
     *    Note that some requests, such as INVITEs, affect several pieces of
     *    state.
     *
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param message - Incoming request message within this dialog.
     */
    Dialog.prototype.receiveRequest = function (message) {
        // ACK guard.
        // By convention, the handling of ACKs is the responsibility
        // the particular dialog implementation. For example, see SessionDialog.
        // Furthermore, ACKs have same sequence number as the associated INVITE.
        if (message.method === messages_1.C.ACK) {
            return;
        }
        // If the remote sequence number was not empty, but the sequence number
        // of the request is lower than the remote sequence number, the request
        // is out of order and MUST be rejected with a 500 (Server Internal
        // Error) response.  If the remote sequence number was not empty, and
        // the sequence number of the request is greater than the remote
        // sequence number, the request is in order.  It is possible for the
        // CSeq sequence number to be higher than the remote sequence number by
        // more than one.  This is not an error condition, and a UAS SHOULD be
        // prepared to receive and process requests with CSeq values more than
        // one higher than the previous received request.  The UAS MUST then set
        // the remote sequence number to the value of the sequence number in the
        // CSeq header field value in the request.
        //
        //    If a proxy challenges a request generated by the UAC, the UAC has
        //    to resubmit the request with credentials.  The resubmitted request
        //    will have a new CSeq number.  The UAS will never see the first
        //    request, and thus, it will notice a gap in the CSeq number space.
        //    Such a gap does not represent any error condition.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (this.remoteSequenceNumber) {
            if (message.cseq <= this.remoteSequenceNumber) {
                throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
            }
            this.dialogState.remoteSequenceNumber = message.cseq;
        }
        // If the remote sequence number is empty, it MUST be set to the value
        // of the sequence number in the CSeq header field value in the request.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (!this.remoteSequenceNumber) {
            this.dialogState.remoteSequenceNumber = message.cseq;
        }
        // When a UAS receives a target refresh request, it MUST replace the
        // dialog's remote target URI with the URI from the Contact header field
        // in that request, if present.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        // Note: "target refresh request" processing delegated to sub-class.
    };
    /**
     * If the dialog identifier in the 2xx response matches the dialog
     * identifier of an existing dialog, the dialog MUST be transitioned to
     * the "confirmed" state, and the route set for the dialog MUST be
     * recomputed based on the 2xx response using the procedures of Section
     * 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
     * constructed using the procedures of Section 12.1.2.
     *
     * Note that the only piece of state that is recomputed is the route
     * set.  Other pieces of state such as the highest sequence numbers
     * (remote and local) sent within the dialog are not recomputed.  The
     * route set only is recomputed for backwards compatibility.  RFC
     * 2543 did not mandate mirroring of the Record-Route header field in
     * a 1xx, only 2xx.  However, we cannot update the entire state of
     * the dialog, since mid-dialog requests may have been sent within
     * the early dialog, modifying the sequence numbers, for example.
     *
     *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4
     */
    Dialog.prototype.recomputeRouteSet = function (message) {
        this.dialogState.routeSet = message.getHeaders("record-route").reverse();
    };
    /**
     * A request within a dialog is constructed by using many of the
     * components of the state stored as part of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.2.1.1
     * @param method - Outgoing request method.
     */
    Dialog.prototype.createOutgoingRequestMessage = function (method, options) {
        // The URI in the To field of the request MUST be set to the remote URI
        // from the dialog state.  The tag in the To header field of the request
        // MUST be set to the remote tag of the dialog ID.  The From URI of the
        // request MUST be set to the local URI from the dialog state.  The tag
        // in the From header field of the request MUST be set to the local tag
        // of the dialog ID.  If the value of the remote or local tags is null,
        // the tag parameter MUST be omitted from the To or From header fields,
        // respectively.
        //
        //    Usage of the URI from the To and From fields in the original
        //    request within subsequent requests is done for backwards
        //    compatibility with RFC 2543, which used the URI for dialog
        //    identification.  In this specification, only the tags are used for
        //    dialog identification.  It is expected that mandatory reflection
        //    of the original To and From URI in mid-dialog requests will be
        //    deprecated in a subsequent revision of this specification.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        var toUri = this.remoteURI;
        var toTag = this.remoteTag;
        var fromUri = this.localURI;
        var fromTag = this.localTag;
        // The Call-ID of the request MUST be set to the Call-ID of the dialog.
        // Requests within a dialog MUST contain strictly monotonically
        // increasing and contiguous CSeq sequence numbers (increasing-by-one)
        // in each direction (excepting ACK and CANCEL of course, whose numbers
        // equal the requests being acknowledged or cancelled).  Therefore, if
        // the local sequence number is not empty, the value of the local
        // sequence number MUST be incremented by one, and this value MUST be
        // placed into the CSeq header field.  If the local sequence number is
        // empty, an initial value MUST be chosen using the guidelines of
        // Section 8.1.1.5.  The method field in the CSeq header field value
        // MUST match the method of the request.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        var callId = this.callId;
        var cseq;
        if (options && options.cseq) {
            cseq = options.cseq;
        }
        else if (!this.dialogState.localSequenceNumber) {
            cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5
        }
        else {
            cseq = this.dialogState.localSequenceNumber += 1;
        }
        // The UAC uses the remote target and route set to build the Request-URI
        // and Route header field of the request.
        //
        // If the route set is empty, the UAC MUST place the remote target URI
        // into the Request-URI.  The UAC MUST NOT add a Route header field to
        // the request.
        //
        // If the route set is not empty, and the first URI in the route set
        // contains the lr parameter (see Section 19.1.1), the UAC MUST place
        // the remote target URI into the Request-URI and MUST include a Route
        // header field containing the route set values in order, including all
        // parameters.
        //
        // If the route set is not empty, and its first URI does not contain the
        // lr parameter, the UAC MUST place the first URI from the route set
        // into the Request-URI, stripping any parameters that are not allowed
        // in a Request-URI.  The UAC MUST add a Route header field containing
        // the remainder of the route set values in order, including all
        // parameters.  The UAC MUST then place the remote target URI into the
        // Route header field as the last value.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        // The lr parameter, when present, indicates that the element
        // responsible for this resource implements the routing mechanisms
        // specified in this document.  This parameter will be used in the
        // URIs proxies place into Record-Route header field values, and
        // may appear in the URIs in a pre-existing route set.
        //
        // This parameter is used to achieve backwards compatibility with
        // systems implementing the strict-routing mechanisms of RFC 2543
        // and the rfc2543bis drafts up to bis-05.  An element preparing
        // to send a request based on a URI not containing this parameter
        // can assume the receiving element implements strict-routing and
        // reformat the message to preserve the information in the
        // Request-URI.
        // https://tools.ietf.org/html/rfc3261#section-19.1.1
        // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
        var ruri = this.remoteTarget;
        var routeSet = this.routeSet;
        var extraHeaders = options && options.extraHeaders;
        var body = options && options.body;
        // The relative order of header fields with different field names is not
        // significant.  However, it is RECOMMENDED that header fields which are
        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
        // Max-Forwards, and Proxy-Authorization, for example) appear towards
        // the top of the message to facilitate rapid parsing.
        // https://tools.ietf.org/html/rfc3261#section-7.3.1
        var message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {
            callId: callId,
            cseq: cseq,
            fromTag: fromTag,
            toTag: toTag,
            routeSet: routeSet
        }, extraHeaders, body);
        return message;
    };
    /**
     * Increment the local sequence number by one.
     * It feels like this should be protected, but the current authentication handling currently
     * needs this to keep the dialog in sync when "auto re-sends" request messages.
     * @internal
     */
    Dialog.prototype.incrementLocalSequenceNumber = function () {
        if (!this.dialogState.localSequenceNumber) {
            throw new Error("Local sequence number undefined.");
        }
        this.dialogState.localSequenceNumber += 1;
    };
    /**
     * If the remote sequence number was not empty, but the sequence number
     * of the request is lower than the remote sequence number, the request
     * is out of order and MUST be rejected with a 500 (Server Internal
     * Error) response.
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param request - Incoming request to guard.
     * @returns True if the program execution is to continue in the branch in question.
     *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.
     */
    Dialog.prototype.sequenceGuard = function (message) {
        // ACK guard.
        // By convention, handling of unexpected ACKs is responsibility
        // the particular dialog implementation. For example, see SessionDialog.
        // Furthermore, we cannot reply to an "out of sequence" ACK.
        if (message.method === messages_1.C.ACK) {
            return true;
        }
        // Note: We are rejecting on "less than or equal to" the remote
        // sequence number (excepting ACK whose numbers equal the requests
        // being acknowledged or cancelled), which is the correct thing to
        // do in our case. The only time a request with the same sequence number
        // will show up here if is a) it is a very late retransmission of a
        // request we already handled or b) it is a different request with the
        // same sequence number which would be violation of the standard.
        // Request retransmissions are absorbed by the transaction layer,
        // so any request with a duplicate sequence number getting here
        // would have to be a retransmission after the transaction terminated
        // or a broken request (with unique via branch value).
        // Requests within a dialog MUST contain strictly monotonically
        // increasing and contiguous CSeq sequence numbers (increasing-by-one)
        // in each direction (excepting ACK and CANCEL of course, whose numbers
        // equal the requests being acknowledged or cancelled).  Therefore, if
        // the local sequence number is not empty, the value of the local
        // sequence number MUST be incremented by one, and this value MUST be
        // placed into the CSeq header field.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {
            this.core.replyStateless(message, { statusCode: 500 });
            return false;
        }
        return true;
    };
    return Dialog;
}());
exports.Dialog = Dialog;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./dialog */ "./node_modules/sip.js/lib/core/dialogs/dialog.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session-dialog */ "./node_modules/sip.js/lib/core/dialogs/session-dialog.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscription-dialog */ "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/session-dialog.js":
/*!****************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/session-dialog.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var session_1 = __webpack_require__(/*! ../session */ "./node_modules/sip.js/lib/core/session/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var bye_user_agent_client_1 = __webpack_require__(/*! ../user-agents/bye-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js");
var bye_user_agent_server_1 = __webpack_require__(/*! ../user-agents/bye-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js");
var info_user_agent_client_1 = __webpack_require__(/*! ../user-agents/info-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js");
var info_user_agent_server_1 = __webpack_require__(/*! ../user-agents/info-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js");
var message_user_agent_client_1 = __webpack_require__(/*! ../user-agents/message-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js");
var message_user_agent_server_1 = __webpack_require__(/*! ../user-agents/message-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js");
var notify_user_agent_client_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js");
var notify_user_agent_server_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js");
var prack_user_agent_client_1 = __webpack_require__(/*! ../user-agents/prack-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js");
var prack_user_agent_server_1 = __webpack_require__(/*! ../user-agents/prack-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js");
var re_invite_user_agent_client_1 = __webpack_require__(/*! ../user-agents/re-invite-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js");
var re_invite_user_agent_server_1 = __webpack_require__(/*! ../user-agents/re-invite-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js");
var refer_user_agent_client_1 = __webpack_require__(/*! ../user-agents/refer-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js");
var refer_user_agent_server_1 = __webpack_require__(/*! ../user-agents/refer-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js");
var dialog_1 = __webpack_require__(/*! ./dialog */ "./node_modules/sip.js/lib/core/dialogs/dialog.js");
/**
 * Session Dialog.
 * @public
 */
var SessionDialog = /** @class */ (function (_super) {
    tslib_1.__extends(SessionDialog, _super);
    function SessionDialog(initialTransaction, core, state, delegate) {
        var _this = _super.call(this, core, state) || this;
        _this.initialTransaction = initialTransaction;
        /** The state of the offer/answer exchange. */
        _this._signalingState = session_1.SignalingState.Initial;
        /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */
        _this.ackWait = false;
        _this.delegate = delegate;
        if (initialTransaction instanceof transactions_1.InviteServerTransaction) {
            // If we're created by an invite server transaction, we're
            // going to be waiting for an ACK if are to be confirmed.
            _this.ackWait = true;
        }
        // If we're confirmed upon creation start the retransmitting whatever
        // the 2xx final response was that confirmed us into existence.
        if (!_this.early) {
            _this.start2xxRetransmissionTimer();
        }
        _this.signalingStateTransition(initialTransaction.request);
        _this.logger = core.loggerFactory.getLogger("sip.invite-dialog");
        _this.logger.log("INVITE dialog " + _this.id + " constructed");
        return _this;
    }
    SessionDialog.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._signalingState = session_1.SignalingState.Closed;
        this._offer = undefined;
        this._answer = undefined;
        if (this.invite2xxTimer) {
            clearTimeout(this.invite2xxTimer);
            this.invite2xxTimer = undefined;
        }
        // The UAS MUST still respond to any pending requests received for that
        // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
        // be generated to those pending requests.
        // https://tools.ietf.org/html/rfc3261#section-15.1.2
        // TODO:
        // this.userAgentServers.forEach((uas) => uas.reply(487));
        this.logger.log("INVITE dialog " + this.id + " destroyed");
    };
    Object.defineProperty(SessionDialog.prototype, "sessionState", {
        // FIXME: Need real state machine
        get: function () {
            if (this.early) {
                return session_1.SessionState.Early;
            }
            else if (this.ackWait) {
                return session_1.SessionState.AckWait;
            }
            else if (this._signalingState === session_1.SignalingState.Closed) {
                return session_1.SessionState.Terminated;
            }
            else {
                return session_1.SessionState.Confirmed;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SessionDialog.prototype, "signalingState", {
        /** The state of the offer/answer exchange. */
        get: function () {
            return this._signalingState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SessionDialog.prototype, "offer", {
        /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */
        get: function () {
            return this._offer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SessionDialog.prototype, "answer", {
        /** The current answer. Undefined unless signaling state Stable. */
        get: function () {
            return this._answer;
        },
        enumerable: true,
        configurable: true
    });
    /** Confirm the dialog. Only matters if dialog is currently early. */
    SessionDialog.prototype.confirm = function () {
        // When we're confirmed start the retransmitting whatever
        // the 2xx final response that may have confirmed us.
        if (this.early) {
            this.start2xxRetransmissionTimer();
        }
        _super.prototype.confirm.call(this);
    };
    /** Re-confirm the dialog. Only matters if handling re-INVITE request. */
    SessionDialog.prototype.reConfirm = function () {
        // When we're confirmed start the retransmitting whatever
        // the 2xx final response that may have confirmed us.
        if (this.reinviteUserAgentServer) {
            this.startReInvite2xxRetransmissionTimer();
        }
    };
    /**
     * The UAC core MUST generate an ACK request for each 2xx received from
     * the transaction layer.  The header fields of the ACK are constructed
     * in the same way as for any request sent within a dialog (see Section
     * 12) with the exception of the CSeq and the header fields related to
     * authentication.  The sequence number of the CSeq header field MUST be
     * the same as the INVITE being acknowledged, but the CSeq method MUST
     * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
     * the 2xx contains an offer (based on the rules above), the ACK MUST
     * carry an answer in its body.  If the offer in the 2xx response is not
     * acceptable, the UAC core MUST generate a valid answer in the ACK and
     * then send a BYE immediately.
     * https://tools.ietf.org/html/rfc3261#section-13.2.2.4
     * @param options - ACK options bucket.
     */
    SessionDialog.prototype.ack = function (options) {
        if (options === void 0) { options = {}; }
        this.logger.log("INVITE dialog " + this.id + " sending ACK request");
        var transaction;
        if (this.reinviteUserAgentClient) {
            // We're sending ACK for a re-INVITE
            if (!(this.reinviteUserAgentClient.transaction instanceof transactions_1.InviteClientTransaction)) {
                throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            transaction = this.reinviteUserAgentClient.transaction;
            this.reinviteUserAgentClient = undefined;
        }
        else {
            // We're sending ACK for the initial INVITE
            if (!(this.initialTransaction instanceof transactions_1.InviteClientTransaction)) {
                throw new Error("Initial transaction not instance of InviteClientTransaction.");
            }
            transaction = this.initialTransaction;
        }
        options.cseq = transaction.request.cseq; // ACK cseq is INVITE cseq
        var message = this.createOutgoingRequestMessage(messages_1.C.ACK, options);
        transaction.ackResponse(message); // See InviteClientTransaction for details.
        this.signalingStateTransition(message);
        return { message: message };
    };
    /**
     * Terminating a Session
     *
     * This section describes the procedures for terminating a session
     * established by SIP.  The state of the session and the state of the
     * dialog are very closely related.  When a session is initiated with an
     * INVITE, each 1xx or 2xx response from a distinct UAS creates a
     * dialog, and if that response completes the offer/answer exchange, it
     * also creates a session.  As a result, each session is "associated"
     * with a single dialog - the one which resulted in its creation.  If an
     * initial INVITE generates a non-2xx final response, that terminates
     * all sessions (if any) and all dialogs (if any) that were created
     * through responses to the request.  By virtue of completing the
     * transaction, a non-2xx final response also prevents further sessions
     * from being created as a result of the INVITE.  The BYE request is
     * used to terminate a specific session or attempted session.  In this
     * case, the specific session is the one with the peer UA on the other
     * side of the dialog.  When a BYE is received on a dialog, any session
     * associated with that dialog SHOULD terminate.  A UA MUST NOT send a
     * BYE outside of a dialog.  The caller's UA MAY send a BYE for either
     * confirmed or early dialogs, and the callee's UA MAY send a BYE on
     * confirmed dialogs, but MUST NOT send a BYE on early dialogs.
     *
     * However, the callee's UA MUST NOT send a BYE on a confirmed dialog
     * until it has received an ACK for its 2xx response or until the server
     * transaction times out.  If no SIP extensions have defined other
     * application layer states associated with the dialog, the BYE also
     * terminates the dialog.
     *
     * https://tools.ietf.org/html/rfc3261#section-15
     * FIXME: Make these proper Exceptions...
     * @param options - BYE options bucket.
     * @returns
     * Throws `Error` if callee's UA attempts a BYE on an early dialog.
     * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog
     *                while it's waiting on the ACK for its 2xx response.
     */
    SessionDialog.prototype.bye = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending BYE request");
        // The caller's UA MAY send a BYE for either
        // confirmed or early dialogs, and the callee's UA MAY send a BYE on
        // confirmed dialogs, but MUST NOT send a BYE on early dialogs.
        //
        // However, the callee's UA MUST NOT send a BYE on a confirmed dialog
        // until it has received an ACK for its 2xx response or until the server
        // transaction times out.
        // https://tools.ietf.org/html/rfc3261#section-15
        if (this.initialTransaction instanceof transactions_1.InviteServerTransaction) {
            if (this.early) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("UAS MUST NOT send a BYE on early dialogs.");
            }
            if (this.ackWait && this.initialTransaction.state !== transactions_1.TransactionState.Terminated) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("UAS MUST NOT send a BYE on a confirmed dialog " +
                    "until it has received an ACK for its 2xx response " +
                    "or until the server transaction times out.");
            }
        }
        // A BYE request is constructed as would any other request within a
        // dialog, as described in Section 12.
        //
        // Once the BYE is constructed, the UAC core creates a new non-INVITE
        // client transaction, and passes it the BYE request.  The UAC MUST
        // consider the session terminated (and therefore stop sending or
        // listening for media) as soon as the BYE request is passed to the
        // client transaction.  If the response for the BYE is a 481
        // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no
        // response at all is received for the BYE (that is, a timeout is
        // returned by the client transaction), the UAC MUST consider the
        // session and the dialog terminated.
        // https://tools.ietf.org/html/rfc3261#section-15.1.1
        return new bye_user_agent_client_1.ByeUserAgentClient(this, delegate, options);
    };
    /**
     * An INFO request can be associated with an Info Package (see
     * Section 5), or associated with a legacy INFO usage (see Section 2).
     *
     * The construction of the INFO request is the same as any other
     * non-target refresh request within an existing invite dialog usage as
     * described in Section 12.2 of RFC 3261.
     * https://tools.ietf.org/html/rfc6086#section-4.2.1
     * @param options - Options bucket.
     */
    SessionDialog.prototype.info = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending INFO request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        return new info_user_agent_client_1.InfoUserAgentClient(this, delegate, options);
    };
    /**
     * Modifying an Existing Session
     *
     * A successful INVITE request (see Section 13) establishes both a
     * dialog between two user agents and a session using the offer-answer
     * model.  Section 12 explains how to modify an existing dialog using a
     * target refresh request (for example, changing the remote target URI
     * of the dialog).  This section describes how to modify the actual
     * session.  This modification can involve changing addresses or ports,
     * adding a media stream, deleting a media stream, and so on.  This is
     * accomplished by sending a new INVITE request within the same dialog
     * that established the session.  An INVITE request sent within an
     * existing dialog is known as a re-INVITE.
     *
     *    Note that a single re-INVITE can modify the dialog and the
     *    parameters of the session at the same time.
     *
     * Either the caller or callee can modify an existing session.
     * https://tools.ietf.org/html/rfc3261#section-14
     * @param options - Options bucket
     */
    SessionDialog.prototype.invite = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending INVITE request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        // Note that a UAC MUST NOT initiate a new INVITE transaction within a
        // dialog while another INVITE transaction is in progress in either
        // direction.
        //
        //    1. If there is an ongoing INVITE client transaction, the TU MUST
        //       wait until the transaction reaches the completed or terminated
        //       state before initiating the new INVITE.
        //
        //    2. If there is an ongoing INVITE server transaction, the TU MUST
        //       wait until the transaction reaches the confirmed or terminated
        //       state before initiating the new INVITE.
        //
        // However, a UA MAY initiate a regular transaction while an INVITE
        // transaction is in progress.  A UA MAY also initiate an INVITE
        // transaction while a regular transaction is in progress.
        // https://tools.ietf.org/html/rfc3261#section-14.1
        if (this.reinviteUserAgentClient) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("There is an ongoing re-INVITE client transaction.");
        }
        if (this.reinviteUserAgentServer) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("There is an ongoing re-INVITE server transaction.");
        }
        return new re_invite_user_agent_client_1.ReInviteUserAgentClient(this, delegate, options);
    };
    /**
     * A UAC MAY associate a MESSAGE request with an existing dialog.  If a
     * MESSAGE request is sent within a dialog, it is "associated" with any
     * media session or sessions associated with that dialog.
     * https://tools.ietf.org/html/rfc3428#section-4
     * @param options - Options bucket.
     */
    SessionDialog.prototype.message = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending MESSAGE request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        var message = this.createOutgoingRequestMessage(messages_1.C.MESSAGE, options);
        return new message_user_agent_client_1.MessageUserAgentClient(this.core, message, delegate);
    };
    /**
     * The NOTIFY mechanism defined in [2] MUST be used to inform the agent
     * sending the REFER of the status of the reference.
     * https://tools.ietf.org/html/rfc3515#section-2.4.4
     * @param options - Options bucket.
     */
    SessionDialog.prototype.notify = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending NOTIFY request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        return new notify_user_agent_client_1.NotifyUserAgentClient(this, delegate, options);
    };
    /**
     * Assuming the response is to be transmitted reliably, the UAC MUST
     * create a new request with method PRACK.  This request is sent within
     * the dialog associated with the provisional response (indeed, the
     * provisional response may have created the dialog).  PRACK requests
     * MAY contain bodies, which are interpreted according to their type and
     * disposition.
     * https://tools.ietf.org/html/rfc3262#section-4
     * @param options - Options bucket.
     */
    SessionDialog.prototype.prack = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending PRACK request");
        return new prack_user_agent_client_1.PrackUserAgentClient(this, delegate, options);
    };
    /**
     * REFER is a SIP request and is constructed as defined in [1].  A REFER
     * request MUST contain exactly one Refer-To header field value.
     * https://tools.ietf.org/html/rfc3515#section-2.4.1
     * @param options - Options bucket.
     */
    SessionDialog.prototype.refer = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending REFER request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        // FIXME: TODO: Validate Refer-To header field value.
        return new refer_user_agent_client_1.ReferUserAgentClient(this, delegate, options);
    };
    /**
     * Requests sent within a dialog, as any other requests, are atomic.  If
     * a particular request is accepted by the UAS, all the state changes
     * associated with it are performed.  If the request is rejected, none
     * of the state changes are performed.
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param message - Incoming request message within this dialog.
     */
    SessionDialog.prototype.receiveRequest = function (message) {
        this.logger.log("INVITE dialog " + this.id + " received " + message.method + " request");
        // Response retransmissions cease when an ACK request for the
        // response is received.  This is independent of whatever transport
        // protocols are used to send the response.
        // https://tools.ietf.org/html/rfc6026#section-8.1
        if (message.method === messages_1.C.ACK) {
            // If ackWait is true, then this is the ACK to the initial INVITE,
            // otherwise this is an ACK to an in dialog INVITE. In either case,
            // guard to make sure the sequence number of the ACK matches the INVITE.
            if (this.ackWait) {
                if (this.initialTransaction instanceof transactions_1.InviteClientTransaction) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                if (this.initialTransaction.request.cseq !== message.cseq) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                // Update before the delegate has a chance to handle the
                // message as delegate may callback into this dialog.
                this.ackWait = false;
            }
            else {
                if (!this.reinviteUserAgentServer) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                this.reinviteUserAgentServer = undefined;
            }
            this.signalingStateTransition(message);
            if (this.delegate && this.delegate.onAck) {
                this.delegate.onAck({ message: message });
            }
            return;
        }
        // Request within a dialog out of sequence guard.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (!this.sequenceGuard(message)) {
            this.logger.log("INVITE dialog " + this.id + " rejected out of order " + message.method + " request.");
            return;
        }
        if (message.method === messages_1.C.INVITE) {
            // A UAS that receives a second INVITE before it sends the final
            // response to a first INVITE with a lower CSeq sequence number on the
            // same dialog MUST return a 500 (Server Internal Error) response to the
            // second INVITE and MUST include a Retry-After header field with a
            // randomly chosen value of between 0 and 10 seconds.
            // https://tools.ietf.org/html/rfc3261#section-14.2
            if (this.reinviteUserAgentServer) {
                // https://tools.ietf.org/html/rfc3261#section-20.33
                var retryAfter = Math.floor((Math.random() * 10)) + 1;
                var extraHeaders = ["Retry-After: " + retryAfter];
                this.core.replyStateless(message, { statusCode: 500, extraHeaders: extraHeaders });
                return;
            }
            // A UAS that receives an INVITE on a dialog while an INVITE it had sent
            // on that dialog is in progress MUST return a 491 (Request Pending)
            // response to the received INVITE.
            // https://tools.ietf.org/html/rfc3261#section-14.2
            if (this.reinviteUserAgentClient) {
                this.core.replyStateless(message, { statusCode: 491 });
                return;
            }
        }
        // Request within a dialog common processing.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        _super.prototype.receiveRequest.call(this, message);
        // Requests within a dialog MAY contain Record-Route and Contact header
        // fields.  However, these requests do not cause the dialog's route set
        // to be modified, although they may modify the remote target URI.
        // Specifically, requests that are not target refresh requests do not
        // modify the dialog's remote target URI, and requests that are target
        // refresh requests do.  For dialogs that have been established with an
        // INVITE, the only target refresh request defined is re-INVITE (see
        // Section 14).  Other extensions may define different target refresh
        // requests for dialogs established in other ways.
        //
        //    Note that an ACK is NOT a target refresh request.
        //
        // Target refresh requests only update the dialog's remote target URI,
        // and not the route set formed from the Record-Route.  Updating the
        // latter would introduce severe backwards compatibility problems with
        // RFC 2543-compliant systems.
        // https://tools.ietf.org/html/rfc3261#section-15
        if (message.method === messages_1.C.INVITE) {
            // FIXME: parser needs to be typed...
            var contact = message.parseHeader("contact");
            if (!contact) { // TODO: Review to make sure this will never happen
                throw new Error("Contact undefined.");
            }
            if (!(contact instanceof messages_1.NameAddrHeader)) {
                throw new Error("Contact not instance of NameAddrHeader.");
            }
            this.dialogState.remoteTarget = contact.uri;
        }
        // Switch on method and then delegate.
        switch (message.method) {
            case messages_1.C.BYE:
                // A UAS core receiving a BYE request for an existing dialog MUST follow
                // the procedures of Section 12.2.2 to process the request.  Once done,
                // the UAS SHOULD terminate the session (and therefore stop sending and
                // listening for media).  The only case where it can elect not to are
                // multicast sessions, where participation is possible even if the other
                // participant in the dialog has terminated its involvement in the
                // session.  Whether or not it ends its participation on the session,
                // the UAS core MUST generate a 2xx response to the BYE, and MUST pass
                // that to the server transaction for transmission.
                //
                // The UAS MUST still respond to any pending requests received for that
                // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
                // be generated to those pending requests.
                // https://tools.ietf.org/html/rfc3261#section-15.1.2
                {
                    var uas = new bye_user_agent_server_1.ByeUserAgentServer(this, message);
                    this.delegate && this.delegate.onBye ?
                        this.delegate.onBye(uas) :
                        uas.accept();
                    this.dispose();
                }
                break;
            case messages_1.C.INFO:
                // If a UA receives an INFO request associated with an Info Package that
                // the UA has not indicated willingness to receive, the UA MUST send a
                // 469 (Bad Info Package) response (see Section 11.6), which contains a
                // Recv-Info header field with Info Packages for which the UA is willing
                // to receive INFO requests.
                {
                    var uas = new info_user_agent_server_1.InfoUserAgentServer(this, message);
                    this.delegate && this.delegate.onInfo ?
                        this.delegate.onInfo(uas) :
                        uas.reject({
                            statusCode: 469,
                            extraHeaders: ["Recv-Info :"]
                        });
                }
                break;
            case messages_1.C.INVITE:
                // If the new session description is not acceptable, the UAS can reject
                // it by returning a 488 (Not Acceptable Here) response for the re-
                // INVITE.  This response SHOULD include a Warning header field.
                // https://tools.ietf.org/html/rfc3261#section-14.2
                {
                    var uas = new re_invite_user_agent_server_1.ReInviteUserAgentServer(this, message);
                    this.signalingStateTransition(message);
                    this.delegate && this.delegate.onInvite ?
                        this.delegate.onInvite(uas) :
                        uas.reject({ statusCode: 488 }); // TODO: Warning header field.
                }
                break;
            case messages_1.C.MESSAGE:
                {
                    var uas = new message_user_agent_server_1.MessageUserAgentServer(this.core, message);
                    this.delegate && this.delegate.onMessage ?
                        this.delegate.onMessage(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.NOTIFY:
                // https://tools.ietf.org/html/rfc3515#section-2.4.4
                {
                    var uas = new notify_user_agent_server_1.NotifyUserAgentServer(this, message);
                    this.delegate && this.delegate.onNotify ?
                        this.delegate.onNotify(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.PRACK:
                // https://tools.ietf.org/html/rfc3262#section-4
                {
                    var uas = new prack_user_agent_server_1.PrackUserAgentServer(this, message);
                    this.delegate && this.delegate.onPrack ?
                        this.delegate.onPrack(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.REFER:
                // https://tools.ietf.org/html/rfc3515#section-2.4.2
                {
                    var uas = new refer_user_agent_server_1.ReferUserAgentServer(this, message);
                    this.delegate && this.delegate.onRefer ?
                        this.delegate.onRefer(uas) :
                        uas.reject();
                }
                break;
            default:
                {
                    this.logger.log("INVITE dialog " + this.id + " received unimplemented " + message.method + " request");
                    this.core.replyStateless(message, { statusCode: 501 });
                }
                break;
        }
    };
    SessionDialog.prototype.reliableSequenceGuard = function (message) {
        var statusCode = message.statusCode;
        if (!statusCode) {
            throw new Error("Status code undefined");
        }
        if (statusCode > 100 && statusCode < 200) {
            // If a provisional response is received for an initial request, and
            // that response contains a Require header field containing the option
            // tag 100rel, the response is to be sent reliably.  If the response is
            // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
            // ignored, and the procedures below MUST NOT be used.
            // https://tools.ietf.org/html/rfc3262#section-4
            var requireHeader = message.getHeader("require");
            var rseqHeader = message.getHeader("rseq");
            var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
            if (rseq) {
                // Handling of subsequent reliable provisional responses for the same
                // initial request follows the same rules as above, with the following
                // difference: reliable provisional responses are guaranteed to be in
                // order.  As a result, if the UAC receives another reliable provisional
                // response to the same request, and its RSeq value is not one higher
                // than the value of the sequence number, that response MUST NOT be
                // acknowledged with a PRACK, and MUST NOT be processed further by the
                // UAC.  An implementation MAY discard the response, or MAY cache the
                // response in the hopes of receiving the missing responses.
                // https://tools.ietf.org/html/rfc3262#section-4
                if (this.rseq && this.rseq + 1 !== rseq) {
                    return false;
                }
                // Once a reliable provisional response is received, retransmissions of
                // that response MUST be discarded.  A response is a retransmission when
                // its dialog ID, CSeq, and RSeq match the original response.  The UAC
                // MUST maintain a sequence number that indicates the most recently
                // received in-order reliable provisional response for the initial
                // request.  This sequence number MUST be maintained until a final
                // response is received for the initial request.  Its value MUST be
                // initialized to the RSeq header field in the first reliable
                // provisional response received for the initial request.
                // https://tools.ietf.org/html/rfc3262#section-4
                if (!this.rseq) {
                    this.rseq = rseq;
                }
            }
        }
        return true;
    };
    /**
     * If not in a stable signaling state, rollback to prior stable signaling state.
     */
    SessionDialog.prototype.signalingStateRollback = function () {
        if (this._signalingState === session_1.SignalingState.HaveLocalOffer ||
            this.signalingState === session_1.SignalingState.HaveRemoteOffer) {
            if (this._rollbackOffer && this._rollbackAnswer) {
                this._signalingState = session_1.SignalingState.Stable;
                this._offer = this._rollbackOffer;
                this._answer = this._rollbackAnswer;
            }
        }
    };
    /**
     * Update the signaling state of the dialog.
     * @param message - The message to base the update off of.
     */
    SessionDialog.prototype.signalingStateTransition = function (message) {
        var body = messages_1.getBody(message);
        // No body, no session. No, woman, no cry.
        if (!body || body.contentDisposition !== "session") {
            return;
        }
        // We've got an existing offer and answer which we may wish to rollback to
        if (this._signalingState === session_1.SignalingState.Stable) {
            this._rollbackOffer = this._offer;
            this._rollbackAnswer = this._answer;
        }
        // We're in UAS role, receiving incoming request with session description
        if (message instanceof messages_1.IncomingRequestMessage) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveRemoteOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
        // We're in UAC role, receiving incoming response with session description
        if (message instanceof messages_1.IncomingResponseMessage) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveRemoteOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
        // We're in UAC role, sending outgoing request with session description
        if (message instanceof messages_1.OutgoingRequestMessage) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveLocalOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
        // We're in UAS role, sending outgoing response with session description
        if (messages_1.isBody(message)) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveLocalOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
    };
    SessionDialog.prototype.start2xxRetransmissionTimer = function () {
        var _this = this;
        if (this.initialTransaction instanceof transactions_1.InviteServerTransaction) {
            var transaction_1 = this.initialTransaction;
            // Once the response has been constructed, it is passed to the INVITE
            // server transaction.  In order to ensure reliable end-to-end
            // transport of the response, it is necessary to periodically pass
            // the response directly to the transport until the ACK arrives.  The
            // 2xx response is passed to the transport with an interval that
            // starts at T1 seconds and doubles for each retransmission until it
            // reaches T2 seconds (T1 and T2 are defined in Section 17).
            // Response retransmissions cease when an ACK request for the
            // response is received.  This is independent of whatever transport
            // protocols are used to send the response.
            // https://tools.ietf.org/html/rfc6026#section-8.1
            var timeout_1 = timers_1.Timers.T1;
            var retransmission_1 = function () {
                if (!_this.ackWait) {
                    _this.invite2xxTimer = undefined;
                    return;
                }
                _this.logger.log("No ACK for 2xx response received, attempting retransmission");
                transaction_1.retransmitAcceptedResponse();
                timeout_1 = Math.min(timeout_1 * 2, timers_1.Timers.T2);
                _this.invite2xxTimer = setTimeout(retransmission_1, timeout_1);
            };
            this.invite2xxTimer = setTimeout(retransmission_1, timeout_1);
            // If the server retransmits the 2xx response for 64*T1 seconds without
            // receiving an ACK, the dialog is confirmed, but the session SHOULD be
            // terminated.  This is accomplished with a BYE, as described in Section 15.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            var stateChanged_1 = function () {
                if (transaction_1.state === transactions_1.TransactionState.Terminated) {
                    transaction_1.removeListener("stateChanged", stateChanged_1);
                    if (_this.invite2xxTimer) {
                        clearTimeout(_this.invite2xxTimer);
                        _this.invite2xxTimer = undefined;
                    }
                    if (_this.ackWait) {
                        if (_this.delegate && _this.delegate.onAckTimeout) {
                            _this.delegate.onAckTimeout();
                        }
                        else {
                            _this.bye();
                        }
                    }
                }
            };
            transaction_1.addListener("stateChanged", stateChanged_1);
        }
    };
    // FIXME: Refactor
    SessionDialog.prototype.startReInvite2xxRetransmissionTimer = function () {
        var _this = this;
        if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof transactions_1.InviteServerTransaction) {
            var transaction_2 = this.reinviteUserAgentServer.transaction;
            // Once the response has been constructed, it is passed to the INVITE
            // server transaction.  In order to ensure reliable end-to-end
            // transport of the response, it is necessary to periodically pass
            // the response directly to the transport until the ACK arrives.  The
            // 2xx response is passed to the transport with an interval that
            // starts at T1 seconds and doubles for each retransmission until it
            // reaches T2 seconds (T1 and T2 are defined in Section 17).
            // Response retransmissions cease when an ACK request for the
            // response is received.  This is independent of whatever transport
            // protocols are used to send the response.
            // https://tools.ietf.org/html/rfc6026#section-8.1
            var timeout_2 = timers_1.Timers.T1;
            var retransmission_2 = function () {
                if (!_this.reinviteUserAgentServer) {
                    _this.invite2xxTimer = undefined;
                    return;
                }
                _this.logger.log("No ACK for 2xx response received, attempting retransmission");
                transaction_2.retransmitAcceptedResponse();
                timeout_2 = Math.min(timeout_2 * 2, timers_1.Timers.T2);
                _this.invite2xxTimer = setTimeout(retransmission_2, timeout_2);
            };
            this.invite2xxTimer = setTimeout(retransmission_2, timeout_2);
            // If the server retransmits the 2xx response for 64*T1 seconds without
            // receiving an ACK, the dialog is confirmed, but the session SHOULD be
            // terminated.  This is accomplished with a BYE, as described in Section 15.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            var stateChanged_2 = function () {
                if (transaction_2.state === transactions_1.TransactionState.Terminated) {
                    transaction_2.removeListener("stateChanged", stateChanged_2);
                    if (_this.invite2xxTimer) {
                        clearTimeout(_this.invite2xxTimer);
                        _this.invite2xxTimer = undefined;
                    }
                    if (_this.reinviteUserAgentServer) {
                        // FIXME: TODO: What to do here
                    }
                }
            };
            transaction_2.addListener("stateChanged", stateChanged_2);
        }
    };
    return SessionDialog;
}(dialog_1.Dialog));
exports.SessionDialog = SessionDialog;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var subscription_1 = __webpack_require__(/*! ../subscription */ "./node_modules/sip.js/lib/core/subscription/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var allowed_methods_1 = __webpack_require__(/*! ../user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var notify_user_agent_server_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js");
var re_subscribe_user_agent_client_1 = __webpack_require__(/*! ../user-agents/re-subscribe-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js");
var dialog_1 = __webpack_require__(/*! ./dialog */ "./node_modules/sip.js/lib/core/dialogs/dialog.js");
/**
 * Subscription Dialog.
 * @remarks
 * SIP-Specific Event Notification
 *
 * Abstract
 *
 *    This document describes an extension to the Session Initiation
 *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is
 *    to provide an extensible framework by which SIP nodes can request
 *    notification from remote nodes indicating that certain events have
 *    occurred.
 *
 *    Note that the event notification mechanisms defined herein are NOT
 *    intended to be a general-purpose infrastructure for all classes of
 *    event subscription and notification.
 *
 *    This document represents a backwards-compatible improvement on the
 *    original mechanism described by RFC 3265, taking into account several
 *    years of implementation experience.  Accordingly, this document
 *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to
 *    accommodate some small changes to the mechanism that were discussed
 *    in that document.
 *
 *  https://tools.ietf.org/html/rfc6665
 * @public
 */
var SubscriptionDialog = /** @class */ (function (_super) {
    tslib_1.__extends(SubscriptionDialog, _super);
    function SubscriptionDialog(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {
        var _this = _super.call(this, core, state) || this;
        _this.delegate = delegate;
        _this._autoRefresh = false;
        _this._subscriptionEvent = subscriptionEvent;
        _this._subscriptionExpires = subscriptionExpires;
        _this._subscriptionExpiresInitial = subscriptionExpires;
        _this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
        _this._subscriptionRefresh = undefined;
        _this._subscriptionRefreshLastSet = undefined;
        _this._subscriptionState = subscriptionState;
        _this.logger = core.loggerFactory.getLogger("sip.subscribe-dialog");
        _this.logger.log("SUBSCRIBE dialog " + _this.id + " constructed");
        return _this;
    }
    /**
     * When a UAC receives a response that establishes a dialog, it
     * constructs the state of the dialog.  This state MUST be maintained
     * for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.2
     * @param outgoingRequestMessage - Outgoing request message for dialog.
     * @param incomingResponseMessage - Incoming response message creating dialog.
     */
    SubscriptionDialog.initialDialogStateForSubscription = function (outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {
        // If the request was sent over TLS, and the Request-URI contained a
        // SIPS URI, the "secure" flag is set to TRUE.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var secure = false; // FIXME: Currently no support for TLS.
        // The route set MUST be set to the list of URIs in the Record-Route
        // header field from the response, taken in reverse order and preserving
        // all URI parameters.  If no Record-Route header field is present in
        // the response, the route set MUST be set to the empty set.  This route
        // set, even if empty, overrides any pre-existing route set for future
        // requests in this dialog.  The remote target MUST be set to the URI
        // from the Contact header field of the response.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var routeSet = incomingNotifyRequestMessage.getHeaders("record-route");
        var contact = incomingNotifyRequestMessage.parseHeader("contact");
        if (!contact) { // TODO: Review to make sure this will never happen
            throw new Error("Contact undefined.");
        }
        if (!(contact instanceof messages_1.NameAddrHeader)) {
            throw new Error("Contact not instance of NameAddrHeader.");
        }
        var remoteTarget = contact.uri;
        // The local sequence number MUST be set to the value of the sequence
        // number in the CSeq header field of the request.  The remote sequence
        // number MUST be empty (it is established when the remote UA sends a
        // request within the dialog).  The call identifier component of the
        // dialog ID MUST be set to the value of the Call-ID in the request.
        // The local tag component of the dialog ID MUST be set to the tag in
        // the From field in the request, and the remote tag component of the
        // dialog ID MUST be set to the tag in the To field of the response.  A
        // UAC MUST be prepared to receive a response without a tag in the To
        // field, in which case the tag is considered to have a value of null.
        //
        //    This is to maintain backwards compatibility with RFC 2543, which
        //    did not mandate To tags.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var localSequenceNumber = outgoingSubscribeRequestMessage.cseq;
        var remoteSequenceNumber = undefined;
        var callId = outgoingSubscribeRequestMessage.callId;
        var localTag = outgoingSubscribeRequestMessage.fromTag;
        var remoteTag = incomingNotifyRequestMessage.fromTag;
        if (!callId) { // TODO: Review to make sure this will never happen
            throw new Error("Call id undefined.");
        }
        if (!localTag) { // TODO: Review to make sure this will never happen
            throw new Error("From tag undefined.");
        }
        if (!remoteTag) { // TODO: Review to make sure this will never happen
            throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
        }
        // The remote URI MUST be set to the URI in the To field, and the local
        // URI MUST be set to the URI in the From field.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        if (!outgoingSubscribeRequestMessage.from) { // TODO: Review to make sure this will never happen
            throw new Error("From undefined.");
        }
        if (!outgoingSubscribeRequestMessage.to) { // TODO: Review to make sure this will never happen
            throw new Error("To undefined.");
        }
        var localURI = outgoingSubscribeRequestMessage.from.uri;
        var remoteURI = outgoingSubscribeRequestMessage.to.uri;
        // A dialog can also be in the "early" state, which occurs when it is
        // created with a provisional response, and then transition to the
        // "confirmed" state when a 2xx final response arrives.
        // https://tools.ietf.org/html/rfc3261#section-12
        var early = false;
        var dialogState = {
            id: callId + localTag + remoteTag,
            early: early,
            callId: callId,
            localTag: localTag,
            remoteTag: remoteTag,
            localSequenceNumber: localSequenceNumber,
            remoteSequenceNumber: remoteSequenceNumber,
            localURI: localURI,
            remoteURI: remoteURI,
            remoteTarget: remoteTarget,
            routeSet: routeSet,
            secure: secure
        };
        return dialogState;
    };
    SubscriptionDialog.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this.N) {
            clearTimeout(this.N);
            this.N = undefined;
        }
        this.refreshTimerClear();
        this.logger.log("SUBSCRIBE dialog " + this.id + " destroyed");
    };
    Object.defineProperty(SubscriptionDialog.prototype, "autoRefresh", {
        get: function () {
            return this._autoRefresh;
        },
        set: function (autoRefresh) {
            this._autoRefresh = true;
            this.refreshTimerSet();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionEvent", {
        get: function () {
            return this._subscriptionEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionExpires", {
        /** Number of seconds until subscription expires. */
        get: function () {
            var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;
            var secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;
            return Math.max(secondsUntilExpires, 0);
        },
        set: function (expires) {
            if (expires < 0) {
                throw new Error("Expires must be greater than or equal to zero.");
            }
            this._subscriptionExpires = expires;
            this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
            if (this.autoRefresh) {
                var refresh = this.subscriptionRefresh;
                if (refresh === undefined || refresh >= expires) {
                    this.refreshTimerSet();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionExpiresInitial", {
        get: function () {
            return this._subscriptionExpiresInitial;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionRefresh", {
        /** Number of seconds until subscription auto refresh. */
        get: function () {
            if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {
                return undefined;
            }
            var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;
            var secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;
            return Math.max(secondsUntilExpires, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionState", {
        get: function () {
            return this._subscriptionState;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Receive in dialog request message from transport.
     * @param message -  The incoming request message.
     */
    SubscriptionDialog.prototype.receiveRequest = function (message) {
        this.logger.log("SUBSCRIBE dialog " + this.id + " received " + message.method + " request");
        // Request within a dialog out of sequence guard.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (!this.sequenceGuard(message)) {
            this.logger.log("SUBSCRIBE dialog " + this.id + " rejected out of order " + message.method + " request.");
            return;
        }
        // Request within a dialog common processing.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        _super.prototype.receiveRequest.call(this, message);
        // Switch on method and then delegate.
        switch (message.method) {
            case messages_1.C.NOTIFY:
                this.onNotify(message);
                break;
            default:
                this.logger.log("SUBSCRIBE dialog " + this.id + " received unimplemented " + message.method + " request");
                this.core.replyStateless(message, { statusCode: 501 });
                break;
        }
    };
    /**
     * 4.1.2.2.  Refreshing of Subscriptions
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     */
    SubscriptionDialog.prototype.refresh = function () {
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        var options = {};
        options.extraHeaders = (options.extraHeaders || []).slice();
        options.extraHeaders.push(allowHeader);
        options.extraHeaders.push("Event: " + this.subscriptionEvent);
        options.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial);
        options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
        return this.subscribe(undefined, options);
    };
    /**
     * 4.1.2.2.  Refreshing of Subscriptions
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     * @param delegate - Delegate to handle responses.
     * @param options - Options bucket.
     */
    SubscriptionDialog.prototype.subscribe = function (delegate, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.subscriptionState !== subscription_1.SubscriptionState.Pending && this.subscriptionState !== subscription_1.SubscriptionState.Active) {
            // FIXME: This needs to be a proper exception
            throw new Error("Invalid state " + this.subscriptionState + ". May only re-subscribe while in state \"pending\" or \"active\".");
        }
        this.logger.log("SUBSCRIBE dialog " + this.id + " sending SUBSCRIBE request");
        var uac = new re_subscribe_user_agent_client_1.ReSubscribeUserAgentClient(this, delegate, options);
        // When refreshing a subscription, a subscriber starts Timer N, set to
        // 64*T1, when it sends the SUBSCRIBE request.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
        this.N = setTimeout(function () { return _this.timer_N(); }, timers_1.Timers.TIMER_N);
        return uac;
    };
    /**
     * 4.4.1.  Dialog Creation and Termination
     * A subscription is destroyed after a notifier sends a NOTIFY request
     * with a "Subscription-State" of "terminated", or in certain error
     * situations described elsewhere in this document.
     * https://tools.ietf.org/html/rfc6665#section-4.4.1
     */
    SubscriptionDialog.prototype.terminate = function () {
        this.stateTransition(subscription_1.SubscriptionState.Terminated);
        this.onTerminated();
    };
    /**
     * 4.1.2.3.  Unsubscribing
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.3
     */
    SubscriptionDialog.prototype.unsubscribe = function () {
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        var options = {};
        options.extraHeaders = (options.extraHeaders || []).slice();
        options.extraHeaders.push(allowHeader);
        options.extraHeaders.push("Event: " + this.subscriptionEvent);
        options.extraHeaders.push("Expires: 0");
        options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
        return this.subscribe(undefined, options);
    };
    /**
     * Handle in dialog NOTIFY requests.
     * This does not include the first NOTIFY which created the dialog.
     * @param message - The incoming NOTIFY request message.
     */
    SubscriptionDialog.prototype.onNotify = function (message) {
        // If, for some reason, the event package designated in the "Event"
        // header field of the NOTIFY request is not supported, the subscriber
        // will respond with a 489 (Bad Event) response.
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var event = message.parseHeader("Event").event;
        if (!event || event !== this.subscriptionEvent) {
            this.core.replyStateless(message, { statusCode: 489 });
            return;
        }
        // In the state diagram, "Re-subscription times out" means that an
        // attempt to refresh or update the subscription using a new SUBSCRIBE
        // request does not result in a NOTIFY request before the corresponding
        // Timer N expires.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2
        if (this.N) {
            clearTimeout(this.N);
            this.N = undefined;
        }
        // NOTIFY requests MUST contain "Subscription-State" header fields that
        // indicate the status of the subscription.
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var subscriptionState = message.parseHeader("Subscription-State");
        if (!subscriptionState || !subscriptionState.state) {
            this.core.replyStateless(message, { statusCode: 489 });
            return;
        }
        var state = subscriptionState.state;
        var expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined;
        // Update our state and expiration.
        switch (state) {
            case "pending":
                this.stateTransition(subscription_1.SubscriptionState.Pending, expires);
                break;
            case "active":
                this.stateTransition(subscription_1.SubscriptionState.Active, expires);
                break;
            case "terminated":
                this.stateTransition(subscription_1.SubscriptionState.Terminated, expires);
                break;
            default:
                this.logger.warn("Unrecognized subscription state.");
                break;
        }
        // Delegate remainder of NOTIFY handling.
        var uas = new notify_user_agent_server_1.NotifyUserAgentServer(this, message);
        if (this.delegate && this.delegate.onNotify) {
            this.delegate.onNotify(uas);
        }
        else {
            uas.accept();
        }
    };
    SubscriptionDialog.prototype.onRefresh = function (request) {
        if (this.delegate && this.delegate.onRefresh) {
            this.delegate.onRefresh(request);
        }
    };
    SubscriptionDialog.prototype.onTerminated = function () {
        if (this.delegate && this.delegate.onTerminated) {
            this.delegate.onTerminated();
        }
    };
    SubscriptionDialog.prototype.refreshTimerClear = function () {
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
            this.refreshTimer = undefined;
        }
    };
    SubscriptionDialog.prototype.refreshTimerSet = function () {
        var _this = this;
        this.refreshTimerClear();
        if (this.autoRefresh && this.subscriptionExpires > 0) {
            var refresh = this.subscriptionExpires * 900;
            this._subscriptionRefresh = Math.floor(refresh / 1000);
            this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);
            this.refreshTimer = setTimeout(function () {
                _this.refreshTimer = undefined;
                _this._subscriptionRefresh = undefined;
                _this._subscriptionRefreshLastSet = undefined;
                _this.onRefresh(_this.refresh());
            }, refresh);
        }
    };
    SubscriptionDialog.prototype.stateTransition = function (newState, newExpires) {
        var _this = this;
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            _this.logger.warn("Invalid subscription state transition from " + _this.subscriptionState + " to " + newState);
        };
        switch (newState) {
            case subscription_1.SubscriptionState.Initial:
                invalidStateTransition();
                return;
            case subscription_1.SubscriptionState.NotifyWait:
                invalidStateTransition();
                return;
            case subscription_1.SubscriptionState.Pending:
                if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Pending) {
                    invalidStateTransition();
                    return;
                }
                break;
            case subscription_1.SubscriptionState.Active:
                if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Pending &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                    invalidStateTransition();
                    return;
                }
                break;
            case subscription_1.SubscriptionState.Terminated:
                if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Pending &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                    invalidStateTransition();
                    return;
                }
                break;
            default:
                invalidStateTransition();
                return;
        }
        // If the "Subscription-State" value is "pending", the subscription has
        // been received by the notifier, but there is insufficient policy
        // information to grant or deny the subscription yet.  If the header
        // field also contains an "expires" parameter, the subscriber SHOULD
        // take it as the authoritative subscription duration and adjust
        // accordingly.  No further action is necessary on the part of the
        // subscriber.  The "retry-after" and "reason" parameters have no
        // semantics for "pending".
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        if (newState === subscription_1.SubscriptionState.Pending) {
            if (newExpires) {
                this.subscriptionExpires = newExpires;
            }
        }
        // If the "Subscription-State" header field value is "active", it means
        // that the subscription has been accepted and (in general) has been
        // authorized.  If the header field also contains an "expires"
        // parameter, the subscriber SHOULD take it as the authoritative
        // subscription duration and adjust accordingly.  The "retry-after" and
        // "reason" parameters have no semantics for "active".
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        if (newState === subscription_1.SubscriptionState.Active) {
            if (newExpires) {
                this.subscriptionExpires = newExpires;
            }
        }
        // If the "Subscription-State" value is "terminated", the subscriber
        // MUST consider the subscription terminated.  The "expires" parameter
        // has no semantics for "terminated" -- notifiers SHOULD NOT include an
        // "expires" parameter on a "Subscription-State" header field with a
        // value of "terminated", and subscribers MUST ignore any such
        // parameter, if present.
        if (newState === subscription_1.SubscriptionState.Terminated) {
            this.dispose();
        }
        this._subscriptionState = newState;
    };
    /**
     * When refreshing a subscription, a subscriber starts Timer N, set to
     * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires
     * prior to the receipt of a NOTIFY request, the subscriber considers
     * the subscription terminated.  If the subscriber receives a success
     * response to the SUBSCRIBE request that indicates that no NOTIFY
     * request will be generated -- such as the 204 response defined for use
     * with the optional extension described in [RFC5839] -- then it MUST
     * cancel Timer N.
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     */
    SubscriptionDialog.prototype.timer_N = function () {
        if (this.subscriptionState !== subscription_1.SubscriptionState.Terminated) {
            this.stateTransition(subscription_1.SubscriptionState.Terminated);
            this.onTerminated();
        }
    };
    return SubscriptionDialog;
}(dialog_1.Dialog));
exports.SubscriptionDialog = SubscriptionDialog;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/exception.js":
/*!**************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/exception.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * An Exception is considered a condition that a reasonable application may wish to catch.
 * An Error indicates serious problems that a reasonable application should not try to catch.
 * @public
 */
var Exception = /** @class */ (function (_super) {
    tslib_1.__extends(Exception, _super);
    function Exception(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain
        return _this;
    }
    return Exception;
}(Error));
exports.Exception = Exception;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./exception */ "./node_modules/sip.js/lib/core/exceptions/exception.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transaction-state-error */ "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transport-error */ "./node_modules/sip.js/lib/core/exceptions/transport-error.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var exception_1 = __webpack_require__(/*! ./exception */ "./node_modules/sip.js/lib/core/exceptions/exception.js");
/**
 * Indicates that the operation could not be completed given the current transaction state.
 * @public
 */
var TransactionStateError = /** @class */ (function (_super) {
    tslib_1.__extends(TransactionStateError, _super);
    function TransactionStateError(message) {
        return _super.call(this, message ? message : "Transaction state error.") || this;
    }
    return TransactionStateError;
}(exception_1.Exception));
exports.TransactionStateError = TransactionStateError;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/transport-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/transport-error.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var exception_1 = __webpack_require__(/*! ./exception */ "./node_modules/sip.js/lib/core/exceptions/exception.js");
/**
 * Transport error.
 * @public
 */
var TransportError = /** @class */ (function (_super) {
    tslib_1.__extends(TransportError, _super);
    function TransportError(message) {
        return _super.call(this, message ? message : "Unspecified transport error.") || this;
    }
    return TransportError;
}(exception_1.Exception));
exports.TransportError = TransportError;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/index.js":
/*!***********************************************!*\
  !*** ./node_modules/sip.js/lib/core/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A core library implementing low level SIP protocol elements.
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Directories
tslib_1.__exportStar(__webpack_require__(/*! ./dialogs */ "./node_modules/sip.js/lib/core/dialogs/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./log */ "./node_modules/sip.js/lib/core/log/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/sip.js/lib/core/messages/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./node_modules/sip.js/lib/core/session/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./node_modules/sip.js/lib/core/subscription/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transactions */ "./node_modules/sip.js/lib/core/transactions/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-core */ "./node_modules/sip.js/lib/core/user-agent-core/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agents */ "./node_modules/sip.js/lib/core/user-agents/index.js"), exports);
// Files
tslib_1.__exportStar(__webpack_require__(/*! ./timers */ "./node_modules/sip.js/lib/core/timers.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/index.js":
/*!***************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./levels */ "./node_modules/sip.js/lib/core/log/levels.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./logger-factory */ "./node_modules/sip.js/lib/core/log/logger-factory.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./logger */ "./node_modules/sip.js/lib/core/log/logger.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/levels.js":
/*!****************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/levels.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Log levels.
 * @public
 */
var Levels;
(function (Levels) {
    Levels[Levels["error"] = 0] = "error";
    Levels[Levels["warn"] = 1] = "warn";
    Levels[Levels["log"] = 2] = "log";
    Levels[Levels["debug"] = 3] = "debug";
})(Levels = exports.Levels || (exports.Levels = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/logger-factory.js":
/*!************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/logger-factory.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var levels_1 = __webpack_require__(/*! ./levels */ "./node_modules/sip.js/lib/core/log/levels.js");
var logger_1 = __webpack_require__(/*! ./logger */ "./node_modules/sip.js/lib/core/log/logger.js");
/**
 * Logger.
 * @public
 */
var LoggerFactory = /** @class */ (function () {
    function LoggerFactory() {
        this.builtinEnabled = true;
        this._level = levels_1.Levels.log;
        this.loggers = {};
        this.logger = this.getLogger("sip:loggerfactory");
    }
    Object.defineProperty(LoggerFactory.prototype, "level", {
        get: function () { return this._level; },
        set: function (newLevel) {
            if (newLevel >= 0 && newLevel <= 3) {
                this._level = newLevel;
            }
            else if (newLevel > 3) {
                this._level = 3;
            }
            else if (levels_1.Levels.hasOwnProperty(newLevel)) {
                this._level = newLevel;
            }
            else {
                this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoggerFactory.prototype, "connector", {
        get: function () {
            return this._connector;
        },
        set: function (value) {
            if (!value) {
                this._connector = undefined;
            }
            else if (typeof value === "function") {
                this._connector = value;
            }
            else {
                this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    LoggerFactory.prototype.getLogger = function (category, label) {
        if (label && this.level === 3) {
            return new logger_1.Logger(this, category, label);
        }
        else if (this.loggers[category]) {
            return this.loggers[category];
        }
        else {
            var logger = new logger_1.Logger(this, category);
            this.loggers[category] = logger;
            return logger;
        }
    };
    LoggerFactory.prototype.genericLog = function (levelToLog, category, label, content) {
        if (this.level >= levelToLog) {
            if (this.builtinEnabled) {
                this.print(levelToLog, category, label, content);
            }
        }
        if (this.connector) {
            this.connector(levels_1.Levels[levelToLog], category, label, content);
        }
    };
    LoggerFactory.prototype.print = function (levelToLog, category, label, content) {
        if (typeof content === "string") {
            var prefix = [new Date(), category];
            if (label) {
                prefix.push(label);
            }
            content = prefix.concat(content).join(" | ");
        }
        switch (levelToLog) {
            case levels_1.Levels.error:
                // tslint:disable-next-line:no-console
                console.error(content);
                break;
            case levels_1.Levels.warn:
                // tslint:disable-next-line:no-console
                console.warn(content);
                break;
            case levels_1.Levels.log:
                // tslint:disable-next-line:no-console
                console.log(content);
                break;
            case levels_1.Levels.debug:
                // tslint:disable-next-line:no-console
                console.debug(content);
                break;
            default:
                break;
        }
    };
    return LoggerFactory;
}());
exports.LoggerFactory = LoggerFactory;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/logger.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var levels_1 = __webpack_require__(/*! ./levels */ "./node_modules/sip.js/lib/core/log/levels.js");
/**
 * Logger.
 * @public
 */
var Logger = /** @class */ (function () {
    function Logger(logger, category, label) {
        this.logger = logger;
        this.category = category;
        this.label = label;
    }
    Logger.prototype.error = function (content) { this.genericLog(levels_1.Levels.error, content); };
    Logger.prototype.warn = function (content) { this.genericLog(levels_1.Levels.warn, content); };
    Logger.prototype.log = function (content) { this.genericLog(levels_1.Levels.log, content); };
    Logger.prototype.debug = function (content) { this.genericLog(levels_1.Levels.debug, content); };
    Logger.prototype.genericLog = function (level, content) {
        this.logger.genericLog(level, this.category, this.label, content);
    };
    return Logger;
}());
exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/body.js":
/*!*******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/body.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var incoming_request_message_1 = __webpack_require__(/*! ./incoming-request-message */ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js");
var incoming_response_message_1 = __webpack_require__(/*! ./incoming-response-message */ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js");
var outgoing_request_message_1 = __webpack_require__(/*! ./outgoing-request-message */ "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js");
/**
 * Create a Body given a legacy body type.
 * @param bodyLegacy - Body Object
 * @internal
 */
function fromBodyLegacy(bodyLegacy) {
    var content = (typeof bodyLegacy === "string") ? bodyLegacy : bodyLegacy.body;
    var contentType = (typeof bodyLegacy === "string") ? "application/sdp" : bodyLegacy.contentType;
    var contentDisposition = contentTypeToContentDisposition(contentType);
    var body = { contentDisposition: contentDisposition, contentType: contentType, content: content };
    return body;
}
exports.fromBodyLegacy = fromBodyLegacy;
/**
 * Given a message, get a normalized body.
 * The content disposition is inferred if not set.
 * @param message - The message.
 * @internal
 */
function getBody(message) {
    var contentDisposition;
    var contentType;
    var content;
    // We're in UAS role, receiving incoming request
    if (message instanceof incoming_request_message_1.IncomingRequestMessage) {
        if (message.body) {
            // FIXME: Parsing needs typing
            var parse = message.parseHeader("Content-Disposition");
            contentDisposition = parse ? parse.type : undefined;
            contentType = message.parseHeader("Content-Type");
            content = message.body;
        }
    }
    // We're in UAC role, receiving incoming response
    if (message instanceof incoming_response_message_1.IncomingResponseMessage) {
        if (message.body) {
            // FIXME: Parsing needs typing
            var parse = message.parseHeader("Content-Disposition");
            contentDisposition = parse ? parse.type : undefined;
            contentType = message.parseHeader("Content-Type");
            content = message.body;
        }
    }
    // We're in UAC role, sending outgoing request
    if (message instanceof outgoing_request_message_1.OutgoingRequestMessage) {
        if (message.body) {
            contentDisposition = message.getHeader("Content-Disposition");
            contentType = message.getHeader("Content-Type");
            if (typeof message.body === "string") {
                // FIXME: OutgoingRequest should not allow a "string" body without a "Content-Type" header.
                if (!contentType) {
                    throw new Error("Header content type header does not equal body content type.");
                }
                content = message.body;
            }
            else {
                // FIXME: OutgoingRequest should not allow the "Content-Type" header not to match th body content type
                if (contentType && contentType !== message.body.contentType) {
                    throw new Error("Header content type header does not equal body content type.");
                }
                contentType = message.body.contentType;
                content = message.body.body;
            }
        }
    }
    // We're in UAS role, sending outgoing response
    if (isBody(message)) {
        contentDisposition = message.contentDisposition;
        contentType = message.contentType;
        content = message.content;
    }
    // No content, no body.
    if (!content) {
        return undefined;
    }
    if (contentType && !contentDisposition) {
        contentDisposition = contentTypeToContentDisposition(contentType);
    }
    if (!contentDisposition) {
        throw new Error("Content disposition undefined.");
    }
    if (!contentType) {
        throw new Error("Content type undefined.");
    }
    return {
        contentDisposition: contentDisposition,
        contentType: contentType,
        content: content
    };
}
exports.getBody = getBody;
/**
 * User-Defined Type Guard for Body.
 * @param body - Body to check.
 * @internal
 */
function isBody(body) {
    return body &&
        typeof body.content === "string" &&
        typeof body.contentType === "string" &&
        body.contentDisposition === undefined ? true : typeof body.contentDisposition === "string";
}
exports.isBody = isBody;
// If the Content-Disposition header field is missing, bodies of
// Content-Type application/sdp imply the disposition "session", while
// other content types imply "render".
// https://tools.ietf.org/html/rfc3261#section-13.2.1
function contentTypeToContentDisposition(contentType) {
    if (contentType === "application/sdp") {
        return "session";
    }
    else {
        return "render";
    }
}


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/digest-authentication.js":
/*!************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/digest-authentication.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var md5_1 = tslib_1.__importDefault(__webpack_require__(/*! crypto-js/md5 */ "./node_modules/crypto-js/md5.js"));
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * Digest Authentication.
 * @internal
 */
var DigestAuthentication = /** @class */ (function () {
    /**
     * Constructor.
     * @param loggerFactory - LoggerFactory.
     * @param username - Username.
     * @param password - Password.
     */
    function DigestAuthentication(loggerFactory, username, password) {
        this.logger = loggerFactory.getLogger("sipjs.digestauthentication");
        this.username = username;
        this.password = password;
        this.nc = 0;
        this.ncHex = "00000000";
    }
    /**
     * Performs Digest authentication given a SIP request and the challenge
     * received in a response to that request.
     * @param request -
     * @param challenge -
     * @returns true if credentials were successfully generated, false otherwise.
     */
    DigestAuthentication.prototype.authenticate = function (request, challenge, body) {
        // Inspect and validate the challenge.
        this.algorithm = challenge.algorithm;
        this.realm = challenge.realm;
        this.nonce = challenge.nonce;
        this.opaque = challenge.opaque;
        this.stale = challenge.stale;
        if (this.algorithm) {
            if (this.algorithm !== "MD5") {
                this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
                return false;
            }
        }
        else {
            this.algorithm = "MD5";
        }
        if (!this.realm) {
            this.logger.warn("challenge without Digest realm, authentication aborted");
            return false;
        }
        if (!this.nonce) {
            this.logger.warn("challenge without Digest nonce, authentication aborted");
            return false;
        }
        // 'qop' can contain a list of values (Array). Let's choose just one.
        if (challenge.qop) {
            if (challenge.qop.indexOf("auth") > -1) {
                this.qop = "auth";
            }
            else if (challenge.qop.indexOf("auth-int") > -1) {
                this.qop = "auth-int";
            }
            else {
                // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
                this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
                return false;
            }
        }
        else {
            this.qop = undefined;
        }
        // Fill other attributes.
        this.method = request.method;
        this.uri = request.ruri;
        this.cnonce = utils_1.createRandomToken(12);
        this.nc += 1;
        this.updateNcHex();
        // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
        if (this.nc === 4294967296) {
            this.nc = 1;
            this.ncHex = "00000001";
        }
        // Calculate the Digest "response" value.
        this.calculateResponse(body);
        return true;
    };
    /**
     * Return the Proxy-Authorization or WWW-Authorization header value.
     */
    DigestAuthentication.prototype.toString = function () {
        var authParams = [];
        if (!this.response) {
            throw new Error("response field does not exist, cannot generate Authorization header");
        }
        authParams.push("algorithm=" + this.algorithm);
        authParams.push('username="' + this.username + '"');
        authParams.push('realm="' + this.realm + '"');
        authParams.push('nonce="' + this.nonce + '"');
        authParams.push('uri="' + this.uri + '"');
        authParams.push('response="' + this.response + '"');
        if (this.opaque) {
            authParams.push('opaque="' + this.opaque + '"');
        }
        if (this.qop) {
            authParams.push("qop=" + this.qop);
            authParams.push('cnonce="' + this.cnonce + '"');
            authParams.push("nc=" + this.ncHex);
        }
        return "Digest " + authParams.join(", ");
    };
    /**
     * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
     */
    DigestAuthentication.prototype.updateNcHex = function () {
        var hex = Number(this.nc).toString(16);
        this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
    };
    /**
     * Generate Digest 'response' value.
     */
    DigestAuthentication.prototype.calculateResponse = function (body) {
        var ha2;
        // HA1 = MD5(A1) = MD5(username:realm:password)
        var ha1 = md5_1.default(this.username + ":" + this.realm + ":" + this.password);
        if (this.qop === "auth") {
            // HA2 = MD5(A2) = MD5(method:digestURI)
            ha2 = md5_1.default(this.method + ":" + this.uri);
            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
            this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
        }
        else if (this.qop === "auth-int") {
            // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
            ha2 = md5_1.default(this.method + ":" + this.uri + ":" + md5_1.default(body ? body : ""));
            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
            this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
        }
        else if (this.qop === undefined) {
            // HA2 = MD5(A2) = MD5(method:digestURI)
            ha2 = md5_1.default(this.method + ":" + this.uri);
            // response = MD5(HA1:nonce:HA2)
            this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + ha2);
        }
    };
    return DigestAuthentication;
}());
exports.DigestAuthentication = DigestAuthentication;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/grammar.js":
/*!**********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/grammar.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var pegGrammar = tslib_1.__importStar(__webpack_require__(/*! ../../grammar/dist/grammar */ "./node_modules/sip.js/lib/grammar/dist/grammar.js"));
/**
 * Grammar.
 * @internal
 */
var Grammar;
(function (Grammar) {
    /**
     * Parse.
     * @param input -
     * @param startRule -
     */
    function parse(input, startRule) {
        var options = { startRule: startRule };
        try {
            pegGrammar.parse(input, options);
        }
        catch (e) {
            options.data = -1;
        }
        return options.data;
    }
    Grammar.parse = parse;
    /**
     * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
     * it is an invalid NameAddrHeader.
     * @param name_addr_header -
     */
    function nameAddrHeaderParse(nameAddrHeader) {
        var parsedNameAddrHeader = Grammar.parse(nameAddrHeader, "Name_Addr_Header");
        return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : undefined;
    }
    Grammar.nameAddrHeaderParse = nameAddrHeaderParse;
    /**
     * Parse the given string and returns a SIP.URI instance or undefined if
     * it is an invalid URI.
     * @param uri -
     */
    function URIParse(uri) {
        var parsedUri = Grammar.parse(uri, "SIP_URI");
        return parsedUri !== -1 ? parsedUri : undefined;
    }
    Grammar.URIParse = URIParse;
})(Grammar = exports.Grammar || (exports.Grammar = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/incoming-message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/incoming-message.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var grammar_1 = __webpack_require__(/*! ./grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * Incoming message.
 * @public
 */
var IncomingMessage = /** @class */ (function () {
    function IncomingMessage() {
        this.headers = {};
    }
    /**
     * Insert a header of the given name and value into the last position of the
     * header array.
     * @param name - header name
     * @param value - header value
     */
    IncomingMessage.prototype.addHeader = function (name, value) {
        var header = { raw: value };
        name = utils_1.headerize(name);
        if (this.headers[name]) {
            this.headers[name].push(header);
        }
        else {
            this.headers[name] = [header];
        }
    };
    /**
     * Get the value of the given header name at the given position.
     * @param name - header name
     * @returns Returns the specified header, undefined if header doesn't exist.
     */
    IncomingMessage.prototype.getHeader = function (name) {
        var header = this.headers[utils_1.headerize(name)];
        if (header) {
            if (header[0]) {
                return header[0].raw;
            }
        }
        else {
            return;
        }
    };
    /**
     * Get the header/s of the given name.
     * @param name - header name
     * @returns Array - with all the headers of the specified name.
     */
    IncomingMessage.prototype.getHeaders = function (name) {
        var header = this.headers[utils_1.headerize(name)];
        var result = [];
        if (!header) {
            return [];
        }
        for (var _i = 0, header_1 = header; _i < header_1.length; _i++) {
            var headerPart = header_1[_i];
            result.push(headerPart.raw);
        }
        return result;
    };
    /**
     * Verify the existence of the given header.
     * @param name - header name
     * @returns true if header with given name exists, false otherwise
     */
    IncomingMessage.prototype.hasHeader = function (name) {
        return !!this.headers[utils_1.headerize(name)];
    };
    /**
     * Parse the given header on the given index.
     * @param name - header name
     * @param idx - header index
     * @returns Parsed header object, undefined if the
     *   header is not present or in case of a parsing error.
     */
    IncomingMessage.prototype.parseHeader = function (name, idx) {
        if (idx === void 0) { idx = 0; }
        name = utils_1.headerize(name);
        if (!this.headers[name]) {
            // this.logger.log("header '" + name + "' not present");
            return;
        }
        else if (idx >= this.headers[name].length) {
            // this.logger.log("not so many '" + name + "' headers present");
            return;
        }
        var header = this.headers[name][idx];
        var value = header.raw;
        if (header.parsed) {
            return header.parsed;
        }
        // substitute '-' by '_' for grammar rule matching.
        var parsed = grammar_1.Grammar.parse(value, name.replace(/-/g, "_"));
        if (parsed === -1) {
            this.headers[name].splice(idx, 1); // delete from headers
            // this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
            return;
        }
        else {
            header.parsed = parsed;
            return parsed;
        }
    };
    /**
     * Message Header attribute selector. Alias of parseHeader.
     * @param name - header name
     * @param idx - header index
     * @returns Parsed header object, undefined if the
     *   header is not present or in case of a parsing error.
     *
     * @example
     * message.s('via',3).port
     */
    IncomingMessage.prototype.s = function (name, idx) {
        if (idx === void 0) { idx = 0; }
        return this.parseHeader(name, idx);
    };
    /**
     * Replace the value of the given header by the value.
     * @param name - header name
     * @param value - header value
     */
    IncomingMessage.prototype.setHeader = function (name, value) {
        this.headers[utils_1.headerize(name)] = [{ raw: value }];
    };
    IncomingMessage.prototype.toString = function () {
        return this.data;
    };
    return IncomingMessage;
}());
exports.IncomingMessage = IncomingMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/incoming-request-message.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var incoming_message_1 = __webpack_require__(/*! ./incoming-message */ "./node_modules/sip.js/lib/core/messages/incoming-message.js");
/**
 * Incoming request message.
 * @public
 */
var IncomingRequestMessage = /** @class */ (function (_super) {
    tslib_1.__extends(IncomingRequestMessage, _super);
    function IncomingRequestMessage() {
        return _super.call(this) || this;
    }
    return IncomingRequestMessage;
}(incoming_message_1.IncomingMessage));
exports.IncomingRequestMessage = IncomingRequestMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/incoming-response-message.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var incoming_message_1 = __webpack_require__(/*! ./incoming-message */ "./node_modules/sip.js/lib/core/messages/incoming-message.js");
/**
 * Incoming response message.
 * @public
 */
var IncomingResponseMessage = /** @class */ (function (_super) {
    tslib_1.__extends(IncomingResponseMessage, _super);
    function IncomingResponseMessage() {
        return _super.call(this) || this;
    }
    return IncomingResponseMessage;
}(incoming_message_1.IncomingMessage));
exports.IncomingResponseMessage = IncomingResponseMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/index.js":
/*!********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Directories
tslib_1.__exportStar(__webpack_require__(/*! ./methods */ "./node_modules/sip.js/lib/core/messages/methods/index.js"), exports);
// Files
tslib_1.__exportStar(__webpack_require__(/*! ./body */ "./node_modules/sip.js/lib/core/messages/body.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./digest-authentication */ "./node_modules/sip.js/lib/core/messages/digest-authentication.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./incoming-message */ "./node_modules/sip.js/lib/core/messages/incoming-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./incoming-request-message */ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./incoming-response-message */ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./name-addr-header */ "./node_modules/sip.js/lib/core/messages/name-addr-header.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./outgoing-request-message */ "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./outgoing-response */ "./node_modules/sip.js/lib/core/messages/outgoing-response.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./parameters */ "./node_modules/sip.js/lib/core/messages/parameters.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./parser */ "./node_modules/sip.js/lib/core/messages/parser.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./uri */ "./node_modules/sip.js/lib/core/messages/uri.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/methods/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/methods/constants.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * SIP Methods
 * @internal
 */
var C;
(function (C) {
    C.ACK = "ACK";
    C.BYE = "BYE";
    C.CANCEL = "CANCEL";
    C.INFO = "INFO";
    C.INVITE = "INVITE";
    C.MESSAGE = "MESSAGE";
    C.NOTIFY = "NOTIFY";
    C.OPTIONS = "OPTIONS";
    C.REGISTER = "REGISTER";
    C.UPDATE = "UPDATE";
    C.SUBSCRIBE = "SUBSCRIBE";
    C.PUBLISH = "PUBLISH";
    C.REFER = "REFER";
    C.PRACK = "PRACK";
})(C = exports.C || (exports.C = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/methods/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/methods/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./constants */ "./node_modules/sip.js/lib/core/messages/methods/constants.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/name-addr-header.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/name-addr-header.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./node_modules/sip.js/lib/core/messages/parameters.js");
/**
 * Name Address SIP header.
 * @public
 */
var NameAddrHeader = /** @class */ (function (_super) {
    tslib_1.__extends(NameAddrHeader, _super);
    /**
     * Constructor
     * @param uri -
     * @param displayName -
     * @param parameters -
     */
    function NameAddrHeader(uri, displayName, parameters) {
        var _this = _super.call(this, parameters) || this;
        _this.uri = uri;
        _this._displayName = displayName;
        return _this;
    }
    Object.defineProperty(NameAddrHeader.prototype, "friendlyName", {
        get: function () {
            return this.displayName || this.uri.aor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NameAddrHeader.prototype, "displayName", {
        get: function () { return this._displayName; },
        set: function (value) {
            this._displayName = value;
        },
        enumerable: true,
        configurable: true
    });
    NameAddrHeader.prototype.clone = function () {
        return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
    };
    NameAddrHeader.prototype.toString = function () {
        var body = (this.displayName || this.displayName === "0") ? '"' + this.displayName + '" ' : "";
        body += "<" + this.uri.toString() + ">";
        for (var parameter in this.parameters) {
            if (this.parameters.hasOwnProperty(parameter)) {
                body += ";" + parameter;
                if (this.parameters[parameter] !== null) {
                    body += "=" + this.parameters[parameter];
                }
            }
        }
        return body;
    };
    return NameAddrHeader;
}(parameters_1.Parameters));
exports.NameAddrHeader = NameAddrHeader;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/outgoing-request-message.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var name_addr_header_1 = __webpack_require__(/*! ./name-addr-header */ "./node_modules/sip.js/lib/core/messages/name-addr-header.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * Outgoing SIP request message.
 * @public
 */
var OutgoingRequestMessage = /** @class */ (function () {
    function OutgoingRequestMessage(method, ruri, fromURI, toURI, options, extraHeaders, body) {
        this.headers = {};
        this.extraHeaders = [];
        this.options = OutgoingRequestMessage.getDefaultOptions();
        // Options - merge a deep copy
        if (options) {
            this.options = tslib_1.__assign(tslib_1.__assign({}, this.options), options);
            if (this.options.optionTags && this.options.optionTags.length) {
                this.options.optionTags = this.options.optionTags.slice();
            }
            if (this.options.routeSet && this.options.routeSet.length) {
                this.options.routeSet = this.options.routeSet.slice();
            }
        }
        // Extra headers - deep copy
        if (extraHeaders && extraHeaders.length) {
            this.extraHeaders = extraHeaders.slice();
        }
        // Body - deep copy
        if (body) {
            // TODO: internal representation should be Body
            // this.body = { ...body };
            this.body = {
                body: body.content,
                contentType: body.contentType
            };
        }
        // Method
        this.method = method;
        // RURI
        this.ruri = ruri.clone();
        // From
        this.fromURI = fromURI.clone();
        this.fromTag = this.options.fromTag ? this.options.fromTag : utils_1.newTag();
        this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);
        // To
        this.toURI = toURI.clone();
        this.toTag = this.options.toTag;
        this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);
        // Call-ID
        this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + utils_1.createRandomToken(15);
        // CSeq
        this.cseq = this.options.cseq;
        // The relative order of header fields with different field names is not
        // significant.  However, it is RECOMMENDED that header fields which are
        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
        // Max-Forwards, and Proxy-Authorization, for example) appear towards
        // the top of the message to facilitate rapid parsing.
        // https://tools.ietf.org/html/rfc3261#section-7.3.1
        this.setHeader("route", this.options.routeSet);
        this.setHeader("via", "");
        this.setHeader("to", this.to.toString());
        this.setHeader("from", this.from.toString());
        this.setHeader("cseq", this.cseq + " " + this.method);
        this.setHeader("call-id", this.callId);
        this.setHeader("max-forwards", "70");
    }
    /** Get a copy of the default options. */
    OutgoingRequestMessage.getDefaultOptions = function () {
        return {
            callId: "",
            callIdPrefix: "",
            cseq: 1,
            toDisplayName: "",
            toTag: "",
            fromDisplayName: "",
            fromTag: "",
            forceRport: false,
            hackViaTcp: false,
            optionTags: ["outbound"],
            routeSet: [],
            userAgentString: "sip.js",
            viaHost: ""
        };
    };
    OutgoingRequestMessage.makeNameAddrHeader = function (uri, displayName, tag) {
        var parameters = {};
        if (tag) {
            parameters.tag = tag;
        }
        return new name_addr_header_1.NameAddrHeader(uri, displayName, parameters);
    };
    /**
     * Get the value of the given header name at the given position.
     * @param name - header name
     * @returns Returns the specified header, undefined if header doesn't exist.
     */
    OutgoingRequestMessage.prototype.getHeader = function (name) {
        var header = this.headers[utils_1.headerize(name)];
        if (header) {
            if (header[0]) {
                return header[0];
            }
        }
        else {
            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
            for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
                var exHeader = _a[_i];
                if (regexp.test(exHeader)) {
                    return exHeader.substring(exHeader.indexOf(":") + 1).trim();
                }
            }
        }
        return;
    };
    /**
     * Get the header/s of the given name.
     * @param name - header name
     * @returns Array with all the headers of the specified name.
     */
    OutgoingRequestMessage.prototype.getHeaders = function (name) {
        var result = [];
        var headerArray = this.headers[utils_1.headerize(name)];
        if (headerArray) {
            for (var _i = 0, headerArray_1 = headerArray; _i < headerArray_1.length; _i++) {
                var headerPart = headerArray_1[_i];
                result.push(headerPart);
            }
        }
        else {
            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
            for (var _a = 0, _b = this.extraHeaders; _a < _b.length; _a++) {
                var exHeader = _b[_a];
                if (regexp.test(exHeader)) {
                    result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
                }
            }
        }
        return result;
    };
    /**
     * Verify the existence of the given header.
     * @param name - header name
     * @returns true if header with given name exists, false otherwise
     */
    OutgoingRequestMessage.prototype.hasHeader = function (name) {
        if (this.headers[utils_1.headerize(name)]) {
            return true;
        }
        else {
            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
            for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
                var extraHeader = _a[_i];
                if (regexp.test(extraHeader)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Replace the the given header by the given value.
     * @param name - header name
     * @param value - header value
     */
    OutgoingRequestMessage.prototype.setHeader = function (name, value) {
        this.headers[utils_1.headerize(name)] = (value instanceof Array) ? value : [value];
    };
    /**
     * The Via header field indicates the transport used for the transaction
     * and identifies the location where the response is to be sent.  A Via
     * header field value is added only after the transport that will be
     * used to reach the next hop has been selected (which may involve the
     * usage of the procedures in [4]).
     *
     * When the UAC creates a request, it MUST insert a Via into that
     * request.  The protocol name and protocol version in the header field
     * MUST be SIP and 2.0, respectively.  The Via header field value MUST
     * contain a branch parameter.  This parameter is used to identify the
     * transaction created by that request.  This parameter is used by both
     * the client and the server.
     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
     * @param branchParameter - The branch parameter.
     * @param transport - The sent protocol transport.
     */
    OutgoingRequestMessage.prototype.setViaHeader = function (branch, transport) {
        // FIXME: Hack
        if (this.options.hackViaTcp) {
            transport = "TCP";
        }
        var via = "SIP/2.0/" + transport;
        via += " " + this.options.viaHost + ";branch=" + branch;
        if (this.options.forceRport) {
            via += ";rport";
        }
        this.setHeader("via", via);
        this.branch = branch;
    };
    OutgoingRequestMessage.prototype.toString = function () {
        var msg = "";
        msg += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";
        for (var header in this.headers) {
            if (this.headers[header]) {
                for (var _i = 0, _a = this.headers[header]; _i < _a.length; _i++) {
                    var headerPart = _a[_i];
                    msg += header + ": " + headerPart + "\r\n";
                }
            }
        }
        for (var _b = 0, _c = this.extraHeaders; _b < _c.length; _b++) {
            var header = _c[_b];
            msg += header.trim() + "\r\n";
        }
        msg += "Supported: " + this.options.optionTags.join(", ") + "\r\n";
        msg += "User-Agent: " + this.options.userAgentString + "\r\n";
        if (this.body) {
            if (typeof this.body === "string") {
                msg += "Content-Length: " + utils_1.str_utf8_length(this.body) + "\r\n\r\n";
                msg += this.body;
            }
            else {
                if (this.body.body && this.body.contentType) {
                    msg += "Content-Type: " + this.body.contentType + "\r\n";
                    msg += "Content-Length: " + utils_1.str_utf8_length(this.body.body) + "\r\n\r\n";
                    msg += this.body.body;
                }
                else {
                    msg += "Content-Length: " + 0 + "\r\n\r\n";
                }
            }
        }
        else {
            msg += "Content-Length: " + 0 + "\r\n\r\n";
        }
        return msg;
    };
    return OutgoingRequestMessage;
}());
exports.OutgoingRequestMessage = OutgoingRequestMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/outgoing-response.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/outgoing-response.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * When a UAS wishes to construct a response to a request, it follows
 * the general procedures detailed in the following subsections.
 * Additional behaviors specific to the response code in question, which
 * are not detailed in this section, may also be required.
 * https://tools.ietf.org/html/rfc3261#section-8.2.6
 * @internal
 */
function constructOutgoingResponse(message, options) {
    var CRLF = "\r\n";
    if (options.statusCode < 100 || options.statusCode > 699) {
        throw new TypeError("Invalid statusCode: " + options.statusCode);
    }
    var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : utils_1.getReasonPhrase(options.statusCode);
    // SIP responses are distinguished from requests by having a Status-Line
    // as their start-line.  A Status-Line consists of the protocol version
    // followed by a numeric Status-Code and its associated textual phrase,
    // with each element separated by a single SP character.
    // https://tools.ietf.org/html/rfc3261#section-7.2
    var response = "SIP/2.0 " + options.statusCode + " " + reasonPhrase + CRLF;
    // One largely non-method-specific guideline for the generation of
    // responses is that UASs SHOULD NOT issue a provisional response for a
    // non-INVITE request.  Rather, UASs SHOULD generate a final response to
    // a non-INVITE request as soon as possible.
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.1
    if (options.statusCode >= 100 && options.statusCode < 200) {
        // TODO
    }
    // When a 100 (Trying) response is generated, any Timestamp header field
    // present in the request MUST be copied into this 100 (Trying)
    // response.  If there is a delay in generating the response, the UAS
    // SHOULD add a delay value into the Timestamp value in the response.
    // This value MUST contain the difference between the time of sending of
    // the response and receipt of the request, measured in seconds.
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.1
    if (options.statusCode === 100) {
        // TODO
    }
    // The From field of the response MUST equal the From header field of
    // the request.  The Call-ID header field of the response MUST equal the
    // Call-ID header field of the request.  The CSeq header field of the
    // response MUST equal the CSeq field of the request.  The Via header
    // field values in the response MUST equal the Via header field values
    // in the request and MUST maintain the same ordering.
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.2
    var fromHeader = "From: " + message.getHeader("From") + CRLF;
    var callIdHeader = "Call-ID: " + message.callId + CRLF;
    var cSeqHeader = "CSeq: " + message.cseq + " " + message.method + CRLF;
    var viaHeaders = message.getHeaders("via").reduce(function (previous, current) {
        return previous + "Via: " + current + CRLF;
    }, "");
    // If a request contained a To tag in the request, the To header field
    // in the response MUST equal that of the request.  However, if the To
    // header field in the request did not contain a tag, the URI in the To
    // header field in the response MUST equal the URI in the To header
    // field; additionally, the UAS MUST add a tag to the To header field in
    // the response (with the exception of the 100 (Trying) response, in
    // which a tag MAY be present).  This serves to identify the UAS that is
    // responding, possibly resulting in a component of a dialog ID.  The
    // same tag MUST be used for all responses to that request, both final
    // and provisional (again excepting the 100 (Trying)).
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.2
    var toHeader = "To: " + message.getHeader("to");
    if (options.statusCode > 100 && !message.parseHeader("to").hasParam("tag")) {
        var toTag = options.toTag;
        if (!toTag) {
            // Stateless UAS Behavior...
            // o  To header tags MUST be generated for responses in a stateless
            //    manner - in a manner that will generate the same tag for the
            //    same request consistently.  For information on tag construction
            //    see Section 19.3.
            // https://tools.ietf.org/html/rfc3261#section-8.2.7
            toTag = utils_1.newTag(); // FIXME: newTag() currently generates random tags
        }
        toHeader += ";tag=" + toTag;
    }
    toHeader += CRLF;
    // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)
    // let recordRouteHeaders = "";
    // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {
    //   recordRouteHeaders = request.getHeaders("record-route").reduce((previous, current) => {
    //     return previous + "Record-Route: " + current + CRLF;
    //   }, "");
    // }
    // FIXME: TODO: needs review...
    var supportedHeader = "";
    if (options.supported) {
        supportedHeader = "Supported: " + options.supported.join(", ") + CRLF;
    }
    // FIXME: TODO: needs review...
    var userAgentHeader = "";
    if (options.userAgent) {
        userAgentHeader = "User-Agent: " + options.userAgent + CRLF;
    }
    var extensionHeaders = "";
    if (options.extraHeaders) {
        extensionHeaders = options.extraHeaders.reduce(function (previous, current) {
            return previous + current.trim() + CRLF;
        }, "");
    }
    // The relative order of header fields with different field names is not
    // significant.  However, it is RECOMMENDED that header fields which are
    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
    // Max-Forwards, and Proxy-Authorization, for example) appear towards
    // the top of the message to facilitate rapid parsing.
    // https://tools.ietf.org/html/rfc3261#section-7.3.1
    // response += recordRouteHeaders;
    response += viaHeaders;
    response += fromHeader;
    response += toHeader;
    response += cSeqHeader;
    response += callIdHeader;
    response += supportedHeader;
    response += userAgentHeader;
    response += extensionHeaders;
    if (options.body) {
        response += "Content-Type: " + options.body.contentType + CRLF;
        response += "Content-Length: " + utils_1.str_utf8_length(options.body.content) + CRLF + CRLF;
        response += options.body.content;
    }
    else {
        response += "Content-Length: " + 0 + CRLF + CRLF;
    }
    return { message: response };
}
exports.constructOutgoingResponse = constructOutgoingResponse;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/parameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/parameters.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 */
var Parameters = /** @class */ (function () {
    function Parameters(parameters) {
        this.parameters = {};
        for (var param in parameters) {
            if (parameters.hasOwnProperty(param)) {
                this.setParam(param, parameters[param]);
            }
        }
    }
    Parameters.prototype.setParam = function (key, value) {
        if (key) {
            this.parameters[key.toLowerCase()] = (typeof value === "undefined" || value === null) ? null : value.toString();
        }
    };
    Parameters.prototype.getParam = function (key) {
        if (key) {
            return this.parameters[key.toLowerCase()];
        }
    };
    Parameters.prototype.hasParam = function (key) {
        if (key) {
            return !!this.parameters.hasOwnProperty(key.toLowerCase());
        }
        return false;
    };
    Parameters.prototype.deleteParam = function (parameter) {
        parameter = parameter.toLowerCase();
        if (this.parameters.hasOwnProperty(parameter)) {
            var value = this.parameters[parameter];
            delete this.parameters[parameter];
            return value;
        }
    };
    Parameters.prototype.clearParams = function () {
        this.parameters = {};
    };
    return Parameters;
}());
exports.Parameters = Parameters;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/parser.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var grammar_1 = __webpack_require__(/*! ./grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js");
var incoming_request_message_1 = __webpack_require__(/*! ./incoming-request-message */ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js");
var incoming_response_message_1 = __webpack_require__(/*! ./incoming-response-message */ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js");
/**
 * Extract and parse every header of a SIP message.
 * @internal
 */
var Parser;
(function (Parser) {
    function getHeader(data, headerStart) {
        // 'start' position of the header.
        var start = headerStart;
        // 'end' position of the header.
        var end = 0;
        // 'partial end' position of the header.
        var partialEnd = 0;
        // End of message.
        if (data.substring(start, start + 2).match(/(^\r\n)/)) {
            return -2;
        }
        while (end === 0) {
            // Partial End of Header.
            partialEnd = data.indexOf("\r\n", start);
            // 'indexOf' returns -1 if the value to be found never occurs.
            if (partialEnd === -1) {
                return partialEnd;
            }
            if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) &&
                data.charAt(partialEnd + 2).match(/(^\s+)/)) {
                // Not the end of the message. Continue from the next position.
                start = partialEnd + 2;
            }
            else {
                end = partialEnd;
            }
        }
        return end;
    }
    Parser.getHeader = getHeader;
    function parseHeader(message, data, headerStart, headerEnd) {
        var hcolonIndex = data.indexOf(":", headerStart);
        var headerName = data.substring(headerStart, hcolonIndex).trim();
        var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
        var parsed;
        // If header-field is well-known, parse it.
        switch (headerName.toLowerCase()) {
            case "via":
            case "v":
                message.addHeader("via", headerValue);
                if (message.getHeaders("via").length === 1) {
                    parsed = message.parseHeader("Via");
                    if (parsed) {
                        message.via = parsed;
                        message.viaBranch = parsed.branch;
                    }
                }
                else {
                    parsed = 0;
                }
                break;
            case "from":
            case "f":
                message.setHeader("from", headerValue);
                parsed = message.parseHeader("from");
                if (parsed) {
                    message.from = parsed;
                    message.fromTag = parsed.getParam("tag");
                }
                break;
            case "to":
            case "t":
                message.setHeader("to", headerValue);
                parsed = message.parseHeader("to");
                if (parsed) {
                    message.to = parsed;
                    message.toTag = parsed.getParam("tag");
                }
                break;
            case "record-route":
                parsed = grammar_1.Grammar.parse(headerValue, "Record_Route");
                if (parsed === -1) {
                    parsed = undefined;
                    break;
                }
                if (!(parsed instanceof Array)) {
                    parsed = undefined;
                    break;
                }
                parsed.forEach(function (header) {
                    message.addHeader("record-route", headerValue.substring(header.position, header.offset));
                    message.headers["Record-Route"][message.getHeaders("record-route").length - 1].parsed = header.parsed;
                });
                break;
            case "call-id":
            case "i":
                message.setHeader("call-id", headerValue);
                parsed = message.parseHeader("call-id");
                if (parsed) {
                    message.callId = headerValue;
                }
                break;
            case "contact":
            case "m":
                parsed = grammar_1.Grammar.parse(headerValue, "Contact");
                if (parsed === -1) {
                    parsed = undefined;
                    break;
                }
                if (!(parsed instanceof Array)) {
                    parsed = undefined;
                    break;
                }
                parsed.forEach(function (header) {
                    message.addHeader("contact", headerValue.substring(header.position, header.offset));
                    message.headers.Contact[message.getHeaders("contact").length - 1].parsed = header.parsed;
                });
                break;
            case "content-length":
            case "l":
                message.setHeader("content-length", headerValue);
                parsed = message.parseHeader("content-length");
                break;
            case "content-type":
            case "c":
                message.setHeader("content-type", headerValue);
                parsed = message.parseHeader("content-type");
                break;
            case "cseq":
                message.setHeader("cseq", headerValue);
                parsed = message.parseHeader("cseq");
                if (parsed) {
                    message.cseq = parsed.value;
                }
                if (message instanceof incoming_response_message_1.IncomingResponseMessage) {
                    message.method = parsed.method;
                }
                break;
            case "max-forwards":
                message.setHeader("max-forwards", headerValue);
                parsed = message.parseHeader("max-forwards");
                break;
            case "www-authenticate":
                message.setHeader("www-authenticate", headerValue);
                parsed = message.parseHeader("www-authenticate");
                break;
            case "proxy-authenticate":
                message.setHeader("proxy-authenticate", headerValue);
                parsed = message.parseHeader("proxy-authenticate");
                break;
            case "refer-to":
            case "r":
                message.setHeader("refer-to", headerValue);
                parsed = message.parseHeader("refer-to");
                if (parsed) {
                    message.referTo = parsed;
                }
                break;
            default:
                // Do not parse this header.
                message.addHeader(headerName.toLowerCase(), headerValue);
                parsed = 0;
        }
        if (parsed === undefined) {
            return {
                error: "error parsing header '" + headerName + "'"
            };
        }
        else {
            return true;
        }
    }
    Parser.parseHeader = parseHeader;
    function parseMessage(data, logger) {
        var headerStart = 0;
        var headerEnd = data.indexOf("\r\n");
        if (headerEnd === -1) {
            logger.warn("no CRLF found, not a SIP message, discarded");
            return;
        }
        // Parse first line. Check if it is a Request or a Reply.
        var firstLine = data.substring(0, headerEnd);
        var parsed = grammar_1.Grammar.parse(firstLine, "Request_Response");
        var message;
        if (parsed === -1) {
            logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
            return;
        }
        else if (!parsed.status_code) {
            message = new incoming_request_message_1.IncomingRequestMessage();
            message.method = parsed.method;
            message.ruri = parsed.uri;
        }
        else {
            message = new incoming_response_message_1.IncomingResponseMessage();
            message.statusCode = parsed.status_code;
            message.reasonPhrase = parsed.reason_phrase;
        }
        message.data = data;
        headerStart = headerEnd + 2;
        // Loop over every line in data. Detect the end of each header and parse
        // it or simply add to the headers collection.
        var bodyStart;
        while (true) {
            headerEnd = getHeader(data, headerStart);
            // The SIP message has normally finished.
            if (headerEnd === -2) {
                bodyStart = headerStart + 2;
                break;
            }
            else if (headerEnd === -1) {
                // data.indexOf returned -1 due to a malformed message.
                logger.error("malformed message");
                return;
            }
            var parsedHeader = parseHeader(message, data, headerStart, headerEnd);
            if (parsedHeader !== true) {
                logger.error(parsed.error);
                return;
            }
            headerStart = headerEnd + 2;
        }
        // RFC3261 18.3.
        // If there are additional bytes in the transport packet
        // beyond the end of the body, they MUST be discarded.
        if (message.hasHeader("content-length")) {
            message.body = data.substr(bodyStart, Number(message.getHeader("content-length")));
        }
        else {
            message.body = data.substring(bodyStart);
        }
        return message;
    }
    Parser.parseMessage = parseMessage;
})(Parser = exports.Parser || (exports.Parser = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/uri.js":
/*!******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/uri.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./node_modules/sip.js/lib/core/messages/parameters.js");
/**
 * URI.
 * @public
 */
var URI = /** @class */ (function (_super) {
    tslib_1.__extends(URI, _super);
    /**
     * Constructor
     * @param scheme -
     * @param user -
     * @param host -
     * @param port -
     * @param parameters -
     * @param headers -
     */
    function URI(scheme, user, host, port, parameters, headers) {
        var _this = _super.call(this, parameters) || this;
        _this.headers = {};
        // Checks
        if (!host) {
            throw new TypeError('missing or invalid "host" parameter');
        }
        // Initialize parameters
        scheme = scheme || "sip";
        for (var header in headers) {
            if (headers.hasOwnProperty(header)) {
                _this.setHeader(header, headers[header]);
            }
        }
        // Raw URI
        _this.raw = {
            scheme: scheme,
            user: user,
            host: host,
            port: port
        };
        // Normalized URI
        _this.normal = {
            scheme: scheme.toLowerCase(),
            user: user,
            host: host.toLowerCase(),
            port: port
        };
        return _this;
    }
    Object.defineProperty(URI.prototype, "scheme", {
        get: function () { return this.normal.scheme; },
        set: function (value) {
            this.raw.scheme = value;
            this.normal.scheme = value.toLowerCase();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "user", {
        get: function () { return this.normal.user; },
        set: function (value) {
            this.normal.user = this.raw.user = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "host", {
        get: function () { return this.normal.host; },
        set: function (value) {
            this.raw.host = value;
            this.normal.host = value.toLowerCase();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "aor", {
        get: function () { return this.normal.user + "@" + this.normal.host; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "port", {
        get: function () { return this.normal.port; },
        set: function (value) {
            this.normal.port = this.raw.port = value === 0 ? value : value;
        },
        enumerable: true,
        configurable: true
    });
    URI.prototype.setHeader = function (name, value) {
        this.headers[this.headerize(name)] = (value instanceof Array) ? value : [value];
    };
    URI.prototype.getHeader = function (name) {
        if (name) {
            return this.headers[this.headerize(name)];
        }
    };
    URI.prototype.hasHeader = function (name) {
        return !!name && !!this.headers.hasOwnProperty(this.headerize(name));
    };
    URI.prototype.deleteHeader = function (header) {
        header = this.headerize(header);
        if (this.headers.hasOwnProperty(header)) {
            var value = this.headers[header];
            delete this.headers[header];
            return value;
        }
    };
    URI.prototype.clearHeaders = function () {
        this.headers = {};
    };
    URI.prototype.clone = function () {
        return new URI(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
    };
    URI.prototype.toRaw = function () {
        return this._toString(this._raw);
    };
    URI.prototype.toString = function () {
        return this._toString(this._normal);
    };
    Object.defineProperty(URI.prototype, "_normal", {
        get: function () { return this.normal; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "_raw", {
        get: function () { return this.raw; },
        enumerable: true,
        configurable: true
    });
    URI.prototype._toString = function (uri) {
        var uriString = uri.scheme + ":";
        // add slashes if it's not a sip(s) URI
        if (!uri.scheme.toLowerCase().match("^sips?$")) {
            uriString += "//";
        }
        if (uri.user) {
            uriString += this.escapeUser(uri.user) + "@";
        }
        uriString += uri.host;
        if (uri.port || uri.port === 0) {
            uriString += ":" + uri.port;
        }
        for (var parameter in this.parameters) {
            if (this.parameters.hasOwnProperty(parameter)) {
                uriString += ";" + parameter;
                if (this.parameters[parameter] !== null) {
                    uriString += "=" + this.parameters[parameter];
                }
            }
        }
        var headers = [];
        for (var header in this.headers) {
            if (this.headers.hasOwnProperty(header)) {
                for (var idx in this.headers[header]) {
                    if (this.headers[header].hasOwnProperty(idx)) {
                        headers.push(header + "=" + this.headers[header][idx]);
                    }
                }
            }
        }
        if (headers.length > 0) {
            uriString += "?" + headers.join("&");
        }
        return uriString;
    };
    /*
     * Hex-escape a SIP URI user.
     * @private
     * @param {String} user
     */
    URI.prototype.escapeUser = function (user) {
        var decodedUser;
        // FIXME: This is called by toString above which should never throw, but
        // decodeURIComponent can throw and I've seen one case in production where
        // it did throw resulting in a cascading failure. This class should be
        // fixed so that decodeURIComponent is not called at this point (in toString).
        // The user should be decoded when the URI is constructor or some other
        // place where we can catch the error before the URI is created or somesuch.
        try {
            decodedUser = decodeURIComponent(user);
        }
        catch (error) {
            throw error;
        }
        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
        return encodeURIComponent(decodedUser)
            .replace(/%3A/ig, ":")
            .replace(/%2B/ig, "+")
            .replace(/%3F/ig, "?")
            .replace(/%2F/ig, "/");
    };
    URI.prototype.headerize = function (str) {
        var exceptions = {
            "Call-Id": "Call-ID",
            "Cseq": "CSeq",
            "Min-Se": "Min-SE",
            "Rack": "RAck",
            "Rseq": "RSeq",
            "Www-Authenticate": "WWW-Authenticate",
        };
        var name = str.toLowerCase().replace(/_/g, "-").split("-");
        var parts = name.length;
        var hname = "";
        for (var part = 0; part < parts; part++) {
            if (part !== 0) {
                hname += "-";
            }
            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
        }
        if (exceptions[hname]) {
            hname = exceptions[hname];
        }
        return hname;
    };
    return URI;
}(parameters_1.Parameters));
exports.URI = URI;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param size -
 * @param base -
 * @internal
 */
function createRandomToken(size, base) {
    if (base === void 0) { base = 32; }
    var token = "";
    for (var i = 0; i < size; i++) {
        var r = Math.floor(Math.random() * base);
        token += r.toString(base);
    }
    return token;
}
exports.createRandomToken = createRandomToken;
/**
 * @internal
 */
function getReasonPhrase(code) {
    return REASON_PHRASE[code] || "";
}
exports.getReasonPhrase = getReasonPhrase;
/**
 * @internal
 */
function newTag() {
    return createRandomToken(10);
}
exports.newTag = newTag;
/**
 * @param str -
 * @internal
 */
function headerize(str) {
    var exceptions = {
        "Call-Id": "Call-ID",
        "Cseq": "CSeq",
        "Min-Se": "Min-SE",
        "Rack": "RAck",
        "Rseq": "RSeq",
        "Www-Authenticate": "WWW-Authenticate",
    };
    var name = str.toLowerCase().replace(/_/g, "-").split("-");
    var parts = name.length;
    var hname = "";
    for (var part = 0; part < parts; part++) {
        if (part !== 0) {
            hname += "-";
        }
        hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
    }
    if (exceptions[hname]) {
        hname = exceptions[hname];
    }
    return hname;
}
exports.headerize = headerize;
/**
 * @param str -
 * @internal
 */
function str_utf8_length(str) {
    return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
}
exports.str_utf8_length = str_utf8_length;
/**
 * SIP Response Reasons
 * DOC: http://www.iana.org/assignments/sip-parameters
 * @internal
 */
var REASON_PHRASE = {
    100: "Trying",
    180: "Ringing",
    181: "Call Is Being Forwarded",
    182: "Queued",
    183: "Session Progress",
    199: "Early Dialog Terminated",
    200: "OK",
    202: "Accepted",
    204: "No Notification",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Moved Temporarily",
    305: "Use Proxy",
    380: "Alternative Service",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    410: "Gone",
    412: "Conditional Request Failed",
    413: "Request Entity Too Large",
    414: "Request-URI Too Long",
    415: "Unsupported Media Type",
    416: "Unsupported URI Scheme",
    417: "Unknown Resource-Priority",
    420: "Bad Extension",
    421: "Extension Required",
    422: "Session Interval Too Small",
    423: "Interval Too Brief",
    428: "Use Identity Header",
    429: "Provide Referrer Identity",
    430: "Flow Failed",
    433: "Anonymity Disallowed",
    436: "Bad Identity-Info",
    437: "Unsupported Certificate",
    438: "Invalid Identity Header",
    439: "First Hop Lacks Outbound Support",
    440: "Max-Breadth Exceeded",
    469: "Bad Info Package",
    470: "Consent Needed",
    478: "Unresolvable Destination",
    480: "Temporarily Unavailable",
    481: "Call/Transaction Does Not Exist",
    482: "Loop Detected",
    483: "Too Many Hops",
    484: "Address Incomplete",
    485: "Ambiguous",
    486: "Busy Here",
    487: "Request Terminated",
    488: "Not Acceptable Here",
    489: "Bad Event",
    491: "Request Pending",
    493: "Undecipherable",
    494: "Security Agreement Required",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Server Time-out",
    505: "Version Not Supported",
    513: "Message Too Large",
    580: "Precondition Failure",
    600: "Busy Everywhere",
    603: "Decline",
    604: "Does Not Exist Anywhere",
    606: "Not Acceptable"
};


/***/ }),

/***/ "./node_modules/sip.js/lib/core/session/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/session/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./node_modules/sip.js/lib/core/session/session.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/session/session.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/session/session.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Session state.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-13
 * @public
 */
var SessionState;
(function (SessionState) {
    SessionState["Initial"] = "Initial";
    SessionState["Early"] = "Early";
    SessionState["AckWait"] = "AckWait";
    SessionState["Confirmed"] = "Confirmed";
    SessionState["Terminated"] = "Terminated";
})(SessionState = exports.SessionState || (exports.SessionState = {}));
/**
 * Offer/Answer state.
 * @remarks
 * ```txt
 *         Offer                Answer             RFC    Ini Est Early
 *  -------------------------------------------------------------------
 *  1. INVITE Req.          2xx INVITE Resp.     RFC 3261  Y   Y    N
 *  2. 2xx INVITE Resp.     ACK Req.             RFC 3261  Y   Y    N
 *  3. INVITE Req.          1xx-rel INVITE Resp. RFC 3262  Y   Y    N
 *  4. 1xx-rel INVITE Resp. PRACK Req.           RFC 3262  Y   Y    N
 *  5. PRACK Req.           200 PRACK Resp.      RFC 3262  N   Y    Y
 *  6. UPDATE Req.          2xx UPDATE Resp.     RFC 3311  N   Y    Y
 *
 *       Table 1: Summary of SIP Usage of the Offer/Answer Model
 * ```
 * https://tools.ietf.org/html/rfc6337#section-2.2
 * @public
 */
var SignalingState;
(function (SignalingState) {
    SignalingState["Initial"] = "Initial";
    SignalingState["HaveLocalOffer"] = "HaveLocalOffer";
    SignalingState["HaveRemoteOffer"] = "HaveRemoteOffer";
    SignalingState["Stable"] = "Stable";
    SignalingState["Closed"] = "Closed";
})(SignalingState = exports.SignalingState || (exports.SignalingState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/subscription/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/subscription/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./node_modules/sip.js/lib/core/subscription/subscription.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/subscription/subscription.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/subscription/subscription.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Subscription state.
 * @remarks
 * https://tools.ietf.org/html/rfc6665#section-4.1.2
 * @public
 */
var SubscriptionState;
(function (SubscriptionState) {
    SubscriptionState["Initial"] = "Initial";
    SubscriptionState["NotifyWait"] = "NotifyWait";
    SubscriptionState["Pending"] = "Pending";
    SubscriptionState["Active"] = "Active";
    SubscriptionState["Terminated"] = "Terminated";
})(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/timers.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/core/timers.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var T1 = 500;
var T2 = 4000;
var T4 = 5000;
/**
 * Timers.
 * @public
 */
exports.Timers = {
    T1: T1,
    T2: T2,
    T4: T4,
    TIMER_B: 64 * T1,
    TIMER_D: 0 * T1,
    TIMER_F: 64 * T1,
    TIMER_H: 64 * T1,
    TIMER_I: 0 * T4,
    TIMER_J: 0 * T1,
    TIMER_K: 0 * T4,
    TIMER_L: 64 * T1,
    TIMER_M: 64 * T1,
    TIMER_N: 64 * T1,
    PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1
};


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/client-transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/client-transaction.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/sip.js/lib/core/transactions/transaction.js");
/**
 * Client Transaction.
 * @remarks
 * The client transaction provides its functionality through the
 * maintenance of a state machine.
 *
 * The TU communicates with the client transaction through a simple
 * interface.  When the TU wishes to initiate a new transaction, it
 * creates a client transaction and passes it the SIP request to send
 * and an IP address, port, and transport to which to send it.  The
 * client transaction begins execution of its state machine.  Valid
 * responses are passed up to the TU from the client transaction.
 * https://tools.ietf.org/html/rfc3261#section-17.1
 * @public
 */
var ClientTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(ClientTransaction, _super);
    function ClientTransaction(_request, transport, user, state, loggerCategory) {
        var _this = _super.call(this, transport, user, ClientTransaction.makeId(_request), state, loggerCategory) || this;
        _this._request = _request;
        _this.user = user;
        // The Via header field indicates the transport used for the transaction
        // and identifies the location where the response is to be sent.  A Via
        // header field value is added only after the transport that will be
        // used to reach the next hop has been selected (which may involve the
        // usage of the procedures in [4]).
        // https://tools.ietf.org/html/rfc3261#section-8.1.1.7
        _request.setViaHeader(_this.id, transport.protocol);
        return _this;
    }
    ClientTransaction.makeId = function (request) {
        if (request.method === "CANCEL") {
            if (!request.branch) {
                throw new Error("Outgoing CANCEL request without a branch.");
            }
            return request.branch;
        }
        else {
            return "z9hG4bK" + Math.floor(Math.random() * 10000000);
        }
    };
    Object.defineProperty(ClientTransaction.prototype, "request", {
        /** The outgoing request the transaction handling. */
        get: function () {
            return this._request;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * A 408 to non-INVITE will always arrive too late to be useful ([3]),
     * The client already has full knowledge of the timeout. The only
     * information this message would convey is whether or not the server
     * believed the transaction timed out. However, with the current design
     * of the NIT, a client cannot do anything with this knowledge. Thus,
     * the 408 is simply wasting network resources and contributes to the
     * response bombardment illustrated in [3].
     * https://tools.ietf.org/html/rfc4320#section-4.1
     */
    ClientTransaction.prototype.onRequestTimeout = function () {
        if (this.user.onRequestTimeout) {
            this.user.onRequestTimeout();
        }
    };
    return ClientTransaction;
}(transaction_1.Transaction));
exports.ClientTransaction = ClientTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./client-transaction */ "./node_modules/sip.js/lib/core/transactions/client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-client-transaction */ "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-server-transaction */ "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./non-invite-client-transaction */ "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./non-invite-server-transaction */ "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-client-transaction */ "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./server-transaction */ "./node_modules/sip.js/lib/core/transactions/server-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transaction */ "./node_modules/sip.js/lib/core/transactions/transaction.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var client_transaction_1 = __webpack_require__(/*! ./client-transaction */ "./node_modules/sip.js/lib/core/transactions/client-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * INVITE Client Transaction.
 * @remarks
 * The INVITE transaction consists of a three-way handshake.  The client
 * transaction sends an INVITE, the server transaction sends responses,
 * and the client transaction sends an ACK.
 * https://tools.ietf.org/html/rfc3261#section-17.1.1
 * @public
 */
var InviteClientTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(InviteClientTransaction, _super);
    /**
     * Constructor.
     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
     * Then `toString` is called on the outgoing request and the message is sent via the transport.
     * After construction the transaction will be in the "calling" state and the transaction id
     * will equal the branch parameter set in the Via header of the outgoing request.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1
     * @param request - The outgoing INVITE request.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function InviteClientTransaction(request, transport, user) {
        var _this = _super.call(this, request, transport, user, transaction_state_1.TransactionState.Calling, "sip.transaction.ict") || this;
        /**
         * Map of 2xx to-tag to ACK.
         * If value is not undefined, value is the ACK which was sent.
         * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.
         * Otherwise, a 2xx was not (yet) received for this transaction.
         */
        _this.ackRetransmissionCache = new Map();
        // FIXME: Timer A for unreliable transport not implemented
        //
        // If an unreliable transport is being used, the client transaction
        // MUST start timer A with a value of T1. If a reliable transport is being used,
        // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).
        // For any transport, the client transaction MUST start timer B with a value
        // of 64*T1 seconds (Timer B controls transaction timeouts).
        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
        //
        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
        // will wait for an INVITE message to be acknowledged (a SIP response message is received).
        // So Timer B should be cleared when the transaction state proceeds from "Calling".
        _this.B = setTimeout(function () { return _this.timer_B(); }, timers_1.Timers.TIMER_B);
        _this.send(request.toString()).catch(function (error) {
            _this.logTransportError(error, "Failed to send initial outgoing request.");
        });
        return _this;
    }
    /**
     * Destructor.
     */
    InviteClientTransaction.prototype.dispose = function () {
        if (this.B) {
            clearTimeout(this.B);
            this.B = undefined;
        }
        if (this.D) {
            clearTimeout(this.D);
            this.D = undefined;
        }
        if (this.M) {
            clearTimeout(this.M);
            this.M = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(InviteClientTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "ict";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * ACK a 2xx final response.
     *
     * The transaction includes the ACK only if the final response was not a 2xx response (the
     * transaction will generate and send the ACK to the transport automagically). If the
     * final response was a 2xx, the ACK is not considered part of the transaction (the
     * transaction user needs to generate and send the ACK).
     *
     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
     * by the transaction layer (instead of the UAC core). The "standard" approach is for
     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
     * and any retransmissions of those ACKs as needed.
     *
     * @param ack - The outgoing ACK request.
     */
    InviteClientTransaction.prototype.ackResponse = function (ack) {
        var _this = this;
        var toTag = ack.toTag;
        if (!toTag) {
            throw new Error("To tag undefined.");
        }
        var id = "z9hG4bK" + Math.floor(Math.random() * 10000000);
        ack.setViaHeader(id, this.transport.protocol);
        this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache
        this.send(ack.toString()).catch(function (error) {
            _this.logTransportError(error, "Failed to send ACK to 2xx response.");
        });
    };
    /**
     * Handler for incoming responses from the transport which match this transaction.
     * @param response - The incoming response.
     */
    InviteClientTransaction.prototype.receiveResponse = function (response) {
        var _this = this;
        var statusCode = response.statusCode;
        if (!statusCode || statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Calling:
                // If the client transaction receives a provisional response while in
                // the "Calling" state, it transitions to the "Proceeding" state. In the
                // "Proceeding" state, the client transaction SHOULD NOT retransmit the
                // request any longer. Furthermore, the provisional response MUST be
                // passed to the TU.  Any further provisional responses MUST be passed
                // up to the TU while in the "Proceeding" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
                if (statusCode >= 100 && statusCode <= 199) {
                    this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When a 2xx response is received while in either the "Calling" or
                // "Proceeding" states, the client transaction MUST transition to
                // the "Accepted" state... The 2xx response MUST be passed up to the TU.
                // The client transaction MUST NOT generate an ACK to the 2xx response -- its
                // handling is delegated to the TU. A UAC core will send an ACK to
                // the 2xx response using a new transaction.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 200 && statusCode <= 299) {
                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                    this.stateTransition(transaction_state_1.TransactionState.Accepted);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When in either the "Calling" or "Proceeding" states, reception of
                // a response with status code from 300-699 MUST cause the client
                // transaction to transition to "Completed". The client transaction
                // MUST pass the received response up to the TU, and the client
                // transaction MUST generate an ACK request, even if the transport is
                // reliable (guidelines for constructing the ACK from the response
                // are given in Section 17.1.1.3), and then pass the ACK to the
                // transport layer for transmission. The ACK MUST be sent to the
                // same address, port, and transport to which the original request was sent.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 300 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.ack(response);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // In the "Proceeding" state, the client transaction SHOULD NOT retransmit the
                // request any longer. Furthermore, the provisional response MUST be
                // passed to the TU.  Any further provisional responses MUST be passed
                // up to the TU while in the "Proceeding" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
                if (statusCode >= 100 && statusCode <= 199) {
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When a 2xx response is received while in either the "Calling" or "Proceeding" states,
                // the client transaction MUST transition to the "Accepted" state...
                // The 2xx response MUST be passed up to the TU. The client
                // transaction MUST NOT generate an ACK to the 2xx response -- its
                // handling is delegated to the TU. A UAC core will send an ACK to
                // the 2xx response using a new transaction.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 200 && statusCode <= 299) {
                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                    this.stateTransition(transaction_state_1.TransactionState.Accepted);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When in either the "Calling" or "Proceeding" states, reception of
                // a response with status code from 300-699 MUST cause the client
                // transaction to transition to "Completed". The client transaction
                // MUST pass the received response up to the TU, and the client
                // transaction MUST generate an ACK request, even if the transport is
                // reliable (guidelines for constructing the ACK from the response
                // are given in Section 17.1.1.3), and then pass the ACK to the
                // transport layer for transmission. The ACK MUST be sent to the
                // same address, port, and transport to which the original request was sent.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 300 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.ack(response);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
                // The purpose of the "Accepted" state is to allow the client
                // transaction to continue to exist to receive, and pass to the TU,
                // any retransmissions of the 2xx response and any additional 2xx
                // responses from other branches of the INVITE if it forked
                // downstream. Timer M reflects the amount of time that the
                // transaction user will wait for such messages.
                //
                // Any 2xx responses that match this client transaction and that are
                // received while in the "Accepted" state MUST be passed up to the
                // TU. The client transaction MUST NOT generate an ACK to the 2xx
                // response. The client transaction takes no further action.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 200 && statusCode <= 299) {
                    // NOTE: This implementation herein is intentionally not RFC compliant.
                    // While the first 2xx response for a given branch is passed up to the TU,
                    // retransmissions of 2xx responses are absorbed and the ACK associated
                    // with the original response is resent. This approach is taken because
                    // our current transaction users are not currently in a good position to
                    // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)
                    //
                    // If we don't have a cache hit, pass the response to the TU.
                    if (!this.ackRetransmissionCache.has(response.toTag)) {
                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // If we have a cache hit, try pulling the ACK from cache and retransmitting it.
                    var ack = this.ackRetransmissionCache.get(response.toTag);
                    if (ack) {
                        this.send(ack.toString()).catch(function (error) {
                            _this.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
                        });
                        return;
                    }
                    // If an ACK was not found in cache then we have received a retransmitted 2xx
                    // response before the TU responded to the original response (we don't have an ACK yet).
                    // So discard this response under the assumption that the TU will eventually
                    // get us a ACK for the original response.
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                // Any retransmissions of a response with status code 300-699 that
                // are received while in the "Completed" state MUST cause the ACK to
                // be re-passed to the transport layer for retransmission, but the
                // newly received response MUST NOT be passed up to the TU.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 300 && statusCode <= 699) {
                    this.ack(response);
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        // Any response received that does not match an existing client
        // transaction state machine is simply dropped. (Implementations are,
        // of course, free to log or do other implementation-specific things
        // with such responses, but the implementer should be sure to consider
        // the impact of large numbers of malicious stray responses.)
        // https://tools.ietf.org/html/rfc6026#section-7.2
        var message = "Received unexpected " + statusCode + " response while in state " + this.state + ".";
        this.logger.warn(message);
        return;
    };
    /**
     * The client transaction SHOULD inform the TU that a transport failure
     * has occurred, and the client transaction SHOULD transition directly
     * to the "Terminated" state.  The TU will handle the failover
     * mechanisms described in [4].
     * https://tools.ietf.org/html/rfc3261#section-17.1.4
     * @param error - The error.
     */
    InviteClientTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
        this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
    };
    /** For logging. */
    InviteClientTransaction.prototype.typeToString = function () {
        return "INVITE client transaction";
    };
    InviteClientTransaction.prototype.ack = function (response) {
        var _this = this;
        // The ACK request constructed by the client transaction MUST contain
        // values for the Call-ID, From, and Request-URI that are equal to the
        // values of those header fields in the request passed to the transport
        // by the client transaction (call this the "original request"). The To
        // header field in the ACK MUST equal the To header field in the
        // response being acknowledged, and therefore will usually differ from
        // the To header field in the original request by the addition of the
        // tag parameter. The ACK MUST contain a single Via header field, and
        // this MUST be equal to the top Via header field of the original
        // request. The CSeq header field in the ACK MUST contain the same
        // value for the sequence number as was present in the original request,
        // but the method parameter MUST be equal to "ACK".
        //
        // If the INVITE request whose response is being acknowledged had Route
        // header fields, those header fields MUST appear in the ACK. This is
        // to ensure that the ACK can be routed properly through any downstream
        // stateless proxies.
        // https://tools.ietf.org/html/rfc3261#section-17.1.1.3
        var ruri = this.request.ruri;
        var callId = this.request.callId;
        var cseq = this.request.cseq;
        var from = this.request.getHeader("from");
        var to = response.getHeader("to");
        var via = this.request.getHeader("via");
        var route = this.request.getHeader("route");
        if (!from) {
            throw new Error("From undefined.");
        }
        if (!to) {
            throw new Error("To undefined.");
        }
        if (!via) {
            throw new Error("Via undefined.");
        }
        var ack = "ACK " + ruri + " SIP/2.0\r\n";
        if (route) {
            ack += "Route: " + route + "\r\n";
        }
        ack += "Via: " + via + "\r\n";
        ack += "To: " + to + "\r\n";
        ack += "From: " + from + "\r\n";
        ack += "Call-ID: " + callId + "\r\n";
        ack += "CSeq: " + cseq + " ACK\r\n";
        ack += "Max-Forwards: 70\r\n";
        ack += "Content-Length: 0\r\n\r\n";
        // TOOO: "User-Agent" header
        this.send(ack).catch(function (error) {
            _this.logTransportError(error, "Failed to send ACK to non-2xx response.");
        });
        return;
    };
    /**
     * Execute a state transition.
     * @param newState - New state.
     */
    InviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
        var _this = this;
        if (dueToTransportError === void 0) { dueToTransportError = false; }
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Calling:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Proceeding:
                if (this.state !== transaction_state_1.TransactionState.Calling) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Calling &&
                    this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Calling &&
                    this.state !== transaction_state_1.TransactionState.Accepted &&
                    this.state !== transaction_state_1.TransactionState.Completed) {
                    if (!dueToTransportError) {
                        invalidStateTransition();
                    }
                }
                break;
            default:
                invalidStateTransition();
        }
        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
        // will wait for an INVITE message to be acknowledged (a SIP response message is received).
        // So Timer B should be cleared when the transaction state proceeds from "Calling".
        if (this.B) {
            clearTimeout(this.B);
            this.B = undefined;
        }
        if (newState === transaction_state_1.TransactionState.Proceeding) {
            // Timers have no effect on "Proceeding" state.
            // In the "Proceeding" state, the client transaction
            // SHOULD NOT retransmit the request any longer.
            // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
        }
        // The client transaction MUST start Timer D when it enters the "Completed" state
        // for any reason, with a value of at least 32 seconds for unreliable transports,
        // and a value of zero seconds for reliable transports.
        // https://tools.ietf.org/html/rfc6026#section-8.4
        if (newState === transaction_state_1.TransactionState.Completed) {
            this.D = setTimeout(function () { return _this.timer_D(); }, timers_1.Timers.TIMER_D);
        }
        // The client transaction MUST transition to the "Accepted" state,
        // and Timer M MUST be started with a value of 64*T1.
        // https://tools.ietf.org/html/rfc6026#section-8.4
        if (newState === transaction_state_1.TransactionState.Accepted) {
            this.M = setTimeout(function () { return _this.timer_M(); }, timers_1.Timers.TIMER_M);
        }
        // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
        // https://tools.ietf.org/html/rfc6026#section-8.7
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        // Update state.
        this.setState(newState);
    };
    /**
     * When timer A fires, the client transaction MUST retransmit the
     * request by passing it to the transport layer, and MUST reset the
     * timer with a value of 2*T1.
     * When timer A fires 2*T1 seconds later, the request MUST be
     * retransmitted again (assuming the client transaction is still in this
     * state). This process MUST continue so that the request is
     * retransmitted with intervals that double after each transmission.
     * These retransmissions SHOULD only be done while the client
     * transaction is in the "Calling" state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
     */
    InviteClientTransaction.prototype.timer_A = function () {
        // TODO
    };
    /**
     * If the client transaction is still in the "Calling" state when timer
     * B fires, the client transaction SHOULD inform the TU that a timeout
     * has occurred.  The client transaction MUST NOT generate an ACK.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
     */
    InviteClientTransaction.prototype.timer_B = function () {
        this.logger.debug("Timer B expired for INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Calling) {
            this.onRequestTimeout();
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * If Timer D fires while the client transaction is in the "Completed" state,
     * the client transaction MUST move to the "Terminated" state.
     * https://tools.ietf.org/html/rfc6026#section-8.4
     */
    InviteClientTransaction.prototype.timer_D = function () {
        this.logger.debug("Timer D expired for INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * If Timer M fires while the client transaction is in the "Accepted"
     * state, the client transaction MUST move to the "Terminated" state.
     * https://tools.ietf.org/html/rfc6026#section-8.4
     */
    InviteClientTransaction.prototype.timer_M = function () {
        this.logger.debug("Timer M expired for INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Accepted) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return InviteClientTransaction;
}(client_transaction_1.ClientTransaction));
exports.InviteClientTransaction = InviteClientTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var server_transaction_1 = __webpack_require__(/*! ./server-transaction */ "./node_modules/sip.js/lib/core/transactions/server-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * INVITE Server Transaction.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-17.2.1
 * @public
 */
var InviteServerTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(InviteServerTransaction, _super);
    /**
     * Constructor.
     * Upon construction, a "100 Trying" reply will be immediately sent.
     * After construction the transaction will be in the "proceeding" state and the transaction
     * `id` will equal the branch parameter set in the Via header of the incoming request.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     * @param request - Incoming INVITE request from the transport.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function InviteServerTransaction(request, transport, user) {
        return _super.call(this, request, transport, user, transaction_state_1.TransactionState.Proceeding, "sip.transaction.ist") || this;
    }
    /**
     * Destructor.
     */
    InviteServerTransaction.prototype.dispose = function () {
        this.stopProgressExtensionTimer();
        if (this.H) {
            clearTimeout(this.H);
            this.H = undefined;
        }
        if (this.I) {
            clearTimeout(this.I);
            this.I = undefined;
        }
        if (this.L) {
            clearTimeout(this.L);
            this.L = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(InviteServerTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "ist";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Receive requests from transport matching this transaction.
     * @param request - Request matching this transaction.
     */
    InviteServerTransaction.prototype.receiveRequest = function (request) {
        var _this = this;
        switch (this.state) {
            case transaction_state_1.TransactionState.Proceeding:
                // If a request retransmission is received while in the "Proceeding" state, the most
                // recent provisional response that was received from the TU MUST be passed to the
                // transport layer for retransmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.INVITE) {
                    if (this.lastProvisionalResponse) {
                        this.send(this.lastProvisionalResponse).catch(function (error) {
                            _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                        });
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
                // While in the "Accepted" state, any retransmissions of the INVITE
                // received will match this transaction state machine and will be
                // absorbed by the machine without changing its state. These
                // retransmissions are not passed onto the TU.
                // https://tools.ietf.org/html/rfc6026#section-7.1
                if (request.method === messages_1.C.INVITE) {
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                // Furthermore, while in the "Completed" state, if a request retransmission is
                // received, the server SHOULD pass the response to the transport for retransmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.INVITE) {
                    if (!this.lastFinalResponse) {
                        throw new Error("Last final response undefined.");
                    }
                    this.send(this.lastFinalResponse).catch(function (error) {
                        _this.logTransportError(error, "Failed to send retransmission of final response.");
                    });
                    return;
                }
                // If an ACK is received while the server transaction is in the "Completed" state,
                // the server transaction MUST transition to the "Confirmed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.ACK) {
                    this.stateTransition(transaction_state_1.TransactionState.Confirmed);
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Confirmed:
                // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
                // triggered from retransmissions of the final response.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.INVITE || request.method === messages_1.C.ACK) {
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                // For good measure absorb any additional messages that arrive (should not happen).
                if (request.method === messages_1.C.INVITE || request.method === messages_1.C.ACK) {
                    return;
                }
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "INVITE server transaction received unexpected " + request.method + " request while in state " + this.state + ".";
        this.logger.warn(message);
        return;
    };
    /**
     * Receive responses from TU for this transaction.
     * @param statusCode - Status code of response.
     * @param response - Response.
     */
    InviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
        var _this = this;
        if (statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Proceeding:
                // The TU passes any number of provisional responses to the server
                // transaction. So long as the server transaction is in the
                // "Proceeding" state, each of these MUST be passed to the transport
                // layer for transmission. They are not sent reliably by the
                // transaction layer (they are not retransmitted by it) and do not cause
                // a change in the state of the server transaction.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (statusCode >= 100 && statusCode <= 199) {
                    this.lastProvisionalResponse = response;
                    // Start the progress extension timer only for a non-100 provisional response.
                    if (statusCode > 100) {
                        this.startProgressExtensionTimer(); // FIXME: remove
                    }
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send 1xx response.");
                    });
                    return;
                }
                // If, while in the "Proceeding" state, the TU passes a 2xx response
                // to the server transaction, the server transaction MUST pass this
                // response to the transport layer for transmission. It is not
                // retransmitted by the server transaction; retransmissions of 2xx
                // responses are handled by the TU. The server transaction MUST then
                // transition to the "Accepted" state.
                // https://tools.ietf.org/html/rfc6026#section-8.5
                if (statusCode >= 200 && statusCode <= 299) {
                    this.lastFinalResponse = response;
                    this.stateTransition(transaction_state_1.TransactionState.Accepted);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send 2xx response.");
                    });
                    return;
                }
                // While in the "Proceeding" state, if the TU passes a response with
                // status code from 300 to 699 to the server transaction, the response
                // MUST be passed to the transport layer for transmission, and the state
                // machine MUST enter the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (statusCode >= 300 && statusCode <= 699) {
                    this.lastFinalResponse = response;
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send non-2xx final response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
                // While in the "Accepted" state, if the TU passes a 2xx response,
                // the server transaction MUST pass the response to the transport layer for transmission.
                // https://tools.ietf.org/html/rfc6026#section-8.7
                if (statusCode >= 200 && statusCode <= 299) {
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send 2xx response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                break;
            case transaction_state_1.TransactionState.Confirmed:
                break;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
        this.logger.error(message);
        throw new Error(message);
    };
    /**
     * Retransmit the last 2xx response. This is a noop if not in the "accepted" state.
     */
    InviteServerTransaction.prototype.retransmitAcceptedResponse = function () {
        var _this = this;
        if (this.state === transaction_state_1.TransactionState.Accepted && this.lastFinalResponse) {
            this.send(this.lastFinalResponse).catch(function (error) {
                _this.logTransportError(error, "Failed to send 2xx response.");
            });
        }
    };
    /**
     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
     * inform the TU that a failure has occurred, and MUST remain in the current state.
     * https://tools.ietf.org/html/rfc6026#section-8.8
     */
    InviteServerTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
    };
    /** For logging. */
    InviteServerTransaction.prototype.typeToString = function () {
        return "INVITE server transaction";
    };
    /**
     * Execute a state transition.
     * @param newState - New state.
     */
    InviteServerTransaction.prototype.stateTransition = function (newState) {
        var _this = this;
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Proceeding:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Accepted:
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Confirmed:
                if (this.state !== transaction_state_1.TransactionState.Completed) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Accepted &&
                    this.state !== transaction_state_1.TransactionState.Completed &&
                    this.state !== transaction_state_1.TransactionState.Confirmed) {
                    invalidStateTransition();
                }
                break;
            default:
                invalidStateTransition();
        }
        // On any state transition, stop resending provisional responses
        this.stopProgressExtensionTimer();
        // The purpose of the "Accepted" state is to absorb retransmissions of an accepted INVITE request.
        // Any such retransmissions are absorbed entirely within the server transaction.
        // They are not passed up to the TU since any downstream UAS cores that accepted the request have
        // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.
        // https://tools.ietf.org/html/rfc6026#section-8.7
        if (newState === transaction_state_1.TransactionState.Accepted) {
            this.L = setTimeout(function () { return _this.timer_L(); }, timers_1.Timers.TIMER_L);
        }
        // When the "Completed" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.
        // Timer H determines when the server transaction abandons retransmitting the response.
        // If an ACK is received while the server transaction is in the "Completed" state,
        // the server transaction MUST transition to the "Confirmed" state.
        // https://tools.ietf.org/html/rfc3261#section-17.2.1
        if (newState === transaction_state_1.TransactionState.Completed) {
            // FIXME: Missing timer G for unreliable transports.
            this.H = setTimeout(function () { return _this.timer_H(); }, timers_1.Timers.TIMER_H);
        }
        // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
        // triggered from retransmissions of the final response. When this state is entered, timer I
        // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable
        // transports. Once timer I fires, the server MUST transition to the "Terminated" state.
        // https://tools.ietf.org/html/rfc3261#section-17.2.1
        if (newState === transaction_state_1.TransactionState.Confirmed) {
            // FIXME: This timer is not getting set correctly for unreliable transports.
            this.I = setTimeout(function () { return _this.timer_I(); }, timers_1.Timers.TIMER_I);
        }
        // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
        // https://tools.ietf.org/html/rfc6026#section-8.7
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        // Update state.
        this.setState(newState);
    };
    /**
     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
     */
    InviteServerTransaction.prototype.startProgressExtensionTimer = function () {
        var _this = this;
        // Start the progress extension timer only for the first non-100 provisional response.
        if (this.progressExtensionTimer === undefined) {
            this.progressExtensionTimer = setInterval(function () {
                _this.logger.debug("Progress extension timer expired for INVITE server transaction " + _this.id + ".");
                if (!_this.lastProvisionalResponse) {
                    throw new Error("Last provisional response undefined.");
                }
                _this.send(_this.lastProvisionalResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                });
            }, timers_1.Timers.PROVISIONAL_RESPONSE_INTERVAL);
        }
    };
    /**
     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
     */
    InviteServerTransaction.prototype.stopProgressExtensionTimer = function () {
        if (this.progressExtensionTimer !== undefined) {
            clearInterval(this.progressExtensionTimer);
            this.progressExtensionTimer = undefined;
        }
    };
    /**
     * While in the "Proceeding" state, if the TU passes a response with status code
     * from 300 to 699 to the server transaction, the response MUST be passed to the
     * transport layer for transmission, and the state machine MUST enter the "Completed" state.
     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
     * reliable transports. If timer G fires, the response is passed to the transport layer once
     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
     * when timer G fires, the response is passed to the transport again for transmission, and
     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
     * it is reset with the value of T2.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */
    InviteServerTransaction.prototype.timer_G = function () {
        // TODO
    };
    /**
     * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
     * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
     * indicate to the TU that a transaction failure has occurred.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */
    InviteServerTransaction.prototype.timer_H = function () {
        this.logger.debug("Timer H expired for INVITE server transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.logger.warn("ACK to negative final response was never received, terminating transaction.");
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * Once timer I fires, the server MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */
    InviteServerTransaction.prototype.timer_I = function () {
        this.logger.debug("Timer I expired for INVITE server transaction " + this.id + ".");
        this.stateTransition(transaction_state_1.TransactionState.Terminated);
    };
    /**
     * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
     * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
     * it MUST be destroyed immediately. Timer L reflects the amount of time the server
     * transaction could receive 2xx responses for retransmission from the
     * TU while it is waiting to receive an ACK.
     * https://tools.ietf.org/html/rfc6026#section-7.1
     * https://tools.ietf.org/html/rfc6026#section-8.7
     */
    InviteServerTransaction.prototype.timer_L = function () {
        this.logger.debug("Timer L expired for INVITE server transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Accepted) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return InviteServerTransaction;
}(server_transaction_1.ServerTransaction));
exports.InviteServerTransaction = InviteServerTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var client_transaction_1 = __webpack_require__(/*! ./client-transaction */ "./node_modules/sip.js/lib/core/transactions/client-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * Non-INVITE Client Transaction.
 * @remarks
 * Non-INVITE transactions do not make use of ACK.
 * They are simple request-response interactions.
 * https://tools.ietf.org/html/rfc3261#section-17.1.2
 * @public
 */
var NonInviteClientTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(NonInviteClientTransaction, _super);
    /**
     * Constructor
     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
     * Then `toString` is called on the outgoing request and the message is sent via the transport.
     * After construction the transaction will be in the "calling" state and the transaction id
     * will equal the branch parameter set in the Via header of the outgoing request.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2
     * @param request - The outgoing Non-INVITE request.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function NonInviteClientTransaction(request, transport, user) {
        var _this = _super.call(this, request, transport, user, transaction_state_1.TransactionState.Trying, "sip.transaction.nict") || this;
        // FIXME: Timer E for unreliable transports not implemented.
        //
        // The "Trying" state is entered when the TU initiates a new client
        // transaction with a request.  When entering this state, the client
        // transaction SHOULD set timer F to fire in 64*T1 seconds. The request
        // MUST be passed to the transport layer for transmission.
        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
        _this.F = setTimeout(function () { return _this.timer_F(); }, timers_1.Timers.TIMER_F);
        _this.send(request.toString()).catch(function (error) {
            _this.logTransportError(error, "Failed to send initial outgoing request.");
        });
        return _this;
    }
    /**
     * Destructor.
     */
    NonInviteClientTransaction.prototype.dispose = function () {
        if (this.F) {
            clearTimeout(this.F);
            this.F = undefined;
        }
        if (this.K) {
            clearTimeout(this.K);
            this.K = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(NonInviteClientTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "nict";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handler for incoming responses from the transport which match this transaction.
     * @param response - The incoming response.
     */
    NonInviteClientTransaction.prototype.receiveResponse = function (response) {
        var statusCode = response.statusCode;
        if (!statusCode || statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Trying:
                // If a provisional response is received while in the "Trying" state, the
                // response MUST be passed to the TU, and then the client transaction
                // SHOULD move to the "Proceeding" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 100 && statusCode <= 199) {
                    this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // If a final response (status codes 200-699) is received while in the
                // "Trying" state, the response MUST be passed to the TU, and the
                // client transaction MUST transition to the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    if (statusCode === 408) {
                        this.onRequestTimeout();
                        return;
                    }
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // If a provisional response is received while in the "Proceeding" state,
                // the response MUST be passed to the TU. (From Figure 6)
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 100 && statusCode <= 199) {
                    if (this.user.receiveResponse) {
                        return this.user.receiveResponse(response);
                    }
                }
                // If a final response (status codes 200-699) is received while in the
                // "Proceeding" state, the response MUST be passed to the TU, and the
                // client transaction MUST transition to the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    if (statusCode === 408) {
                        this.onRequestTimeout();
                        return;
                    }
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
            case transaction_state_1.TransactionState.Completed:
                // The "Completed" state exists to buffer any additional response
                // retransmissions that may be received (which is why the client
                // transaction remains there only for unreliable transports).
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                return;
            case transaction_state_1.TransactionState.Terminated:
                // For good measure just absorb additional response retransmissions.
                return;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "Non-INVITE client transaction received unexpected " + statusCode + " response while in state " + this.state + ".";
        this.logger.warn(message);
        return;
    };
    /**
     * The client transaction SHOULD inform the TU that a transport failure has occurred,
     * and the client transaction SHOULD transition directly to the "Terminated" state.
     * The TU will handle the fail over mechanisms described in [4].
     * https://tools.ietf.org/html/rfc3261#section-17.1.4
     * @param error - Transport error
     */
    NonInviteClientTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
        this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
    };
    /** For logging. */
    NonInviteClientTransaction.prototype.typeToString = function () {
        return "non-INVITE client transaction";
    };
    /**
     * Execute a state transition.
     * @param newState - New state.
     */
    NonInviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
        var _this = this;
        if (dueToTransportError === void 0) { dueToTransportError = false; }
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Trying:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Proceeding:
                if (this.state !== transaction_state_1.TransactionState.Trying) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Trying &&
                    this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Trying &&
                    this.state !== transaction_state_1.TransactionState.Proceeding &&
                    this.state !== transaction_state_1.TransactionState.Completed) {
                    if (!dueToTransportError) {
                        invalidStateTransition();
                    }
                }
                break;
            default:
                invalidStateTransition();
        }
        // Once the client transaction enters the "Completed" state, it MUST set
        // Timer K to fire in T4 seconds for unreliable transports, and zero
        // seconds for reliable transports  The "Completed" state exists to
        // buffer any additional response retransmissions that may be received
        // (which is why the client transaction remains there only for unreliable transports).
        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
        if (newState === transaction_state_1.TransactionState.Completed) {
            if (this.F) {
                clearTimeout(this.F);
                this.F = undefined;
            }
            this.K = setTimeout(function () { return _this.timer_K(); }, timers_1.Timers.TIMER_K);
        }
        // Once the transaction is in the terminated state, it MUST be destroyed immediately.
        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        // Update state.
        this.setState(newState);
    };
    /**
     * If Timer F fires while the client transaction is still in the
     * "Trying" state, the client transaction SHOULD inform the TU about the
     * timeout, and then it SHOULD enter the "Terminated" state.
     * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
     * a timeout, and the client transaction MUST transition to the terminated state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
     */
    NonInviteClientTransaction.prototype.timer_F = function () {
        this.logger.debug("Timer F expired for non-INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Trying || this.state === transaction_state_1.TransactionState.Proceeding) {
            this.onRequestTimeout();
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * If Timer K fires while in this (COMPLETED) state, the client transaction
     * MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
     */
    NonInviteClientTransaction.prototype.timer_K = function () {
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return NonInviteClientTransaction;
}(client_transaction_1.ClientTransaction));
exports.NonInviteClientTransaction = NonInviteClientTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var server_transaction_1 = __webpack_require__(/*! ./server-transaction */ "./node_modules/sip.js/lib/core/transactions/server-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * Non-INVITE Server Transaction.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-17.2.2
 * @public
 */
var NonInviteServerTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(NonInviteServerTransaction, _super);
    /**
     * Constructor.
     * After construction the transaction will be in the "trying": state and the transaction
     * `id` will equal the branch parameter set in the Via header of the incoming request.
     * https://tools.ietf.org/html/rfc3261#section-17.2.2
     * @param request - Incoming Non-INVITE request from the transport.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function NonInviteServerTransaction(request, transport, user) {
        return _super.call(this, request, transport, user, transaction_state_1.TransactionState.Trying, "sip.transaction.nist") || this;
    }
    /**
     * Destructor.
     */
    NonInviteServerTransaction.prototype.dispose = function () {
        if (this.J) {
            clearTimeout(this.J);
            this.J = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(NonInviteServerTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "nist";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Receive requests from transport matching this transaction.
     * @param request - Request matching this transaction.
     */
    NonInviteServerTransaction.prototype.receiveRequest = function (request) {
        var _this = this;
        switch (this.state) {
            case transaction_state_1.TransactionState.Trying:
                // Once in the "Trying" state, any further request retransmissions are discarded.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // If a retransmission of the request is received while in the "Proceeding" state,
                // the most recently sent provisional response MUST be passed to the transport layer for retransmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                if (!this.lastResponse) {
                    throw new Error("Last response undefined.");
                }
                this.send(this.lastResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                });
                break;
            case transaction_state_1.TransactionState.Completed:
                // While in the "Completed" state, the server transaction MUST pass the final response to the transport
                // layer for retransmission whenever a retransmission of the request is received. Any other final responses
                // passed by the TU to the server transaction MUST be discarded while in the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                if (!this.lastResponse) {
                    throw new Error("Last response undefined.");
                }
                this.send(this.lastResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send retransmission of final response.");
                });
                break;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
    };
    /**
     * Receive responses from TU for this transaction.
     * @param statusCode - Status code of response. 101-199 not allowed per RFC 4320.
     * @param response - Response to send.
     */
    NonInviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
        var _this = this;
        if (statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        // An SIP element MUST NOT send any provisional response with a
        // Status-Code other than 100 to a non-INVITE request.
        // An SIP element MUST NOT respond to a non-INVITE request with a
        // Status-Code of 100 over any unreliable transport, such as UDP,
        // before the amount of time it takes a client transaction's Timer E to be reset to T2.
        // An SIP element MAY respond to a non-INVITE request with a
        // Status-Code of 100 over a reliable transport at any time.
        // https://tools.ietf.org/html/rfc4320#section-4.1
        if (statusCode > 100 && statusCode <= 199) {
            throw new Error("Provisional response other than 100 not allowed.");
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Trying:
                // While in the "Trying" state, if the TU passes a provisional response
                // to the server transaction, the server transaction MUST enter the "Proceeding" state.
                // The response MUST be passed to the transport layer for transmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                this.lastResponse = response;
                if (statusCode >= 100 && statusCode < 200) {
                    this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send provisional response.");
                    });
                    return;
                }
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send final response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // Any further provisional responses that are received from the TU while
                // in the "Proceeding" state MUST be passed to the transport layer for transmission.
                // If the TU passes a final response (status codes 200-699) to the server while in
                // the "Proceeding" state, the transaction MUST enter the "Completed" state, and
                // the response MUST be passed to the transport layer for transmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                this.lastResponse = response;
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send final response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                // Any other final responses passed by the TU to the server
                // transaction MUST be discarded while in the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                return;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "Non-INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
        this.logger.error(message);
        throw new Error(message);
    };
    /**
     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
     * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.4
     */
    NonInviteServerTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
        this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
    };
    /** For logging. */
    NonInviteServerTransaction.prototype.typeToString = function () {
        return "non-INVITE server transaction";
    };
    NonInviteServerTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
        var _this = this;
        if (dueToTransportError === void 0) { dueToTransportError = false; }
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Trying:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Proceeding:
                if (this.state !== transaction_state_1.TransactionState.Trying) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Trying && this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Proceeding && this.state !== transaction_state_1.TransactionState.Completed) {
                    if (!dueToTransportError) {
                        invalidStateTransition();
                    }
                }
                break;
            default:
                invalidStateTransition();
        }
        // When the server transaction enters the "Completed" state, it MUST set Timer J to fire
        // in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports.
        // https://tools.ietf.org/html/rfc3261#section-17.2.2
        if (newState === transaction_state_1.TransactionState.Completed) {
            this.J = setTimeout(function () { return _this.timer_J(); }, timers_1.Timers.TIMER_J);
        }
        // The server transaction MUST be destroyed the instant it enters the "Terminated" state.
        // https://tools.ietf.org/html/rfc3261#section-17.2.2
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        this.setState(newState);
    };
    /**
     * The server transaction remains in this state until Timer J fires,
     * at which point it MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.2
     */
    NonInviteServerTransaction.prototype.timer_J = function () {
        this.logger.debug("Timer J expired for NON-INVITE server transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return NonInviteServerTransaction;
}(server_transaction_1.ServerTransaction));
exports.NonInviteServerTransaction = NonInviteServerTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/server-transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/server-transaction.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/sip.js/lib/core/transactions/transaction.js");
/**
 * Server Transaction.
 * @remarks
 * The server transaction is responsible for the delivery of requests to
 * the TU and the reliable transmission of responses.  It accomplishes
 * this through a state machine.  Server transactions are created by the
 * core when a request is received, and transaction handling is desired
 * for that request (this is not always the case).
 * https://tools.ietf.org/html/rfc3261#section-17.2
 * @public
 */
var ServerTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(ServerTransaction, _super);
    function ServerTransaction(_request, transport, user, state, loggerCategory) {
        var _this = _super.call(this, transport, user, _request.viaBranch, state, loggerCategory) || this;
        _this._request = _request;
        _this.user = user;
        return _this;
    }
    Object.defineProperty(ServerTransaction.prototype, "request", {
        /** The incoming request the transaction handling. */
        get: function () {
            return this._request;
        },
        enumerable: true,
        configurable: true
    });
    return ServerTransaction;
}(transaction_1.Transaction));
exports.ServerTransaction = ServerTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/transaction-state.js":
/*!************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/transaction-state.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction state.
 * @public
 */
var TransactionState;
(function (TransactionState) {
    TransactionState["Accepted"] = "Accepted";
    TransactionState["Calling"] = "Calling";
    TransactionState["Completed"] = "Completed";
    TransactionState["Confirmed"] = "Confirmed";
    TransactionState["Proceeding"] = "Proceeding";
    TransactionState["Terminated"] = "Terminated";
    TransactionState["Trying"] = "Trying";
})(TransactionState = exports.TransactionState || (exports.TransactionState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/transaction.js":
/*!******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/transaction.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js");
/**
 * Transaction.
 * @remarks
 * SIP is a transactional protocol: interactions between components take
 * place in a series of independent message exchanges.  Specifically, a
 * SIP transaction consists of a single request and any responses to
 * that request, which include zero or more provisional responses and
 * one or more final responses.  In the case of a transaction where the
 * request was an INVITE (known as an INVITE transaction), the
 * transaction also includes the ACK only if the final response was not
 * a 2xx response.  If the response was a 2xx, the ACK is not considered
 * part of the transaction.
 * https://tools.ietf.org/html/rfc3261#section-17
 * @public
 */
var Transaction = /** @class */ (function (_super) {
    tslib_1.__extends(Transaction, _super);
    function Transaction(_transport, _user, _id, _state, loggerCategory) {
        var _this = _super.call(this) || this;
        _this._transport = _transport;
        _this._user = _user;
        _this._id = _id;
        _this._state = _state;
        _this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
        _this.logger.debug("Constructing " + _this.typeToString() + " with id " + _this.id + ".");
        return _this;
    }
    /**
     * Destructor.
     * Once the transaction is in the "terminated" state, it is destroyed
     * immediately and there is no need to call `dispose`. However, if a
     * transaction needs to be ended prematurely, the transaction user may
     * do so by calling this method (for example, perhaps the UA is shutting down).
     * No state transition will occur upon calling this method, all outstanding
     * transmission timers will be cancelled, and use of the transaction after
     * calling `dispose` is undefined.
     */
    Transaction.prototype.dispose = function () {
        this.logger.debug("Destroyed " + this.typeToString() + " with id " + this.id + ".");
    };
    Object.defineProperty(Transaction.prototype, "id", {
        /** Transaction id. */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            throw new Error("Invalid kind.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "state", {
        /** Transaction state. */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "transport", {
        /** Transaction transport. */
        get: function () {
            return this._transport;
        },
        enumerable: true,
        configurable: true
    });
    Transaction.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    Transaction.prototype.logTransportError = function (error, message) {
        this.logger.error(error.message);
        this.logger.error("Transport error occurred in " + this.typeToString() + " with id " + this.id + ".");
        this.logger.error(message);
    };
    /**
     * Pass message to transport for transmission. If transport fails,
     * the transaction user is notified by callback to onTransportError().
     * @returns
     * Rejects with `TransportError` if transport fails.
     */
    Transaction.prototype.send = function (message) {
        var _this = this;
        return this.transport.send(message).catch(function (error) {
            // If the transport rejects, it SHOULD reject with a TransportError.
            // But the transport may be external code, so we are careful
            // make sure we convert it to a TransportError if need be.
            if (error instanceof exceptions_1.TransportError) {
                _this.onTransportError(error);
                throw error;
            }
            var transportError;
            if (error && typeof error.message === "string") {
                transportError = new exceptions_1.TransportError(error.message);
            }
            else {
                transportError = new exceptions_1.TransportError();
            }
            _this.onTransportError(transportError);
            throw transportError;
        });
    };
    Transaction.prototype.setState = function (state) {
        this.logger.debug("State change to \"" + state + "\" on " + this.typeToString() + " with id " + this.id + ".");
        this._state = state;
        if (this._user.onStateChange) {
            this._user.onStateChange(state);
        }
        this.emit("stateChanged");
    };
    Transaction.prototype.typeToString = function () {
        return "UnknownType";
    };
    return Transaction;
}(events_1.EventEmitter));
exports.Transaction = Transaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
/**
 * FIXME: TODO: Should be configurable/variable.
 */
exports.AllowedMethods = [
    messages_1.C.ACK,
    messages_1.C.BYE,
    messages_1.C.CANCEL,
    messages_1.C.INFO,
    messages_1.C.INVITE,
    messages_1.C.MESSAGE,
    messages_1.C.NOTIFY,
    messages_1.C.OPTIONS,
    messages_1.C.PRACK,
    messages_1.C.REFER,
    messages_1.C.REGISTER,
    messages_1.C.SUBSCRIBE
];


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agent-core/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agent-core/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-core */ "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agents_1 = __webpack_require__(/*! ../user-agents */ "./node_modules/sip.js/lib/core/user-agents/index.js");
var allowed_methods_1 = __webpack_require__(/*! ./allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
/**
 * This is ported from UA.C.ACCEPTED_BODY_TYPES.
 * FIXME: TODO: Should be configurable/variable.
 */
var acceptedBodyTypes = [
    "application/sdp",
    "application/dtmf-relay"
];
/**
 * User Agent Core.
 * @remarks
 * Core designates the functions specific to a particular type
 * of SIP entity, i.e., specific to either a stateful or stateless
 * proxy, a user agent or registrar.  All cores, except those for
 * the stateless proxy, are transaction users.
 * https://tools.ietf.org/html/rfc3261#section-6
 *
 * UAC Core: The set of processing functions required of a UAC that
 * reside above the transaction and transport layers.
 * https://tools.ietf.org/html/rfc3261#section-6
 *
 * UAS Core: The set of processing functions required at a UAS that
 * resides above the transaction and transport layers.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentCore = /** @class */ (function () {
    /**
     * Constructor.
     * @param configuration - Configuration.
     * @param delegate - Delegate.
     */
    function UserAgentCore(configuration, delegate) {
        if (delegate === void 0) { delegate = {}; }
        /** UACs. */
        this.userAgentClients = new Map();
        /** UASs. */
        this.userAgentServers = new Map();
        this.configuration = configuration;
        this.delegate = delegate;
        this.dialogs = new Map();
        this.subscribers = new Map();
        this.logger = configuration.loggerFactory.getLogger("sip.user-agent-core");
    }
    /** Destructor. */
    UserAgentCore.prototype.dispose = function () {
        this.reset();
    };
    /** Reset. */
    UserAgentCore.prototype.reset = function () {
        this.dialogs.forEach(function (dialog) { return dialog.dispose(); });
        this.dialogs.clear();
        this.subscribers.forEach(function (subscriber) { return subscriber.dispose(); });
        this.subscribers.clear();
        this.userAgentClients.forEach(function (uac) { return uac.dispose(); });
        this.userAgentClients.clear();
        this.userAgentServers.forEach(function (uac) { return uac.dispose(); });
        this.userAgentServers.clear();
    };
    Object.defineProperty(UserAgentCore.prototype, "loggerFactory", {
        /** Logger factory. */
        get: function () {
            return this.configuration.loggerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentCore.prototype, "transport", {
        /** Transport. */
        get: function () {
            var transport = this.configuration.transportAccessor();
            if (!transport) {
                throw new Error("Transport undefined.");
            }
            return transport;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Send INVITE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.invite = function (request, delegate) {
        return new user_agents_1.InviteUserAgentClient(this, request, delegate);
    };
    /**
     * Send MESSAGE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.message = function (request, delegate) {
        return new user_agents_1.MessageUserAgentClient(this, request, delegate);
    };
    /**
     * Send PUBLISH.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.publish = function (request, delegate) {
        return new user_agents_1.PublishUserAgentClient(this, request, delegate);
    };
    /**
     * Send REGISTER.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.register = function (request, delegate) {
        return new user_agents_1.RegisterUserAgentClient(this, request, delegate);
    };
    /**
     * Send SUBSCRIBE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.subscribe = function (request, delegate) {
        return new user_agents_1.SubscribeUserAgentClient(this, request, delegate);
    };
    /**
     * Send a request.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.request = function (request, delegate) {
        return new user_agents_1.UserAgentClient(transactions_1.NonInviteClientTransaction, this, request, delegate);
    };
    /**
     * Outgoing request message factory function.
     * @param method - Method.
     * @param requestURI - Request-URI.
     * @param fromURI - From URI.
     * @param toURI - To URI.
     * @param options - Request options.
     * @param extraHeaders - Extra headers to add.
     * @param body - Message body.
     */
    UserAgentCore.prototype.makeOutgoingRequestMessage = function (method, requestURI, fromURI, toURI, options, extraHeaders, body) {
        // default values from user agent configuration
        var callIdPrefix = this.configuration.sipjsId;
        var fromDisplayName = this.configuration.displayName;
        var forceRport = this.configuration.viaForceRport;
        var hackViaTcp = this.configuration.hackViaTcp;
        var optionTags = this.configuration.supportedOptionTags.slice();
        if (method === messages_1.C.REGISTER) {
            optionTags.push("path", "gruu");
        }
        if (method === messages_1.C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {
            optionTags.push("gruu");
        }
        var routeSet = this.configuration.routeSet;
        var userAgentString = this.configuration.userAgentHeaderFieldValue;
        var viaHost = this.configuration.viaHost;
        var defaultOptions = {
            callIdPrefix: callIdPrefix,
            forceRport: forceRport,
            fromDisplayName: fromDisplayName,
            hackViaTcp: hackViaTcp,
            optionTags: optionTags,
            routeSet: routeSet,
            userAgentString: userAgentString,
            viaHost: viaHost,
        };
        // merge provided options with default options
        var requestOptions = tslib_1.__assign(tslib_1.__assign({}, defaultOptions), options);
        return new messages_1.OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);
    };
    /**
     * Handle an incoming request message from the transport.
     * @param message - Incoming request message from transport layer.
     */
    UserAgentCore.prototype.receiveIncomingRequestFromTransport = function (message) {
        this.receiveRequestFromTransport(message);
    };
    /**
     * Handle an incoming response message from the transport.
     * @param message - Incoming response message from transport layer.
     */
    UserAgentCore.prototype.receiveIncomingResponseFromTransport = function (message) {
        this.receiveResponseFromTransport(message);
    };
    /**
     * A stateless UAS is a UAS that does not maintain transaction state.
     * It replies to requests normally, but discards any state that would
     * ordinarily be retained by a UAS after a response has been sent.  If a
     * stateless UAS receives a retransmission of a request, it regenerates
     * the response and re-sends it, just as if it were replying to the first
     * instance of the request. A UAS cannot be stateless unless the request
     * processing for that method would always result in the same response
     * if the requests are identical. This rules out stateless registrars,
     * for example.  Stateless UASs do not use a transaction layer; they
     * receive requests directly from the transport layer and send responses
     * directly to the transport layer.
     * https://tools.ietf.org/html/rfc3261#section-8.2.7
     * @param message - Incoming request message to reply to.
     * @param statusCode - Status code to reply with.
     */
    UserAgentCore.prototype.replyStateless = function (message, options) {
        var _this = this;
        var userAgent = this.configuration.userAgentHeaderFieldValue;
        var supported = this.configuration.supportedOptionTagsResponse;
        options = tslib_1.__assign(tslib_1.__assign({}, options), { userAgent: userAgent, supported: supported });
        var response = messages_1.constructOutgoingResponse(message, options);
        this.transport.send(response.message).catch(function (error) {
            // If the transport rejects, it SHOULD reject with a TransportError.
            // But the transport may be external code, so we are careful...
            if (error instanceof Error) {
                _this.logger.error(error.message);
            }
            _this.logger.error("Transport error occurred sending stateless reply to " + message.method + " request.");
            // TODO: Currently there is no hook to provide notification that a transport error occurred
            // and throwing would result in an uncaught error (in promise), so we silently eat the error.
            // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.
        });
        return response;
    };
    /**
     * In Section 18.2.1, replace the last paragraph with:
     *
     * Next, the server transport attempts to match the request to a
     * server transaction.  It does so using the matching rules described
     * in Section 17.2.3.  If a matching server transaction is found, the
     * request is passed to that transaction for processing.  If no match
     * is found, the request is passed to the core, which may decide to
     * construct a new server transaction for that request.
     * https://tools.ietf.org/html/rfc6026#section-8.10
     * @param message - Incoming request message from transport layer.
     */
    UserAgentCore.prototype.receiveRequestFromTransport = function (message) {
        // When a request is received from the network by the server, it has to
        // be matched to an existing transaction.  This is accomplished in the
        // following manner.
        //
        // The branch parameter in the topmost Via header field of the request
        // is examined.  If it is present and begins with the magic cookie
        // "z9hG4bK", the request was generated by a client transaction
        // compliant to this specification.  Therefore, the branch parameter
        // will be unique across all transactions sent by that client.  The
        // request matches a transaction if:
        //
        //    1. the branch parameter in the request is equal to the one in the
        //       top Via header field of the request that created the
        //       transaction, and
        //
        //    2. the sent-by value in the top Via of the request is equal to the
        //       one in the request that created the transaction, and
        //
        //    3. the method of the request matches the one that created the
        //       transaction, except for ACK, where the method of the request
        //       that created the transaction is INVITE.
        //
        // This matching rule applies to both INVITE and non-INVITE transactions
        // alike.
        //
        //    The sent-by value is used as part of the matching process because
        //    there could be accidental or malicious duplication of branch
        //    parameters from different clients.
        // https://tools.ietf.org/html/rfc3261#section-17.2.3
        var transactionId = message.viaBranch; // FIXME: Currently only using rule 1...
        var uas = this.userAgentServers.get(transactionId);
        // When receiving an ACK that matches an existing INVITE server
        // transaction and that does not contain a branch parameter containing
        // the magic cookie defined in RFC 3261, the matching transaction MUST
        // be checked to see if it is in the "Accepted" state.  If it is, then
        // the ACK must be passed directly to the transaction user instead of
        // being absorbed by the transaction state machine.  This is necessary
        // as requests from RFC 2543 clients will not include a unique branch
        // parameter, and the mechanisms for calculating the transaction ID from
        // such a request will be the same for both INVITE and ACKs.
        // https://tools.ietf.org/html/rfc6026#section-6
        // Any ACKs received from the network while in the "Accepted" state MUST be
        // passed directly to the TU and not absorbed.
        // https://tools.ietf.org/html/rfc6026#section-7.1
        if (message.method === messages_1.C.ACK) {
            if (uas && uas.transaction.state === transactions_1.TransactionState.Accepted) {
                if (uas instanceof user_agents_1.InviteUserAgentServer) {
                    // These are ACKs matching an INVITE server transaction.
                    // These should never happen with RFC 3261 compliant user agents
                    // (would be a broken ACK to negative final response or something)
                    // but is apparently how RFC 2543 user agents do things.
                    // We are not currently supporting this case.
                    // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
                    this.logger.warn("Discarding out of dialog ACK after 2xx response sent on transaction " + transactionId + ".");
                    return;
                }
            }
        }
        // The CANCEL method requests that the TU at the server side cancel a
        // pending transaction.  The TU determines the transaction to be
        // cancelled by taking the CANCEL request, and then assuming that the
        // request method is anything but CANCEL or ACK and applying the
        // transaction matching procedures of Section 17.2.3.  The matching
        // transaction is the one to be cancelled.
        // https://tools.ietf.org/html/rfc3261#section-9.2
        if (message.method === messages_1.C.CANCEL) {
            if (uas) {
                // Regardless of the method of the original request, as long as the
                // CANCEL matched an existing transaction, the UAS answers the CANCEL
                // request itself with a 200 (OK) response.
                // https://tools.ietf.org/html/rfc3261#section-9.2
                this.replyStateless(message, { statusCode: 200 });
                // If the transaction for the original request still exists, the behavior
                // of the UAS on receiving a CANCEL request depends on whether it has already
                // sent a final response for the original request. If it has, the CANCEL
                // request has no effect on the processing of the original request, no
                // effect on any session state, and no effect on the responses generated
                // for the original request. If the UAS has not issued a final response
                // for the original request, its behavior depends on the method of the
                // original request. If the original request was an INVITE, the UAS
                // SHOULD immediately respond to the INVITE with a 487 (Request
                // Terminated).
                // https://tools.ietf.org/html/rfc3261#section-9.2
                if (uas.transaction instanceof transactions_1.InviteServerTransaction &&
                    uas.transaction.state === transactions_1.TransactionState.Proceeding) {
                    if (uas instanceof user_agents_1.InviteUserAgentServer) {
                        uas.receiveCancel(message);
                    }
                    // A CANCEL request has no impact on the processing of
                    // transactions with any other method defined in this specification.
                    // https://tools.ietf.org/html/rfc3261#section-9.2
                }
            }
            else {
                // If the UAS did not find a matching transaction for the CANCEL
                // according to the procedure above, it SHOULD respond to the CANCEL
                // with a 481 (Call Leg/Transaction Does Not Exist).
                // https://tools.ietf.org/html/rfc3261#section-9.2
                this.replyStateless(message, { statusCode: 481 });
            }
            return;
        }
        // If a matching server transaction is found, the request is passed to that
        // transaction for processing.
        // https://tools.ietf.org/html/rfc6026#section-8.10
        if (uas) {
            uas.transaction.receiveRequest(message);
            return;
        }
        // If no match is found, the request is passed to the core, which may decide to
        // construct a new server transaction for that request.
        // https://tools.ietf.org/html/rfc6026#section-8.10
        this.receiveRequest(message);
        return;
    };
    /**
     * UAC and UAS procedures depend strongly on two factors.  First, based
     * on whether the request or response is inside or outside of a dialog,
     * and second, based on the method of a request.  Dialogs are discussed
     * thoroughly in Section 12; they represent a peer-to-peer relationship
     * between user agents and are established by specific SIP methods, such
     * as INVITE.
     * @param message - Incoming request message.
     */
    UserAgentCore.prototype.receiveRequest = function (message) {
        // 8.2 UAS Behavior
        // UASs SHOULD process the requests in the order of the steps that
        // follow in this section (that is, starting with authentication, then
        // inspecting the method, the header fields, and so on throughout the
        // remainder of this section).
        // https://tools.ietf.org/html/rfc3261#section-8.2
        // 8.2.1 Method Inspection
        // Once a request is authenticated (or authentication is skipped), the
        // UAS MUST inspect the method of the request.  If the UAS recognizes
        // but does not support the method of a request, it MUST generate a 405
        // (Method Not Allowed) response.  Procedures for generating responses
        // are described in Section 8.2.6.  The UAS MUST also add an Allow
        // header field to the 405 (Method Not Allowed) response.  The Allow
        // header field MUST list the set of methods supported by the UAS
        // generating the message.
        // https://tools.ietf.org/html/rfc3261#section-8.2.1
        if (allowed_methods_1.AllowedMethods.indexOf(message.method) === -1) {
            var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
            this.replyStateless(message, {
                statusCode: 405,
                extraHeaders: [allowHeader]
            });
            return;
        }
        // 8.2.2 Header Inspection
        // https://tools.ietf.org/html/rfc3261#section-8.2.2
        if (!message.ruri) { // FIXME: A request message should always have an ruri
            throw new Error("Request-URI undefined.");
        }
        // 8.2.2.1 To and Request-URI
        // If the Request-URI uses a scheme not supported by the UAS, it SHOULD
        // reject the request with a 416 (Unsupported URI Scheme) response.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
        if (message.ruri.scheme !== "sip") {
            this.replyStateless(message, { statusCode: 416 });
            return;
        }
        // 8.2.2.1 To and Request-URI
        // If the Request-URI does not identify an address that the
        // UAS is willing to accept requests for, it SHOULD reject
        // the request with a 404 (Not Found) response.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
        var ruri = message.ruri;
        var ruriMatches = function (uri) {
            return !!uri && uri.user === ruri.user;
        };
        if (!ruriMatches(this.configuration.aor) &&
            !(ruriMatches(this.configuration.contact.uri) ||
                ruriMatches(this.configuration.contact.pubGruu) ||
                ruriMatches(this.configuration.contact.tempGruu))) {
            this.logger.warn("Request-URI does not point to us.");
            if (message.method !== messages_1.C.ACK) {
                this.replyStateless(message, { statusCode: 404 });
            }
            return;
        }
        // 8.2.2.1 To and Request-URI
        // Other potential sources of received Request-URIs include
        // the Contact header fields of requests and responses sent by the UA
        // that establish or refresh dialogs.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
        if (message.method === messages_1.C.INVITE) {
            if (!message.hasHeader("Contact")) {
                this.replyStateless(message, {
                    statusCode: 400,
                    reasonPhrase: "Missing Contact Header"
                });
                return;
            }
        }
        // 8.2.2.2 Merged Requests
        // If the request has no tag in the To header field, the UAS core MUST
        // check the request against ongoing transactions.  If the From tag,
        // Call-ID, and CSeq exactly match those associated with an ongoing
        // transaction, but the request does not match that transaction (based
        // on the matching rules in Section 17.2.3), the UAS core SHOULD
        // generate a 482 (Loop Detected) response and pass it to the server
        // transaction.
        //
        //    The same request has arrived at the UAS more than once, following
        //    different paths, most likely due to forking.  The UAS processes
        //    the first such request received and responds with a 482 (Loop
        //    Detected) to the rest of them.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.2
        if (!message.toTag) {
            var transactionId = message.viaBranch;
            if (!this.userAgentServers.has(transactionId)) {
                var mergedRequest = Array.from(this.userAgentServers.values())
                    .some(function (uas) {
                    return uas.transaction.request.fromTag === message.fromTag &&
                        uas.transaction.request.callId === message.callId &&
                        uas.transaction.request.cseq === message.cseq;
                });
                if (mergedRequest) {
                    this.replyStateless(message, { statusCode: 482 });
                    return;
                }
            }
        }
        // 8.2.2.3 Require
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.3
        // TODO
        // 8.2.3 Content Processing
        // https://tools.ietf.org/html/rfc3261#section-8.2.3
        // TODO
        // 8.2.4 Applying Extensions
        // https://tools.ietf.org/html/rfc3261#section-8.2.4
        // TODO
        // 8.2.5 Processing the Request
        // Assuming all of the checks in the previous subsections are passed,
        // the UAS processing becomes method-specific.
        // https://tools.ietf.org/html/rfc3261#section-8.2.5
        // The UAS will receive the request from the transaction layer.  If the
        // request has a tag in the To header field, the UAS core computes the
        // dialog identifier corresponding to the request and compares it with
        // existing dialogs.  If there is a match, this is a mid-dialog request.
        // In that case, the UAS first applies the same processing rules for
        // requests outside of a dialog, discussed in Section 8.2.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (message.toTag) {
            this.receiveInsideDialogRequest(message);
        }
        else {
            this.receiveOutsideDialogRequest(message);
        }
        return;
    };
    /**
     * Once a dialog has been established between two UAs, either of them
     * MAY initiate new transactions as needed within the dialog.  The UA
     * sending the request will take the UAC role for the transaction.  The
     * UA receiving the request will take the UAS role.  Note that these may
     * be different roles than the UAs held during the transaction that
     * established the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.2
     * @param message - Incoming request message.
     */
    UserAgentCore.prototype.receiveInsideDialogRequest = function (message) {
        // NOTIFY requests are matched to such SUBSCRIBE requests if they
        // contain the same "Call-ID", a "To" header field "tag" parameter that
        // matches the "From" header field "tag" parameter of the SUBSCRIBE
        // request, and the same "Event" header field.  Rules for comparisons of
        // the "Event" header fields are described in Section 8.2.1.
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        if (message.method === messages_1.C.NOTIFY) {
            var event_1 = message.parseHeader("Event");
            if (!event_1 || !event_1.event) {
                this.replyStateless(message, { statusCode: 489 });
                return;
            }
            // FIXME: Subscriber id should also matching on event id.
            var subscriberId = message.callId + message.toTag + event_1.event;
            var subscriber = this.subscribers.get(subscriberId);
            if (subscriber) {
                var uas = new user_agents_1.NotifyUserAgentServer(this, message);
                subscriber.onNotify(uas);
                return;
            }
        }
        // Requests sent within a dialog, as any other requests, are atomic.  If
        // a particular request is accepted by the UAS, all the state changes
        // associated with it are performed.  If the request is rejected, none
        // of the state changes are performed.
        //
        //    Note that some requests, such as INVITEs, affect several pieces of
        //    state.
        //
        // The UAS will receive the request from the transaction layer.  If the
        // request has a tag in the To header field, the UAS core computes the
        // dialog identifier corresponding to the request and compares it with
        // existing dialogs.  If there is a match, this is a mid-dialog request.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        var dialogId = message.callId + message.toTag + message.fromTag;
        var dialog = this.dialogs.get(dialogId);
        if (dialog) {
            // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS
            // You got the question right.
            //
            // And you got the right answer too. :-)
            //
            //   Thanks,
            //   Paul
            //
            // Robert Sparks wrote:
            // > So I've lost track of the question during the musing.
            // >
            // > I _think_ the fundamental question being asked is this:
            // >
            // > Is an endpoint required to reject (with a 481) an OPTIONS request that
            // > arrives with at to-tag but does not match any existing dialog state.
            // > (Assuming some earlier requirement hasn't forced another error code). Or
            // > is it OK if it just sends
            // > a 200 OK anyhow.
            // >
            // > My take on the collection of specs is that its _not_ ok for it to send
            // > the 200 OK anyhow and that it is required to send
            // > the 481. I base this primarily on these sentences from 11.2 in 3261:
            // >
            // >    The response to an OPTIONS is constructed using the standard rules
            // >    for a SIP response as discussed in Section 8.2.6.  The response code
            // >    chosen MUST be the same that would have been chosen had the request
            // >    been an INVITE.
            // >
            // > Did I miss the point of the question?
            // >
            // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:
            // >
            // >> [Including Robert in hopes of getting his insight on this.]
            // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html
            //
            // Requests that do not change in any way the state of a dialog may be
            // received within a dialog (for example, an OPTIONS request).  They are
            // processed as if they had been received outside the dialog.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (message.method === messages_1.C.OPTIONS) {
                var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
                this.replyStateless(message, {
                    statusCode: 200,
                    extraHeaders: [allowHeader, acceptHeader]
                });
                return;
            }
            // Pass the incoming request to the dialog for further handling.
            dialog.receiveRequest(message);
            return;
        }
        // The most important behaviors of a stateless UAS are the following:
        // ...
        // o  A stateless UAS MUST ignore ACK requests.
        // ...
        // https://tools.ietf.org/html/rfc3261#section-8.2.7
        if (message.method === messages_1.C.ACK) {
            // If a final response to an INVITE was sent statelessly,
            // the corresponding ACK:
            // - will not match an existing transaction
            // - may have tag in the To header field
            // - not not match any existing dialogs
            // Absorb unmatched ACKs.
            return;
        }
        // If the request has a tag in the To header field, but the dialog
        // identifier does not match any existing dialogs, the UAS may have
        // crashed and restarted, or it may have received a request for a
        // different (possibly failed) UAS (the UASs can construct the To tags
        // so that a UAS can identify that the tag was for a UAS for which it is
        // providing recovery).  Another possibility is that the incoming
        // request has been simply mis-routed.  Based on the To tag, the UAS MAY
        // either accept or reject the request.  Accepting the request for
        // acceptable To tags provides robustness, so that dialogs can persist
        // even through crashes.  UAs wishing to support this capability must
        // take into consideration some issues such as choosing monotonically
        // increasing CSeq sequence numbers even across reboots, reconstructing
        // the route set, and accepting out-of-range RTP timestamps and sequence
        // numbers.
        //
        // If the UAS wishes to reject the request because it does not wish to
        // recreate the dialog, it MUST respond to the request with a 481
        // (Call/Transaction Does Not Exist) status code and pass that to the
        // server transaction.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        this.replyStateless(message, { statusCode: 481 });
        return;
    };
    /**
     * Assuming all of the checks in the previous subsections are passed,
     * the UAS processing becomes method-specific.
     *  https://tools.ietf.org/html/rfc3261#section-8.2.5
     * @param message - Incoming request message.
     */
    UserAgentCore.prototype.receiveOutsideDialogRequest = function (message) {
        switch (message.method) {
            case messages_1.C.ACK:
                // Absorb stray out of dialog ACKs
                break;
            case messages_1.C.BYE:
                // If the BYE does not match an existing dialog, the UAS core SHOULD
                // generate a 481 (Call/Transaction Does Not Exist) response and pass
                // that to the server transaction. This rule means that a BYE sent
                // without tags by a UAC will be rejected.
                // https://tools.ietf.org/html/rfc3261#section-15.1.2
                this.replyStateless(message, { statusCode: 481 });
                break;
            case messages_1.C.CANCEL:
                throw new Error("Unexpected out of dialog request method " + message.method + ".");
                break;
            case messages_1.C.INFO:
                // Use of the INFO method does not constitute a separate dialog usage.
                // INFO messages are always part of, and share the fate of, an invite
                // dialog usage [RFC5057].  INFO messages cannot be sent as part of
                // other dialog usages, or outside an existing dialog.
                // https://tools.ietf.org/html/rfc6086#section-1
                this.replyStateless(message, { statusCode: 405 }); // Should never happen
                break;
            case messages_1.C.INVITE:
                // https://tools.ietf.org/html/rfc3261#section-13.3.1
                {
                    var uas = new user_agents_1.InviteUserAgentServer(this, message);
                    this.delegate.onInvite ?
                        this.delegate.onInvite(uas) :
                        uas.reject();
                }
                break;
            case messages_1.C.MESSAGE:
                // MESSAGE requests are discouraged inside a dialog.  Implementations
                // are restricted from creating a usage for the purpose of carrying a
                // sequence of MESSAGE requests (though some implementations use it that
                // way, against the standard recommendation).
                // https://tools.ietf.org/html/rfc5057#section-5.3
                {
                    var uas = new user_agents_1.MessageUserAgentServer(this, message);
                    this.delegate.onMessage ?
                        this.delegate.onMessage(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.NOTIFY:
                // Obsoleted by: RFC 6665
                // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,
                // it is the responsibility of the parties defining those mechanisms to
                // ensure that correlation of a NOTIFY message to the corresponding
                // subscription is possible.  Designers of such mechanisms are also
                // warned to make a distinction between sending a NOTIFY message to a
                // subscriber who is aware of the subscription, and sending a NOTIFY
                // message to an unsuspecting node.  The latter behavior is invalid, and
                // MUST receive a "481 Subscription does not exist" response (unless
                // some other 400- or 500-class error code is more applicable), as
                // described in section 3.2.4.  In other words, knowledge of a
                // subscription must exist in both the subscriber and the notifier to be
                // valid, even if installed via a non-SUBSCRIBE mechanism.
                // https://tools.ietf.org/html/rfc3265#section-3.2
                //
                // NOTIFY requests are sent to inform subscribers of changes in state to
                // which the subscriber has a subscription.  Subscriptions are created
                // using the SUBSCRIBE method.  In legacy implementations, it is
                // possible that other means of subscription creation have been used.
                // However, this specification does not allow the creation of
                // subscriptions except through SUBSCRIBE requests and (for backwards-
                // compatibility) REFER requests [RFC3515].
                // https://tools.ietf.org/html/rfc6665#section-3.2
                {
                    var uas = new user_agents_1.NotifyUserAgentServer(this, message);
                    this.delegate.onNotify ?
                        this.delegate.onNotify(uas) :
                        uas.reject({ statusCode: 405 });
                }
                break;
            case messages_1.C.OPTIONS:
                // https://tools.ietf.org/html/rfc3261#section-11.2
                {
                    var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                    var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
                    this.replyStateless(message, {
                        statusCode: 200,
                        extraHeaders: [allowHeader, acceptHeader]
                    });
                }
                break;
            case messages_1.C.REFER:
                // https://tools.ietf.org/html/rfc3515#section-2.4.2
                {
                    var uas = new user_agents_1.ReferUserAgentServer(this, message);
                    this.delegate.onRefer ?
                        this.delegate.onRefer(uas) :
                        uas.reject({ statusCode: 405 });
                }
                break;
            case messages_1.C.REGISTER:
                // https://tools.ietf.org/html/rfc3261#section-10.3
                {
                    var uas = new user_agents_1.RegisterUserAgentServer(this, message);
                    this.delegate.onRegister ?
                        this.delegate.onRegister(uas) :
                        uas.reject({ statusCode: 405 });
                }
                break;
            case messages_1.C.SUBSCRIBE:
                // https://tools.ietf.org/html/rfc6665#section-4.2
                {
                    var uas = new user_agents_1.SubscribeUserAgentServer(this, message);
                    this.delegate.onSubscribe ?
                        this.delegate.onSubscribe(uas) :
                        uas.reject({ statusCode: 480 });
                }
                break;
            default:
                throw new Error("Unexpected out of dialog request method " + message.method + ".");
        }
        return;
    };
    /**
     * Responses are first processed by the transport layer and then passed
     * up to the transaction layer.  The transaction layer performs its
     * processing and then passes the response up to the TU.  The majority
     * of response processing in the TU is method specific.  However, there
     * are some general behaviors independent of the method.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3
     * @param message - Incoming response message from transport layer.
     */
    UserAgentCore.prototype.receiveResponseFromTransport = function (message) {
        // 8.1.3.1 Transaction Layer Errors
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
        // Handled by transaction layer callbacks.
        // 8.1.3.2 Unrecognized Responses
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
        // TODO
        // 8.1.3.3 Vias
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.3
        if (message.getHeaders("via").length > 1) {
            this.logger.warn("More than one Via header field present in the response, dropping");
            return;
        }
        // 8.1.3.4 Processing 3xx Responses
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.4
        // TODO
        // 8.1.3.5 Processing 4xx Responses
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
        // TODO
        // When the transport layer in the client receives a response, it has to
        // determine which client transaction will handle the response, so that
        // the processing of Sections 17.1.1 and 17.1.2 can take place.  The
        // branch parameter in the top Via header field is used for this
        // purpose.  A response matches a client transaction under two
        // conditions:
        //
        //    1.  If the response has the same value of the branch parameter in
        //        the top Via header field as the branch parameter in the top
        //        Via header field of the request that created the transaction.
        //
        //    2.  If the method parameter in the CSeq header field matches the
        //        method of the request that created the transaction.  The
        //        method is needed since a CANCEL request constitutes a
        //        different transaction, but shares the same value of the branch
        //        parameter.
        // https://tools.ietf.org/html/rfc3261#section-17.1.3
        var userAgentClientId = message.viaBranch + message.method;
        var userAgentClient = this.userAgentClients.get(userAgentClientId);
        // The client transport uses the matching procedures of Section
        // 17.1.3 to attempt to match the response to an existing
        // transaction.  If there is a match, the response MUST be passed to
        // that transaction.  Otherwise, any element other than a stateless
        // proxy MUST silently discard the response.
        // https://tools.ietf.org/html/rfc6026#section-8.9
        if (userAgentClient) {
            userAgentClient.transaction.receiveResponse(message);
        }
        else {
            this.logger.warn("Discarding unmatched " + message.statusCode + " response to " + message.method + " " + userAgentClientId + ".");
        }
    };
    return UserAgentCore;
}());
exports.UserAgentCore = UserAgentCore;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * BYE UAC.
 * @public
 */
var ByeUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ByeUserAgentClient, _super);
    function ByeUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.BYE, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        dialog.dispose();
        return _this;
    }
    return ByeUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ByeUserAgentClient = ByeUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * BYE UAS.
 * @public
 */
var ByeUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ByeUserAgentServer, _super);
    function ByeUserAgentServer(dialog, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
    }
    return ByeUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ByeUserAgentServer = ByeUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * CANCEL UAC.
 * @public
 */
var CancelUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(CancelUserAgentClient, _super);
    function CancelUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return CancelUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.CancelUserAgentClient = CancelUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./bye-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./bye-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./cancel-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./info-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./info-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./message-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./message-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notify-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notify-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./publish-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./prack-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./prack-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-invite-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-invite-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-subscribe-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-subscribe-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./refer-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./refer-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./register-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./register-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscribe-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscribe-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * INFO UAC.
 * @public
 */
var InfoUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(InfoUserAgentClient, _super);
    function InfoUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.INFO, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        return _this;
    }
    return InfoUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.InfoUserAgentClient = InfoUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * INFO UAS.
 * @public
 */
var InfoUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(InfoUserAgentServer, _super);
    function InfoUserAgentServer(dialog, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
    }
    return InfoUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.InfoUserAgentServer = InfoUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var dialogs_1 = __webpack_require__(/*! ../dialogs */ "./node_modules/sip.js/lib/core/dialogs/index.js");
var session_1 = __webpack_require__(/*! ../session */ "./node_modules/sip.js/lib/core/session/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * INVITE UAC.
 * @remarks
 * 13 Initiating a Session
 * https://tools.ietf.org/html/rfc3261#section-13
 * 13.1 Overview
 * https://tools.ietf.org/html/rfc3261#section-13.1
 * 13.2 UAC Processing
 * https://tools.ietf.org/html/rfc3261#section-13.2
 * @public
 */
var InviteUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(InviteUserAgentClient, _super);
    function InviteUserAgentClient(core, message, delegate) {
        var _this = _super.call(this, transactions_1.InviteClientTransaction, core, message, delegate) || this;
        _this.confirmedDialogAcks = new Map();
        _this.confirmedDialogs = new Map();
        _this.earlyDialogs = new Map();
        _this.delegate = delegate;
        return _this;
    }
    InviteUserAgentClient.prototype.dispose = function () {
        // The UAC core considers the INVITE transaction completed 64*T1 seconds
        // after the reception of the first 2xx response.  At this point all the
        // early dialogs that have not transitioned to established dialogs are
        // terminated.  Once the INVITE transaction is considered completed by
        // the UAC core, no more new 2xx responses are expected to arrive.
        //
        // If, after acknowledging any 2xx response to an INVITE, the UAC does
        // not want to continue with that dialog, then the UAC MUST terminate
        // the dialog by sending a BYE request as described in Section 15.
        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
        this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
        this.earlyDialogs.clear();
        _super.prototype.dispose.call(this);
    };
    /**
     * Special case for transport error while sending ACK.
     * @param error - Transport error
     */
    InviteUserAgentClient.prototype.onTransportError = function (error) {
        if (this.transaction.state === transactions_1.TransactionState.Calling) {
            return _super.prototype.onTransportError.call(this, error);
        }
        // If not in 'calling' state, the transport error occurred while sending an ACK.
        this.logger.error(error.message);
        this.logger.error("User agent client request transport error while sending ACK.");
    };
    /**
     * Once the INVITE has been passed to the INVITE client transaction, the
     * UAC waits for responses for the INVITE.
     * https://tools.ietf.org/html/rfc3261#section-13.2.2
     * @param incomingResponse - Incoming response to INVITE request.
     */
    InviteUserAgentClient.prototype.receiveResponse = function (message) {
        var _this = this;
        if (!this.authenticationGuard(message)) {
            return;
        }
        var statusCode = message.statusCode ? message.statusCode.toString() : "";
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        switch (true) {
            case /^100$/.test(statusCode):
                if (this.delegate && this.delegate.onTrying) {
                    this.delegate.onTrying({ message: message });
                }
                return;
            case /^1[0-9]{2}$/.test(statusCode):
                // Zero, one or multiple provisional responses may arrive before one or
                // more final responses are received.  Provisional responses for an
                // INVITE request can create "early dialogs".  If a provisional response
                // has a tag in the To field, and if the dialog ID of the response does
                // not match an existing dialog, one is constructed using the procedures
                // defined in Section 12.1.2.
                //
                // The early dialog will only be needed if the UAC needs to send a
                // request to its peer within the dialog before the initial INVITE
                // transaction completes.  Header fields present in a provisional
                // response are applicable as long as the dialog is in the early state
                // (for example, an Allow header field in a provisional response
                // contains the methods that can be used in the dialog while this is in
                // the early state).
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.1
                {
                    // Provisional without to tag, no dialog to create.
                    if (!message.toTag) {
                        this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
                        return;
                    }
                    // Compute dialog state.
                    var dialogState = dialogs_1.Dialog.initialDialogStateForUserAgentClient(this.message, message);
                    // Have existing early dialog or create a new one.
                    var earlyDialog = this.earlyDialogs.get(dialogState.id);
                    if (!earlyDialog) {
                        var transaction = this.transaction;
                        if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                            throw new Error("Transaction not instance of InviteClientTransaction.");
                        }
                        earlyDialog = new dialogs_1.SessionDialog(transaction, this.core, dialogState);
                        this.earlyDialogs.set(earlyDialog.id, earlyDialog);
                    }
                    // Guard against out of order reliable provisional responses.
                    // Note that this is where the rseq tracking is done.
                    if (!earlyDialog.reliableSequenceGuard(message)) {
                        this.logger.warn("1xx INVITE reliable response received out of order, dropping.");
                        return;
                    }
                    // If the initial offer is in an INVITE, the answer MUST be in a
                    // reliable non-failure message from UAS back to UAC which is
                    // correlated to that INVITE.  For this specification, that is
                    // only the final 2xx response to that INVITE.  That same exact
                    // answer MAY also be placed in any provisional responses sent
                    // prior to the answer.  The UAC MUST treat the first session
                    // description it receives as the answer, and MUST ignore any
                    // session descriptions in subsequent responses to the initial
                    // INVITE.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    if (earlyDialog.signalingState === session_1.SignalingState.Initial ||
                        earlyDialog.signalingState === session_1.SignalingState.HaveLocalOffer) {
                        earlyDialog.signalingStateTransition(message);
                    }
                    // Pass response to delegate.
                    var session_2 = earlyDialog;
                    if (this.delegate && this.delegate.onProgress) {
                        this.delegate.onProgress({
                            message: message,
                            session: session_2,
                            prack: function (options) {
                                var outgoingPrackRequest = session_2.prack(undefined, options);
                                return outgoingPrackRequest;
                            }
                        });
                    }
                }
                return;
            case /^2[0-9]{2}$/.test(statusCode):
                // Multiple 2xx responses may arrive at the UAC for a single INVITE
                // request due to a forking proxy.  Each response is distinguished by
                // the tag parameter in the To header field, and each represents a
                // distinct dialog, with a distinct dialog identifier.
                //
                // If the dialog identifier in the 2xx response matches the dialog
                // identifier of an existing dialog, the dialog MUST be transitioned to
                // the "confirmed" state, and the route set for the dialog MUST be
                // recomputed based on the 2xx response using the procedures of Section
                // 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
                // constructed using the procedures of Section 12.1.2.
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                {
                    // Compute dialog state.
                    var dialogState = dialogs_1.Dialog.initialDialogStateForUserAgentClient(this.message, message);
                    // NOTE: Currently our transaction layer is caching the 2xx ACKs and
                    // handling retransmissions of the ACK which is an approach which is
                    // not to spec. In any event, this block is intended to provide a to
                    // spec implementation of ACK retransmissions, but it should not be
                    // hit currently.
                    var dialog = this.confirmedDialogs.get(dialogState.id);
                    if (dialog) {
                        // Once the ACK has been constructed, the procedures of [4] are used to
                        // determine the destination address, port and transport.  However, the
                        // request is passed to the transport layer directly for transmission,
                        // rather than a client transaction.  This is because the UAC core
                        // handles retransmissions of the ACK, not the transaction layer.  The
                        // ACK MUST be passed to the client transport every time a
                        // retransmission of the 2xx final response that triggered the ACK
                        // arrives.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                        var outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);
                        if (outgoingAckRequest) {
                            var transaction = this.transaction;
                            if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                                throw new Error("Client transaction not instance of InviteClientTransaction.");
                            }
                            transaction.ackResponse(outgoingAckRequest.message);
                        }
                        else {
                            // If still waiting for an ACK, drop the retransmission of the 2xx final response.
                        }
                        return;
                    }
                    // If the dialog identifier in the 2xx response matches the dialog
                    // identifier of an existing dialog, the dialog MUST be transitioned to
                    // the "confirmed" state, and the route set for the dialog MUST be
                    // recomputed based on the 2xx response using the procedures of Section
                    // 12.2.1.2. Otherwise, a new dialog in the "confirmed" state MUST be
                    // constructed using the procedures of Section 12.1.2.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                    dialog = this.earlyDialogs.get(dialogState.id);
                    if (dialog) {
                        dialog.confirm();
                        dialog.recomputeRouteSet(message);
                        this.earlyDialogs.delete(dialog.id);
                        this.confirmedDialogs.set(dialog.id, dialog);
                    }
                    else {
                        var transaction = this.transaction;
                        if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                            throw new Error("Transaction not instance of InviteClientTransaction.");
                        }
                        dialog = new dialogs_1.SessionDialog(transaction, this.core, dialogState);
                        this.confirmedDialogs.set(dialog.id, dialog);
                    }
                    // If the initial offer is in an INVITE, the answer MUST be in a
                    // reliable non-failure message from UAS back to UAC which is
                    // correlated to that INVITE.  For this specification, that is
                    // only the final 2xx response to that INVITE.  That same exact
                    // answer MAY also be placed in any provisional responses sent
                    // prior to the answer.  The UAC MUST treat the first session
                    // description it receives as the answer, and MUST ignore any
                    // session descriptions in subsequent responses to the initial
                    // INVITE.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    if (dialog.signalingState === session_1.SignalingState.Initial ||
                        dialog.signalingState === session_1.SignalingState.HaveLocalOffer) {
                        dialog.signalingStateTransition(message);
                    }
                    // Session Initiated! :)
                    var session_3 = dialog;
                    // The UAC core MUST generate an ACK request for each 2xx received from
                    // the transaction layer.  The header fields of the ACK are constructed
                    // in the same way as for any request sent within a dialog (see Section
                    // 12) with the exception of the CSeq and the header fields related to
                    // authentication.  The sequence number of the CSeq header field MUST be
                    // the same as the INVITE being acknowledged, but the CSeq method MUST
                    // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
                    // the 2xx contains an offer (based on the rules above), the ACK MUST
                    // carry an answer in its body.  If the offer in the 2xx response is not
                    // acceptable, the UAC core MUST generate a valid answer in the ACK and
                    // then send a BYE immediately.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                    if (this.delegate && this.delegate.onAccept) {
                        this.delegate.onAccept({
                            message: message,
                            session: session_3,
                            ack: function (options) {
                                var outgoingAckRequest = session_3.ack(options);
                                _this.confirmedDialogAcks.set(session_3.id, outgoingAckRequest);
                                return outgoingAckRequest;
                            }
                        });
                    }
                    else {
                        var outgoingAckRequest = session_3.ack();
                        this.confirmedDialogAcks.set(session_3.id, outgoingAckRequest);
                    }
                }
                return;
            case /^3[0-9]{2}$/.test(statusCode):
                // 12.3 Termination of a Dialog
                //
                // Independent of the method, if a request outside of a dialog generates
                // a non-2xx final response, any early dialogs created through
                // provisional responses to that request are terminated.  The mechanism
                // for terminating confirmed dialogs is method specific.  In this
                // specification, the BYE method terminates a session and the dialog
                // associated with it.  See Section 15 for details.
                // https://tools.ietf.org/html/rfc3261#section-12.3
                // All early dialogs are considered terminated upon reception of the
                // non-2xx final response.
                //
                // After having received the non-2xx final response the UAC core
                // considers the INVITE transaction completed.  The INVITE client
                // transaction handles the generation of ACKs for the response (see
                // Section 17).
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
                this.earlyDialogs.clear();
                // A 3xx response may contain one or more Contact header field values
                // providing new addresses where the callee might be reachable.
                // Depending on the status code of the 3xx response (see Section 21.3),
                // the UAC MAY choose to try those new addresses.
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.2
                if (this.delegate && this.delegate.onRedirect) {
                    this.delegate.onRedirect({ message: message });
                }
                return;
            case /^[4-6][0-9]{2}$/.test(statusCode):
                // 12.3 Termination of a Dialog
                //
                // Independent of the method, if a request outside of a dialog generates
                // a non-2xx final response, any early dialogs created through
                // provisional responses to that request are terminated.  The mechanism
                // for terminating confirmed dialogs is method specific.  In this
                // specification, the BYE method terminates a session and the dialog
                // associated with it.  See Section 15 for details.
                // https://tools.ietf.org/html/rfc3261#section-12.3
                // All early dialogs are considered terminated upon reception of the
                // non-2xx final response.
                //
                // After having received the non-2xx final response the UAC core
                // considers the INVITE transaction completed.  The INVITE client
                // transaction handles the generation of ACKs for the response (see
                // Section 17).
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
                this.earlyDialogs.clear();
                // A single non-2xx final response may be received for the INVITE.  4xx,
                // 5xx and 6xx responses may contain a Contact header field value
                // indicating the location where additional information about the error
                // can be found.  Subsequent final responses (which would only arrive
                // under error conditions) MUST be ignored.
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                if (this.delegate && this.delegate.onReject) {
                    this.delegate.onReject({ message: message });
                }
                return;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
        throw new Error("Executing what should be an unreachable code path receiving " + statusCode + " response.");
    };
    return InviteUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.InviteUserAgentClient = InviteUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var dialogs_1 = __webpack_require__(/*! ../dialogs */ "./node_modules/sip.js/lib/core/dialogs/index.js");
var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js");
var session_1 = __webpack_require__(/*! ../session */ "./node_modules/sip.js/lib/core/session/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var allowed_methods_1 = __webpack_require__(/*! ../user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * INVITE UAS.
 * @remarks
 * 13 Initiating a Session
 * https://tools.ietf.org/html/rfc3261#section-13
 * 13.1 Overview
 * https://tools.ietf.org/html/rfc3261#section-13.1
 * 13.3 UAS Processing
 * https://tools.ietf.org/html/rfc3261#section-13.3
 * @public
 */
var InviteUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(InviteUserAgentServer, _super);
    function InviteUserAgentServer(core, message, delegate) {
        var _this = _super.call(this, transactions_1.InviteServerTransaction, core, message, delegate) || this;
        _this.core = core;
        return _this;
    }
    InviteUserAgentServer.prototype.dispose = function () {
        if (this.earlyDialog) {
            this.earlyDialog.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * 13.3.1.4 The INVITE is Accepted
     * The UAS core generates a 2xx response.  This response establishes a
     * dialog, and therefore follows the procedures of Section 12.1.1 in
     * addition to those of Section 8.2.6.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.4
     * @param options - Accept options bucket.
     */
    InviteUserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        if (!this.acceptable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not acceptable in state " + this.transaction.state + ".");
        }
        // This response establishes a dialog...
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        if (!this.confirmedDialog) {
            if (this.earlyDialog) {
                this.earlyDialog.confirm();
                this.confirmedDialog = this.earlyDialog;
                this.earlyDialog = undefined;
            }
            else {
                var transaction = this.transaction;
                if (!(transaction instanceof transactions_1.InviteServerTransaction)) {
                    throw new Error("Transaction not instance of InviteClientTransaction.");
                }
                var state = dialogs_1.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);
                this.confirmedDialog = new dialogs_1.SessionDialog(transaction, this.core, state);
            }
        }
        // When a UAS responds to a request with a response that establishes a
        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
        // header field values from the request into the response (including the
        // URIs, URI parameters, and any Record-Route header field parameters,
        // whether they are known or unknown to the UAS) and MUST maintain the
        // order of those values.  The UAS MUST add a Contact header field to
        // the response.  The Contact header field contains an address where the
        // UAS would like to be contacted for subsequent requests in the dialog
        // (which includes the ACK for a 2xx response in the case of an INVITE).
        // Generally, the host portion of this URI is the IP address or FQDN of
        // the host.  The URI provided in the Contact header field MUST be a SIP
        // or SIPS URI.  If the request that initiated the dialog contained a
        // SIPS URI in the Request-URI or in the top Record-Route header field
        // value, if there was any, or the Contact header field if there was no
        // Record-Route header field, the Contact header field in the response
        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
        // same URI can be used in messages outside this dialog).  The same way,
        // the scope of the URI in the Contact header field of the INVITE is not
        // limited to this dialog either.  It can therefore be used in messages
        // to the UAC even outside this dialog.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var recordRouteHeader = this.message
            .getHeaders("record-route")
            .map(function (header) { return "Record-Route: " + header; });
        var contactHeader = "Contact: " + this.core.configuration.contact.toString();
        // A 2xx response to an INVITE SHOULD contain the Allow header field and
        // the Supported header field, and MAY contain the Accept header field.
        // Including these header fields allows the UAC to determine the
        // features and extensions supported by the UAS for the duration of the
        // call, without probing.
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        // FIXME: TODO: This should not be hard coded.
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        // FIXME: TODO: Supported header (see reply())
        // FIXME: TODO: Accept header
        // If the INVITE request contained an offer, and the UAS had not yet
        // sent an answer, the 2xx MUST contain an answer.  If the INVITE did
        // not contain an offer, the 2xx MUST contain an offer if the UAS had
        // not yet sent an offer.
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        if (!options.body) {
            if (this.confirmedDialog.signalingState === session_1.SignalingState.Stable) {
                options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response
            }
            else if (this.confirmedDialog.signalingState === session_1.SignalingState.Initial ||
                this.confirmedDialog.signalingState === session_1.SignalingState.HaveRemoteOffer) {
                throw new Error("Response must have a body.");
            }
        }
        options.statusCode = options.statusCode || 200;
        options.extraHeaders = options.extraHeaders || [];
        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
        options.extraHeaders.push(allowHeader);
        options.extraHeaders.push(contactHeader);
        var response = _super.prototype.accept.call(this, options);
        var session = this.confirmedDialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        // Update dialog signaling state
        if (options.body) {
            // Once the UAS has sent or received an answer to the initial
            // offer, it MUST NOT generate subsequent offers in any responses
            // to the initial INVITE.  This means that a UAS based on this
            // specification alone can never generate subsequent offers until
            // completion of the initial transaction.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            if (this.confirmedDialog.signalingState !== session_1.SignalingState.Stable) {
                this.confirmedDialog.signalingStateTransition(options.body);
            }
        }
        return result;
    };
    /**
     * 13.3.1.1 Progress
     * If the UAS is not able to answer the invitation immediately, it can
     * choose to indicate some kind of progress to the UAC (for example, an
     * indication that a phone is ringing).  This is accomplished with a
     * provisional response between 101 and 199.  These provisional
     * responses establish early dialogs and therefore follow the procedures
     * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY
     * send as many provisional responses as it likes.  Each of these MUST
     * indicate the same dialog ID.  However, these will not be delivered
     * reliably.
     *
     * If the UAS desires an extended period of time to answer the INVITE,
     * it will need to ask for an "extension" in order to prevent proxies
     * from canceling the transaction.  A proxy has the option of canceling
     * a transaction when there is a gap of 3 minutes between responses in a
     * transaction.  To prevent cancellation, the UAS MUST send a non-100
     * provisional response at every minute, to handle the possibility of
     * lost provisional responses.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.1
     * @param options - Progress options bucket.
     */
    InviteUserAgentServer.prototype.progress = function (options) {
        if (options === void 0) { options = { statusCode: 180 }; }
        if (!this.progressable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not progressable in state " + this.transaction.state + ".");
        }
        // This response establishes a dialog...
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        if (!this.earlyDialog) {
            var transaction = this.transaction;
            if (!(transaction instanceof transactions_1.InviteServerTransaction)) {
                throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            var state = dialogs_1.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);
            this.earlyDialog = new dialogs_1.SessionDialog(transaction, this.core, state);
        }
        // When a UAS responds to a request with a response that establishes a
        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
        // header field values from the request into the response (including the
        // URIs, URI parameters, and any Record-Route header field parameters,
        // whether they are known or unknown to the UAS) and MUST maintain the
        // order of those values.  The UAS MUST add a Contact header field to
        // the response.  The Contact header field contains an address where the
        // UAS would like to be contacted for subsequent requests in the dialog
        // (which includes the ACK for a 2xx response in the case of an INVITE).
        // Generally, the host portion of this URI is the IP address or FQDN of
        // the host.  The URI provided in the Contact header field MUST be a SIP
        // or SIPS URI.  If the request that initiated the dialog contained a
        // SIPS URI in the Request-URI or in the top Record-Route header field
        // value, if there was any, or the Contact header field if there was no
        // Record-Route header field, the Contact header field in the response
        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
        // same URI can be used in messages outside this dialog).  The same way,
        // the scope of the URI in the Contact header field of the INVITE is not
        // limited to this dialog either.  It can therefore be used in messages
        // to the UAC even outside this dialog.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var recordRouteHeader = this.message
            .getHeaders("record-route")
            .map(function (header) { return "Record-Route: " + header; });
        var contactHeader = "Contact: " + this.core.configuration.contact;
        options.extraHeaders = options.extraHeaders || [];
        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
        options.extraHeaders.push(contactHeader);
        var response = _super.prototype.progress.call(this, options);
        var session = this.earlyDialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        // Update dialog signaling state
        if (options.body) {
            // Once the UAS has sent or received an answer to the initial
            // offer, it MUST NOT generate subsequent offers in any responses
            // to the initial INVITE.  This means that a UAS based on this
            // specification alone can never generate subsequent offers until
            // completion of the initial transaction.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            if (this.earlyDialog.signalingState !== session_1.SignalingState.Stable) {
                this.earlyDialog.signalingStateTransition(options.body);
            }
        }
        return result;
    };
    /**
     * 13.3.1.2 The INVITE is Redirected
     * If the UAS decides to redirect the call, a 3xx response is sent.  A
     * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved
     * Temporarily) response SHOULD contain a Contact header field
     * containing one or more URIs of new addresses to be tried.  The
     * response is passed to the INVITE server transaction, which will deal
     * with its retransmissions.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.2
     * @param contacts - Contacts to redirect to.
     * @param options - Redirect options bucket.
     */
    InviteUserAgentServer.prototype.redirect = function (contacts, options) {
        if (options === void 0) { options = { statusCode: 302 }; }
        return _super.prototype.redirect.call(this, contacts, options);
    };
    /**
     * 13.3.1.3 The INVITE is Rejected
     * A common scenario occurs when the callee is currently not willing or
     * able to take additional calls at this end system.  A 486 (Busy Here)
     * SHOULD be returned in such a scenario.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.3
     * @param options - Reject options bucket.
     */
    InviteUserAgentServer.prototype.reject = function (options) {
        if (options === void 0) { options = { statusCode: 486 }; }
        return _super.prototype.reject.call(this, options);
    };
    return InviteUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.InviteUserAgentServer = InviteUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * MESSAGE UAC.
 * @public
 */
var MessageUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(MessageUserAgentClient, _super);
    function MessageUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return MessageUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.MessageUserAgentClient = MessageUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * MESSAGE UAS.
 * @public
 */
var MessageUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(MessageUserAgentServer, _super);
    function MessageUserAgentServer(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
    }
    return MessageUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.MessageUserAgentServer = MessageUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * NOTIFY UAS.
 * @public
 */
var NotifyUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(NotifyUserAgentClient, _super);
    function NotifyUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.NOTIFY, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        return _this;
    }
    return NotifyUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.NotifyUserAgentClient = NotifyUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * NOTIFY UAS.
 * @public
 */
var NotifyUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(NotifyUserAgentServer, _super);
    /**
     * NOTIFY UAS constructor.
     * @param dialogOrCore - Dialog for in dialog NOTIFY, UserAgentCore for out of dialog NOTIFY (deprecated).
     * @param message - Incoming NOTIFY request message.
     */
    function NotifyUserAgentServer(dialogOrCore, message, delegate) {
        var _this = this;
        var userAgentCore = instanceOfDialog(dialogOrCore) ?
            dialogOrCore.userAgentCore :
            dialogOrCore;
        _this = _super.call(this, transactions_1.NonInviteServerTransaction, userAgentCore, message, delegate) || this;
        return _this;
    }
    return NotifyUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.NotifyUserAgentServer = NotifyUserAgentServer;
function instanceOfDialog(object) {
    return object.userAgentCore !== undefined;
}


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * PRACK UAC.
 * @public
 */
var PrackUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(PrackUserAgentClient, _super);
    function PrackUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.PRACK, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        dialog.signalingStateTransition(message);
        return _this;
    }
    return PrackUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.PrackUserAgentClient = PrackUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * PRACK UAS.
 * @public
 */
var PrackUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(PrackUserAgentServer, _super);
    function PrackUserAgentServer(dialog, message, delegate) {
        var _this = _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        // Update dialog signaling state with offer/answer in body
        dialog.signalingStateTransition(message);
        _this.dialog = dialog;
        return _this;
    }
    /**
     * Update the dialog signaling state on a 2xx response.
     * @param options - Options bucket.
     */
    PrackUserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        if (options.body) {
            // Update dialog signaling state with offer/answer in body
            this.dialog.signalingStateTransition(options.body);
        }
        return _super.prototype.accept.call(this, options);
    };
    return PrackUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.PrackUserAgentServer = PrackUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * PUBLISH UAC.
 * @public
 */
var PublishUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(PublishUserAgentClient, _super);
    function PublishUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return PublishUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.PublishUserAgentClient = PublishUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * Re-INVITE UAC.
 * @remarks
 * 14 Modifying an Existing Session
 * https://tools.ietf.org/html/rfc3261#section-14
 * 14.1 UAC Behavior
 * https://tools.ietf.org/html/rfc3261#section-14.1
 * @public
 */
var ReInviteUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ReInviteUserAgentClient, _super);
    function ReInviteUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.INVITE, options);
        _this = _super.call(this, transactions_1.InviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        _this.delegate = delegate;
        dialog.signalingStateTransition(message);
        // FIXME: TODO: next line obviously needs to be improved...
        dialog.reinviteUserAgentClient = _this; // let the dialog know re-invite request sent
        _this.dialog = dialog;
        return _this;
    }
    ReInviteUserAgentClient.prototype.receiveResponse = function (message) {
        var _this = this;
        if (!this.authenticationGuard(message, this.dialog)) {
            return;
        }
        var statusCode = message.statusCode ? message.statusCode.toString() : "";
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        switch (true) {
            case /^100$/.test(statusCode):
                if (this.delegate && this.delegate.onTrying) {
                    this.delegate.onTrying({ message: message });
                }
                break;
            case /^1[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onProgress) {
                    this.delegate.onProgress({
                        message: message,
                        session: this.dialog,
                        prack: function (options) {
                            throw new Error("Unimplemented.");
                        }
                    });
                }
                break;
            case /^2[0-9]{2}$/.test(statusCode):
                // Update dialog signaling state with offer/answer in body
                this.dialog.signalingStateTransition(message);
                if (this.delegate && this.delegate.onAccept) {
                    this.delegate.onAccept({
                        message: message,
                        session: this.dialog,
                        ack: function (options) {
                            var outgoingAckRequest = _this.dialog.ack(options);
                            return outgoingAckRequest;
                        }
                    });
                }
                break;
            case /^3[0-9]{2}$/.test(statusCode):
                this.dialog.signalingStateRollback();
                this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction
                if (this.delegate && this.delegate.onRedirect) {
                    this.delegate.onRedirect({ message: message });
                }
                break;
            case /^[4-6][0-9]{2}$/.test(statusCode):
                this.dialog.signalingStateRollback();
                this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction
                if (this.delegate && this.delegate.onReject) {
                    this.delegate.onReject({ message: message });
                }
                else {
                    // If a UA receives a non-2xx final response to a re-INVITE, the session
                    // parameters MUST remain unchanged, as if no re-INVITE had been issued.
                    // Note that, as stated in Section 12.2.1.2, if the non-2xx final
                    // response is a 481 (Call/Transaction Does Not Exist), or a 408
                    // (Request Timeout), or no response at all is received for the re-
                    // INVITE (that is, a timeout is returned by the INVITE client
                    // transaction), the UAC will terminate the dialog.
                    //
                    // If a UAC receives a 491 response to a re-INVITE, it SHOULD start a
                    // timer with a value T chosen as follows:
                    //
                    //    1. If the UAC is the owner of the Call-ID of the dialog ID
                    //       (meaning it generated the value), T has a randomly chosen value
                    //       between 2.1 and 4 seconds in units of 10 ms.
                    //
                    //    2. If the UAC is not the owner of the Call-ID of the dialog ID, T
                    //       has a randomly chosen value of between 0 and 2 seconds in units
                    //       of 10 ms.
                    //
                    // When the timer fires, the UAC SHOULD attempt the re-INVITE once more,
                    // if it still desires for that session modification to take place.  For
                    // example, if the call was already hung up with a BYE, the re-INVITE
                    // would not take place.
                    // https://tools.ietf.org/html/rfc3261#section-14.1
                    // FIXME: TODO: The above.
                }
                break;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
    };
    return ReInviteUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ReInviteUserAgentClient = ReInviteUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * Re-INVITE UAS.
 * @remarks
 * 14 Modifying an Existing Session
 * https://tools.ietf.org/html/rfc3261#section-14
 * 14.2 UAS Behavior
 * https://tools.ietf.org/html/rfc3261#section-14.2
 * @public
 */
var ReInviteUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ReInviteUserAgentServer, _super);
    function ReInviteUserAgentServer(dialog, message, delegate) {
        var _this = _super.call(this, transactions_1.InviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        dialog.reinviteUserAgentServer = _this;
        _this.dialog = dialog;
        return _this;
    }
    /**
     * Update the dialog signaling state on a 2xx response.
     * @param options - Options bucket.
     */
    ReInviteUserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        // FIXME: The next two lines SHOULD go away, but I suppose it's technically harmless...
        // These are here because some versions of SIP.js prior to 0.13.8 set the route set
        // of all in dialog ACKs based on the Record-Route headers in the associated 2xx
        // response. While this worked for dialog forming 2xx responses, it was technically
        // broken for re-INVITE ACKS as it only worked if the UAS populated the Record-Route
        // headers in the re-INVITE 2xx response (which is not required and a waste of bandwidth
        // as the should be ignored if present in re-INVITE ACKS) and the UAS populated
        // the Record-Route headers with the correct values (would be weird not too, but...).
        // Anyway, for now the technically useless Record-Route headers are being added
        // to maintain "backwards compatibility" with the older broken versions of SIP.js.
        options.extraHeaders = options.extraHeaders || [];
        options.extraHeaders = options.extraHeaders.concat(this.dialog.routeSet.map(function (route) { return "Record-Route: " + route; }));
        // Send and return the response
        var response = _super.prototype.accept.call(this, options);
        var session = this.dialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        if (options.body) {
            // Update dialog signaling state with offer/answer in body
            this.dialog.signalingStateTransition(options.body);
        }
        // Update dialog
        this.dialog.reConfirm();
        return result;
    };
    /**
     * Update the dialog signaling state on a 1xx response.
     * @param options - Progress options bucket.
     */
    ReInviteUserAgentServer.prototype.progress = function (options) {
        if (options === void 0) { options = { statusCode: 180 }; }
        // Send and return the response
        var response = _super.prototype.progress.call(this, options);
        var session = this.dialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        // Update dialog signaling state
        if (options.body) {
            this.dialog.signalingStateTransition(options.body);
        }
        return result;
    };
    /**
     * TODO: Not Yet Supported
     * @param contacts - Contacts to redirect to.
     * @param options - Redirect options bucket.
     */
    ReInviteUserAgentServer.prototype.redirect = function (contacts, options) {
        if (options === void 0) { options = { statusCode: 302 }; }
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction
        throw new Error("Unimplemented.");
    };
    /**
     * 3.1 Background on Re-INVITE Handling by UASs
     * An error response to a re-INVITE has the following semantics.  As
     * specified in Section 12.2.2 of RFC 3261 [RFC3261], if a re-INVITE is
     * rejected, no state changes are performed.
     * https://tools.ietf.org/html/rfc6141#section-3.1
     * @param options - Reject options bucket.
     */
    ReInviteUserAgentServer.prototype.reject = function (options) {
        if (options === void 0) { options = { statusCode: 488 }; }
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction
        return _super.prototype.reject.call(this, options);
    };
    return ReInviteUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ReInviteUserAgentServer = ReInviteUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * Re-SUBSCRIBE UAC.
 * @public
 */
var ReSubscribeUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ReSubscribeUserAgentClient, _super);
    function ReSubscribeUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.SUBSCRIBE, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        _this.dialog = dialog;
        return _this;
    }
    ReSubscribeUserAgentClient.prototype.waitNotifyStop = function () {
        // TODO: Placeholder. Not utilized currently.
        return;
    };
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */
    ReSubscribeUserAgentClient.prototype.receiveResponse = function (message) {
        if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
            //  The "Expires" header field in a 200-class response to SUBSCRIBE
            //  request indicates the actual duration for which the subscription will
            //  remain active (unless refreshed).  The received value might be
            //  smaller than the value indicated in the SUBSCRIBE request but cannot
            //  be larger; see Section 4.2.1 for details.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
            var expires = message.getHeader("Expires");
            if (!expires) {
                this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
            }
            else {
                var subscriptionExpiresReceived = Number(expires);
                if (this.dialog.subscriptionExpires > subscriptionExpiresReceived) {
                    this.dialog.subscriptionExpires = subscriptionExpiresReceived;
                }
            }
        }
        if (message.statusCode && message.statusCode >= 400 && message.statusCode < 700) {
            // If a SUBSCRIBE request to refresh a subscription receives a 404, 405,
            // 410, 416, 480-485, 489, 501, or 604 response, the subscriber MUST
            // consider the subscription terminated.  (See [RFC5057] for further
            // details and notes about the effect of error codes on dialogs and
            // usages within dialog, such as subscriptions).  If the subscriber
            // wishes to re-subscribe to the state, he does so by composing an
            // unrelated initial SUBSCRIBE request with a freshly generated Call-ID
            // and a new, unique "From" tag (see Section 4.1.2.1).
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
            var errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];
            if (errorCodes.indexOf(message.statusCode) !== -1) {
                this.dialog.terminate();
            }
            // If a SUBSCRIBE request to refresh a subscription fails with any error
            // code other than those listed above, the original subscription is
            // still considered valid for the duration of the most recently known
            // "Expires" value as negotiated by the most recent successful SUBSCRIBE
            // transaction, or as communicated by a NOTIFY request in its
            // "Subscription-State" header field "expires" parameter.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
        }
        _super.prototype.receiveResponse.call(this, message);
    };
    return ReSubscribeUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ReSubscribeUserAgentClient = ReSubscribeUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * Re-SUBSCRIBE UAS.
 * @public
 */
var ReSubscribeUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ReSubscribeUserAgentServer, _super);
    function ReSubscribeUserAgentServer(dialog, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
    }
    return ReSubscribeUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ReSubscribeUserAgentServer = ReSubscribeUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * REFER UAC.
 * @public
 */
var ReferUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ReferUserAgentClient, _super);
    function ReferUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.REFER, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        return _this;
    }
    return ReferUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ReferUserAgentClient = ReferUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * REFER UAS.
 * @public
 */
var ReferUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ReferUserAgentServer, _super);
    /**
     * REFER UAS constructor.
     * @param dialogOrCore - Dialog for in dialog REFER, UserAgentCore for out of dialog REFER.
     * @param message - Incoming REFER request message.
     */
    function ReferUserAgentServer(dialogOrCore, message, delegate) {
        var _this = this;
        var userAgentCore = instanceOfSessionDialog(dialogOrCore) ?
            dialogOrCore.userAgentCore :
            dialogOrCore;
        _this = _super.call(this, transactions_1.NonInviteServerTransaction, userAgentCore, message, delegate) || this;
        return _this;
    }
    return ReferUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ReferUserAgentServer = ReferUserAgentServer;
function instanceOfSessionDialog(object) {
    return object.userAgentCore !== undefined;
}


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * REGISTER UAC.
 * @public
 */
var RegisterUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(RegisterUserAgentClient, _super);
    function RegisterUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return RegisterUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.RegisterUserAgentClient = RegisterUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * REGISTER UAS.
 * @public
 */
var RegisterUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(RegisterUserAgentServer, _super);
    function RegisterUserAgentServer(core, message, delegate) {
        var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
        _this.core = core;
        return _this;
    }
    return RegisterUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.RegisterUserAgentServer = RegisterUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var subscription_dialog_1 = __webpack_require__(/*! ../dialogs/subscription-dialog */ "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js");
var subscription_1 = __webpack_require__(/*! ../subscription */ "./node_modules/sip.js/lib/core/subscription/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * SUBSCRIBE UAC.
 * @remarks
 * 4.1.  Subscriber Behavior
 * https://tools.ietf.org/html/rfc6665#section-4.1
 *
 * User agent client for installation of a single subscription per SUBSCRIBE request.
 * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE requests.
 * @public
 */
var SubscribeUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(SubscribeUserAgentClient, _super);
    function SubscribeUserAgentClient(core, message, delegate) {
        var _this = this;
        // Get event from request message.
        var event = message.getHeader("Event");
        if (!event) {
            throw new Error("Event undefined");
        }
        // Get expires from request message.
        var expires = message.getHeader("Expires");
        if (!expires) {
            throw new Error("Expires undefined");
        }
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
        _this.delegate = delegate;
        // FIXME: Subscriber id should also be matching on event id.
        _this.subscriberId = message.callId + message.fromTag + event;
        _this.subscriptionExpiresRequested = _this.subscriptionExpires = Number(expires);
        _this.subscriptionEvent = event;
        _this.subscriptionState = subscription_1.SubscriptionState.NotifyWait;
        // Start waiting for a NOTIFY we can use to create a subscription.
        _this.waitNotifyStart();
        return _this;
    }
    /**
     * Destructor.
     * Note that Timer N may live on waiting for an initial NOTIFY and
     * the delegate may still receive that NOTIFY. If you don't want
     * that behavior then either clear the delegate so the delegate
     * doesn't get called (a 200 will be sent in response to the NOTIFY)
     * or call `waitNotifyStop` which will clear Timer N and remove this
     * UAC from the core (a 481 will be sent in response to the NOTIFY).
     */
    SubscribeUserAgentClient.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle out of dialog NOTIFY associated with SUBSCRIBE request.
     * This is the first NOTIFY received after the SUBSCRIBE request.
     * @param uas - User agent server handling the subscription creating NOTIFY.
     */
    SubscribeUserAgentClient.prototype.onNotify = function (uas) {
        // NOTIFY requests are matched to such SUBSCRIBE requests if they
        // contain the same "Call-ID", a "To" header field "tag" parameter that
        // matches the "From" header field "tag" parameter of the SUBSCRIBE
        // request, and the same "Event" header field.  Rules for comparisons of
        // the "Event" header fields are described in Section 8.2.1.
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        var event = uas.message.parseHeader("Event").event;
        if (!event || event !== this.subscriptionEvent) {
            this.logger.warn("Failed to parse event.");
            uas.reject({ statusCode: 489 });
            return;
        }
        // NOTIFY requests MUST contain "Subscription-State" header fields that
        // indicate the status of the subscription.
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var subscriptionState = uas.message.parseHeader("Subscription-State");
        if (!subscriptionState || !subscriptionState.state) {
            this.logger.warn("Failed to parse subscription state.");
            uas.reject({ statusCode: 489 });
            return;
        }
        // Validate subscription state.
        var state = subscriptionState.state;
        switch (state) {
            case "pending":
                break;
            case "active":
                break;
            case "terminated":
                break;
            default:
                this.logger.warn("Invalid subscription state " + state);
                uas.reject({ statusCode: 489 });
                return;
        }
        // Dialogs usages are created upon completion of a NOTIFY transaction
        // for a new subscription, unless the NOTIFY request contains a
        // "Subscription-State" of "terminated."
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        if (state !== "terminated") {
            // The Contact header field MUST be present and contain exactly one SIP
            // or SIPS URI in any request that can result in the establishment of a
            // dialog.
            // https://tools.ietf.org/html/rfc3261#section-8.1.1.8
            var contact = uas.message.parseHeader("contact");
            if (!contact) {
                this.logger.warn("Failed to parse contact.");
                uas.reject({ statusCode: 489 });
                return;
            }
        }
        // In accordance with the rules for proxying non-INVITE requests as
        // defined in [RFC3261], successful SUBSCRIBE requests will receive only
        // one 200-class response; however, due to forking, the subscription may
        // have been accepted by multiple nodes.  The subscriber MUST therefore
        // be prepared to receive NOTIFY requests with "From:" tags that differ
        // from the "To:" tag received in the SUBSCRIBE 200-class response.
        //
        // If multiple NOTIFY requests are received in different dialogs in
        // response to a single SUBSCRIBE request, each dialog represents a
        // different destination to which the SUBSCRIBE request was forked.
        // Subscriber handling in such situations varies by event package; see
        // Section 5.4.9 for details.
        // https://tools.ietf.org/html/rfc6665#section-4.1.4
        // Each event package MUST specify whether forked SUBSCRIBE requests are
        // allowed to install multiple subscriptions.
        //
        // If such behavior is not allowed, the first potential dialog-
        // establishing message will create a dialog.  All subsequent NOTIFY
        // requests that correspond to the SUBSCRIBE request (i.e., have
        // matching "To", "From", "Call-ID", and "Event" header fields, as well
        // as "From" header field "tag" parameter and "Event" header field "id"
        // parameter) but that do not match the dialog would be rejected with a
        // 481 response.  Note that the 200-class response to the SUBSCRIBE
        // request can arrive after a matching NOTIFY request has been received;
        // such responses might not correlate to the same dialog established by
        // the NOTIFY request.  Except as required to complete the SUBSCRIBE
        // transaction, such non-matching 200-class responses are ignored.
        //
        // If installing of multiple subscriptions by way of a single forked
        // SUBSCRIBE request is allowed, the subscriber establishes a new dialog
        // towards each notifier by returning a 200-class response to each
        // NOTIFY request.  Each dialog is then handled as its own entity and is
        // refreshed independently of the other dialogs.
        //
        // In the case that multiple subscriptions are allowed, the event
        // package MUST specify whether merging of the notifications to form a
        // single state is required, and how such merging is to be performed.
        // Note that it is possible that some event packages may be defined in
        // such a way that each dialog is tied to a mutually exclusive state
        // that is unaffected by the other dialogs; this MUST be clearly stated
        // if it is the case.
        // https://tools.ietf.org/html/rfc6665#section-5.4.9
        // *** NOTE: This implementation is only for event packages which
        // do not allow forked requests to install multiple subscriptions.
        // As such and in accordance with the specification, we stop waiting
        // and any future NOTIFY requests will be rejected with a 481.
        if (this.dialog) {
            throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");
        }
        this.waitNotifyStop();
        // Update expires.
        this.subscriptionExpires =
            subscriptionState.expires ?
                Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) :
                this.subscriptionExpires;
        // Update subscription state.
        switch (state) {
            case "pending":
                this.subscriptionState = subscription_1.SubscriptionState.Pending;
                break;
            case "active":
                this.subscriptionState = subscription_1.SubscriptionState.Active;
                break;
            case "terminated":
                this.subscriptionState = subscription_1.SubscriptionState.Terminated;
                break;
            default:
                throw new Error("Unrecognized state " + state + ".");
        }
        // Dialogs usages are created upon completion of a NOTIFY transaction
        // for a new subscription, unless the NOTIFY request contains a
        // "Subscription-State" of "terminated."
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        if (this.subscriptionState !== subscription_1.SubscriptionState.Terminated) {
            // Because the dialog usage is established by the NOTIFY request, the
            // route set at the subscriber is taken from the NOTIFY request itself,
            // as opposed to the route set present in the 200-class response to the
            // SUBSCRIBE request.
            // https://tools.ietf.org/html/rfc6665#section-4.4.1
            var dialogState = subscription_dialog_1.SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message);
            // Subscription Initiated! :)
            this.dialog = new subscription_dialog_1.SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);
        }
        // Delegate.
        if (this.delegate && this.delegate.onNotify) {
            var request = uas;
            var subscription = this.dialog;
            this.delegate.onNotify({ request: request, subscription: subscription });
        }
        else {
            uas.accept();
        }
    };
    SubscribeUserAgentClient.prototype.waitNotifyStart = function () {
        var _this = this;
        if (!this.N) {
            // Add ourselves to the core's subscriber map.
            // This allows the core to route out of dialog NOTIFY messages to us.
            this.core.subscribers.set(this.subscriberId, this);
            this.N = setTimeout(function () { return _this.timer_N(); }, timers_1.Timers.TIMER_N);
        }
    };
    SubscribeUserAgentClient.prototype.waitNotifyStop = function () {
        if (this.N) {
            // Remove ourselves to the core's subscriber map.
            // Any future out of dialog NOTIFY messages will be rejected with a 481.
            this.core.subscribers.delete(this.subscriberId);
            clearTimeout(this.N);
            this.N = undefined;
        }
    };
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */
    SubscribeUserAgentClient.prototype.receiveResponse = function (message) {
        if (!this.authenticationGuard(message)) {
            return;
        }
        if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
            //  The "Expires" header field in a 200-class response to SUBSCRIBE
            //  request indicates the actual duration for which the subscription will
            //  remain active (unless refreshed).  The received value might be
            //  smaller than the value indicated in the SUBSCRIBE request but cannot
            //  be larger; see Section 4.2.1 for details.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
            // The "Expires" values present in SUBSCRIBE 200-class responses behave
            // in the same way as they do in REGISTER responses: the server MAY
            // shorten the interval but MUST NOT lengthen it.
            //
            //    If the duration specified in a SUBSCRIBE request is unacceptably
            //    short, the notifier may be able to send a 423 response, as
            //    described earlier in this section.
            //
            // 200-class responses to SUBSCRIBE requests will not generally contain
            // any useful information beyond subscription duration; their primary
            // purpose is to serve as a reliability mechanism.  State information
            // will be communicated via a subsequent NOTIFY request from the
            // notifier.
            // https://tools.ietf.org/html/rfc6665#section-4.2.1.1
            var expires = message.getHeader("Expires");
            if (!expires) {
                this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
            }
            else {
                var subscriptionExpiresReceived = Number(expires);
                if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {
                    this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request");
                }
                if (subscriptionExpiresReceived < this.subscriptionExpires) {
                    this.subscriptionExpires = subscriptionExpiresReceived;
                }
            }
            // If a NOTIFY arrived before 200-class response a dialog may have been created.
            // Updated the dialogs expiration only if this indicates earlier expiration.
            if (this.dialog) {
                if (this.dialog.subscriptionExpires > this.subscriptionExpires) {
                    this.dialog.subscriptionExpires = this.subscriptionExpires;
                }
            }
        }
        if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {
            this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.
        }
        _super.prototype.receiveResponse.call(this, message);
    };
    /**
     * To ensure that subscribers do not wait indefinitely for a
     * subscription to be established, a subscriber starts a Timer N, set to
     * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires
     * prior to the receipt of a NOTIFY request, the subscriber considers
     * the subscription failed, and cleans up any state associated with the
     * subscription attempt.
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.4
     */
    SubscribeUserAgentClient.prototype.timer_N = function () {
        this.logger.warn("Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.");
        this.waitNotifyStop();
        if (this.delegate && this.delegate.onNotifyTimeout) {
            this.delegate.onNotifyTimeout();
        }
    };
    return SubscribeUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.SubscribeUserAgentClient = SubscribeUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * SUBSCRIBE UAS.
 * @public
 */
var SubscribeUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(SubscribeUserAgentServer, _super);
    function SubscribeUserAgentServer(core, message, delegate) {
        var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
        _this.core = core;
        return _this;
    }
    return SubscribeUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.SubscribeUserAgentServer = SubscribeUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/user-agent-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
/**
 * User Agent Client (UAC).
 * @remarks
 * A user agent client is a logical entity
 * that creates a new request, and then uses the client
 * transaction state machinery to send it.  The role of UAC lasts
 * only for the duration of that transaction.  In other words, if
 * a piece of software initiates a request, it acts as a UAC for
 * the duration of that transaction.  If it receives a request
 * later, it assumes the role of a user agent server for the
 * processing of that transaction.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentClient = /** @class */ (function () {
    function UserAgentClient(transactionConstructor, core, message, delegate) {
        this.transactionConstructor = transactionConstructor;
        this.core = core;
        this.message = message;
        this.delegate = delegate;
        this.challenged = false;
        this.stale = false;
        this.logger = this.loggerFactory.getLogger("sip.user-agent-client");
        this.init();
    }
    UserAgentClient.prototype.dispose = function () {
        this.transaction.dispose();
    };
    Object.defineProperty(UserAgentClient.prototype, "loggerFactory", {
        get: function () {
            return this.core.loggerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentClient.prototype, "transaction", {
        /** The transaction associated with this request. */
        get: function () {
            if (!this._transaction) {
                throw new Error("Transaction undefined.");
            }
            return this._transaction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Since requests other than INVITE are responded to immediately, sending a
     * CANCEL for a non-INVITE request would always create a race condition.
     * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
     * https://tools.ietf.org/html/rfc3261#section-9.1
     * @param options - Cancel options bucket.
     */
    UserAgentClient.prototype.cancel = function (reason, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.transaction) {
            throw new Error("Transaction undefined.");
        }
        if (!this.message.to) {
            throw new Error("To undefined.");
        }
        if (!this.message.from) {
            throw new Error("From undefined.");
        }
        // The following procedures are used to construct a CANCEL request.  The
        // Request-URI, Call-ID, To, the numeric part of CSeq, and From header
        // fields in the CANCEL request MUST be identical to those in the
        // request being cancelled, including tags.  A CANCEL constructed by a
        // client MUST have only a single Via header field value matching the
        // top Via value in the request being cancelled.  Using the same values
        // for these header fields allows the CANCEL to be matched with the
        // request it cancels (Section 9.2 indicates how such matching occurs).
        // However, the method part of the CSeq header field MUST have a value
        // of CANCEL.  This allows it to be identified and processed as a
        // transaction in its own right (See Section 17).
        // https://tools.ietf.org/html/rfc3261#section-9.1
        var message = this.core.makeOutgoingRequestMessage(messages_1.C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
            toTag: this.message.toTag,
            fromTag: this.message.fromTag,
            callId: this.message.callId,
            cseq: this.message.cseq
        }, options.extraHeaders);
        // TODO: Revisit this.
        // The CANCEL needs to use the same branch parameter so that
        // it matches the INVITE transaction, but this is a hacky way to do this.
        // Or at the very least not well documented. If the the branch parameter
        // is set on the outgoing request, the transaction will use it.
        // Otherwise the transaction will make a new one.
        message.branch = this.message.branch;
        if (this.message.headers.Route) {
            message.headers.Route = this.message.headers.Route;
        }
        if (reason) {
            message.setHeader("Reason", reason);
        }
        // If no provisional response has been received, the CANCEL request MUST
        // NOT be sent; rather, the client MUST wait for the arrival of a
        // provisional response before sending the request. If the original
        // request has generated a final response, the CANCEL SHOULD NOT be
        // sent, as it is an effective no-op, since CANCEL has no effect on
        // requests that have already generated a final response.
        // https://tools.ietf.org/html/rfc3261#section-9.1
        if (this.transaction.state === transactions_1.TransactionState.Proceeding) {
            var uac = new UserAgentClient(transactions_1.NonInviteClientTransaction, this.core, message);
        }
        else {
            this.transaction.once("stateChanged", function () {
                if (_this.transaction && _this.transaction.state === transactions_1.TransactionState.Proceeding) {
                    var uac = new UserAgentClient(transactions_1.NonInviteClientTransaction, _this.core, message);
                }
            });
        }
        return message;
    };
    /**
     * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
     * response is received, the UAC SHOULD follow the authorization
     * procedures of Section 22.2 and Section 22.3 to retry the request with
     * credentials.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.5
     * 22 Usage of HTTP Authentication
     * https://tools.ietf.org/html/rfc3261#section-22
     * 22.1 Framework
     * https://tools.ietf.org/html/rfc3261#section-22.1
     * 22.2 User-to-User Authentication
     * https://tools.ietf.org/html/rfc3261#section-22.2
     * 22.3 Proxy-to-User Authentication
     * https://tools.ietf.org/html/rfc3261#section-22.3
     *
     * FIXME: This "guard for and retry the request with credentials"
     * implementation is not complete and at best minimally passable.
     * @param response - The incoming response to guard.
     * @param dialog - If defined, the dialog within which the response was received.
     * @returns True if the program execution is to continue in the branch in question.
     *          Otherwise the request is retried with credentials and current request processing must stop.
     */
    UserAgentClient.prototype.authenticationGuard = function (message, dialog) {
        var statusCode = message.statusCode;
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
        // response is received, the UAC SHOULD follow the authorization
        // procedures of Section 22.2 and Section 22.3 to retry the request with
        // credentials.
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
        if (statusCode !== 401 && statusCode !== 407) {
            return true;
        }
        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
        var challenge;
        var authorizationHeaderName;
        if (statusCode === 401) {
            challenge = message.parseHeader("www-authenticate");
            authorizationHeaderName = "authorization";
        }
        else {
            challenge = message.parseHeader("proxy-authenticate");
            authorizationHeaderName = "proxy-authorization";
        }
        // Verify it seems a valid challenge.
        if (!challenge) {
            this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
            return true;
        }
        // Avoid infinite authentications.
        if (this.challenged && (this.stale || challenge.stale !== true)) {
            this.logger.warn(statusCode + " apparently in authentication loop, cannot authenticate");
            return true;
        }
        // Get credentials.
        if (!this.credentials) {
            this.credentials = this.core.configuration.authenticationFactory();
            if (!this.credentials) {
                this.logger.warn("Unable to obtain credentials, cannot authenticate");
                return true;
            }
        }
        // Verify that the challenge is really valid.
        if (!this.credentials.authenticate(this.message, challenge)) {
            return true;
        }
        this.challenged = true;
        if (challenge.stale) {
            this.stale = true;
        }
        // If response to out of dialog request, assume incrementing the CSeq will suffice.
        var cseq = this.message.cseq += 1;
        // If response to in dialog request, get a valid next CSeq number.
        if (dialog && dialog.localSequenceNumber) {
            dialog.incrementLocalSequenceNumber();
            cseq = this.message.cseq = dialog.localSequenceNumber;
        }
        this.message.setHeader("cseq", cseq + " " + this.message.method);
        this.message.setHeader(authorizationHeaderName, this.credentials.toString());
        // Calling init (again) will swap out our existing client transaction with a new one.
        // FIXME: HACK: An assumption is being made here that there is nothing that needs to
        // be cleaned up beyond the client transaction which is being replaced. For example,
        // it is assumed that no early dialogs have been created.
        this.init();
        return false;
    };
    /**
     * 8.1.3.1 Transaction Layer Errors
     * In some cases, the response returned by the transaction layer will
     * not be a SIP message, but rather a transaction layer error.  When a
     * timeout error is received from the transaction layer, it MUST be
     * treated as if a 408 (Request Timeout) status code has been received.
     * If a fatal transport error is reported by the transport layer
     * (generally, due to fatal ICMP errors in UDP or connection failures in
     * TCP), the condition MUST be treated as a 503 (Service Unavailable)
     * status code.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
     */
    UserAgentClient.prototype.onRequestTimeout = function () {
        this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
        var message = new messages_1.IncomingResponseMessage();
        message.statusCode = 408;
        message.reasonPhrase = "Request Timeout";
        this.receiveResponse(message);
        return;
    };
    /**
     * 8.1.3.1 Transaction Layer Errors
     * In some cases, the response returned by the transaction layer will
     * not be a SIP message, but rather a transaction layer error.  When a
     * timeout error is received from the transaction layer, it MUST be
     * treated as if a 408 (Request Timeout) status code has been received.
     * If a fatal transport error is reported by the transport layer
     * (generally, due to fatal ICMP errors in UDP or connection failures in
     * TCP), the condition MUST be treated as a 503 (Service Unavailable)
     * status code.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
     * @param error - Transport error
     */
    UserAgentClient.prototype.onTransportError = function (error) {
        this.logger.error(error.message);
        this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
        var message = new messages_1.IncomingResponseMessage();
        message.statusCode = 503;
        message.reasonPhrase = "Service Unavailable";
        this.receiveResponse(message);
    };
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */
    UserAgentClient.prototype.receiveResponse = function (message) {
        if (!this.authenticationGuard(message)) {
            return;
        }
        var statusCode = message.statusCode ? message.statusCode.toString() : "";
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        switch (true) {
            case /^100$/.test(statusCode):
                if (this.delegate && this.delegate.onTrying) {
                    this.delegate.onTrying({ message: message });
                }
                break;
            case /^1[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onProgress) {
                    this.delegate.onProgress({ message: message });
                }
                break;
            case /^2[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onAccept) {
                    this.delegate.onAccept({ message: message });
                }
                break;
            case /^3[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onRedirect) {
                    this.delegate.onRedirect({ message: message });
                }
                break;
            case /^[4-6][0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onReject) {
                    this.delegate.onReject({ message: message });
                }
                break;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
    };
    UserAgentClient.prototype.init = function () {
        var _this = this;
        // We are the transaction user.
        var user = {
            loggerFactory: this.loggerFactory,
            onRequestTimeout: function () { return _this.onRequestTimeout(); },
            onStateChange: function (newState) {
                if (newState === transactions_1.TransactionState.Terminated) {
                    // Remove the terminated transaction from the core.
                    _this.core.userAgentClients.delete(userAgentClientId);
                    // FIXME: HACK: Our transaction may have been swapped out with a new one
                    // post authentication (see above), so make sure to only to dispose of
                    // ourselves if this terminating transaction is our current transaction.
                    if (transaction === _this._transaction) {
                        _this.dispose();
                    }
                }
            },
            onTransportError: function (error) { return _this.onTransportError(error); },
            receiveResponse: function (message) { return _this.receiveResponse(message); }
        };
        // Create a new transaction with us as the user.
        var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
        this._transaction = transaction;
        // Add the new transaction to the core.
        var userAgentClientId = transaction.id + transaction.request.method;
        this.core.userAgentClients.set(userAgentClientId, this);
    };
    return UserAgentClient;
}());
exports.UserAgentClient = UserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/user-agent-server.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var utils_1 = __webpack_require__(/*! ../messages/utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
/**
 * User Agent Server (UAS).
 * @remarks
 * A user agent server is a logical entity
 * that generates a response to a SIP request.  The response
 * accepts, rejects, or redirects the request.  This role lasts
 * only for the duration of that transaction.  In other words, if
 * a piece of software responds to a request, it acts as a UAS for
 * the duration of that transaction.  If it generates a request
 * later, it assumes the role of a user agent client for the
 * processing of that transaction.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentServer = /** @class */ (function () {
    function UserAgentServer(transactionConstructor, core, message, delegate) {
        this.transactionConstructor = transactionConstructor;
        this.core = core;
        this.message = message;
        this.delegate = delegate;
        this.logger = this.loggerFactory.getLogger("sip.user-agent-server");
        this.toTag = message.toTag ? message.toTag : utils_1.newTag();
        this.init();
    }
    UserAgentServer.prototype.dispose = function () {
        this.transaction.dispose();
    };
    Object.defineProperty(UserAgentServer.prototype, "loggerFactory", {
        get: function () {
            return this.core.loggerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "transaction", {
        /** The transaction associated with this request. */
        get: function () {
            if (!this._transaction) {
                throw new Error("Transaction undefined.");
            }
            return this._transaction;
        },
        enumerable: true,
        configurable: true
    });
    UserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        if (!this.acceptable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not acceptable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 200 || statusCode > 299) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.progress = function (options) {
        if (options === void 0) { options = { statusCode: 180 }; }
        if (!this.progressable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not progressable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 101 || statusCode > 199) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.redirect = function (contacts, options) {
        if (options === void 0) { options = { statusCode: 302 }; }
        if (!this.redirectable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not redirectable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 300 || statusCode > 399) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var contactHeaders = new Array();
        contacts.forEach(function (contact) { return contactHeaders.push("Contact: " + contact.toString()); });
        options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.reject = function (options) {
        if (options === void 0) { options = { statusCode: 480 }; }
        if (!this.rejectable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not rejectable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 400 || statusCode > 699) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.trying = function (options) {
        if (!this.tryingable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not tryingable in state " + this.transaction.state + ".");
        }
        var response = this.reply({ statusCode: 100 });
        return response;
    };
    /**
     * If the UAS did not find a matching transaction for the CANCEL
     * according to the procedure above, it SHOULD respond to the CANCEL
     * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction
     * for the original request still exists, the behavior of the UAS on
     * receiving a CANCEL request depends on whether it has already sent a
     * final response for the original request.  If it has, the CANCEL
     * request has no effect on the processing of the original request, no
     * effect on any session state, and no effect on the responses generated
     * for the original request.  If the UAS has not issued a final response
     * for the original request, its behavior depends on the method of the
     * original request.  If the original request was an INVITE, the UAS
     * SHOULD immediately respond to the INVITE with a 487 (Request
     * Terminated).  A CANCEL request has no impact on the processing of
     * transactions with any other method defined in this specification.
     * https://tools.ietf.org/html/rfc3261#section-9.2
     * @param request - Incoming CANCEL request.
     */
    UserAgentServer.prototype.receiveCancel = function (message) {
        // Note: Currently CANCEL is being handled as a special case.
        // No UAS is created to handle the CANCEL and the response to
        // it CANCEL is being handled statelessly by the user agent core.
        // As such, there is currently no way to externally impact the
        // response to the a CANCEL request.
        if (this.delegate && this.delegate.onCancel) {
            this.delegate.onCancel(message);
        }
    };
    Object.defineProperty(UserAgentServer.prototype, "acceptable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Proceeding ||
                    this.transaction.state === transactions_1.TransactionState.Accepted);
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Trying ||
                    this.transaction.state === transactions_1.TransactionState.Proceeding);
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "progressable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return false; // https://tools.ietf.org/html/rfc4320#section-4.1
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "redirectable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Trying ||
                    this.transaction.state === transactions_1.TransactionState.Proceeding);
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "rejectable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Trying ||
                    this.transaction.state === transactions_1.TransactionState.Proceeding);
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "tryingable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Trying;
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * When a UAS wishes to construct a response to a request, it follows
     * the general procedures detailed in the following subsections.
     * Additional behaviors specific to the response code in question, which
     * are not detailed in this section, may also be required.
     *
     * Once all procedures associated with the creation of a response have
     * been completed, the UAS hands the response back to the server
     * transaction from which it received the request.
     * https://tools.ietf.org/html/rfc3261#section-8.2.6
     * @param statusCode - Status code to reply with.
     * @param options - Reply options bucket.
     */
    UserAgentServer.prototype.reply = function (options) {
        if (!options.toTag && options.statusCode !== 100) {
            options.toTag = this.toTag;
        }
        options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;
        options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;
        var response = messages_1.constructOutgoingResponse(this.message, options);
        this.transaction.receiveResponse(options.statusCode, response.message);
        return response;
    };
    UserAgentServer.prototype.init = function () {
        var _this = this;
        // We are the transaction user.
        var user = {
            loggerFactory: this.loggerFactory,
            onStateChange: function (newState) {
                if (newState === transactions_1.TransactionState.Terminated) {
                    // Remove the terminated transaction from the core.
                    _this.core.userAgentServers.delete(userAgentServerId);
                    _this.dispose();
                }
            },
            onTransportError: function (error) {
                _this.logger.error(error.message);
                if (_this.delegate && _this.delegate.onTransportError) {
                    _this.delegate.onTransportError(error);
                }
                else {
                    _this.logger.error("User agent server response transport error.");
                }
            }
        };
        // Create a new transaction with us as the user.
        var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
        this._transaction = transaction;
        // Add the new transaction to the core.
        var userAgentServerId = transaction.id;
        this.core.userAgentServers.set(transaction.id, this);
    };
    return UserAgentServer;
}());
exports.UserAgentServer = UserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/grammar/dist/grammar.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/grammar/dist/grammar.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable:interface-name
// tslint:disable: trailing-comma
// tslint:disable: object-literal-sort-keys
// tslint:disable: max-line-length
// tslint:disable: only-arrow-functions
// tslint:disable: one-variable-per-declaration
// tslint:disable: no-consecutive-blank-lines
// tslint:disable: align
// tslint:disable: radix
// tslint:disable: quotemark
// tslint:disable: semicolon
// tslint:disable: object-literal-shorthand
// tslint:disable: variable-name
// tslint:disable: no-var-keyword
// tslint:disable: whitespace
// tslint:disable: curly
// tslint:disable: prefer-const
// tslint:disable: object-literal-key-quotes
// tslint:disable: no-string-literal
// tslint:disable: one-line
// tslint:disable: no-unused-expression
// tslint:disable: space-before-function-paren
// tslint:disable: arrow-return-shorthand
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.6 )
//
// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs
var name_addr_header_1 = __webpack_require__(/*! ../../core/messages/name-addr-header */ "./node_modules/sip.js/lib/core/messages/name-addr-header.js");
var uri_1 = __webpack_require__(/*! ../../core/messages/uri */ "./node_modules/sip.js/lib/core/messages/uri.js");
var SyntaxError = /** @class */ (function (_super) {
    tslib_1.__extends(SyntaxError, _super);
    function SyntaxError(message, expected, found, location) {
        var _this = _super.call(this) || this;
        _this.message = message;
        _this.expected = expected;
        _this.found = found;
        _this.location = location;
        _this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(_this, SyntaxError);
        }
        return _this;
    }
    SyntaxError.buildMessage = function (expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
        }
        function classEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
        }
        function describeExpectation(expectation) {
            switch (expectation.type) {
                case "literal":
                    return "\"" + literalEscape(expectation.text) + "\"";
                case "class":
                    var escapedParts = expectation.parts.map(function (part) {
                        return Array.isArray(part)
                            ? classEscape(part[0]) + "-" + classEscape(part[1])
                            : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            var descriptions = expected1.map(describeExpectation);
            var i;
            var j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }
            switch (descriptions.length) {
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    return SyntaxError;
}(Error));
exports.SyntaxError = SyntaxError;
function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 };
    var peg$startRuleIndex = 119;
    var peg$consts = [
        "\r\n",
        peg$literalExpectation("\r\n", false),
        /^[0-9]/,
        peg$classExpectation([["0", "9"]], false, false),
        /^[a-zA-Z]/,
        peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
        /^[0-9a-fA-F]/,
        peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
        /^[\0-\xFF]/,
        peg$classExpectation([["\0", "\xFF"]], false, false),
        /^["]/,
        peg$classExpectation(["\""], false, false),
        " ",
        peg$literalExpectation(" ", false),
        "\t",
        peg$literalExpectation("\t", false),
        /^[a-zA-Z0-9]/,
        peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
        ";",
        peg$literalExpectation(";", false),
        "/",
        peg$literalExpectation("/", false),
        "?",
        peg$literalExpectation("?", false),
        ":",
        peg$literalExpectation(":", false),
        "@",
        peg$literalExpectation("@", false),
        "&",
        peg$literalExpectation("&", false),
        "=",
        peg$literalExpectation("=", false),
        "+",
        peg$literalExpectation("+", false),
        "$",
        peg$literalExpectation("$", false),
        ",",
        peg$literalExpectation(",", false),
        "-",
        peg$literalExpectation("-", false),
        "_",
        peg$literalExpectation("_", false),
        ".",
        peg$literalExpectation(".", false),
        "!",
        peg$literalExpectation("!", false),
        "~",
        peg$literalExpectation("~", false),
        "*",
        peg$literalExpectation("*", false),
        "'",
        peg$literalExpectation("'", false),
        "(",
        peg$literalExpectation("(", false),
        ")",
        peg$literalExpectation(")", false),
        "%",
        peg$literalExpectation("%", false),
        function () { return " "; },
        function () { return ':'; },
        /^[!-~]/,
        peg$classExpectation([["!", "~"]], false, false),
        /^[\x80-\uFFFF]/,
        peg$classExpectation([["\x80", "\uFFFF"]], false, false),
        /^[\x80-\xBF]/,
        peg$classExpectation([["\x80", "\xBF"]], false, false),
        /^[a-f]/,
        peg$classExpectation([["a", "f"]], false, false),
        "`",
        peg$literalExpectation("`", false),
        "<",
        peg$literalExpectation("<", false),
        ">",
        peg$literalExpectation(">", false),
        "\\",
        peg$literalExpectation("\\", false),
        "[",
        peg$literalExpectation("[", false),
        "]",
        peg$literalExpectation("]", false),
        "{",
        peg$literalExpectation("{", false),
        "}",
        peg$literalExpectation("}", false),
        function () { return "*"; },
        function () { return "/"; },
        function () { return "="; },
        function () { return "("; },
        function () { return ")"; },
        function () { return ">"; },
        function () { return "<"; },
        function () { return ","; },
        function () { return ";"; },
        function () { return ":"; },
        function () { return "\""; },
        /^[!-']/,
        peg$classExpectation([["!", "'"]], false, false),
        /^[*-[]/,
        peg$classExpectation([["*", "["]], false, false),
        /^[\]-~]/,
        peg$classExpectation([["]", "~"]], false, false),
        function (contents) {
            return contents;
        },
        /^[#-[]/,
        peg$classExpectation([["#", "["]], false, false),
        /^[\0-\t]/,
        peg$classExpectation([["\0", "\t"]], false, false),
        /^[\x0B-\f]/,
        peg$classExpectation([["\x0B", "\f"]], false, false),
        /^[\x0E-\x7F]/,
        peg$classExpectation([["\x0E", "\x7F"]], false, false),
        function () {
            options = options || { data: {} };
            options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
            delete options.data.scheme;
            delete options.data.user;
            delete options.data.host;
            delete options.data.host_type;
            delete options.data.port;
        },
        function () {
            options = options || { data: {} };
            options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
            delete options.data.scheme;
            delete options.data.user;
            delete options.data.host;
            delete options.data.host_type;
            delete options.data.port;
            delete options.data.uri_params;
            if (options.startRule === 'SIP_URI') {
                options.data = options.data.uri;
            }
        },
        "sips",
        peg$literalExpectation("sips", true),
        "sip",
        peg$literalExpectation("sip", true),
        function (uri_scheme) {
            options = options || { data: {} };
            options.data.scheme = uri_scheme;
        },
        function () {
            options = options || { data: {} };
            options.data.user = decodeURIComponent(text().slice(0, -1));
        },
        function () {
            options = options || { data: {} };
            options.data.password = text();
        },
        function () {
            options = options || { data: {} };
            options.data.host = text();
            return options.data.host;
        },
        function () {
            options = options || { data: {} };
            options.data.host_type = 'domain';
            return text();
        },
        /^[a-zA-Z0-9_\-]/,
        peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
        /^[a-zA-Z0-9\-]/,
        peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
        function () {
            options = options || { data: {} };
            options.data.host_type = 'IPv6';
            return text();
        },
        "::",
        peg$literalExpectation("::", false),
        function () {
            options = options || { data: {} };
            options.data.host_type = 'IPv6';
            return text();
        },
        function () {
            options = options || { data: {} };
            options.data.host_type = 'IPv4';
            return text();
        },
        "25",
        peg$literalExpectation("25", false),
        /^[0-5]/,
        peg$classExpectation([["0", "5"]], false, false),
        "2",
        peg$literalExpectation("2", false),
        /^[0-4]/,
        peg$classExpectation([["0", "4"]], false, false),
        "1",
        peg$literalExpectation("1", false),
        /^[1-9]/,
        peg$classExpectation([["1", "9"]], false, false),
        function (port) {
            options = options || { data: {} };
            port = parseInt(port.join(''));
            options.data.port = port;
            return port;
        },
        "transport=",
        peg$literalExpectation("transport=", true),
        "udp",
        peg$literalExpectation("udp", true),
        "tcp",
        peg$literalExpectation("tcp", true),
        "sctp",
        peg$literalExpectation("sctp", true),
        "tls",
        peg$literalExpectation("tls", true),
        function (transport) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['transport'] = transport.toLowerCase();
        },
        "user=",
        peg$literalExpectation("user=", true),
        "phone",
        peg$literalExpectation("phone", true),
        "ip",
        peg$literalExpectation("ip", true),
        function (user) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['user'] = user.toLowerCase();
        },
        "method=",
        peg$literalExpectation("method=", true),
        function (method) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['method'] = method;
        },
        "ttl=",
        peg$literalExpectation("ttl=", true),
        function (ttl) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            options.data.params['ttl'] = ttl;
        },
        "maddr=",
        peg$literalExpectation("maddr=", true),
        function (maddr) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['maddr'] = maddr;
        },
        "lr",
        peg$literalExpectation("lr", true),
        function () {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['lr'] = undefined;
        },
        function (param, value) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            if (value === null) {
                value = undefined;
            }
            else {
                value = value[1];
            }
            options.data.uri_params[param.toLowerCase()] = value;
        },
        function (hname, hvalue) {
            hname = hname.join('').toLowerCase();
            hvalue = hvalue.join('');
            options = options || { data: {} };
            if (!options.data.uri_headers)
                options.data.uri_headers = {};
            if (!options.data.uri_headers[hname]) {
                options.data.uri_headers[hname] = [hvalue];
            }
            else {
                options.data.uri_headers[hname].push(hvalue);
            }
        },
        function () {
            options = options || { data: {} };
            // lots of tests fail if this isn't guarded...
            if (options.startRule === 'Refer_To') {
                options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
                delete options.data.scheme;
                delete options.data.user;
                delete options.data.host;
                delete options.data.host_type;
                delete options.data.port;
                delete options.data.uri_params;
            }
        },
        "//",
        peg$literalExpectation("//", false),
        function () {
            options = options || { data: {} };
            options.data.scheme = text();
        },
        peg$literalExpectation("SIP", true),
        function () {
            options = options || { data: {} };
            options.data.sip_version = text();
        },
        "INVITE",
        peg$literalExpectation("INVITE", false),
        "ACK",
        peg$literalExpectation("ACK", false),
        "VXACH",
        peg$literalExpectation("VXACH", false),
        "OPTIONS",
        peg$literalExpectation("OPTIONS", false),
        "BYE",
        peg$literalExpectation("BYE", false),
        "CANCEL",
        peg$literalExpectation("CANCEL", false),
        "REGISTER",
        peg$literalExpectation("REGISTER", false),
        "SUBSCRIBE",
        peg$literalExpectation("SUBSCRIBE", false),
        "NOTIFY",
        peg$literalExpectation("NOTIFY", false),
        "REFER",
        peg$literalExpectation("REFER", false),
        "PUBLISH",
        peg$literalExpectation("PUBLISH", false),
        function () {
            options = options || { data: {} };
            options.data.method = text();
            return options.data.method;
        },
        function (status_code) {
            options = options || { data: {} };
            options.data.status_code = parseInt(status_code.join(''));
        },
        function () {
            options = options || { data: {} };
            options.data.reason_phrase = text();
        },
        function () {
            options = options || { data: {} };
            options.data = text();
        },
        function () {
            var idx, length;
            options = options || { data: {} };
            length = options.data.multi_header.length;
            for (idx = 0; idx < length; idx++) {
                if (options.data.multi_header[idx].parsed === null) {
                    options.data = null;
                    break;
                }
            }
            if (options.data !== null) {
                options.data = options.data.multi_header;
            }
            else {
                options.data = -1;
            }
        },
        function () {
            var header;
            options = options || { data: {} };
            if (!options.data.multi_header)
                options.data.multi_header = [];
            try {
                header = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                delete options.data.uri;
                delete options.data.displayName;
                delete options.data.params;
            }
            catch (e) {
                header = null;
            }
            options.data.multi_header.push({ 'position': peg$currPos,
                'offset': location().start.offset,
                'parsed': header
            });
        },
        function (displayName) {
            displayName = text().trim();
            if (displayName[0] === '\"') {
                displayName = displayName.substring(1, displayName.length - 1);
            }
            options = options || { data: {} };
            options.data.displayName = displayName;
        },
        "q",
        peg$literalExpectation("q", true),
        function (q) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            options.data.params['q'] = q;
        },
        "expires",
        peg$literalExpectation("expires", true),
        function (expires) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            options.data.params['expires'] = expires;
        },
        function (delta_seconds) {
            return parseInt(delta_seconds.join(''));
        },
        "0",
        peg$literalExpectation("0", false),
        function () {
            return parseFloat(text());
        },
        function (param, value) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            if (value === null) {
                value = undefined;
            }
            else {
                value = value[1];
            }
            options.data.params[param.toLowerCase()] = value;
        },
        "render",
        peg$literalExpectation("render", true),
        "session",
        peg$literalExpectation("session", true),
        "icon",
        peg$literalExpectation("icon", true),
        "alert",
        peg$literalExpectation("alert", true),
        function () {
            options = options || { data: {} };
            if (options.startRule === 'Content_Disposition') {
                options.data.type = text().toLowerCase();
            }
        },
        "handling",
        peg$literalExpectation("handling", true),
        "optional",
        peg$literalExpectation("optional", true),
        "required",
        peg$literalExpectation("required", true),
        function (length) {
            options = options || { data: {} };
            options.data = parseInt(length.join(''));
        },
        function () {
            options = options || { data: {} };
            options.data = text();
        },
        "text",
        peg$literalExpectation("text", true),
        "image",
        peg$literalExpectation("image", true),
        "audio",
        peg$literalExpectation("audio", true),
        "video",
        peg$literalExpectation("video", true),
        "application",
        peg$literalExpectation("application", true),
        "message",
        peg$literalExpectation("message", true),
        "multipart",
        peg$literalExpectation("multipart", true),
        "x-",
        peg$literalExpectation("x-", true),
        function (cseq_value) {
            options = options || { data: {} };
            options.data.value = parseInt(cseq_value.join(''));
        },
        function (expires) { options = options || { data: {} }; options.data = expires; },
        function (event_type) {
            options = options || { data: {} };
            options.data.event = event_type.toLowerCase();
        },
        function () {
            options = options || { data: {} };
            var tag = options.data.tag;
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
            if (tag) {
                options.data.setParam('tag', tag);
            }
        },
        "tag",
        peg$literalExpectation("tag", true),
        function (tag) { options = options || { data: {} }; options.data.tag = tag; },
        function (forwards) {
            options = options || { data: {} };
            options.data = parseInt(forwards.join(''));
        },
        function (min_expires) { options = options || { data: {} }; options.data = min_expires; },
        function () {
            options = options || { data: {} };
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
        },
        "digest",
        peg$literalExpectation("Digest", true),
        "realm",
        peg$literalExpectation("realm", true),
        function (realm) { options = options || { data: {} }; options.data.realm = realm; },
        "domain",
        peg$literalExpectation("domain", true),
        "nonce",
        peg$literalExpectation("nonce", true),
        function (nonce) { options = options || { data: {} }; options.data.nonce = nonce; },
        "opaque",
        peg$literalExpectation("opaque", true),
        function (opaque) { options = options || { data: {} }; options.data.opaque = opaque; },
        "stale",
        peg$literalExpectation("stale", true),
        "true",
        peg$literalExpectation("true", true),
        function () { options = options || { data: {} }; options.data.stale = true; },
        "false",
        peg$literalExpectation("false", true),
        function () { options = options || { data: {} }; options.data.stale = false; },
        "algorithm",
        peg$literalExpectation("algorithm", true),
        "md5",
        peg$literalExpectation("MD5", true),
        "md5-sess",
        peg$literalExpectation("MD5-sess", true),
        function (algorithm) {
            options = options || { data: {} };
            options.data.algorithm = algorithm.toUpperCase();
        },
        "qop",
        peg$literalExpectation("qop", true),
        "auth-int",
        peg$literalExpectation("auth-int", true),
        "auth",
        peg$literalExpectation("auth", true),
        function (qop_value) {
            options = options || { data: {} };
            options.data.qop || (options.data.qop = []);
            options.data.qop.push(qop_value.toLowerCase());
        },
        function (rack_value) {
            options = options || { data: {} };
            options.data.value = parseInt(rack_value.join(''));
        },
        function () {
            var idx, length;
            options = options || { data: {} };
            length = options.data.multi_header.length;
            for (idx = 0; idx < length; idx++) {
                if (options.data.multi_header[idx].parsed === null) {
                    options.data = null;
                    break;
                }
            }
            if (options.data !== null) {
                options.data = options.data.multi_header;
            }
            else {
                options.data = -1;
            }
        },
        function () {
            var header;
            options = options || { data: {} };
            if (!options.data.multi_header)
                options.data.multi_header = [];
            try {
                header = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                delete options.data.uri;
                delete options.data.displayName;
                delete options.data.params;
            }
            catch (e) {
                header = null;
            }
            options.data.multi_header.push({ 'position': peg$currPos,
                'offset': location().start.offset,
                'parsed': header
            });
        },
        function () {
            options = options || { data: {} };
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
        },
        function () {
            options = options || { data: {} };
            if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
                options.data = -1;
            }
        },
        function () {
            options = options || { data: {} };
            options.data = {
                call_id: options.data
            };
        },
        "from-tag",
        peg$literalExpectation("from-tag", true),
        function (from_tag) {
            options = options || { data: {} };
            options.data.replaces_from_tag = from_tag;
        },
        "to-tag",
        peg$literalExpectation("to-tag", true),
        function (to_tag) {
            options = options || { data: {} };
            options.data.replaces_to_tag = to_tag;
        },
        "early-only",
        peg$literalExpectation("early-only", true),
        function () {
            options = options || { data: {} };
            options.data.early_only = true;
        },
        function (head, r) { return r; },
        function (head, tail) { return list(head, tail); },
        function (value) {
            options = options || { data: {} };
            if (options.startRule === 'Require') {
                options.data = value || [];
            }
        },
        function (rseq_value) {
            options = options || { data: {} };
            options.data.value = parseInt(rseq_value.join(''));
        },
        "active",
        peg$literalExpectation("active", true),
        "pending",
        peg$literalExpectation("pending", true),
        "terminated",
        peg$literalExpectation("terminated", true),
        function () {
            options = options || { data: {} };
            options.data.state = text();
        },
        "reason",
        peg$literalExpectation("reason", true),
        function (reason) {
            options = options || { data: {} };
            if (typeof reason !== 'undefined')
                options.data.reason = reason;
        },
        function (expires) {
            options = options || { data: {} };
            if (typeof expires !== 'undefined')
                options.data.expires = expires;
        },
        "retry_after",
        peg$literalExpectation("retry_after", true),
        function (retry_after) {
            options = options || { data: {} };
            if (typeof retry_after !== 'undefined')
                options.data.retry_after = retry_after;
        },
        "deactivated",
        peg$literalExpectation("deactivated", true),
        "probation",
        peg$literalExpectation("probation", true),
        "rejected",
        peg$literalExpectation("rejected", true),
        "timeout",
        peg$literalExpectation("timeout", true),
        "giveup",
        peg$literalExpectation("giveup", true),
        "noresource",
        peg$literalExpectation("noresource", true),
        "invariant",
        peg$literalExpectation("invariant", true),
        function (value) {
            options = options || { data: {} };
            if (options.startRule === 'Supported') {
                options.data = value || [];
            }
        },
        function () {
            options = options || { data: {} };
            var tag = options.data.tag;
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
            if (tag) {
                options.data.setParam('tag', tag);
            }
        },
        "ttl",
        peg$literalExpectation("ttl", true),
        function (via_ttl_value) {
            options = options || { data: {} };
            options.data.ttl = via_ttl_value;
        },
        "maddr",
        peg$literalExpectation("maddr", true),
        function (via_maddr) {
            options = options || { data: {} };
            options.data.maddr = via_maddr;
        },
        "received",
        peg$literalExpectation("received", true),
        function (via_received) {
            options = options || { data: {} };
            options.data.received = via_received;
        },
        "branch",
        peg$literalExpectation("branch", true),
        function (via_branch) {
            options = options || { data: {} };
            options.data.branch = via_branch;
        },
        "rport",
        peg$literalExpectation("rport", true),
        function (response_port) {
            options = options || { data: {} };
            if (typeof response_port !== 'undefined')
                options.data.rport = response_port.join('');
        },
        function (via_protocol) {
            options = options || { data: {} };
            options.data.protocol = via_protocol;
        },
        peg$literalExpectation("UDP", true),
        peg$literalExpectation("TCP", true),
        peg$literalExpectation("TLS", true),
        peg$literalExpectation("SCTP", true),
        function (via_transport) {
            options = options || { data: {} };
            options.data.transport = via_transport;
        },
        function () {
            options = options || { data: {} };
            options.data.host = text();
        },
        function (via_sent_by_port) {
            options = options || { data: {} };
            options.data.port = parseInt(via_sent_by_port.join(''));
        },
        function (ttl) {
            return parseInt(ttl.join(''));
        },
        function (deltaSeconds) {
            options = options || { data: {} };
            if (options.startRule === 'Session_Expires') {
                options.data.deltaSeconds = deltaSeconds;
            }
        },
        "refresher",
        peg$literalExpectation("refresher", false),
        "uas",
        peg$literalExpectation("uas", false),
        "uac",
        peg$literalExpectation("uac", false),
        function (endpoint) {
            options = options || { data: {} };
            if (options.startRule === 'Session_Expires') {
                options.data.refresher = endpoint;
            }
        },
        function (deltaSeconds) {
            options = options || { data: {} };
            if (options.startRule === 'Min_SE') {
                options.data = deltaSeconds;
            }
        },
        "stuns",
        peg$literalExpectation("stuns", true),
        "stun",
        peg$literalExpectation("stun", true),
        function (scheme) {
            options = options || { data: {} };
            options.data.scheme = scheme;
        },
        function (host) {
            options = options || { data: {} };
            options.data.host = host;
        },
        "?transport=",
        peg$literalExpectation("?transport=", false),
        "turns",
        peg$literalExpectation("turns", true),
        "turn",
        peg$literalExpectation("turn", true),
        function (transport) {
            options = options || { data: {} };
            options.data.transport = transport;
        },
        function () {
            options = options || { data: {} };
            options.data = text();
        },
        "Referred-By",
        peg$literalExpectation("Referred-By", false),
        "b",
        peg$literalExpectation("b", false),
        "cid",
        peg$literalExpectation("cid", false)
    ];
    var peg$bytecode = [
        peg$decode("2 \"\"6 7!"),
        peg$decode("4\"\"\"5!7#"),
        peg$decode("4$\"\"5!7%"),
        peg$decode("4&\"\"5!7'"),
        peg$decode(";'.# &;("),
        peg$decode("4(\"\"5!7)"),
        peg$decode("4*\"\"5!7+"),
        peg$decode("2,\"\"6,7-"),
        peg$decode("2.\"\"6.7/"),
        peg$decode("40\"\"5!71"),
        peg$decode("22\"\"6273.\x89 &24\"\"6475.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
        peg$decode(";).# &;,"),
        peg$decode("2F\"\"6F7G.} &2H\"\"6H7I.q &2J\"\"6J7K.e &2L\"\"6L7M.Y &2N\"\"6N7O.M &2P\"\"6P7Q.A &2R\"\"6R7S.5 &2T\"\"6T7U.) &2V\"\"6V7W"),
        peg$decode("%%2X\"\"6X7Y/5#;#/,$;#/#$+#)(#'#(\"'#&'#/\"!&,)"),
        peg$decode("%%$;$0#*;$&/,#; /#$+\")(\"'#&'#.\" &\"/=#$;$/&#0#*;$&&&#/'$8\":Z\" )(\"'#&'#"),
        peg$decode(";..\" &\""),
        peg$decode("%$;'.# &;(0)*;'.# &;(&/?#28\"\"6879/0$;//'$8#:[# )(#'#(\"'#&'#"),
        peg$decode("%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+\")(\"'#&'#0=*%$;.0#*;.&/,#;2/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"),
        peg$decode("4\\\"\"5!7].# &;3"),
        peg$decode("4^\"\"5!7_"),
        peg$decode("4`\"\"5!7a"),
        peg$decode(";!.) &4b\"\"5!7c"),
        peg$decode("%$;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x9E#0\x9B*;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"),
        peg$decode("%$;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x92#0\x8F*;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"),
        peg$decode("2T\"\"6T7U.\xE3 &2V\"\"6V7W.\xD7 &2f\"\"6f7g.\xCB &2h\"\"6h7i.\xBF &2:\"\"6:7;.\xB3 &2D\"\"6D7E.\xA7 &22\"\"6273.\x9B &28\"\"6879.\x8F &2j\"\"6j7k.\x83 &;&.} &24\"\"6475.q &2l\"\"6l7m.e &2n\"\"6n7o.Y &26\"\"6677.M &2>\"\"6>7?.A &2p\"\"6p7q.5 &2r\"\"6r7s.) &;'.# &;("),
        peg$decode("%$;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s/\u0134#0\u0131*;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s&&&#/\"!&,)"),
        peg$decode("%;//?#2P\"\"6P7Q/0$;//'$8#:t# )(#'#(\"'#&'#"),
        peg$decode("%;//?#24\"\"6475/0$;//'$8#:u# )(#'#(\"'#&'#"),
        peg$decode("%;//?#2>\"\"6>7?/0$;//'$8#:v# )(#'#(\"'#&'#"),
        peg$decode("%;//?#2T\"\"6T7U/0$;//'$8#:w# )(#'#(\"'#&'#"),
        peg$decode("%;//?#2V\"\"6V7W/0$;//'$8#:x# )(#'#(\"'#&'#"),
        peg$decode("%2h\"\"6h7i/0#;//'$8\":y\" )(\"'#&'#"),
        peg$decode("%;//6#2f\"\"6f7g/'$8\":z\" )(\"'#&'#"),
        peg$decode("%;//?#2D\"\"6D7E/0$;//'$8#:{# )(#'#(\"'#&'#"),
        peg$decode("%;//?#22\"\"6273/0$;//'$8#:|# )(#'#(\"'#&'#"),
        peg$decode("%;//?#28\"\"6879/0$;//'$8#:}# )(#'#(\"'#&'#"),
        peg$decode("%;//0#;&/'$8\":~\" )(\"'#&'#"),
        peg$decode("%;&/0#;//'$8\":~\" )(\"'#&'#"),
        peg$decode("%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\"'#&'#"),
        peg$decode("4\x7F\"\"5!7\x80.A &4\x81\"\"5!7\x82.5 &4\x83\"\"5!7\x84.) &;3.# &;."),
        peg$decode("%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\"'#&'#/\"!&,)"),
        peg$decode("%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\"!&,)/1$;&/($8$:\x85$!!)($'#(#'#(\"'#&'#"),
        peg$decode(";..G &2L\"\"6L7M.; &4\x86\"\"5!7\x87./ &4\x83\"\"5!7\x84.# &;3"),
        peg$decode("%2j\"\"6j7k/J#4\x88\"\"5!7\x89.5 &4\x8A\"\"5!7\x8B.) &4\x8C\"\"5!7\x8D/#$+\")(\"'#&'#"),
        peg$decode("%;N/M#28\"\"6879/>$;O.\" &\"/0$;S/'$8$:\x8E$ )($'#(#'#(\"'#&'#"),
        peg$decode("%;N/d#28\"\"6879/U$;O.\" &\"/G$;S/>$;_/5$;l.\" &\"/'$8&:\x8F& )(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%3\x90\"\"5$7\x91.) &3\x92\"\"5#7\x93/' 8!:\x94!! )"),
        peg$decode("%;P/]#%28\"\"6879/,#;R/#$+\")(\"'#&'#.\" &\"/6$2:\"\"6:7;/'$8#:\x95# )(#'#(\"'#&'#"),
        peg$decode("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"),
        peg$decode("2<\"\"6<7=.q &2>\"\"6>7?.e &2@\"\"6@7A.Y &2B\"\"6B7C.M &2D\"\"6D7E.A &22\"\"6273.5 &26\"\"6677.) &24\"\"6475"),
        peg$decode("%$;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E0e*;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E&/& 8!:\x96! )"),
        peg$decode("%;T/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%;U.) &;\\.# &;X/& 8!:\x97! )"),
        peg$decode("%$%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#0<*%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#&/D#;W/;$2J\"\"6J7K.\" &\"/'$8#:\x98# )(#'#(\"'#&'#"),
        peg$decode("$4\x99\"\"5!7\x9A/,#0)*4\x99\"\"5!7\x9A&&&#"),
        peg$decode("%4$\"\"5!7%/?#$4\x9B\"\"5!7\x9C0)*4\x9B\"\"5!7\x9C&/#$+\")(\"'#&'#"),
        peg$decode("%2l\"\"6l7m/?#;Y/6$2n\"\"6n7o/'$8#:\x9D# )(#'#(\"'#&'#"),
        peg$decode("%%;Z/\xB3#28\"\"6879/\xA4$;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0790 &%2\x9E\"\"6\x9E7\x9F/\xA4#;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u06F9 &%2\x9E\"\"6\x9E7\x9F/\x8C#;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u067A &%2\x9E\"\"6\x9E7\x9F/t#;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0613 &%2\x9E\"\"6\x9E7\x9F/\\#;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+&)(&'#(%'#($'#(#'#(\"'#&'#.\u05C4 &%2\x9E\"\"6\x9E7\x9F/D#;Z/;$28\"\"6879/,$;[/#$+$)($'#(#'#(\"'#&'#.\u058D &%2\x9E\"\"6\x9E7\x9F/,#;[/#$+\")(\"'#&'#.\u056E &%2\x9E\"\"6\x9E7\x9F/,#;Z/#$+\")(\"'#&'#.\u054F &%;Z/\x9B#2\x9E\"\"6\x9E7\x9F/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u04C7 &%;Z/\xAA#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x83$2\x9E\"\"6\x9E7\x9F/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0430 &%;Z/\xB9#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x92$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/k$2\x9E\"\"6\x9E7\x9F/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u038A &%;Z/\xC8#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA1$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/z$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/S$2\x9E\"\"6\x9E7\x9F/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u02D5 &%;Z/\xD7#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;[/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0211 &%;Z/\xFE#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xD7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0126 &%;Z/\u011C#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xF5$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xCE$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x80$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/Y$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/2$2\x9E\"\"6\x9E7\x9F/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/& 8!:\xA0! )"),
        peg$decode("%;#/M#;#.\" &\"/?$;#.\" &\"/1$;#.\" &\"/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%;Z/;#28\"\"6879/,$;Z/#$+#)(#'#(\"'#&'#.# &;\\"),
        peg$decode("%;]/o#2J\"\"6J7K/`$;]/W$2J\"\"6J7K/H$;]/?$2J\"\"6J7K/0$;]/'$8':\xA1' )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%2\xA2\"\"6\xA27\xA3/2#4\xA4\"\"5!7\xA5/#$+\")(\"'#&'#.\x98 &%2\xA6\"\"6\xA67\xA7/;#4\xA8\"\"5!7\xA9/,$;!/#$+#)(#'#(\"'#&'#.j &%2\xAA\"\"6\xAA7\xAB/5#;!/,$;!/#$+#)(#'#(\"'#&'#.B &%4\xAC\"\"5!7\xAD/,#;!/#$+\")(\"'#&'#.# &;!"),
        peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\xAE!! )"),
        peg$decode("$%22\"\"6273/,#;`/#$+\")(\"'#&'#0<*%22\"\"6273/,#;`/#$+\")(\"'#&'#&"),
        peg$decode(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"),
        peg$decode("%3\xAF\"\"5*7\xB0/a#3\xB1\"\"5#7\xB2.G &3\xB3\"\"5#7\xB4.; &3\xB5\"\"5$7\xB6./ &3\xB7\"\"5#7\xB8.# &;6/($8\":\xB9\"! )(\"'#&'#"),
        peg$decode("%3\xBA\"\"5%7\xBB/I#3\xBC\"\"5%7\xBD./ &3\xBE\"\"5\"7\xBF.# &;6/($8\":\xC0\"! )(\"'#&'#"),
        peg$decode("%3\xC1\"\"5'7\xC2/1#;\x90/($8\":\xC3\"! )(\"'#&'#"),
        peg$decode("%3\xC4\"\"5$7\xC5/1#;\xF0/($8\":\xC6\"! )(\"'#&'#"),
        peg$decode("%3\xC7\"\"5&7\xC8/1#;T/($8\":\xC9\"! )(\"'#&'#"),
        peg$decode("%3\xCA\"\"5\"7\xCB/N#%2>\"\"6>7?/,#;6/#$+\")(\"'#&'#.\" &\"/'$8\":\xCC\" )(\"'#&'#"),
        peg$decode("%;h/P#%2>\"\"6>7?/,#;i/#$+\")(\"'#&'#.\" &\"/)$8\":\xCD\"\"! )(\"'#&'#"),
        peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"),
        peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"),
        peg$decode(";k.) &;+.# &;-"),
        peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &28\"\"6879.A &2<\"\"6<7=.5 &2@\"\"6@7A.) &2B\"\"6B7C"),
        peg$decode("%26\"\"6677/n#;m/e$$%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#0<*%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#&/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;n/A#2>\"\"6>7?/2$;o/)$8#:\xCE#\"\" )(#'#(\"'#&'#"),
        peg$decode("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"),
        peg$decode("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"),
        peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &26\"\"6677.A &28\"\"6879.5 &2@\"\"6@7A.) &2B\"\"6B7C"),
        peg$decode(";\x91.# &;r"),
        peg$decode("%;\x90/G#;'/>$;s/5$;'/,$;\x84/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode(";M.# &;t"),
        peg$decode("%;\x7F/E#28\"\"6879/6$;u.# &;x/'$8#:\xCF# )(#'#(\"'#&'#"),
        peg$decode("%;v.# &;w/J#%26\"\"6677/,#;\x83/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%2\xD0\"\"6\xD07\xD1/:#;\x80/1$;w.\" &\"/#$+#)(#'#(\"'#&'#"),
        peg$decode("%24\"\"6475/,#;{/#$+\")(\"'#&'#"),
        peg$decode("%;z/3#$;y0#*;y&/#$+\")(\"'#&'#"),
        peg$decode(";*.) &;+.# &;-"),
        peg$decode(";+.\x8F &;-.\x89 &22\"\"6273.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
        peg$decode("%;|/e#$%24\"\"6475/,#;|/#$+\")(\"'#&'#0<*%24\"\"6475/,#;|/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%$;~0#*;~&/e#$%22\"\"6273/,#;}/#$+\")(\"'#&'#0<*%22\"\"6273/,#;}/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("$;~0#*;~&"),
        peg$decode(";+.w &;-.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
        peg$decode("%%;\"/\x87#$;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K0M*;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K&/#$+\")(\"'#&'#/& 8!:\xD2! )"),
        peg$decode(";\x81.# &;\x82"),
        peg$decode("%%;O/2#2:\"\"6:7;/#$+\")(\"'#&'#.\" &\"/,#;S/#$+\")(\"'#&'#.\" &\""),
        peg$decode("$;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A/\x8C#0\x89*;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A&&&#"),
        peg$decode("$;y0#*;y&"),
        peg$decode("%3\x92\"\"5#7\xD3/q#24\"\"6475/b$$;!/&#0#*;!&&&#/L$2J\"\"6J7K/=$$;!/&#0#*;!&&&#/'$8%:\xD4% )(%'#($'#(#'#(\"'#&'#"),
        peg$decode("2\xD5\"\"6\xD57\xD6"),
        peg$decode("2\xD7\"\"6\xD77\xD8"),
        peg$decode("2\xD9\"\"6\xD97\xDA"),
        peg$decode("2\xDB\"\"6\xDB7\xDC"),
        peg$decode("2\xDD\"\"6\xDD7\xDE"),
        peg$decode("2\xDF\"\"6\xDF7\xE0"),
        peg$decode("2\xE1\"\"6\xE17\xE2"),
        peg$decode("2\xE3\"\"6\xE37\xE4"),
        peg$decode("2\xE5\"\"6\xE57\xE6"),
        peg$decode("2\xE7\"\"6\xE77\xE8"),
        peg$decode("2\xE9\"\"6\xE97\xEA"),
        peg$decode("%;\x85.Y &;\x86.S &;\x88.M &;\x89.G &;\x8A.A &;\x8B.; &;\x8C.5 &;\x8F./ &;\x8D.) &;\x8E.# &;6/& 8!:\xEB! )"),
        peg$decode("%;\x84/G#;'/>$;\x92/5$;'/,$;\x94/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%;\x93/' 8!:\xEC!! )"),
        peg$decode("%;!/5#;!/,$;!/#$+#)(#'#(\"'#&'#"),
        peg$decode("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:\xED! )"),
        peg$decode("%;\xB6/Y#$%;A/,#;\xB6/#$+\")(\"'#&'#06*%;A/,#;\xB6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;9/N#%2:\"\"6:7;/,#;9/#$+\")(\"'#&'#.\" &\"/'$8\":\xEE\" )(\"'#&'#"),
        peg$decode("%;:.c &%;\x98/Y#$%;A/,#;\x98/#$+\")(\"'#&'#06*%;A/,#;\x98/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/& 8!:\xEF! )"),
        peg$decode("%;L.# &;\x99/]#$%;B/,#;\x9B/#$+\")(\"'#&'#06*%;B/,#;\x9B/#$+\")(\"'#&'#&/'$8\":\xF0\" )(\"'#&'#"),
        peg$decode("%;\x9A.\" &\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%%;6/Y#$%;./,#;6/#$+\")(\"'#&'#06*%;./,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#.# &;H/' 8!:\xF1!! )"),
        peg$decode(";\x9C.) &;\x9D.# &;\xA0"),
        peg$decode("%3\xF2\"\"5!7\xF3/:#;</1$;\x9F/($8#:\xF4#! )(#'#(\"'#&'#"),
        peg$decode("%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\xF7#! )(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\xF8!! )"),
        peg$decode("%2\xF9\"\"6\xF97\xFA/o#%2J\"\"6J7K/M#;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+$)($'#(#'#(\"'#&'#.\" &\"/'$8\":\xFB\" )(\"'#&'#"),
        peg$decode("%;6/J#%;</,#;\xA1/#$+\")(\"'#&'#.\" &\"/)$8\":\xFC\"\"! )(\"'#&'#"),
        peg$decode(";6.) &;T.# &;H"),
        peg$decode("%;\xA3/Y#$%;B/,#;\xA4/#$+\")(\"'#&'#06*%;B/,#;\xA4/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%3\xFD\"\"5&7\xFE.G &3\xFF\"\"5'7\u0100.; &3\u0101\"\"5$7\u0102./ &3\u0103\"\"5%7\u0104.# &;6/& 8!:\u0105! )"),
        peg$decode(";\xA5.# &;\xA0"),
        peg$decode("%3\u0106\"\"5(7\u0107/M#;</D$3\u0108\"\"5(7\u0109./ &3\u010A\"\"5(7\u010B.# &;6/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u010C!! )"),
        peg$decode("%;\xA9/& 8!:\u010D! )"),
        peg$decode("%;\xAA/k#;;/b$;\xAF/Y$$%;B/,#;\xB0/#$+\")(\"'#&'#06*%;B/,#;\xB0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode(";\xAB.# &;\xAC"),
        peg$decode("3\u010E\"\"5$7\u010F.S &3\u0110\"\"5%7\u0111.G &3\u0112\"\"5%7\u0113.; &3\u0114\"\"5%7\u0115./ &3\u0116\"\"5+7\u0117.# &;\xAD"),
        peg$decode("3\u0118\"\"5'7\u0119./ &3\u011A\"\"5)7\u011B.# &;\xAD"),
        peg$decode(";6.# &;\xAE"),
        peg$decode("%3\u011C\"\"5\"7\u011D/,#;6/#$+\")(\"'#&'#"),
        peg$decode(";\xAD.# &;6"),
        peg$decode("%;6/5#;</,$;\xB1/#$+#)(#'#(\"'#&'#"),
        peg$decode(";6.# &;H"),
        peg$decode("%;\xB3/5#;./,$;\x90/#$+#)(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u011E!! )"),
        peg$decode("%;\x9E/' 8!:\u011F!! )"),
        peg$decode("%;\xB6/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u0120\"!!)(\"'#&'#"),
        peg$decode("%%;7/e#$%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#0<*%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"),
        peg$decode("%;L.# &;\x99/]#$%;B/,#;\xB8/#$+\")(\"'#&'#06*%;B/,#;\xB8/#$+\")(\"'#&'#&/'$8\":\u0121\" )(\"'#&'#"),
        peg$decode(";\xB9.# &;\xA0"),
        peg$decode("%3\u0122\"\"5#7\u0123/:#;</1$;6/($8#:\u0124#! )(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u0125!! )"),
        peg$decode("%;\x9E/' 8!:\u0126!! )"),
        peg$decode("%$;\x9A0#*;\x9A&/x#;@/o$;M/f$;?/]$$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8%:\u0127% )(%'#($'#(#'#(\"'#&'#"),
        peg$decode(";\xBE"),
        peg$decode("%3\u0128\"\"5&7\u0129/k#;./b$;\xC1/Y$$%;A/,#;\xC1/#$+\")(\"'#&'#06*%;A/,#;\xC1/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#.# &;\xBF"),
        peg$decode("%;6/k#;./b$;\xC0/Y$$%;A/,#;\xC0/#$+\")(\"'#&'#06*%;A/,#;\xC0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%;6/;#;</2$;6.# &;H/#$+#)(#'#(\"'#&'#"),
        peg$decode(";\xC2.G &;\xC4.A &;\xC6.; &;\xC8.5 &;\xC9./ &;\xCA.) &;\xCB.# &;\xC0"),
        peg$decode("%3\u012A\"\"5%7\u012B/5#;</,$;\xC3/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;I/' 8!:\u012C!! )"),
        peg$decode("%3\u012D\"\"5&7\u012E/\x97#;</\x8E$;D/\x85$;\xC5/|$$%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode(";t.# &;w"),
        peg$decode("%3\u012F\"\"5%7\u0130/5#;</,$;\xC7/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;I/' 8!:\u0131!! )"),
        peg$decode("%3\u0132\"\"5&7\u0133/:#;</1$;I/($8#:\u0134#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0135\"\"5%7\u0136/]#;</T$%3\u0137\"\"5$7\u0138/& 8!:\u0139! ).4 &%3\u013A\"\"5%7\u013B/& 8!:\u013C! )/#$+#)(#'#(\"'#&'#"),
        peg$decode("%3\u013D\"\"5)7\u013E/R#;</I$3\u013F\"\"5#7\u0140./ &3\u0141\"\"5(7\u0142.# &;6/($8#:\u0143#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0144\"\"5#7\u0145/\x93#;</\x8A$;D/\x81$%;\xCC/e#$%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#0<*%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%3\u0146\"\"5(7\u0147./ &3\u0148\"\"5$7\u0149.# &;6/' 8!:\u014A!! )"),
        peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;\xCF/G#;./>$;\xCF/5$;./,$;\x90/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u014B!! )"),
        peg$decode("%;\xD1/]#$%;A/,#;\xD1/#$+\")(\"'#&'#06*%;A/,#;\xD1/#$+\")(\"'#&'#&/'$8\":\u014C\" )(\"'#&'#"),
        peg$decode("%;\x99/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014D\" )(\"'#&'#"),
        peg$decode("%;L.O &;\x99.I &%;@.\" &\"/:#;t/1$;?.\" &\"/#$+#)(#'#(\"'#&'#/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014E\" )(\"'#&'#"),
        peg$decode("%;\xD4/]#$%;B/,#;\xD5/#$+\")(\"'#&'#06*%;B/,#;\xD5/#$+\")(\"'#&'#&/'$8\":\u014F\" )(\"'#&'#"),
        peg$decode("%;\x96/& 8!:\u0150! )"),
        peg$decode("%3\u0151\"\"5(7\u0152/:#;</1$;6/($8#:\u0153#! )(#'#(\"'#&'#.g &%3\u0154\"\"5&7\u0155/:#;</1$;6/($8#:\u0156#! )(#'#(\"'#&'#.: &%3\u0157\"\"5*7\u0158/& 8!:\u0159! ).# &;\xA0"),
        peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u015C!! )"),
        peg$decode("%;\xD8/Y#$%;A/,#;\xD8/#$+\")(\"'#&'#06*%;A/,#;\xD8/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;\x99/Y#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u015D!! )"),
        peg$decode("%;\xDB/Y#$%;B/,#;\xDC/#$+\")(\"'#&'#06*%;B/,#;\xDC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%3\u015E\"\"5&7\u015F.; &3\u0160\"\"5'7\u0161./ &3\u0162\"\"5*7\u0163.# &;6/& 8!:\u0164! )"),
        peg$decode("%3\u0165\"\"5&7\u0166/:#;</1$;\xDD/($8#:\u0167#! )(#'#(\"'#&'#.} &%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\u0168#! )(#'#(\"'#&'#.P &%3\u0169\"\"5+7\u016A/:#;</1$;\x9E/($8#:\u016B#! )(#'#(\"'#&'#.# &;\xA0"),
        peg$decode("3\u016C\"\"5+7\u016D.k &3\u016E\"\"5)7\u016F._ &3\u0170\"\"5(7\u0171.S &3\u0172\"\"5'7\u0173.G &3\u0174\"\"5&7\u0175.; &3\u0176\"\"5*7\u0177./ &3\u0178\"\"5)7\u0179.# &;6"),
        peg$decode(";1.\" &\""),
        peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u017A!! )"),
        peg$decode("%;L.# &;\x99/]#$%;B/,#;\xE1/#$+\")(\"'#&'#06*%;B/,#;\xE1/#$+\")(\"'#&'#&/'$8\":\u017B\" )(\"'#&'#"),
        peg$decode(";\xB9.# &;\xA0"),
        peg$decode("%;\xE3/Y#$%;A/,#;\xE3/#$+\")(\"'#&'#06*%;A/,#;\xE3/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;\xEA/k#;./b$;\xED/Y$$%;B/,#;\xE4/#$+\")(\"'#&'#06*%;B/,#;\xE4/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode(";\xE5.; &;\xE6.5 &;\xE7./ &;\xE8.) &;\xE9.# &;\xA0"),
        peg$decode("%3\u017C\"\"5#7\u017D/:#;</1$;\xF0/($8#:\u017E#! )(#'#(\"'#&'#"),
        peg$decode("%3\u017F\"\"5%7\u0180/:#;</1$;T/($8#:\u0181#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0182\"\"5(7\u0183/F#;</=$;\\.) &;Y.# &;X/($8#:\u0184#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0185\"\"5&7\u0186/:#;</1$;6/($8#:\u0187#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0188\"\"5%7\u0189/A#;</8$$;!0#*;!&/($8#:\u018A#! )(#'#(\"'#&'#"),
        peg$decode("%;\xEB/G#;;/>$;6/5$;;/,$;\xEC/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%3\x92\"\"5#7\xD3.# &;6/' 8!:\u018B!! )"),
        peg$decode("%3\xB1\"\"5#7\u018C.G &3\xB3\"\"5#7\u018D.; &3\xB7\"\"5#7\u018E./ &3\xB5\"\"5$7\u018F.# &;6/' 8!:\u0190!! )"),
        peg$decode("%;\xEE/D#%;C/,#;\xEF/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%;U.) &;\\.# &;X/& 8!:\u0191! )"),
        peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\u0192!! )"),
        peg$decode("%%;!/?#;!.\" &\"/1$;!.\" &\"/#$+#)(#'#(\"'#&'#/' 8!:\u0193!! )"),
        peg$decode(";\xBE"),
        peg$decode("%;\x9E/^#$%;B/,#;\xF3/#$+\")(\"'#&'#06*%;B/,#;\xF3/#$+\")(\"'#&'#&/($8\":\u0194\"!!)(\"'#&'#"),
        peg$decode(";\xF4.# &;\xA0"),
        peg$decode("%2\u0195\"\"6\u01957\u0196/L#;</C$2\u0197\"\"6\u01977\u0198.) &2\u0199\"\"6\u01997\u019A/($8#:\u019B#! )(#'#(\"'#&'#"),
        peg$decode("%;\x9E/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u019C\"!!)(\"'#&'#"),
        peg$decode("%;6/5#;0/,$;\xF7/#$+#)(#'#(\"'#&'#"),
        peg$decode("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"),
        peg$decode("$;%0#*;%&"),
        peg$decode("%;\xFA/;#28\"\"6879/,$;\xFB/#$+#)(#'#(\"'#&'#"),
        peg$decode("%3\u019D\"\"5%7\u019E.) &3\u019F\"\"5$7\u01A0/' 8!:\u01A1!! )"),
        peg$decode("%;\xFC/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%;\\.) &;X.# &;\x82/' 8!:\u01A2!! )"),
        peg$decode(";\".S &;!.M &2F\"\"6F7G.A &2J\"\"6J7K.5 &2H\"\"6H7I.) &2N\"\"6N7O"),
        peg$decode("2L\"\"6L7M.\x95 &2B\"\"6B7C.\x89 &2<\"\"6<7=.} &2R\"\"6R7S.q &2T\"\"6T7U.e &2V\"\"6V7W.Y &2P\"\"6P7Q.M &2@\"\"6@7A.A &2D\"\"6D7E.5 &22\"\"6273.) &2>\"\"6>7?"),
        peg$decode("%;\u0100/b#28\"\"6879/S$;\xFB/J$%2\u01A3\"\"6\u01A37\u01A4/,#;\xEC/#$+\")(\"'#&'#.\" &\"/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%3\u01A5\"\"5%7\u01A6.) &3\u01A7\"\"5$7\u01A8/' 8!:\u01A1!! )"),
        peg$decode("%3\xB1\"\"5#7\xB2.6 &3\xB3\"\"5#7\xB4.* &$;+0#*;+&/' 8!:\u01A9!! )"),
        peg$decode("%;\u0104/\x87#2F\"\"6F7G/x$;\u0103/o$2F\"\"6F7G/`$;\u0103/W$2F\"\"6F7G/H$;\u0103/?$2F\"\"6F7G/0$;\u0105/'$8):\u01AA) )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%;\u0103/,#;\u0103/#$+\")(\"'#&'#"),
        peg$decode("%;\u0103/5#;\u0103/,$;\u0103/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;q/T#$;m0#*;m&/D$%; /,#;\xF8/#$+\")(\"'#&'#.\" &\"/#$+#)(#'#(\"'#&'#"),
        peg$decode("%2\u01AB\"\"6\u01AB7\u01AC.) &2\u01AD\"\"6\u01AD7\u01AE/w#;0/n$;\u0108/e$$%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#0<*%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode(";\x99.# &;L"),
        peg$decode("%2\u01AF\"\"6\u01AF7\u01B0/5#;</,$;\u010A/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;D/S#;,/J$2:\"\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#")
    ];
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleIndices)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }
        peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return { type: "literal", text: text1, ignoreCase: ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }
    function peg$anyExpectation() {
        return { type: "any" };
    }
    function peg$endExpectation() {
        return { type: "end" };
    }
    function peg$otherExpectation(description) {
        return { type: "other", description: description };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
            return details;
        }
        else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
                p--;
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                }
                else {
                    details.column++;
                }
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new SyntaxError(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$decode(s) {
        return s.split("").map(function (ch) { return ch.charCodeAt(0) - 32; });
    }
    function peg$parseRule(index) {
        var bc = peg$bytecode[index];
        var ip = 0;
        var ips = [];
        var end = bc.length;
        var ends = [];
        var stack = [];
        var params;
        while (true) {
            while (ip < end) {
                switch (bc[ip]) {
                    case 0:
                        stack.push(peg$consts[bc[ip + 1]]);
                        ip += 2;
                        break;
                    case 1:
                        stack.push(undefined);
                        ip++;
                        break;
                    case 2:
                        stack.push(null);
                        ip++;
                        break;
                    case 3:
                        stack.push(peg$FAILED);
                        ip++;
                        break;
                    case 4:
                        stack.push([]);
                        ip++;
                        break;
                    case 5:
                        stack.push(peg$currPos);
                        ip++;
                        break;
                    case 6:
                        stack.pop();
                        ip++;
                        break;
                    case 7:
                        peg$currPos = stack.pop();
                        ip++;
                        break;
                    case 8:
                        stack.length -= bc[ip + 1];
                        ip += 2;
                        break;
                    case 9:
                        stack.splice(-2, 1);
                        ip++;
                        break;
                    case 10:
                        stack[stack.length - 2].push(stack.pop());
                        ip++;
                        break;
                    case 11:
                        stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                        ip += 2;
                        break;
                    case 12:
                        stack.push(input.substring(stack.pop(), peg$currPos));
                        ip++;
                        break;
                    case 13:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (stack[stack.length - 1]) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 14:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (stack[stack.length - 1] === peg$FAILED) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 15:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (stack[stack.length - 1] !== peg$FAILED) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 16:
                        if (stack[stack.length - 1] !== peg$FAILED) {
                            ends.push(end);
                            ips.push(ip);
                            end = ip + 2 + bc[ip + 1];
                            ip += 2;
                        }
                        else {
                            ip += 2 + bc[ip + 1];
                        }
                        break;
                    case 17:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (input.length > peg$currPos) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 18:
                        ends.push(end);
                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                        if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                            end = ip + 4 + bc[ip + 2];
                            ip += 4;
                        }
                        else {
                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                            ip += 4 + bc[ip + 2];
                        }
                        break;
                    case 19:
                        ends.push(end);
                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                        if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                            end = ip + 4 + bc[ip + 2];
                            ip += 4;
                        }
                        else {
                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                            ip += 4 + bc[ip + 2];
                        }
                        break;
                    case 20:
                        ends.push(end);
                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                        if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                            end = ip + 4 + bc[ip + 2];
                            ip += 4;
                        }
                        else {
                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                            ip += 4 + bc[ip + 2];
                        }
                        break;
                    case 21:
                        stack.push(input.substr(peg$currPos, bc[ip + 1]));
                        peg$currPos += bc[ip + 1];
                        ip += 2;
                        break;
                    case 22:
                        stack.push(peg$consts[bc[ip + 1]]);
                        peg$currPos += peg$consts[bc[ip + 1]].length;
                        ip += 2;
                        break;
                    case 23:
                        stack.push(peg$FAILED);
                        if (peg$silentFails === 0) {
                            peg$fail(peg$consts[bc[ip + 1]]);
                        }
                        ip += 2;
                        break;
                    case 24:
                        peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
                        ip += 2;
                        break;
                    case 25:
                        peg$savedPos = peg$currPos;
                        ip++;
                        break;
                    case 26:
                        params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
                            .map(function (p) { return stack[stack.length - 1 - p]; });
                        stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
                        ip += 4 + bc[ip + 3];
                        break;
                    case 27:
                        stack.push(peg$parseRule(bc[ip + 1]));
                        ip += 2;
                        break;
                    case 28:
                        peg$silentFails++;
                        ip++;
                        break;
                    case 29:
                        peg$silentFails--;
                        ip++;
                        break;
                    default:
                        throw new Error("Invalid opcode: " + bc[ip] + ".");
                }
            }
            if (ends.length > 0) {
                end = ends.pop();
                ip = ips.pop();
            }
            else {
                break;
            }
        }
        return stack[0];
    }
    options.data = {}; // Object to which header attributes will be assigned during parsing
    function list(head, tail) {
        return [head].concat(tail);
    }
    peg$result = peg$parseRule(peg$startRuleIndex);
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
    }
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
exports.parse = peg$parse;


/***/ }),

/***/ "./node_modules/sip.js/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/sip.js/lib/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
exports.DigestAuthentication = core_1.DigestAuthentication;
exports.Grammar = core_1.Grammar;
exports.IncomingRequest = core_1.IncomingRequestMessage;
exports.IncomingResponse = core_1.IncomingResponseMessage;
exports.LoggerFactory = core_1.LoggerFactory;
exports.NameAddrHeader = core_1.NameAddrHeader;
exports.OutgoingRequest = core_1.OutgoingRequestMessage;
exports.Parser = core_1.Parser;
exports.Timers = core_1.Timers;
exports.URI = core_1.URI;
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
exports.ClientContext = ClientContext_1.ClientContext;
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
exports.C = Constants_1.C;
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
exports.DialogStatus = Enums_1.DialogStatus;
exports.SessionStatus = Enums_1.SessionStatus;
exports.TypeStrings = Enums_1.TypeStrings;
exports.UAStatus = Enums_1.UAStatus;
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
exports.Exceptions = Exceptions_1.Exceptions;
var PublishContext_1 = __webpack_require__(/*! ./PublishContext */ "./node_modules/sip.js/lib/PublishContext.js");
exports.PublishContext = PublishContext_1.PublishContext;
var ReferContext_1 = __webpack_require__(/*! ./ReferContext */ "./node_modules/sip.js/lib/ReferContext.js");
exports.ReferClientContext = ReferContext_1.ReferClientContext;
exports.ReferServerContext = ReferContext_1.ReferServerContext;
var RegisterContext_1 = __webpack_require__(/*! ./RegisterContext */ "./node_modules/sip.js/lib/RegisterContext.js");
exports.RegisterContext = RegisterContext_1.RegisterContext;
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
exports.ServerContext = ServerContext_1.ServerContext;
var Session_1 = __webpack_require__(/*! ./Session */ "./node_modules/sip.js/lib/Session.js");
exports.InviteClientContext = Session_1.InviteClientContext;
exports.InviteServerContext = Session_1.InviteServerContext;
exports.Session = Session_1.Session;
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/sip.js/lib/Subscription.js");
exports.Subscription = Subscription_1.Subscription;
var Transport_1 = __webpack_require__(/*! ./Transport */ "./node_modules/sip.js/lib/Transport.js");
exports.Transport = Transport_1.Transport;
var transactions_1 = __webpack_require__(/*! ./core/transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var Transactions = {
    InviteClientTransaction: transactions_1.InviteClientTransaction,
    InviteServerTransaction: transactions_1.InviteServerTransaction,
    NonInviteClientTransaction: transactions_1.NonInviteClientTransaction,
    NonInviteServerTransaction: transactions_1.NonInviteServerTransaction
};
exports.Transactions = Transactions;
var UA_1 = __webpack_require__(/*! ./UA */ "./node_modules/sip.js/lib/UA.js");
exports.makeUserAgentCoreConfigurationFromUA = UA_1.makeUserAgentCoreConfigurationFromUA;
exports.UA = UA_1.UA;
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
exports.Utils = Utils_1.Utils;
var Web = tslib_1.__importStar(__webpack_require__(/*! ./Web/index */ "./node_modules/sip.js/lib/Web/index.js"));
exports.Web = Web;
var version = Constants_1.C.version;
exports.version = version;
var name = "sip.js";
exports.name = name;
var Core = tslib_1.__importStar(__webpack_require__(/*! ./core/index */ "./node_modules/sip.js/lib/core/index.js"));
exports.Core = Core;


/***/ }),

/***/ "./node_modules/sip.js/lib/version.js":
/*!********************************************!*\
  !*** ./node_modules/sip.js/lib/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LIBRARY_VERSION = "0.15.11";


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./src/cdcts-sipjs.js":
/*!****************************!*\
  !*** ./src/cdcts-sipjs.js ***!
  \****************************/
/*! exports provided: CdctsDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_cdcts_device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/cdcts-device */ "./src/lib/cdcts-device.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CdctsDevice", function() { return _lib_cdcts_device__WEBPACK_IMPORTED_MODULE_0__["CdctsDevice"]; });




/***/ }),

/***/ "./src/lib/cdcts-call.js":
/*!*******************************!*\
  !*** ./src/lib/cdcts-call.js ***!
  \*******************************/
/*! exports provided: CdctsCall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(SIP) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdctsCall", function() { return CdctsCall; });
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-event-emitter */ "./node_modules/es6-event-emitter/dist/emitter.js");
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_event_emitter__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var CdctsCall = /*#__PURE__*/function (_EventEmitter) {
  _inherits(CdctsCall, _EventEmitter);

  var _super = _createSuper(CdctsCall);

  /**
  * Create a CdctsCall. Normally created by CdctsDevice.
  *
  * Once a call is created, you can either make a call with `makeCall()`
  * or set yourself up to recieve an incoming call with `incomingCall()`
  *
  * @param {UA} UA - A SIP.js User Agent
  * @param {String} inviteUri - A Properly formatted SIP.js invite URI (create with SIP.URI)
  *
  * @emits CdctsCall#connecting
  */
  function CdctsCall(UA) {
    var _this;

    _classCallCheck(this, CdctsCall);

    _this = _super.call(this);
    _this._mute = false;
    _this._status = 'starting';
    _this._callType = '';
    _this.UA = UA;
    _this._docBody = document.getElementsByTagName('body')[0];
    _this.audioElement = false;

    _this.UA.start();

    return _this;
  }
  /**
  * Make a call to a phone number
  *
  * @param {URI} inviteUri - A SIP.js URI that includes the phone number to connect to
  */


  _createClass(CdctsCall, [{
    key: "makeCall",
    value: function makeCall(inviteUri) {
      this._callType = 'outgoing';
      this._session = this.UA.invite(inviteUri, this._getAudioElement());

      this._attatchSessionEvents(this._session);
    }
    /**
    * Set up to handle an incoming call.
    * The calling function will then be able to accept or reject the call.
    *
    * @param {Session} session - A SIP.js Session, specifically of the SIP.ServerContext type
    */

  }, {
    key: "incomingCall",
    value: function incomingCall(session) {
      this._callType = 'incoming';
      this._session = session;

      this._attatchSessionEvents();
    }
  }, {
    key: "_getAudioElement",
    value: function _getAudioElement() {
      if (!this.audioElement) {
        console.log("this.audioElement", this.audioElement);
        this.audioElement = document.createElement('audio');
        this.audioElement.className = 'cdcts-sipjs-remote-audio';

        this._docBody.appendChild(this.audioElement);
      }

      return this.audioElement;
    }
  }, {
    key: "_attatchSessionEvents",
    value: function _attatchSessionEvents(session) {
      var _this2 = this;

      /**
      * connecting event:
      *
      * Fired as the system starts to make the connection.
      * This is after the userMedia (microphone) has been aquired.
      *
      * @event CdctsCall#connecting
      * @type {object}
      */
      this._session.on("connecting", function () {
        _this2.trigger("connecting");

        _this2._status = 'initiating';
      });
      /**
      * progress event:
      *
      * Usually fired twice during call intialization, once for TRYING and once for RINGING.
      *
      * @event CdctsCall#progress
      * @type {object}
      * @property {object} response - Details of the response
      */


      this._session.on("progress", function (response) {
        if (response.statusCode == 183 && response.body && _this2._session.hasOffer && !_this2._session.dialog) {
          if (!response.hasHeader('require') || response.getHeader('require').indexOf('100rel') === -1) {
            if (_this2._session.sessionDescriptionHandler.hasDescription(response.getHeader('Content-Type'))) {
              // @hack: https://github.com/onsip/SIP.js/issues/242
              _this2._session.status = SIP.Session.C.STATUS_EARLY_MEDIA; // this._waitingForApplyingAnswer(session, response)
            }
          }
        }

        _this2.trigger("progress", response);
      });
      /**
      * accepted event:
      *
      * Fired when the call was accepted by the callee. The call is now connected.
      *
      * @event CdctsCall#accepted
      * @type {object}
      * @property {object} data - Details of the response
      */


      this._session.on("accepted", function (data) {
        _this2.trigger("accepted", data), _this2._status = 'connected';
      });
      /**
      * dtmf event:
      *
      * Sent when the user has successfully sent a DTMF (keypad) signal.
      *
      * @event CdctsCall#dtmf
      * @type {object}
      * @property {object} request - Details of the request
      * @property {string} dtmf - the key(s) that were submitted
      */


      this._session.on("dtmf", function (request, dtmf) {
        return _this2.trigger("dtmf", request, dtmf);
      });
      /**
      * muted event:
      *
      * Fired when the system has successfully responded to a mute request.
      *
      * @event CdctsCall#muted
      * @type {object}
      * @property {object} data - Details of the response
      */


      this._session.on("muted", function (data) {
        return _this2.trigger("muted", data);
      });
      /**
      * unmuted event
      *
      * Fired when the system has successfully responded to an unmute request.
      *
      * @event CdctsCall#unmuted
      * @type {object}
      * @property {object} data - Details of the response
      */


      this._session.on("unmuted", function (data) {
        return _this2.trigger("unmuted", data);
      });
      /**
      * cancel event:
      *
      * Fired when the call was terminated before end to end connection was established,
      * usually by the user's request.
      *
      * @event CdctsCall#cancel
      */


      this._session.on("cancel", function () {
        _this2.trigger("cancel");

        _this2._status = 'ended';
      });
      /**
      * refer event
      *
      * @event CdctsCall#refer
      * @property {function} callback
      * @property {object} response
      * @property {object} newSession
      */


      this._session.on("refer", function (callback, response, newSession) {
        _this2.trigger("rejected");
      });
      /**
      * replaced event
      *
      * @event CdctsCall#replaced
      * @property {object} newSession
      */


      this._session.on("replaced", function (newSession) {
        _this2.trigger("rejected", newSession);
      });
      /**
      * rejected event
      *
      * @event CdctsCall#rejected
      * @property {object} response
      * @property {object} cause
      */


      this._session.on("rejected", function (response, cause) {
        _this2.trigger("rejected", response, cause);

        _this2._status = 'ended';
      });
      /**
      * failed event
      *
      * @event CdctsCall#failed
      * @property {object} response
      * @property {object} cause
      */


      this._session.on("failed", function (response, cause) {
        _this2.trigger("failed", response, cause);

        _this2._status = 'ended';
      });
      /**
      * terminated event
      *
      * @event CdctsCall#terminated
      * @property {object} response
      * @property {object} cause
      */


      this._session.on("terminated", function (message, cause) {
        _this2.trigger("terminated", message, cause);

        _this2._status = 'ended';
      });
      /**
      * bye event
      *
      * @event CdctsCall#bye
      */


      this._session.on("bye", function () {
        _this2.trigger("bye");

        _this2._status = 'ended';
      });
      /**
      * userMediaRequest event:
      *
      * Fired when the every time the system checks to see if it has microphone permission from the user.
      * You can use this to detect when the browser's "Allow website to use microphone" dialog is open,
      * but you will need to be somewhat careful. This event will fire even if the user already has
      * given permission, then will be immediately followed by a {@link CdctsCall#userMedia} event.
      * If you wish to have your UI display some sort of "asking for permission" element, you may need to
      * debounce this event; listening for {@link CdctsCall#userMedia} to cancel your UI update.
      *
      * @event CdctsCall#userMediaRequest
      * @property {object} constraints
      */


      this._session.on('trackAdded', function () {
        if (session) {
          var pc = session.sessionDescriptionHandler.peerConnection; // var this.audioElement = this.audioElement;
          // this.audioElement.className = 'cdcts-sipjs-remote-audio';

          var remoteStream = new MediaStream();
          pc.getReceivers().forEach(function (receiver) {
            remoteStream.addTrack(receiver.track);
          });

          if (typeof session.passedOptions.srcObject !== 'undefined') {
            session.passedOptions.srcObject = remoteStream;
          } else if (typeof session.passedOptions.mozSrcObject !== 'undefined') {
            session.passedOptions.mozSrcObject = remoteStream;
          } else if (typeof session.passedOptions.src !== 'undefined') {
            session.passedOptions.src = URL.createObjectURL(remoteStream);
          } else {
            console.log('Error attaching stream to element.');
          }

          session.passedOptions.play();
        }
      }); // this._session.mediaHandler.on("userMediaRequest", (constraints) => {this.trigger("userMediaRequest", constraints);});
      // /**
      // * userMedia event:
      // *
      // * Fired when the system has aquired permission to use the microphone. This will happen either
      // * immediately after {@link CdctsCall#userMediaRequest} if the user has previously given permission
      // * or after the user approves the request.
      // *
      // * @event CdctsCall#userMedia
      // * @property {object} stream
      // */
      // this._session.mediaHandler.on("userMedia", (stream) => {this.trigger("userMedia", stream);});
      // /**
      // * userMediaFailed event:
      // *
      // * Fired when the user refuses permission to use the microphone. There is no way back from this
      // * except for the user to go into browser settings and remove the exception for your site.
      // *
      // * @event CdctsCall#userMediaFailed
      // * @property {object} error
      // */
      // this._session.mediaHandler.on("userMediaFailed", (error) => {this.trigger("userMediaFailed", error);});
      // /**
      // * iceGathering event
      // *
      // * @event CdctsCall#iceGathering
      // */
      // this._session.mediaHandler.on("iceGathering", () => {this.trigger("iceGathering");});
      // /**
      // * iceCandidate event
      // *
      // * @event CdctsCall#iceCandidate
      // * @property {object} candidate
      // */
      // this._session.mediaHandler.on("iceCandidate", (candidate) => {this.trigger("iceCandidate", candidate);});
      // /**
      // * iceGatheringComplete event
      // *
      // * @event CdctsCall#iceGatheringComplete
      // */
      // this._session.mediaHandler.on("iceGatheringComplete", () => {this.trigger("iceGatheringComplete");});
      // /**
      // * iceConnection event
      // *
      // * @event CdctsCall#iceConnection
      // */
      // this._session.mediaHandler.on("iceConnection", () => {this.trigger("iceConnection");});
      // /**
      // * iceConnectionChecking event
      // *
      // * @event CdctsCall#iceConnectionChecking
      // */
      // this._session.mediaHandler.on("iceConnectionChecking", () => {this.trigger("iceConnectionChecking");});
      // /**
      // * iceConnectionConnected event
      // *
      // * @event CdctsCall#iceConnectionConnected
      // */
      // this._session.mediaHandler.on("iceConnectionConnected", () => {this.trigger("iceConnectionConnected");});
      // /**
      // * iceConnectionCompleted event
      // *
      // * @event CdctsCall#iceConnectionCompleted
      // */
      // this._session.mediaHandler.on("iceConnectionCompleted", () => {this.trigger("iceConnectionCompleted");});
      // /**
      // * iceConnectionFailed event
      // *
      // * @event CdctsCall#iceConnectionFailed
      // */
      // this._session.mediaHandler.on("iceConnectionFailed", () => {this.trigger("iceConnectionFailed");});
      // /**
      // * iceConnectionDisconnected event
      // *
      // * @event CdctsCall#iceConnectionDisconnected
      // */
      // this._session.mediaHandler.on("iceConnectionDisconnected", () => {this.trigger("iceConnectionDisconnected");});
      // /**
      // * iceConnectionClosed event
      // *
      // * @event CdctsCall#iceConnectionClosed
      // */
      // this._session.mediaHandler.on("iceConnectionClosed", () => {this.trigger("iceConnectionClosed");});
      // /**
      // * getDescription event
      // *
      // * @event CdctsCall#getDescription
      // * @property {object} sdpWrapper
      // */
      // this._session.mediaHandler.on("getDescription", (sdpWrapper) => {this.trigger("getDescription", sdpWrapper);});
      // /**
      // * setDescription event
      // *
      // * @event CdctsCall#setDescription
      // * @property {object} sdpWrapper
      // */
      // this._session.mediaHandler.on("setDescription", (sdpWrapper) => {this.trigger("setDescription", sdpWrapper);});
      // /**
      // * dataChannel event
      // *
      // * @event CdctsCall#dataChannel
      // * @property {object} dataChannel
      // */
      // this._session.mediaHandler.on("dataChannel", (dataChannel) => {this.trigger("dataChannel", dataChannel);});
      // /**
      // * addStream event
      // *
      // * @event CdctsCall#addStream
      // * @property {object} stream
      // */
      // this._session.mediaHandler.on("addStream", (stream) => { this.trigger("addStream", stream); });

    }
    /**
     * Accept an incoming call.
     * When a call is received `CdctsDevice` will create a new `CdctsCall` for the session
     * and emit a `incomingInvite` event.
     * The new `CdctsCall` is passed along with the event. Call `accept()` to accept the call.
     */

  }, {
    key: "answer",
    value: function answer() {
      if (this._callType !== 'incoming') {
        console.error("accept() method is only valid on incoming calls");
        return;
      }

      this._session.accept({
        media: {
          constraints: {
            audio: true,
            video: false
          },
          render: {
            remote: this._getAudioElement()
          }
        },
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: false
          },
          render: {
            remote: this._getAudioElement()
          }
        }
      });

      this._attatchSessionEvents(this);
    }
    /**
     * Reject an incoming call.
     * When a call is received `CdctsDevice` will create a new `CdctsCall` for the session
     * and emit a `incomingInvite` event.
     * The new `CdctsCall` is passed along with the event. Call `reject()` to reject the call.
     */

  }, {
    key: "reject",
    value: function reject() {
      if (this._callType !== 'incoming') {
        console.error("reject() method is only valid on incoming calls");
        return;
      }

      this._session.reject();
    }
    /**
     * The request object contains metadata about the current session,
     * including the who the call is going `to` and in the case of incoming calls,
     * who the call is coming `from`.
     *
     * @return {object} request
     */

  }, {
    key: "request",
    get: function get() {
      if (!this._session) {
        return false;
      }

      if (this._callType === 'incoming') {
        return this._session.transaction.request;
      } else if (this._callType === 'outgoing') {
        return this._session.request;
      } else {
        return false;
      }
    }
    /**
    * Is the call still initiating?
    *
    * @return {Boolean} isInitiating
    */

  }, {
    key: "isInitiating",
    value: function isInitiating() {
      return this._status === 'initiating';
    }
    /**
    * Has the call connected?
    *
    * @return {Boolean} isConnected
    */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._status === 'connected';
    }
    /**
    * Has the call ended?
    *
    * @return {Boolean} isEnded
    */

  }, {
    key: "isEnded",
    value: function isEnded() {
      return this._status === 'ended';
    }
    /**
    * Is this an incoming call?
    *
    * @return {Boolean} isIncoming
    */

  }, {
    key: "isIncoming",
    value: function isIncoming() {
      return this._callType === 'incoming';
    }
    /**
    * Is this an outgoing call?
    *
    * @return {Boolean} isOutgoing
    */

  }, {
    key: "isOutgoing",
    value: function isOutgoing() {
      return this._callType === 'outgoing';
    }
    /**
    * End the session
    *
    * @emits CdctsCall#terminated
    */

  }, {
    key: "terminate",
    value: function terminate() {
      this._session.terminate();
    }
    /**
    * Shutdown the connection to the WebRTC servers
    * @deprecated Please use CdctsDevice.stopWS instead.
    */

  }, {
    key: "shutdown",
    value: function shutdown() {
      this.UA.stop();
    }
    /**
    * Toggle mute
    *
    * @param {boolean} isMute - if true you want mute to be ON
    */

  }, {
    key: "mute",
    value: function mute(isMute
    /*bool*/
    ) {
      this._mute = isMute;

      if (this._mute) {
        this._session.mute();
      } else {
        this._session.unmute();
      }
    }
    /**
    * Toggle hold
    *
    * @param {boolean} isHold - if true you want mute to be ON
    */

  }, {
    key: "hold",
    value: function hold(isHold
    /*bool*/
    ) {
      if (isHold) {
        this._session.hold();
      } else {
        this._session.unhold();
      }
    }
    /**
    * Current mute state
    *
    * @return {boolean} true if call is on mute
    */

  }, {
    key: "isMuted",
    value: function isMuted() {
      return this._mute;
    }
    /**
    * Send phone keypad presses (DTMF tones)
    *
    * Used after the call is in progress.
    *
    * @param {string} digits - a string containg digits 0-9, *, #
    * @emits CdctsCall#dtmf
    */

  }, {
    key: "sendDigits",
    value: function sendDigits(digits) {
      this._session.dtmf(digits);
    }
    /**
    * Send phone keypad presses (DTMF tones)
    *
    * Used after the call is in progress.
    *
    * @param {string} digits - a string containg digits 0-9, *, #
    * @emits CdctsCall#dtmf
    */

  }, {
    key: "refer",
    value: function refer(digits) {
      this._session.refer(digits);
    }
    /**
    * The "simple" status.
    *
    * All of the many phases of the call boiled down into 3 states: Initiating, Connected and Ended.
    *
    * @return {string} one of initiating, connected, ended
    */

  }, {
    key: "status",
    value: function status() {
      return this._status;
    }
  }, {
    key: "_waitingForApplyingAnswer",
    value: function _waitingForApplyingAnswer(session, response) {
      var i = 1,
          clearTimer;
      setTimeout(function check() {
        i++;
        clearTimer = setTimeout(check, 10);

        if (session && session.hasAnswer || i > 14) {
          if (session.hasAnswer) {
            clearTimeout(clearTimer);
          } else if (i === 15) {
            clearTimeout(clearTimer);
            session.sessionDescriptionHandler.setDescription(response.body)["catch"](function (error) {
              session.logger.warn(error);
              session.failed(response, C.causes.BAD_MEDIA_DESCRIPTION);
              session.terminate({
                statusCode: 488,
                reason_phrase: 'Bad Media Description'
              });
            });
          }
        }
      }, 10);
    }
  }]);

  return CdctsCall;
}(es6_event_emitter__WEBPACK_IMPORTED_MODULE_0___default.a);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! sip.js */ "./node_modules/sip.js/lib/index.js")))

/***/ }),

/***/ "./src/lib/cdcts-device.js":
/*!*********************************!*\
  !*** ./src/lib/cdcts-device.js ***!
  \*********************************/
/*! exports provided: CdctsDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdctsDevice", function() { return CdctsDevice; });
/* harmony import */ var sip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sip.js */ "./node_modules/sip.js/lib/index.js");
/* harmony import */ var sip_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sip_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-event-emitter */ "./node_modules/es6-event-emitter/dist/emitter.js");
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_event_emitter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cdcts_call__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cdcts-call */ "./src/lib/cdcts-call.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




/**
* Represents the software phone running in a web browser or other context.
*
* @class
*/

var CdctsDevice = /*#__PURE__*/function (_EventEmitter) {
  _inherits(CdctsDevice, _EventEmitter);

  var _super = _createSuper(CdctsDevice);

  /**
  * Create a new CdctsDevice.
  *
  * @param {Object} config Configuration Object
  * @param {String} config.host The host name or IP address of the SIP server
  * @param {String} config.port The port of the SIP server
  * @param {String} config.wsServers URI(s) of the WebSocket Servers. Format `wss://123.0.0.0:5066`. An array of strings is also accepted.
  * @param {String} config.username The username for the SIP server
  * @param {String} config.password The passweord for the SIP server
  * @param {String} config.displayName The human readable name passed in the from field. Will be used for Caller ID
  * @param {String} config.stunServers URI(s) for how to connect to the STUN servers. Format `stun:stun.cdcts.com:8000`. An array of strings is also accepted.
  * @param {Object} config.turnServers Details for how to connect to the TURN servers. An array of objects is also accepted.
  * @param {String} config.turnServers.urls URI(s) for the TURN server(s). Format `turn:turn.cdcts.com:8000?transport=tcp`. An array of strings is also accepted.
  * @param {String} config.turnServers.username Username to authenticate on TURN server(s)
  * @param {String} config.turnServers.password Password to authenticate on TURN server(s)
  * @param {String} config.registrarServer URI for the registrar Server. Format `sip:123.0.0.0:5066`
  * @param {Boolean} config.traceSip If true, SIP traces will be logged to the dev console.
  * @param {String} config.logLevel One of "debug", "log", "warn", "error", "off".  default is "log"
   */
  function CdctsDevice(config) {
    var _this;

    _classCallCheck(this, CdctsDevice);

    _this = _super.call(this);

    if (!config || _typeof(config) !== 'object') {
      throw new TypeError("CdctsDevice: Missing config");
    }

    if (!config.host) {
      throw new TypeError("CdctsDevice: Missing 'host' parameter");
    }

    if (!config.port) {
      throw new TypeError("CdctsDevice: Missing 'port' parameter");
    }

    _this.config = config;
    _this.host = config.host;
    _this.port = config.port;
    _this.uri = "sip:".concat(config.username, "@").concat(config.host);
    _this.path = config.path || '';
    _this.wsServers = arrayify(config.wsServers);
    _this.username = config.username;
    _this.password = config.password;
    _this.displayName = config.displayName || config.username;
    _this.stunServers = arrayify(config.stunServers);
    _this.turnServers = config.turnServers;
    _this.registrarServer = config.registrarServer;
    _this._userAgent = null;

    _this._ensureConnectivityWithSipServer(); // let uri = new SIP.URI("sip", this.username, this.host, this.port).toString();


    var sipUAConfig = {
      uri: "sip:".concat(_this.username, "@").concat(_this.host),
      transportOptions: {
        wsServers: ["wss://".concat(_this.host, ":").concat(_this.port).concat(_this.path)]
      },
      authorizationUsersip: _this.username,
      password: _this.password,
      displayName: _this.displayName,
      // stunServers: this.stunServers,
      // turnServers: this.turnServers,
      // registrarServer: this.registrarServer
      sessionDescriptionHandlerOptions: {
        constraints: {
          audio: true,
          video: false
        }
      }
    };

    if (config.traceSip) {
      sipUAConfig.traceSip = true;
    }

    if (config.logLevel) {
      if (config.logLevel === "off") {
        sipUAConfig.log = {
          builtinEnabled: false
        };
      } else {
        sipUAConfig.log = {
          level: config.logLevel
        };
      }
    }

    _this._userAgent = new sip_js__WEBPACK_IMPORTED_MODULE_0__["UA"](sipUAConfig);
    /**
    * wsConnecting event
    *
    * Fired when the device attempts to connect to the WebSocket server.
    * If the connection drops, the device will try to reconnect and this event will fire again.
    *
    * @event CdctsDevice#wsConnecting
    * @type {object}
    * @property {number} attempts - the number of connection attempts that have been made
    */

    _this._userAgent.on("connecting", function (args) {
      _this.trigger("wsConnecting", {
        attempts: args.attempts
      });
    });
    /**
    * wsConnected event
    *
    * Fired when the WebSocket connection has been established.
    *
    * @event CdctsDevice#wsConnected
    */


    _this._userAgent.on("connected", function () {
      _this.trigger("wsConnected");
    });
    /**
    * wsDisconnected event
    *
    * Fried when the WebSocket connection attempt fails.
    *
    * @event CdctsDevice#wsDisconnected
    */


    _this._userAgent.on("disconnected", function () {
      _this.trigger("wsDisconnected");
    });
    /**
    * registered event
    *
    * Fired when a the device has been successfully registered to recieve calls.
    *
    * @event CdctsDevice#registered
    */


    _this._userAgent.on("registered", function () {
      _this.trigger("registered");
    });
    /**
    * unregistered event
    *
    * Fired as the result of a call to `unregister()` or if a periodic re-registration fails.
    *
    * @event CdctsDevice#unregistered
    * @type {object}
    * @property {object} cause - null if `unregister()` was called, otherwise see [SIPjs causes]{@link http://sipjs.com/api/0.15.0/causes/}
    * @property {object} response - The SIP message which caused the failure, if it exists.
    */


    _this._userAgent.on("unregistered", function (response, cause) {
      _this.trigger("unregistered", {
        cause: cause,
        response: response
      });
    });
    /**
    * registrationFailed event
    *
    * Fired when a registration attepmt fails.
    *
    * @event CdctsDevice#registrationFailed
    * @type {object}
    * @property {object} cause - see [SIPjs causes]{@link http://sipjs.com/api/0.15.0/causes/}
    * @property {object} response - The SIP message which caused the failure, if it exists.
    */


    _this._userAgent.on("registrationFailed", function (cause, response) {
      _this.trigger("registrationFailed", {
        cause: cause,
        response: response
      });
    });
    /**
    * incomingInvite event
    *
    * Fired when the device recieves an INVITE request
    * @event CdctsDevice#invite
    * @type {Session}
    */


    _this._userAgent.on("invite", function (session) {
      _this._activeCall = new _cdcts_call__WEBPACK_IMPORTED_MODULE_2__["CdctsCall"](_this._userAgent);

      _this._activeCall.incomingCall(session);

      _this.trigger("invite", {
        id: session.id,
        phoneNumber: session.remoteIdentity._displayName,
        status: session.status,
        type: 'incoming'
      });
    });
    /**
    * message event
    *
    * @event CdctsDevice#message
    * @type {object}
    * @property {object} message - Contains the SIP message sent and server context necessary to receive and send replies.
    */


    _this._userAgent.on("message", function (message) {
      _this.trigger("message", {
        message: message
      });
    });

    return _this;
  }
  /**
  * Start the connection to the WebSocket server, and restore the previous state if stopped.
  * You need to start the WebSocket connection before you can send or recieve calls. If you
  * try to `initiateCall` without first starting the connection, it will be started for you,
  * but it will not be stopped when the call is terminated.
  */


  _createClass(CdctsDevice, [{
    key: "startWS",
    value: function startWS() {
      this._userAgent.start();
    }
    /**
    * Stop the connection to the WebSocket server, saving the state so it can be restored later
    * (by `start`).
    */

  }, {
    key: "stopWS",
    value: function stopWS() {
      this._userAgent.stop();
    }
    /**
    * Status of the WebSocket connection
    *
    * @return {Boolean} isConnected `true` if the device is connected to the WebSocket server, `false` otherwise
    */

  }, {
    key: "isWSConnected",
    value: function isWSConnected() {
      return this._userAgent.isConnected();
    }
    /**
    * Register the device with the SIP server so that it can receive incoming calls.
    *
    * @param {Object} options
    * @param {String[]} options.extraHeaders SIP headers that will be added to each REGISTER request. Each header is string in the format `"X-Header-Name: Header-value"`.
    * @emits CdctsDevice#registered
    */

  }, {
    key: "register",
    value: function register(options) {
      this._userAgent.register(options);
    }
    /**
    * Unregister the device from the SIP server; it will no longer recieve incoming calls.
    *
    * @param {Object} options
    * @param {Boolean} options.all [Optional] - if set & `true` it will unregister *all* bindings for the SIP user.
    * @param {String[]} options.extraHeaders SIP headers that will be added to each REGISTER request. Each header is string in the format `"X-Header-Name: Header-value"`.
    * @emits CdctsDevice#unregistered
    */

  }, {
    key: "unregister",
    value: function unregister(options) {
      this._userAgent.register(options);
    }
    /**
    * Status of SIP registration
    *
    * @return {Boolean} isRegistered `true` if the device is registered with the SIP Server, `false` otherwise
    */

  }, {
    key: "isRegistered",
    value: function isRegistered() {
      return this._userAgent.isRegistered();
    }
    /**
    * Make a phone call
    *
    * @param {String} phoneNumber The desination phone number to connect to. Just digits, no punctuation. Example `"12065551111"`.
    * @return {CdctsCall} activeCall Keep an eye on the call's state by listening to events emitted by activeCall
    */

  }, {
    key: "initiateCall",
    value: function initiateCall(phoneNumber) {
      var _this2 = this;

      // let uri = new SIP.URI("sip", phoneNumber, this.host, this.port).toString();
      this._activeCall = new _cdcts_call__WEBPACK_IMPORTED_MODULE_2__["CdctsCall"](this._userAgent);

      this._activeCall.makeCall(phoneNumber);

      this._activeCall._session.on("cancel", function (data) {
        _this2.trigger("cancel", data);
      });

      this._activeCall._session.on("bye", function (data) {
        _this2.trigger("bye", data);
      });

      this._activeCall._session.on("replaced", function (data) {
        _this2.trigger("replaced", data);
      });

      this._activeCall._session.on("failed", function (response, cause) {
        _this2.trigger("failed", response, cause);
      });

      this._activeCall._session.on("rejected", function (response, cause) {
        _this2.trigger("rejected", response, cause);
      });

      return this._activeCall;
    }
    /**
    * Answer phone call
    *
    * @return {CdctsCall} activeCall Keep an eye on the call's state by listening to events emitted by activeCall
    */

  }, {
    key: "accept",
    value: function accept() {
      var _this3 = this;

      this._activeCall._session.accept();

      this._activeCall._session.on('trackAdded', function () {
        var pc = this.sessionDescriptionHandler.peerConnection; // var this.audioElement = this.audioElement;

        var player = document.getElementsByClassName("cdcts-sipjs-remote-audio")[0]; // this.audioElement.className = 'cdcts-sipjs-remote-audio';

        var remoteStream = new MediaStream();
        pc.getReceivers().forEach(function (receiver) {
          remoteStream.addTrack(receiver.track);
        });

        if (typeof player.srcObject !== 'undefined') {
          player.srcObject = remoteStream;
        } else if (typeof player.mozSrcObject !== 'undefined') {
          player.mozSrcObject = remoteStream;
        } else if (typeof player.src !== 'undefined') {
          player.src = URL.createObjectURL(remoteStream);
        } else {
          console.log('Error attaching stream to element.');
        }

        player.play();
        return this._activeCall;
      });

      this._activeCall._session.on("cancel", function (data) {
        _this3.trigger("cancel", data);
      });

      this._activeCall._session.on("bye", function (data) {
        _this3.trigger("bye", data);
      });

      this._activeCall._session.on("replaced", function (data) {
        _this3.trigger("replaced", data);
      });

      this._activeCall._session.on("failed", function (response, cause) {
        _this3.trigger("failed", response, cause);
      });

      this._activeCall._session.on("rejected", function (response, cause) {
        _this3.trigger("rejected", response, cause);
      });

      this.trigger("accepted", {
        id: this._activeCall._session.id,
        phoneNumber: this._activeCall._session.remoteIdentity.displayName,
        startTime: this._activeCall._session.startTime ? this._activeCall._session.startTime : new Date(),
        status: this._activeCall._session.status
      });
    }
    /**
    * Get a reference to the call currently in progress
    *
    * @return {CdctsCall} activeCall Keep an eye on the call's state by listening to events emitted by activeCall
    */

  }, {
    key: "activeCall",
    value: function activeCall() {
      return this._activeCall;
    }
    /**
     * Refer
     * @param {String} phoneNumber The phonenumber can to refer
     */

  }, {
    key: "referNumber",
    value: function referNumber(phoneNumber) {
      this._refer = new sip_js__WEBPACK_IMPORTED_MODULE_0__["ReferClientContext"](this._userAgent, this._activeCall._session, phoneNumber);

      this._refer.refer();

      return this._refer;
    }
    /**
     * isMuted
     * @param {Boolean} isMuted The isMuted can to refer
     */

  }, {
    key: "mute",
    value: function mute(isMute) {
      var pc = this._activeCall._session.sessionDescriptionHandler.peerConnection;
      var audioTracks = pc.getLocalStreams()[0].getAudioTracks(); // if MediaStream has reference to microphone

      if (audioTracks[0]) {
        audioTracks[0].enabled = !isMute;
      }

      return pc;
    }
    /**
     * isHold
     * @param {Boolean} isHold The isMuted can to refer
     */

  }, {
    key: "hold",
    value: function hold(isHold) {
      if (isHold) {
        this._activeCall._session.hold();

        return this._activeCall._session;
      } else {
        this._activeCall._session.unhold();

        return this._activeCall._session;
      }
    }
    /**
    * End the session
    *
    * @emits TelnyxCall#terminated
    */

  }, {
    key: "reject",
    value: function reject() {
      this._activeCall._session.terminate();
    } // Ensure that we can connect to the SIP server.
    // Due to a bug in chrome, we need to open an http connection to the SIP server
    // before trying to connect via Web Socket.
    //
    //  https://bugs.chromium.org/p/chromium/issues/detail?id=329884

  }, {
    key: "_ensureConnectivityWithSipServer",
    value: function _ensureConnectivityWithSipServer() {
      try {
        var xhr = new XMLHttpRequest();
        xhr.addEventListener("error", function () {
          console.info("Failed http connection to SIP server is expected. It is related to a chrome bug.");
        });
        xhr.open("GET", "https://".concat(this.host, ":").concat(this.port), true);
        xhr.send();
      } catch (e) {// do nothing. If an error occurs, it's not going to matter here.
      }
    }
  }]);

  return CdctsDevice;
}(es6_event_emitter__WEBPACK_IMPORTED_MODULE_1___default.a);

function arrayify(item) {
  if (Array.isArray(item)) {
    return item.slice(0); // Shallow Copy
  } else {
    var arr = [];
    arr.push(item);
    return arr;
  }
}



/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstbWFwLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3dlYWstbWFwLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL2VzNi1ldmVudC1lbWl0dGVyL2Rpc3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvQ2xpZW50Q29udGV4dC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL0VudW1zLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvRXhjZXB0aW9ucy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1B1Ymxpc2hDb250ZXh0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvUmVmZXJDb250ZXh0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvUmVnaXN0ZXJDb250ZXh0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvU2VydmVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9TZXNzaW9uL0RUTUYuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9TZXNzaW9uL0RUTUZWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9UcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9VQS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1V0aWxzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvV2ViL01vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1dlYi9TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvV2ViL1Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1dlYi9TaW1wbGUuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9XZWIvVHJhbnNwb3J0LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvV2ViL2luZGV4LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvYXBpL2J5ZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9lbWl0dGVyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvYXBpL2V4Y2VwdGlvbnMvY29udGVudC10eXBlLXVuc3VwcG9ydGVkLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvYXBpL2V4Y2VwdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9yZXF1ZXN0LXBlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9zZXNzaW9uLWRlc2NyaXB0aW9uLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9zZXNzaW9uLXRlcm1pbmF0ZWQuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9zdGF0ZS10cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvYXBpL2luZm8uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9ub3RpZmljYXRpb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvcmVmZXJyYWwuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvc2Vzc2lvbi1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9zZXNzaW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9kaWFsb2dzL2RpYWxvZy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZGlhbG9ncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZGlhbG9ncy9zZXNzaW9uLWRpYWxvZy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZGlhbG9ncy9zdWJzY3JpcHRpb24tZGlhbG9nLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9leGNlcHRpb25zL2V4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZXhjZXB0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZXhjZXB0aW9ucy90cmFuc2FjdGlvbi1zdGF0ZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZXhjZXB0aW9ucy90cmFuc3BvcnQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9sb2cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2xvZy9sZXZlbHMuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2xvZy9sb2dnZXItZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbG9nL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvYm9keS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvZGlnZXN0LWF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9ncmFtbWFyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9pbmNvbWluZy1tZXNzYWdlLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL21lc3NhZ2VzL2luY29taW5nLXJlc3BvbnNlLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL21lc3NhZ2VzL2luZGV4LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9tZXRob2RzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvbWV0aG9kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvbmFtZS1hZGRyLWhlYWRlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvb3V0Z29pbmctcmVxdWVzdC1tZXNzYWdlLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9vdXRnb2luZy1yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvcGFyYW1ldGVycy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvcGFyc2VyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy91cmkuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL21lc3NhZ2VzL3V0aWxzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9zZXNzaW9uL2luZGV4LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9zZXNzaW9uL3Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3N1YnNjcmlwdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdGltZXJzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS90cmFuc2FjdGlvbnMvY2xpZW50LXRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS90cmFuc2FjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy9pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS90cmFuc2FjdGlvbnMvaW52aXRlLXNlcnZlci10cmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdHJhbnNhY3Rpb25zL25vbi1pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS90cmFuc2FjdGlvbnMvbm9uLWludml0ZS1zZXJ2ZXItdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy9zZXJ2ZXItdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbi1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdHJhbnNhY3Rpb25zL3RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50LWNvcmUvYWxsb3dlZC1tZXRob2RzLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50LWNvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnQtY29yZS91c2VyLWFnZW50LWNvcmUuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL2J5ZS11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvYnllLXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9jYW5jZWwtdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL2luZGV4LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9pbnZpdGUtdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL2ludml0ZS11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvbWVzc2FnZS11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvbWVzc2FnZS11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvbm90aWZ5LXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9ub3RpZnktdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3ByYWNrLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9wcmFjay11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvcHVibGlzaC11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvcmUtaW52aXRlLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZS1pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3JlLXN1YnNjcmliZS11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvcmUtc3Vic2NyaWJlLXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZWZlci11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvcmVmZXItdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3JlZ2lzdGVyLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZWdpc3Rlci11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvc3Vic2NyaWJlLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9zdWJzY3JpYmUtdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3VzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy91c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2dyYW1tYXIvZGlzdC9ncmFtbWFyLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2RjdHMtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi92ZXJzaW9uLmpzIiwid2VicGFjazovL2NkY3RzLXNpcGpzLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL3NyYy9jZGN0cy1zaXBqcy5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL3NyYy9saWIvY2RjdHMtY2FsbC5qcyIsIndlYnBhY2s6Ly9jZGN0cy1zaXBqcy8uL3NyYy9saWIvY2RjdHMtZGV2aWNlLmpzIl0sIm5hbWVzIjpbIkNkY3RzQ2FsbCIsIlVBIiwiX211dGUiLCJfc3RhdHVzIiwiX2NhbGxUeXBlIiwiX2RvY0JvZHkiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXVkaW9FbGVtZW50Iiwic3RhcnQiLCJpbnZpdGVVcmkiLCJfc2Vzc2lvbiIsImludml0ZSIsIl9nZXRBdWRpb0VsZW1lbnQiLCJfYXR0YXRjaFNlc3Npb25FdmVudHMiLCJzZXNzaW9uIiwiY29uc29sZSIsImxvZyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJhcHBlbmRDaGlsZCIsIm9uIiwidHJpZ2dlciIsInJlc3BvbnNlIiwic3RhdHVzQ29kZSIsImJvZHkiLCJoYXNPZmZlciIsImRpYWxvZyIsImhhc0hlYWRlciIsImdldEhlYWRlciIsImluZGV4T2YiLCJzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIiwiaGFzRGVzY3JpcHRpb24iLCJzdGF0dXMiLCJTSVAiLCJTZXNzaW9uIiwiQyIsIlNUQVRVU19FQVJMWV9NRURJQSIsImRhdGEiLCJyZXF1ZXN0IiwiZHRtZiIsImNhbGxiYWNrIiwibmV3U2Vzc2lvbiIsImNhdXNlIiwibWVzc2FnZSIsInBjIiwicGVlckNvbm5lY3Rpb24iLCJyZW1vdGVTdHJlYW0iLCJNZWRpYVN0cmVhbSIsImdldFJlY2VpdmVycyIsImZvckVhY2giLCJyZWNlaXZlciIsImFkZFRyYWNrIiwidHJhY2siLCJwYXNzZWRPcHRpb25zIiwic3JjT2JqZWN0IiwibW96U3JjT2JqZWN0Iiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicGxheSIsImVycm9yIiwiYWNjZXB0IiwibWVkaWEiLCJjb25zdHJhaW50cyIsImF1ZGlvIiwidmlkZW8iLCJyZW5kZXIiLCJyZW1vdGUiLCJzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyIsInJlamVjdCIsInRyYW5zYWN0aW9uIiwidGVybWluYXRlIiwic3RvcCIsImlzTXV0ZSIsIm11dGUiLCJ1bm11dGUiLCJpc0hvbGQiLCJob2xkIiwidW5ob2xkIiwiZGlnaXRzIiwicmVmZXIiLCJpIiwiY2xlYXJUaW1lciIsInNldFRpbWVvdXQiLCJjaGVjayIsImhhc0Fuc3dlciIsImNsZWFyVGltZW91dCIsInNldERlc2NyaXB0aW9uIiwibG9nZ2VyIiwid2FybiIsImZhaWxlZCIsImNhdXNlcyIsIkJBRF9NRURJQV9ERVNDUklQVElPTiIsInJlYXNvbl9waHJhc2UiLCJFdmVudEVtaXR0ZXIiLCJDZGN0c0RldmljZSIsImNvbmZpZyIsIlR5cGVFcnJvciIsImhvc3QiLCJwb3J0IiwidXJpIiwidXNlcm5hbWUiLCJwYXRoIiwid3NTZXJ2ZXJzIiwiYXJyYXlpZnkiLCJwYXNzd29yZCIsImRpc3BsYXlOYW1lIiwic3R1blNlcnZlcnMiLCJ0dXJuU2VydmVycyIsInJlZ2lzdHJhclNlcnZlciIsIl91c2VyQWdlbnQiLCJfZW5zdXJlQ29ubmVjdGl2aXR5V2l0aFNpcFNlcnZlciIsInNpcFVBQ29uZmlnIiwidHJhbnNwb3J0T3B0aW9ucyIsImF1dGhvcml6YXRpb25Vc2Vyc2lwIiwidHJhY2VTaXAiLCJsb2dMZXZlbCIsImJ1aWx0aW5FbmFibGVkIiwibGV2ZWwiLCJhcmdzIiwiYXR0ZW1wdHMiLCJfYWN0aXZlQ2FsbCIsImluY29taW5nQ2FsbCIsImlkIiwicGhvbmVOdW1iZXIiLCJyZW1vdGVJZGVudGl0eSIsIl9kaXNwbGF5TmFtZSIsInR5cGUiLCJpc0Nvbm5lY3RlZCIsIm9wdGlvbnMiLCJyZWdpc3RlciIsImlzUmVnaXN0ZXJlZCIsIm1ha2VDYWxsIiwicGxheWVyIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJfcmVmZXIiLCJSZWZlckNsaWVudENvbnRleHQiLCJhdWRpb1RyYWNrcyIsImdldExvY2FsU3RyZWFtcyIsImdldEF1ZGlvVHJhY2tzIiwiZW5hYmxlZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImluZm8iLCJvcGVuIiwic2VuZCIsImUiLCJpdGVtIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJhcnIiLCJwdXNoIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVB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QUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hELENBQUMsa0NBQWtDOzs7Ozs7Ozs7Ozs7O0FDL0x0QjtBQUNiO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUVBQW1FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzRUFBc0U7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQseUJBQXlCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdUNBQXVDLEVBQUU7QUFDMUYsbURBQW1ELHlDQUF5QyxFQUFFO0FBQzlGLG1EQUFtRCx5Q0FBeUMsRUFBRTtBQUM5RixpREFBaUQsdUNBQXVDLEVBQUU7QUFDMUYsaURBQWlELHVDQUF1QztBQUN4RixT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Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDBCQUEwQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2Q0FBNkM7QUFDbEQsQ0FBQyxxQ0FBcUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNkNBQTZDLEVBQUU7QUFDOUg7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2psQ2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQywyREFBYTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBeUI7QUFDakQsWUFBWSxtQkFBTyxDQUFDLDJFQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDOzs7Ozs7Ozs7Ozs7O0FDN09sQztBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQzFtQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLG9EQUFVO0FBQ2hDO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUM3QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsZ0RBQU87QUFDN0IsZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyw4Q0FBTztBQUMxQixxQ0FBcUMsbUJBQU8sQ0FBQywrREFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUVBQW1FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0FBQywyREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQ2ZhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDL0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDL0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDL0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLHdEQUFTO0FBQzlCO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNU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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrREFBa0QsRUFBRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFxRCxFQUFFO0FBQzFGLHFEQUFxRCxr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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4Q0FBOEM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0IsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUM1RCxjQUFjLG1CQUFPLENBQUMsaUVBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoSWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QixFQUFFO0FBQ3BFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDbmVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLGdEQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQywyREFBVztBQUNsQywyQkFBMkIsbUJBQU8sQ0FBQywrRkFBc0I7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsNkZBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsRUFBRTtBQUMzRTtBQUNBLHdEQUF3RCw2QkFBNkIsRUFBRTtBQUN2RjtBQUNBLHNEQUFzRCxzQkFBc0IsRUFBRTtBQUM5RTtBQUNBLHNEQUFzRCxzQkFBc0IsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYSw2Q0FBNkM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0IsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUM3eUJhO0FBQ2IsOENBQThDLGNBQWM7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDhCQUE4QixFQUFFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7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a0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQStDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQ3hTYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxnREFBTztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsNEZBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQ2xCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLDZFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxr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QUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOEJBQThCLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9DQUFvQyxFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7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QUE4QixZQUFNO0FBQ2xDbEksaUJBQU8sQ0FBQ21JLElBQVIsQ0FBYSxrRkFBYjtBQUNELFNBRkQ7QUFHQUgsV0FBRyxDQUFDSSxJQUFKLENBQVMsS0FBVCxvQkFBMkIsS0FBS2pELElBQWhDLGNBQXdDLEtBQUtDLElBQTdDLEdBQXFELElBQXJEO0FBQ0E0QyxXQUFHLENBQUNLLElBQUo7QUFDRCxPQVBELENBT0UsT0FBT0MsQ0FBUCxFQUFVLENBQ1Y7QUFDRDtBQUNGOzs7O0VBeld1QnZELHdEOztBQTRXMUIsU0FBU1UsUUFBVCxDQUFrQjhDLElBQWxCLEVBQXdCO0FBQ3RCLE1BQUlDLEtBQUssQ0FBQ0MsT0FBTixDQUFjRixJQUFkLENBQUosRUFBeUI7QUFDdkIsV0FBT0EsSUFBSSxDQUFDRyxLQUFMLENBQVcsQ0FBWCxDQUFQLENBRHVCLENBQ0Q7QUFDdkIsR0FGRCxNQUVPO0FBQ0wsUUFBSUMsR0FBRyxHQUFHLEVBQVY7QUFDQUEsT0FBRyxDQUFDQyxJQUFKLENBQVNMLElBQVQ7QUFDQSxXQUFPSSxHQUFQO0FBQ0Q7QUFDRiIsImZpbGUiOiJjZGN0cy1zaXBqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiY2RjdHMtc2lwanNcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY2RjdHMtc2lwanNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiY2RjdHMtc2lwanNcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2NkY3RzLXNpcGpzLmpzXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5XZWFrTWFwO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICBpZiAoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2UoKTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgZWFjaCgnYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OJy5zcGxpdCgnLCcpLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYgKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKSBoaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgS0VZKTtcbiAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSkgcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY1tLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBJU19XRUFLIHx8IGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEyJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGlzRW51bS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIElTX0lFMTEgPSAhZ2xvYmFsLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbDtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKE5BVElWRV9XRUFLX01BUCAmJiBJU19JRTExKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha01hcCcpO1xuIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cbiIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsIG9mIE9iamVjdC5jcmVhdGVcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge307XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAobV93KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuXHQgICAgICAgICAgICAgICAgdmFyIG1feiA9IDB4M2FkZTY4YjE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgLz0gMHgxMDAwMDAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IDAuNTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xuXG5cdCAgICAgICAgICAgICAgICByY2FjaGUgPSBfcigpICogMHgzYWRlNjdiNztcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfd2Vha01hcCA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy93ZWFrLW1hcCcpO1xuXG52YXIgX3dlYWtNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2Vha01hcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBlbWl0dGVyID0gbmV3IF93ZWFrTWFwMi5kZWZhdWx0KCk7XG5cbnZhciBFbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBFbWl0dGVyKCkge1xuXHRcdCgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEVtaXR0ZXIpO1xuXG5cdFx0ZW1pdHRlci5zZXQodGhpcywge1xuXHRcdFx0ZXZlbnRzOiB7fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5ldmVudExlbmd0aCA9IDA7XG5cdH1cblxuXHQoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShFbWl0dGVyLCBbe1xuXHRcdGtleTogJ29uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGNiKSB7XG5cdFx0XHR2YXIgb25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cblx0XHRcdGlmICh0eXBlb2YgY2IgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIGNhbGxiYWNrIG1ldGhvZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdMaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuXHRcdFx0dGhpcy5ldmVudHNbZXZlbnRdLnB1c2goe1xuXHRcdFx0XHRjYjogY2IsXG5cdFx0XHRcdG9uY2U6IG9uY2Vcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmV2ZW50TGVuZ3RoKys7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ29mZicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgY2IpIHtcblx0XHRcdGlmICh0eXBlb2YgY2IgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIGNhbGxiYWNrIG1ldGhvZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdMaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLmV2ZW50c1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXZlbnQgbm90IGZvdW5kIC0gdGhlIGV2ZW50IHlvdSBwcm92aWRlZCBpczogJyArIGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcblxuXHRcdFx0bGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcblx0XHRcdFx0aWYgKHYuY2IgPT09IGNiKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG5cblx0XHRcdFx0dGhpcy5ldmVudExlbmd0aC0tO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICd0cmlnZ2VyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdHJpZ2dlcihldmVudCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0XHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIGV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gZXZlbnQgdG8gdHJpZ2dlci4nKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcblx0XHRcdHZhciBvbmNlTGlzdGVuZXJzID0gW107XG5cblx0XHRcdGlmICh0eXBlb2YgbGlzdGVuZXJzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuXHRcdFx0XHRcdHYuY2IuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuXG5cdFx0XHRcdFx0aWYgKHYub25jZSkgb25jZUxpc3RlbmVycy51bnNoaWZ0KGspO1xuXG5cdFx0XHRcdFx0b25jZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGssIDEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnb25jZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGNiKSB7XG5cdFx0XHR0aGlzLm9uKGV2ZW50LCBjYiwgdHJ1ZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZGVzdHJveScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0XHRlbWl0dGVyLmRlbGV0ZSh0aGlzKTtcblxuXHRcdFx0dGhpcy5ldmVudExlbmd0aCA9IDA7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZXZlbnRzJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiBlbWl0dGVyLmdldCh0aGlzKS5ldmVudHM7XG5cdFx0fVxuXHR9XSk7XG5cdHJldHVybiBFbWl0dGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG52YXIgQ2xpZW50Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDbGllbnRDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsaWVudENvbnRleHQodWEsIG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgQ2xpZW50Q29udGV4dC5pbml0aWFsaXplcihfdGhpcywgdWEsIG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDbGllbnRDb250ZXh0LmluaXRpYWxpemVyID0gZnVuY3Rpb24gKG9ialRvQ29uc3RydWN0LCB1YSwgbWV0aG9kLCBvcmlnaW5hbFRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICBvYmpUb0NvbnN0cnVjdC50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5DbGllbnRDb250ZXh0O1xuICAgICAgICAvLyBWYWxpZGF0ZSBhcmd1bWVudHNcbiAgICAgICAgaWYgKG9yaWdpbmFsVGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBvYmpUb0NvbnN0cnVjdC51YSA9IHVhO1xuICAgICAgICBvYmpUb0NvbnN0cnVjdC5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoXCJzaXAuY2xpZW50Y29udGV4dFwiKTtcbiAgICAgICAgb2JqVG9Db25zdHJ1Y3QubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdWEubm9ybWFsaXplVGFyZ2V0KG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhcmdldDogXCIgKyBvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21VUkkgPSB1YS51c2VyQWdlbnRDb3JlLmNvbmZpZ3VyYXRpb24uYW9yO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmFtcyAmJiBvcHRpb25zLnBhcmFtcy5mcm9tVXJpKSB7XG4gICAgICAgICAgICBmcm9tVVJJID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMucGFyYW1zLmZyb21VcmkgPT09IFwic3RyaW5nXCIpID9cbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLkdyYW1tYXIuVVJJUGFyc2Uob3B0aW9ucy5wYXJhbXMuZnJvbVVyaSkgOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5mcm9tVXJpO1xuICAgICAgICAgICAgaWYgKCFmcm9tVVJJKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZnJvbSBVUkk6IFwiICsgb3B0aW9ucy5wYXJhbXMuZnJvbVVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvVVJJID0gdGFyZ2V0O1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmFtcyAmJiBvcHRpb25zLnBhcmFtcy50b1VyaSkge1xuICAgICAgICAgICAgdG9VUkkgPVxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5wYXJhbXMudG9VcmkgPT09IFwic3RyaW5nXCIpID9cbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLkdyYW1tYXIuVVJJUGFyc2Uob3B0aW9ucy5wYXJhbXMudG9VcmkpIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMudG9Vcmk7XG4gICAgICAgICAgICBpZiAoIXRvVVJJKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdG8gVVJJOiBcIiArIG9wdGlvbnMucGFyYW1zLnRvVXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBPcHRpb25zXG4gICAgICAgICogLSBleHRyYUhlYWRlcnNcbiAgICAgICAgKiAtIHBhcmFtc1xuICAgICAgICAqIC0gY29udGVudFR5cGVcbiAgICAgICAgKiAtIGJvZHlcbiAgICAgICAgKi9cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIGJvZHlPYmo7XG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIGJvZHlPYmogPSB7XG4gICAgICAgICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zLmNvbnRlbnRUeXBlID8gb3B0aW9ucy5jb250ZW50VHlwZSA6IFwiYXBwbGljYXRpb24vc2RwXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvYmpUb0NvbnN0cnVjdC5ib2R5ID0gYm9keU9iajtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgaWYgKGJvZHlPYmopIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlsc18xLlV0aWxzLmZyb21Cb2R5T2JqKGJvZHlPYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSByZXF1ZXN0XG4gICAgICAgIG9ialRvQ29uc3RydWN0LnJlcXVlc3QgPSB1YS51c2VyQWdlbnRDb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1ldGhvZCwgdGFyZ2V0LCBmcm9tVVJJLCB0b1VSSSwgcGFyYW1zLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAvKiBTZXQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSByZXF1ZXN0ICovXG4gICAgICAgIGlmIChvYmpUb0NvbnN0cnVjdC5yZXF1ZXN0LmZyb20pIHtcbiAgICAgICAgICAgIG9ialRvQ29uc3RydWN0LmxvY2FsSWRlbnRpdHkgPSBvYmpUb0NvbnN0cnVjdC5yZXF1ZXN0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ialRvQ29uc3RydWN0LnJlcXVlc3QudG8pIHtcbiAgICAgICAgICAgIG9ialRvQ29uc3RydWN0LnJlbW90ZUlkZW50aXR5ID0gb2JqVG9Db25zdHJ1Y3QucmVxdWVzdC50bztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51YS51c2VyQWdlbnRDb3JlLnJlcXVlc3QodGhpcy5yZXF1ZXN0LCB7XG4gICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25Ucnlpbmc6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENsaWVudENvbnRleHQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGUgfHwgMDtcbiAgICAgICAgdmFyIGNhdXNlID0gVXRpbHNfMS5VdGlscy5nZXRSZWFzb25QaHJhc2Uoc3RhdHVzQ29kZSk7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51YS5hcHBsaWNhbnRzW3RoaXMudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudWEuYXBwbGljYW50c1t0aGlzLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJhY2NlcHRlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51YS5hcHBsaWNhbnRzW3RoaXMudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudWEuYXBwbGljYW50c1t0aGlzLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWplY3RlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRDb250ZXh0LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgdW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH07XG4gICAgQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50Q29udGV4dDtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLkNsaWVudENvbnRleHQgPSBDbGllbnRDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbnZhciBDO1xuKGZ1bmN0aW9uIChDKSB7XG4gICAgQy52ZXJzaW9uID0gdmVyc2lvbl8xLkxJQlJBUllfVkVSU0lPTjtcbiAgICBDLlVTRVJfQUdFTlQgPSBcIlNJUC5qcy9cIiArIHZlcnNpb25fMS5MSUJSQVJZX1ZFUlNJT047XG4gICAgLy8gU0lQIHNjaGVtZVxuICAgIEMuU0lQID0gXCJzaXBcIjtcbiAgICBDLlNJUFMgPSBcInNpcHNcIjtcbiAgICAvLyBFbmQgYW5kIEZhaWx1cmUgY2F1c2VzXG4gICAgdmFyIGNhdXNlcztcbiAgICAoZnVuY3Rpb24gKGNhdXNlcykge1xuICAgICAgICAvLyBHZW5lcmljIGVycm9yIGNhdXNlc1xuICAgICAgICBjYXVzZXNbXCJDT05ORUNUSU9OX0VSUk9SXCJdID0gXCJDb25uZWN0aW9uIEVycm9yXCI7XG4gICAgICAgIGNhdXNlc1tcIklOVEVSTkFMX0VSUk9SXCJdID0gXCJJbnRlcm5hbCBFcnJvclwiO1xuICAgICAgICBjYXVzZXNbXCJSRVFVRVNUX1RJTUVPVVRcIl0gPSBcIlJlcXVlc3QgVGltZW91dFwiO1xuICAgICAgICBjYXVzZXNbXCJTSVBfRkFJTFVSRV9DT0RFXCJdID0gXCJTSVAgRmFpbHVyZSBDb2RlXCI7XG4gICAgICAgIC8vIFNJUCBlcnJvciBjYXVzZXNcbiAgICAgICAgY2F1c2VzW1wiQUREUkVTU19JTkNPTVBMRVRFXCJdID0gXCJBZGRyZXNzIEluY29tcGxldGVcIjtcbiAgICAgICAgY2F1c2VzW1wiQVVUSEVOVElDQVRJT05fRVJST1JcIl0gPSBcIkF1dGhlbnRpY2F0aW9uIEVycm9yXCI7XG4gICAgICAgIGNhdXNlc1tcIkJVU1lcIl0gPSBcIkJ1c3lcIjtcbiAgICAgICAgY2F1c2VzW1wiRElBTE9HX0VSUk9SXCJdID0gXCJEaWFsb2cgRXJyb3JcIjtcbiAgICAgICAgY2F1c2VzW1wiSU5DT01QQVRJQkxFX1NEUFwiXSA9IFwiSW5jb21wYXRpYmxlIFNEUFwiO1xuICAgICAgICBjYXVzZXNbXCJOT1RfRk9VTkRcIl0gPSBcIk5vdCBGb3VuZFwiO1xuICAgICAgICBjYXVzZXNbXCJSRURJUkVDVEVEXCJdID0gXCJSZWRpcmVjdGVkXCI7XG4gICAgICAgIGNhdXNlc1tcIlJFSkVDVEVEXCJdID0gXCJSZWplY3RlZFwiO1xuICAgICAgICBjYXVzZXNbXCJVTkFWQUlMQUJMRVwiXSA9IFwiVW5hdmFpbGFibGVcIjtcbiAgICAgICAgLy8gU2Vzc2lvbiBlcnJvciBjYXVzZXNcbiAgICAgICAgY2F1c2VzW1wiQkFEX01FRElBX0RFU0NSSVBUSU9OXCJdID0gXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIjtcbiAgICAgICAgY2F1c2VzW1wiQ0FOQ0VMRURcIl0gPSBcIkNhbmNlbGVkXCI7XG4gICAgICAgIGNhdXNlc1tcIkVYUElSRVNcIl0gPSBcIkV4cGlyZXNcIjtcbiAgICAgICAgY2F1c2VzW1wiTk9fQUNLXCJdID0gXCJObyBBQ0tcIjtcbiAgICAgICAgY2F1c2VzW1wiTk9fQU5TV0VSXCJdID0gXCJObyBBbnN3ZXJcIjtcbiAgICAgICAgY2F1c2VzW1wiTk9fUFJBQ0tcIl0gPSBcIk5vIFBSQUNLXCI7XG4gICAgICAgIGNhdXNlc1tcIlJUUF9USU1FT1VUXCJdID0gXCJSVFAgVGltZW91dFwiO1xuICAgICAgICBjYXVzZXNbXCJVU0VSX0RFTklFRF9NRURJQV9BQ0NFU1NcIl0gPSBcIlVzZXIgRGVuaWVkIE1lZGlhIEFjY2Vzc1wiO1xuICAgICAgICBjYXVzZXNbXCJXRUJSVENfRVJST1JcIl0gPSBcIldlYlJUQyBFcnJvclwiO1xuICAgICAgICBjYXVzZXNbXCJXRUJSVENfTk9UX1NVUFBPUlRFRFwiXSA9IFwiV2ViUlRDIE5vdCBTdXBwb3J0ZWRcIjtcbiAgICB9KShjYXVzZXMgPSBDLmNhdXNlcyB8fCAoQy5jYXVzZXMgPSB7fSkpO1xuICAgIHZhciBzdXBwb3J0ZWQ7XG4gICAgKGZ1bmN0aW9uIChzdXBwb3J0ZWQpIHtcbiAgICAgICAgc3VwcG9ydGVkW1wiUkVRVUlSRURcIl0gPSBcInJlcXVpcmVkXCI7XG4gICAgICAgIHN1cHBvcnRlZFtcIlNVUFBPUlRFRFwiXSA9IFwic3VwcG9ydGVkXCI7XG4gICAgICAgIHN1cHBvcnRlZFtcIlVOU1VQUE9SVEVEXCJdID0gXCJub25lXCI7XG4gICAgfSkoc3VwcG9ydGVkID0gQy5zdXBwb3J0ZWQgfHwgKEMuc3VwcG9ydGVkID0ge30pKTtcbiAgICBDLlNJUF9FUlJPUl9DQVVTRVMgPSB7XG4gICAgICAgIEFERFJFU1NfSU5DT01QTEVURTogWzQ4NF0sXG4gICAgICAgIEFVVEhFTlRJQ0FUSU9OX0VSUk9SOiBbNDAxLCA0MDddLFxuICAgICAgICBCVVNZOiBbNDg2LCA2MDBdLFxuICAgICAgICBJTkNPTVBBVElCTEVfU0RQOiBbNDg4LCA2MDZdLFxuICAgICAgICBOT1RfRk9VTkQ6IFs0MDQsIDYwNF0sXG4gICAgICAgIFJFRElSRUNURUQ6IFszMDAsIDMwMSwgMzAyLCAzMDUsIDM4MF0sXG4gICAgICAgIFJFSkVDVEVEOiBbNDAzLCA2MDNdLFxuICAgICAgICBVTkFWQUlMQUJMRTogWzQ4MCwgNDEwLCA0MDgsIDQzMF1cbiAgICB9O1xuICAgIC8vIFNJUCBNZXRob2RzXG4gICAgQy5BQ0sgPSBcIkFDS1wiO1xuICAgIEMuQllFID0gXCJCWUVcIjtcbiAgICBDLkNBTkNFTCA9IFwiQ0FOQ0VMXCI7XG4gICAgQy5JTkZPID0gXCJJTkZPXCI7XG4gICAgQy5JTlZJVEUgPSBcIklOVklURVwiO1xuICAgIEMuTUVTU0FHRSA9IFwiTUVTU0FHRVwiO1xuICAgIEMuTk9USUZZID0gXCJOT1RJRllcIjtcbiAgICBDLk9QVElPTlMgPSBcIk9QVElPTlNcIjtcbiAgICBDLlJFR0lTVEVSID0gXCJSRUdJU1RFUlwiO1xuICAgIEMuVVBEQVRFID0gXCJVUERBVEVcIjtcbiAgICBDLlNVQlNDUklCRSA9IFwiU1VCU0NSSUJFXCI7XG4gICAgQy5QVUJMSVNIID0gXCJQVUJMSVNIXCI7XG4gICAgQy5SRUZFUiA9IFwiUkVGRVJcIjtcbiAgICBDLlBSQUNLID0gXCJQUkFDS1wiO1xuICAgIC8qIFNJUCBSZXNwb25zZSBSZWFzb25zXG4gICAgICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzXG4gICAgICogQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3ZlcnNhdGljYS9PdmVyU0lQL2Jsb2IvbWFzdGVyL2xpYi9vdmVyc2lwL3NpcC9jb25zdGFudHMucmIjTDdcbiAgICAgKi9cbiAgICBDLlJFQVNPTl9QSFJBU0UgPSB7XG4gICAgICAgIDEwMDogXCJUcnlpbmdcIixcbiAgICAgICAgMTgwOiBcIlJpbmdpbmdcIixcbiAgICAgICAgMTgxOiBcIkNhbGwgSXMgQmVpbmcgRm9yd2FyZGVkXCIsXG4gICAgICAgIDE4MjogXCJRdWV1ZWRcIixcbiAgICAgICAgMTgzOiBcIlNlc3Npb24gUHJvZ3Jlc3NcIixcbiAgICAgICAgMTk5OiBcIkVhcmx5IERpYWxvZyBUZXJtaW5hdGVkXCIsXG4gICAgICAgIDIwMDogXCJPS1wiLFxuICAgICAgICAyMDI6IFwiQWNjZXB0ZWRcIixcbiAgICAgICAgMjA0OiBcIk5vIE5vdGlmaWNhdGlvblwiLFxuICAgICAgICAzMDA6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICAgICAgICAzMDE6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgICAgICAgMzAyOiBcIk1vdmVkIFRlbXBvcmFyaWx5XCIsXG4gICAgICAgIDMwNTogXCJVc2UgUHJveHlcIixcbiAgICAgICAgMzgwOiBcIkFsdGVybmF0aXZlIFNlcnZpY2VcIixcbiAgICAgICAgNDAwOiBcIkJhZCBSZXF1ZXN0XCIsXG4gICAgICAgIDQwMTogXCJVbmF1dGhvcml6ZWRcIixcbiAgICAgICAgNDAyOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgICAgICAgNDAzOiBcIkZvcmJpZGRlblwiLFxuICAgICAgICA0MDQ6IFwiTm90IEZvdW5kXCIsXG4gICAgICAgIDQwNTogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgICAgICAgNDA2OiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gICAgICAgIDQwNzogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICAgICAgICA0MDg6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gICAgICAgIDQxMDogXCJHb25lXCIsXG4gICAgICAgIDQxMjogXCJDb25kaXRpb25hbCBSZXF1ZXN0IEZhaWxlZFwiLFxuICAgICAgICA0MTM6IFwiUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlXCIsXG4gICAgICAgIDQxNDogXCJSZXF1ZXN0LVVSSSBUb28gTG9uZ1wiLFxuICAgICAgICA0MTU6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICAgICAgICA0MTY6IFwiVW5zdXBwb3J0ZWQgVVJJIFNjaGVtZVwiLFxuICAgICAgICA0MTc6IFwiVW5rbm93biBSZXNvdXJjZS1Qcmlvcml0eVwiLFxuICAgICAgICA0MjA6IFwiQmFkIEV4dGVuc2lvblwiLFxuICAgICAgICA0MjE6IFwiRXh0ZW5zaW9uIFJlcXVpcmVkXCIsXG4gICAgICAgIDQyMjogXCJTZXNzaW9uIEludGVydmFsIFRvbyBTbWFsbFwiLFxuICAgICAgICA0MjM6IFwiSW50ZXJ2YWwgVG9vIEJyaWVmXCIsXG4gICAgICAgIDQyODogXCJVc2UgSWRlbnRpdHkgSGVhZGVyXCIsXG4gICAgICAgIDQyOTogXCJQcm92aWRlIFJlZmVycmVyIElkZW50aXR5XCIsXG4gICAgICAgIDQzMDogXCJGbG93IEZhaWxlZFwiLFxuICAgICAgICA0MzM6IFwiQW5vbnltaXR5IERpc2FsbG93ZWRcIixcbiAgICAgICAgNDM2OiBcIkJhZCBJZGVudGl0eS1JbmZvXCIsXG4gICAgICAgIDQzNzogXCJVbnN1cHBvcnRlZCBDZXJ0aWZpY2F0ZVwiLFxuICAgICAgICA0Mzg6IFwiSW52YWxpZCBJZGVudGl0eSBIZWFkZXJcIixcbiAgICAgICAgNDM5OiBcIkZpcnN0IEhvcCBMYWNrcyBPdXRib3VuZCBTdXBwb3J0XCIsXG4gICAgICAgIDQ0MDogXCJNYXgtQnJlYWR0aCBFeGNlZWRlZFwiLFxuICAgICAgICA0Njk6IFwiQmFkIEluZm8gUGFja2FnZVwiLFxuICAgICAgICA0NzA6IFwiQ29uc2VudCBOZWVkZWRcIixcbiAgICAgICAgNDc4OiBcIlVucmVzb2x2YWJsZSBEZXN0aW5hdGlvblwiLFxuICAgICAgICA0ODA6IFwiVGVtcG9yYXJpbHkgVW5hdmFpbGFibGVcIixcbiAgICAgICAgNDgxOiBcIkNhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3RcIixcbiAgICAgICAgNDgyOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgICAgICAgNDgzOiBcIlRvbyBNYW55IEhvcHNcIixcbiAgICAgICAgNDg0OiBcIkFkZHJlc3MgSW5jb21wbGV0ZVwiLFxuICAgICAgICA0ODU6IFwiQW1iaWd1b3VzXCIsXG4gICAgICAgIDQ4NjogXCJCdXN5IEhlcmVcIixcbiAgICAgICAgNDg3OiBcIlJlcXVlc3QgVGVybWluYXRlZFwiLFxuICAgICAgICA0ODg6IFwiTm90IEFjY2VwdGFibGUgSGVyZVwiLFxuICAgICAgICA0ODk6IFwiQmFkIEV2ZW50XCIsXG4gICAgICAgIDQ5MTogXCJSZXF1ZXN0IFBlbmRpbmdcIixcbiAgICAgICAgNDkzOiBcIlVuZGVjaXBoZXJhYmxlXCIsXG4gICAgICAgIDQ5NDogXCJTZWN1cml0eSBBZ3JlZW1lbnQgUmVxdWlyZWRcIixcbiAgICAgICAgNTAwOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgICAgICA1MDE6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gICAgICAgIDUwMjogXCJCYWQgR2F0ZXdheVwiLFxuICAgICAgICA1MDM6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICAgICAgICA1MDQ6IFwiU2VydmVyIFRpbWUtb3V0XCIsXG4gICAgICAgIDUwNTogXCJWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgICAgICAgNTEzOiBcIk1lc3NhZ2UgVG9vIExhcmdlXCIsXG4gICAgICAgIDU4MDogXCJQcmVjb25kaXRpb24gRmFpbHVyZVwiLFxuICAgICAgICA2MDA6IFwiQnVzeSBFdmVyeXdoZXJlXCIsXG4gICAgICAgIDYwMzogXCJEZWNsaW5lXCIsXG4gICAgICAgIDYwNDogXCJEb2VzIE5vdCBFeGlzdCBBbnl3aGVyZVwiLFxuICAgICAgICA2MDY6IFwiTm90IEFjY2VwdGFibGVcIlxuICAgIH07XG4gICAgLyogU0lQIE9wdGlvbiBUYWdzXG4gICAgICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzL3NpcC1wYXJhbWV0ZXJzLnhodG1sI3NpcC1wYXJhbWV0ZXJzLTRcbiAgICAgKi9cbiAgICBDLk9QVElPTl9UQUdTID0ge1xuICAgICAgICBcIjEwMHJlbFwiOiB0cnVlLFxuICAgICAgICBcIjE5OVwiOiB0cnVlLFxuICAgICAgICBcImFuc3dlcm1vZGVcIjogdHJ1ZSxcbiAgICAgICAgXCJlYXJseS1zZXNzaW9uXCI6IHRydWUsXG4gICAgICAgIFwiZXZlbnRsaXN0XCI6IHRydWUsXG4gICAgICAgIFwiZXhwbGljaXRzdWJcIjogdHJ1ZSxcbiAgICAgICAgXCJmcm9tLWNoYW5nZVwiOiB0cnVlLFxuICAgICAgICBcImdlb2xvY2F0aW9uLWh0dHBcIjogdHJ1ZSxcbiAgICAgICAgXCJnZW9sb2NhdGlvbi1zaXBcIjogdHJ1ZSxcbiAgICAgICAgXCJnaW5cIjogdHJ1ZSxcbiAgICAgICAgXCJncnV1XCI6IHRydWUsXG4gICAgICAgIFwiaGlzdGluZm9cIjogdHJ1ZSxcbiAgICAgICAgXCJpY2VcIjogdHJ1ZSxcbiAgICAgICAgXCJqb2luXCI6IHRydWUsXG4gICAgICAgIFwibXVsdGlwbGUtcmVmZXJcIjogdHJ1ZSxcbiAgICAgICAgXCJub3JlZmVyc3ViXCI6IHRydWUsXG4gICAgICAgIFwibm9zdWJcIjogdHJ1ZSxcbiAgICAgICAgXCJvdXRib3VuZFwiOiB0cnVlLFxuICAgICAgICBcInBhdGhcIjogdHJ1ZSxcbiAgICAgICAgXCJwb2xpY3lcIjogdHJ1ZSxcbiAgICAgICAgXCJwcmVjb25kaXRpb25cIjogdHJ1ZSxcbiAgICAgICAgXCJwcmVmXCI6IHRydWUsXG4gICAgICAgIFwicHJpdmFjeVwiOiB0cnVlLFxuICAgICAgICBcInJlY2lwaWVudC1saXN0LWludml0ZVwiOiB0cnVlLFxuICAgICAgICBcInJlY2lwaWVudC1saXN0LW1lc3NhZ2VcIjogdHJ1ZSxcbiAgICAgICAgXCJyZWNpcGllbnQtbGlzdC1zdWJzY3JpYmVcIjogdHJ1ZSxcbiAgICAgICAgXCJyZXBsYWNlc1wiOiB0cnVlLFxuICAgICAgICBcInJlc291cmNlLXByaW9yaXR5XCI6IHRydWUsXG4gICAgICAgIFwic2RwLWFuYXRcIjogdHJ1ZSxcbiAgICAgICAgXCJzZWMtYWdyZWVcIjogdHJ1ZSxcbiAgICAgICAgXCJ0ZGlhbG9nXCI6IHRydWUsXG4gICAgICAgIFwidGltZXJcIjogdHJ1ZSxcbiAgICAgICAgXCJ1dWlcIjogdHJ1ZSAvLyBSRkMgNzQzM1xuICAgIH07XG4gICAgdmFyIGR0bWZUeXBlO1xuICAgIChmdW5jdGlvbiAoZHRtZlR5cGUpIHtcbiAgICAgICAgZHRtZlR5cGVbXCJJTkZPXCJdID0gXCJpbmZvXCI7XG4gICAgICAgIGR0bWZUeXBlW1wiUlRQXCJdID0gXCJydHBcIjtcbiAgICB9KShkdG1mVHlwZSA9IEMuZHRtZlR5cGUgfHwgKEMuZHRtZlR5cGUgPSB7fSkpO1xufSkoQyA9IGV4cG9ydHMuQyB8fCAoZXhwb3J0cy5DID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gZW51bXMgY2FuJ3QgcmVhbGx5IGJlIGRlY2xhcmVkLCBzbyB0aGV5IGFyZSBzZXQgaGVyZS5cbi8vIHB1bGxlZCBvdXQgb2YgaW5kaXZpZHVhbCBmaWxlcyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEaWFsb2dTdGF0dXM7XG4oZnVuY3Rpb24gKERpYWxvZ1N0YXR1cykge1xuICAgIERpYWxvZ1N0YXR1c1tEaWFsb2dTdGF0dXNbXCJTVEFUVVNfRUFSTFlcIl0gPSAxXSA9IFwiU1RBVFVTX0VBUkxZXCI7XG4gICAgRGlhbG9nU3RhdHVzW0RpYWxvZ1N0YXR1c1tcIlNUQVRVU19DT05GSVJNRURcIl0gPSAyXSA9IFwiU1RBVFVTX0NPTkZJUk1FRFwiO1xufSkoRGlhbG9nU3RhdHVzID0gZXhwb3J0cy5EaWFsb2dTdGF0dXMgfHwgKGV4cG9ydHMuRGlhbG9nU3RhdHVzID0ge30pKTtcbnZhciBTZXNzaW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChTZXNzaW9uU3RhdHVzKSB7XG4gICAgLy8gU2Vzc2lvbiBzdGF0ZXNcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfTlVMTFwiXSA9IDBdID0gXCJTVEFUVVNfTlVMTFwiO1xuICAgIFNlc3Npb25TdGF0dXNbU2Vzc2lvblN0YXR1c1tcIlNUQVRVU19JTlZJVEVfU0VOVFwiXSA9IDFdID0gXCJTVEFUVVNfSU5WSVRFX1NFTlRcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfMVhYX1JFQ0VJVkVEXCJdID0gMl0gPSBcIlNUQVRVU18xWFhfUkVDRUlWRURcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfSU5WSVRFX1JFQ0VJVkVEXCJdID0gM10gPSBcIlNUQVRVU19JTlZJVEVfUkVDRUlWRURcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSXCJdID0gNF0gPSBcIlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVJcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfQU5TV0VSRURcIl0gPSA1XSA9IFwiU1RBVFVTX0FOU1dFUkVEXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLXCJdID0gNl0gPSBcIlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDS1wiO1xuICAgIFNlc3Npb25TdGF0dXNbU2Vzc2lvblN0YXR1c1tcIlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0tcIl0gPSA3XSA9IFwiU1RBVFVTX1dBSVRJTkdfRk9SX0FDS1wiO1xuICAgIFNlc3Npb25TdGF0dXNbU2Vzc2lvblN0YXR1c1tcIlNUQVRVU19DQU5DRUxFRFwiXSA9IDhdID0gXCJTVEFUVVNfQ0FOQ0VMRURcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfVEVSTUlOQVRFRFwiXSA9IDldID0gXCJTVEFUVVNfVEVSTUlOQVRFRFwiO1xuICAgIFNlc3Npb25TdGF0dXNbU2Vzc2lvblN0YXR1c1tcIlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDS1wiXSA9IDEwXSA9IFwiU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX0VBUkxZX01FRElBXCJdID0gMTFdID0gXCJTVEFUVVNfRUFSTFlfTUVESUFcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfQ09ORklSTUVEXCJdID0gMTJdID0gXCJTVEFUVVNfQ09ORklSTUVEXCI7XG59KShTZXNzaW9uU3RhdHVzID0gZXhwb3J0cy5TZXNzaW9uU3RhdHVzIHx8IChleHBvcnRzLlNlc3Npb25TdGF0dXMgPSB7fSkpO1xudmFyIFR5cGVTdHJpbmdzO1xuKGZ1bmN0aW9uIChUeXBlU3RyaW5ncykge1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiQ2xpZW50Q29udGV4dFwiXSA9IDBdID0gXCJDbGllbnRDb250ZXh0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJDb25maWd1cmF0aW9uRXJyb3JcIl0gPSAxXSA9IFwiQ29uZmlndXJhdGlvbkVycm9yXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJEaWFsb2dcIl0gPSAyXSA9IFwiRGlhbG9nXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJEaWdlc3RBdXRoZW50aWNhdGlvblwiXSA9IDNdID0gXCJEaWdlc3RBdXRoZW50aWNhdGlvblwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiRFRNRlwiXSA9IDRdID0gXCJEVE1GXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJJbmNvbWluZ01lc3NhZ2VcIl0gPSA1XSA9IFwiSW5jb21pbmdNZXNzYWdlXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJJbmNvbWluZ1JlcXVlc3RcIl0gPSA2XSA9IFwiSW5jb21pbmdSZXF1ZXN0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJJbmNvbWluZ1Jlc3BvbnNlXCJdID0gN10gPSBcIkluY29taW5nUmVzcG9uc2VcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIkludmFsaWRTdGF0ZUVycm9yXCJdID0gOF0gPSBcIkludmFsaWRTdGF0ZUVycm9yXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJJbnZpdGVDbGllbnRDb250ZXh0XCJdID0gOV0gPSBcIkludml0ZUNsaWVudENvbnRleHRcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIkludml0ZVNlcnZlckNvbnRleHRcIl0gPSAxMF0gPSBcIkludml0ZVNlcnZlckNvbnRleHRcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIkxvZ2dlclwiXSA9IDExXSA9IFwiTG9nZ2VyXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJMb2dnZXJGYWN0b3J5XCJdID0gMTJdID0gXCJMb2dnZXJGYWN0b3J5XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJNZXRob2RQYXJhbWV0ZXJFcnJvclwiXSA9IDEzXSA9IFwiTWV0aG9kUGFyYW1ldGVyRXJyb3JcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIk5hbWVBZGRySGVhZGVyXCJdID0gMTRdID0gXCJOYW1lQWRkckhlYWRlclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiTm90U3VwcG9ydGVkRXJyb3JcIl0gPSAxNV0gPSBcIk5vdFN1cHBvcnRlZEVycm9yXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJPdXRnb2luZ1JlcXVlc3RcIl0gPSAxNl0gPSBcIk91dGdvaW5nUmVxdWVzdFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiUGFyYW1ldGVyc1wiXSA9IDE3XSA9IFwiUGFyYW1ldGVyc1wiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiUHVibGlzaENvbnRleHRcIl0gPSAxOF0gPSBcIlB1Ymxpc2hDb250ZXh0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJSZWZlckNsaWVudENvbnRleHRcIl0gPSAxOV0gPSBcIlJlZmVyQ2xpZW50Q29udGV4dFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiUmVmZXJTZXJ2ZXJDb250ZXh0XCJdID0gMjBdID0gXCJSZWZlclNlcnZlckNvbnRleHRcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlJlZ2lzdGVyQ29udGV4dFwiXSA9IDIxXSA9IFwiUmVnaXN0ZXJDb250ZXh0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJSZW5lZ290aWF0aW9uRXJyb3JcIl0gPSAyMl0gPSBcIlJlbmVnb3RpYXRpb25FcnJvclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiUmVxdWVzdFNlbmRlclwiXSA9IDIzXSA9IFwiUmVxdWVzdFNlbmRlclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiU2VydmVyQ29udGV4dFwiXSA9IDI0XSA9IFwiU2VydmVyQ29udGV4dFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiU2Vzc2lvblwiXSA9IDI1XSA9IFwiU2Vzc2lvblwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiXSA9IDI2XSA9IFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yXCJdID0gMjddID0gXCJTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3JcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlclwiXSA9IDI4XSA9IFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJTdWJzY3JpcHRpb25cIl0gPSAyOV0gPSBcIlN1YnNjcmlwdGlvblwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiVHJhbnNwb3J0XCJdID0gMzBdID0gXCJUcmFuc3BvcnRcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlVBXCJdID0gMzFdID0gXCJVQVwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiVVJJXCJdID0gMzJdID0gXCJVUklcIjtcbn0pKFR5cGVTdHJpbmdzID0gZXhwb3J0cy5UeXBlU3RyaW5ncyB8fCAoZXhwb3J0cy5UeXBlU3RyaW5ncyA9IHt9KSk7XG4vLyBVQSBzdGF0dXMgY29kZXNcbnZhciBVQVN0YXR1cztcbihmdW5jdGlvbiAoVUFTdGF0dXMpIHtcbiAgICBVQVN0YXR1c1tVQVN0YXR1c1tcIlNUQVRVU19JTklUXCJdID0gMF0gPSBcIlNUQVRVU19JTklUXCI7XG4gICAgVUFTdGF0dXNbVUFTdGF0dXNbXCJTVEFUVVNfU1RBUlRJTkdcIl0gPSAxXSA9IFwiU1RBVFVTX1NUQVJUSU5HXCI7XG4gICAgVUFTdGF0dXNbVUFTdGF0dXNbXCJTVEFUVVNfUkVBRFlcIl0gPSAyXSA9IFwiU1RBVFVTX1JFQURZXCI7XG4gICAgVUFTdGF0dXNbVUFTdGF0dXNbXCJTVEFUVVNfVVNFUl9DTE9TRURcIl0gPSAzXSA9IFwiU1RBVFVTX1VTRVJfQ0xPU0VEXCI7XG4gICAgVUFTdGF0dXNbVUFTdGF0dXNbXCJTVEFUVVNfTk9UX1JFQURZXCJdID0gNF0gPSBcIlNUQVRVU19OT1RfUkVBRFlcIjtcbn0pKFVBU3RhdHVzID0gZXhwb3J0cy5VQVN0YXR1cyB8fCAoZXhwb3J0cy5VQVN0YXR1cyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbnZhciBFeGNlcHRpb25zO1xuKGZ1bmN0aW9uIChFeGNlcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgaGFzIGNsb3NlZC5cbiAgICAgKiBPY2N1cnMgd2hlbiBnZXREZXNjcmlwdGlvbigpIG9yIHNldERlc2NyaXB0aW9uKCkgYXJlIGNhbGxlZCBhZnRlciBjbG9zZSgpIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBPY2N1cnMgd2hlbiBjbG9zZSgpIGlzIGNhbGxlZCB3aGlsZSBnZXREZXNjcmlwdGlvbigpIG9yIHNldERlc2NyaXB0aW9uKCkgYXJlIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIHZhciBDbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKENsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiVGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBoYXMgY2xvc2VkLlwiKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3I7XG4gICAgfShjb3JlXzEuRXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5DbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgPSBDbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3I7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBzZXNzaW9uIHRlcm1pbmF0ZWQgYmVmb3JlIHRoZSBhY3Rpb24gY29tcGxldGVkLlxuICAgICAqL1xuICAgIHZhciBUZXJtaW5hdGVkU2Vzc2lvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUZXJtaW5hdGVkU2Vzc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUZXJtaW5hdGVkU2Vzc2lvbkVycm9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiVGhlIHNlc3Npb24gaGFzIHRlcm1pbmF0ZWQuXCIpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRlcm1pbmF0ZWRTZXNzaW9uRXJyb3I7XG4gICAgfShjb3JlXzEuRXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5UZXJtaW5hdGVkU2Vzc2lvbkVycm9yID0gVGVybWluYXRlZFNlc3Npb25FcnJvcjtcbiAgICAvKipcbiAgICAgKiBVbnN1cHBvcnRlZCBzZXNzaW9uIGRlc2NyaXB0aW9uIGNvbnRlbnQgdHlwZS5cbiAgICAgKi9cbiAgICB2YXIgVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhVbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFVuc3VwcG9ydGVkU2Vzc2lvbkRlc2NyaXB0aW9uQ29udGVudFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlVuc3VwcG9ydGVkIHNlc3Npb24gZGVzY3JpcHRpb24gY29udGVudCB0eXBlLlwiKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3I7XG4gICAgfShjb3JlXzEuRXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5VbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3IgPSBVbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3I7XG59KShFeGNlcHRpb25zID0gZXhwb3J0cy5FeGNlcHRpb25zIHx8IChleHBvcnRzLkV4Y2VwdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBERVBSRUNBVEVEOiBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gb2YgZXhjZXB0aW9ucyBpbiB0aGlzIGxpYnJhcnkgYXR0ZW1wdGVkIHRvXG4gKiBkZWFsIHdpdGggdGhlIGxhY2sgb2YgdHlwZSBjaGVja2luZyBpbiBKYXZhU2NyaXB0IGJ5IGFkZGluZyBhIFwidHlwZVwiIGF0dHJpYnV0ZVxuICogdG8gb2JqZWN0cyBhbmQgdXNpbmcgdGhhdCB0byBkaXNjcmltaW5hdGUuIE9uIHRvcCBvZiB0aGF0IGl0IGxheWVyZWQgYWxsY29hdGVkXG4gKiBcImNvZGVcIiBudW1iZXJzIGFuZCBjb25zdGFudCBcIm5hbWVcIiBzdHJpbmdzLiBBbGwgb2YgdGhhdCBpcyB1bm5lY2Vzc2FyeSB3aGVuIHVzaW5nXG4gKiBUeXBlU2NyaXB0LCBpbmhlcml0aW5nIGZyb20gRXJyb3IgYW5kIHByb3Blcmx5IHNldHRpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi4uLlxuICovXG52YXIgTGVnYWN5RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKExlZ2FjeUV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWdhY3lFeGNlcHRpb24oY29kZSwgbmFtZSwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMZWdhY3lFeGNlcHRpb247XG59KGNvcmVfMS5FeGNlcHRpb24pKTtcbihmdW5jdGlvbiAoRXhjZXB0aW9ucykge1xuICAgIHZhciBDb25maWd1cmF0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKENvbmZpZ3VyYXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDEsIFwiQ09ORklHVVJBVElPTl9FUlJPUlwiLCAoIXZhbHVlKSA/IFwiTWlzc2luZyBwYXJhbWV0ZXI6IFwiICsgcGFyYW1ldGVyIDpcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgdmFsdWUgXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyBcIiBmb3IgcGFyYW1ldGVyICdcIiArIHBhcmFtZXRlciArIFwiJ1wiKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuQ29uZmlndXJhdGlvbkVycm9yO1xuICAgICAgICAgICAgX3RoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29uZmlndXJhdGlvbkVycm9yO1xuICAgIH0oTGVnYWN5RXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IgPSBDb25maWd1cmF0aW9uRXJyb3I7XG4gICAgdmFyIEludmFsaWRTdGF0ZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZhbGlkU3RhdGVFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW52YWxpZFN0YXRlRXJyb3Ioc3RhdHVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAyLCBcIklOVkFMSURfU1RBVEVfRVJST1JcIiwgXCJJbnZhbGlkIHN0YXR1czogXCIgKyBzdGF0dXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5JbnZhbGlkU3RhdGVFcnJvcjtcbiAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3I7XG4gICAgfShMZWdhY3lFeGNlcHRpb24pKTtcbiAgICBFeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XG4gICAgdmFyIE5vdFN1cHBvcnRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb3RTdXBwb3J0ZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm90U3VwcG9ydGVkRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMywgXCJOT1RfU1VQUE9SVEVEX0VSUk9SXCIsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5Ob3RTdXBwb3J0ZWRFcnJvcjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm90U3VwcG9ydGVkRXJyb3I7XG4gICAgfShMZWdhY3lFeGNlcHRpb24pKTtcbiAgICBFeGNlcHRpb25zLk5vdFN1cHBvcnRlZEVycm9yID0gTm90U3VwcG9ydGVkRXJyb3I7XG4gICAgLy8gNCB3YXMgR2V0RGVzY3JpcHRpb25FcnJvciwgd2hpY2ggd2FzIGRlcHJlY2F0ZWQgYW5kIG5vdyByZW1vdmVkXG4gICAgdmFyIFJlbmVnb3RpYXRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVuZWdvdGlhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZW5lZ290aWF0aW9uRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNSwgXCJSRU5FR09USUFUSU9OX0VSUk9SXCIsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5SZW5lZ290aWF0aW9uRXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmVnb3RpYXRpb25FcnJvcjtcbiAgICB9KExlZ2FjeUV4Y2VwdGlvbikpO1xuICAgIEV4Y2VwdGlvbnMuUmVuZWdvdGlhdGlvbkVycm9yID0gUmVuZWdvdGlhdGlvbkVycm9yO1xuICAgIHZhciBNZXRob2RQYXJhbWV0ZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoTWV0aG9kUGFyYW1ldGVyRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE1ldGhvZFBhcmFtZXRlckVycm9yKG1ldGhvZCwgcGFyYW1ldGVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNiwgXCJNRVRIT0RfUEFSQU1FVEVSX0VSUk9SXCIsICghdmFsdWUpID9cbiAgICAgICAgICAgICAgICBcIk1pc3NpbmcgcGFyYW1ldGVyOiBcIiArIHBhcmFtZXRlciA6XG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCIgZm9yIHBhcmFtZXRlciAnXCIgKyBwYXJhbWV0ZXIgKyBcIidcIikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLk1ldGhvZFBhcmFtZXRlckVycm9yO1xuICAgICAgICAgICAgX3RoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgX3RoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWV0aG9kUGFyYW1ldGVyRXJyb3I7XG4gICAgfShMZWdhY3lFeGNlcHRpb24pKTtcbiAgICBFeGNlcHRpb25zLk1ldGhvZFBhcmFtZXRlckVycm9yID0gTWV0aG9kUGFyYW1ldGVyRXJyb3I7XG4gICAgLy8gNyB3YXMgVHJhbnNwb3J0RXJyb3IsIHdoaWNoIHdhcyByZXBsYWNlZFxuICAgIHZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKG1ldGhvZCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDgsIFwiU0VTU0lPTl9ERVNDUklQVElPTl9IQU5ETEVSX0VSUk9SXCIsIG1lc3NhZ2UgfHwgXCJFcnJvciB3aXRoIFNlc3Npb24gRGVzY3JpcHRpb24gSGFuZGxlclwiKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xuICAgICAgICAgICAgX3RoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgX3RoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xuICAgIH0oTGVnYWN5RXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgPSBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3I7XG59KShFeGNlcHRpb25zID0gZXhwb3J0cy5FeGNlcHRpb25zIHx8IChleHBvcnRzLkV4Y2VwdGlvbnMgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDbGllbnRDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9DbGllbnRDb250ZXh0XCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xudmFyIEV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvbnNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuLyoqXG4gKiBTSVAgUHVibGlzaCAoU0lQIEV4dGVuc2lvbiBmb3IgRXZlbnQgU3RhdGUgUHVibGljYXRpb24gUkZDMzkwMylcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBQdWJsaXNoQ29udGV4dC5cbiAqL1xudmFyIFB1Ymxpc2hDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFB1Ymxpc2hDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFB1Ymxpc2hDb250ZXh0KHVhLCB0YXJnZXQsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBvcHRpb25zLmNvbnRlbnRUeXBlID0gKG9wdGlvbnMuY29udGVudFR5cGUgfHwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwaXJlcyAhPT0gXCJudW1iZXJcIiB8fCAob3B0aW9ucy5leHBpcmVzICUgMSkgIT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IDM2MDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmV4cGlyZXMgPSBOdW1iZXIob3B0aW9ucy5leHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLnVucHVibGlzaE9uQ2xvc2UpICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgb3B0aW9ucy51bnB1Ymxpc2hPbkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLk1ldGhvZFBhcmFtZXRlckVycm9yKFwiUHVibGlzaFwiLCBcIlRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuTWV0aG9kUGFyYW1ldGVyRXJyb3IoXCJQdWJsaXNoXCIsIFwiVGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1YSwgQ29uc3RhbnRzXzEuQy5QVUJMSVNILCB0YXJnZXQsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlB1Ymxpc2hDb250ZXh0O1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBpZiAoZXZlbnQgPT09IHVuZGVmaW5lZCB8fCBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLk1ldGhvZFBhcmFtZXRlckVycm9yKFwiUHVibGlzaFwiLCBcIkV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKFwic2lwLnB1Ymxpc2hcIik7XG4gICAgICAgIF90aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gX3RoaXMub3B0aW9ucy5leHBpcmVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gRXZlbnQgYm9keSB0byBwdWJsaXNoLCBvcHRpb25hbFxuICAgICAqL1xuICAgIFB1Ymxpc2hDb250ZXh0LnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgYmVmb3JlIHRoZSBydW5cbiAgICAgICAgaWYgKHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXMgSW5pdGFsIG9yIE1vZGlmeSByZXF1ZXN0XG4gICAgICAgIHRoaXMub3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5wdWJSZXF1ZXN0Qm9keSA9IHRoaXMub3B0aW9ucy5ib2R5O1xuICAgICAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBJbml0aWFsIHJlcXVlc3QgYWZ0ZXIgdW5wdWJsaXNoXG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gdGhpcy5vcHRpb25zLmV4cGlyZXM7XG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFdGFnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRoaXMudWEucHVibGlzaGVyc1t0aGlzLnRhcmdldC50b1N0cmluZygpICsgXCI6XCIgKyB0aGlzLmV2ZW50XSkpIHtcbiAgICAgICAgICAgIHRoaXMudWEucHVibGlzaGVyc1t0aGlzLnRhcmdldC50b1N0cmluZygpICsgXCI6XCIgKyB0aGlzLmV2ZW50XSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kUHVibGlzaFJlcXVlc3QoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVucHVibGlzaFxuICAgICAqL1xuICAgIFB1Ymxpc2hDb250ZXh0LnByb3RvdHlwZS51bnB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSB0aGUgcnVuXG4gICAgICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSAwO1xuICAgICAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRQdWJsaXNoUmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZVxuICAgICAqL1xuICAgIFB1Ymxpc2hDb250ZXh0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2VuZCB1bnB1Ymxpc2gsIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVucHVibGlzaE9uQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMudW5wdWJsaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0Qm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSAwO1xuICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51YS5wdWJsaXNoZXJzW3RoaXMudGFyZ2V0LnRvU3RyaW5nKCkgKyBcIjpcIiArIHRoaXMuZXZlbnRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy51YS5wdWJsaXNoZXJzW3RoaXMudGFyZ2V0LnRvU3RyaW5nKCkgKyBcIjpcIiArIHRoaXMuZXZlbnRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdChcInVucHVibGlzaGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuICAgIFB1Ymxpc2hDb250ZXh0LnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidW5wdWJsaXNoZWRcIiwgdW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9O1xuICAgIFB1Ymxpc2hDb250ZXh0LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlIHx8IDA7XG4gICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgLy8gU2V0IFNJUC1FdGFnXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhhc0hlYWRlcihcIlNJUC1FVGFnXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV0YWcgPSByZXNwb25zZS5nZXRIZWFkZXIoXCJTSVAtRVRhZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJTSVAtRVRhZyBoZWFkZXIgbWlzc2luZyBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBQVUJMSVNIXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgRXhwaXJlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhhc0hlYWRlcihcIkV4cGlyZXNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGlyZXMgPSBOdW1iZXIocmVzcG9uc2UuZ2V0SGVhZGVyKFwiRXhwaXJlc1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJlcyA9PT0gXCJudW1iZXJcIiAmJiBleHBpcmVzID49IDAgJiYgZXhwaXJlcyA8PSB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gZXhwaXJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJCYWQgRXhwaXJlcyBoZWFkZXIgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gUFVCTElTSFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkV4cGlyZXMgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gUFVCTElTSFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV4cGlyZXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlZnJlc2hSZXF1ZXN0KCk7IH0sIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgKiA5MDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwdWJsaXNoZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVucHVibGlzaGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjQxMiQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgICAgICAgICAvLyA0MTIgY29kZSBtZWFucyBubyBtYXRjaGluZyBFVGFnIC0gcG9zc2libHkgdGhlIFBVQkxJU0ggZXhwaXJlZFxuICAgICAgICAgICAgICAgIC8vIFJlc3VibWl0IGFzIG5ldyByZXF1ZXN0LCBpZiB0aGUgY3VycmVudCByZXF1ZXN0IGlzIG5vdCBhIFwicmVtb3ZlXCJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXRhZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIjQxMiByZXNwb25zZSB0byBQVUJMSVNILCByZWNvdmVyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFdGFnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5vcHRpb25zLmJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIjQxMiByZXNwb25zZSB0byBQVUJMSVNILCByZWNvdmVyeSBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidW5wdWJsaXNoZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eNDIzJC8udGVzdChzdGF0dXNDb2RlLnRvU3RyaW5nKCkpOlxuICAgICAgICAgICAgICAgIC8vIDQyMyBjb2RlIG1lYW5zIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBFeHBpcmVzIGludGVydmFsIHVwXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV4cGlyZXMgIT09IDAgJiYgcmVzcG9uc2UuaGFzSGVhZGVyKFwiTWluLUV4cGlyZXNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkV4cGlyZXMgPSBOdW1iZXIocmVzcG9uc2UuZ2V0SGVhZGVyKFwiTWluLUV4cGlyZXNcIikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1pbkV4cGlyZXMgPT09IFwibnVtYmVyXCIgfHwgbWluRXhwaXJlcyA+IHRoaXMucHViUmVxdWVzdEV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCI0MjMgY29kZSBpbiByZXNwb25zZSB0byBQVUJMSVNILCBhZGp1c3RpbmcgdGhlIEV4cGlyZXMgdmFsdWUgYW5kIHRyeWluZyB0byByZWNvdmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IG1pbkV4cGlyZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMub3B0aW9ucy5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJCYWQgNDIzIHJlc3BvbnNlIE1pbi1FeHBpcmVzIGhlYWRlciByZWNlaXZlZCBmb3IgUFVCTElTSFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1bnB1Ymxpc2hlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiNDIzIHJlc3BvbnNlIHRvIFBVQkxJU0gsIHJlY292ZXJ5IGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1bnB1Ymxpc2hlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidW5wdWJsaXNoZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgY2xlYW51cFxuICAgICAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFdGFnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51YS51c2VyQWdlbnRDb3JlLnB1Ymxpc2godGhpcy5yZXF1ZXN0LCB7XG4gICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25Ucnlpbmc6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFB1Ymxpc2hDb250ZXh0LnByb3RvdHlwZS5yZWZyZXNoUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgYmVmb3JlIHRoZSBydW5cbiAgICAgICAgaWYgKHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBSZWZyZXNoIHJlcXVlc3RcbiAgICAgICAgdGhpcy5wdWJSZXF1ZXN0Qm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCBub3QgdmFsaWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5NZXRob2RQYXJhbWV0ZXJFcnJvcihcIlB1Ymxpc2hcIiwgXCJCb2R5XCIsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3Qgbm90IHZhbGlkXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuTWV0aG9kUGFyYW1ldGVyRXJyb3IoXCJQdWJsaXNoXCIsIFwiRXhwaXJlXCIsIHRoaXMucHViUmVxdWVzdEV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFB1Ymxpc2hSZXF1ZXN0KCk7XG4gICAgfTtcbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUuc2VuZFB1Ymxpc2hSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVxT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICAgICAgICByZXFPcHRpb25zLmV4dHJhSGVhZGVycyA9ICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICByZXFPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiRXZlbnQ6IFwiICsgdGhpcy5ldmVudCk7XG4gICAgICAgIHJlcU9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJFeHBpcmVzOiBcIiArIHRoaXMucHViUmVxdWVzdEV4cGlyZXMpO1xuICAgICAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXFPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiU0lQLUlmLU1hdGNoOiBcIiArIHRoaXMucHViUmVxdWVzdEV0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydXJpID0gdGhpcy50YXJnZXQgaW5zdGFuY2VvZiBjb3JlXzEuVVJJID8gdGhpcy50YXJnZXQgOiB0aGlzLnVhLm5vcm1hbGl6ZVRhcmdldCh0aGlzLnRhcmdldCk7XG4gICAgICAgIGlmICghcnVyaSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicnVyaSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgYm9keU9iajtcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm9keU9iaiA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiB0aGlzLnB1YlJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIGlmIChib2R5T2JqKSB7XG4gICAgICAgICAgICBib2R5ID0gVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaihib2R5T2JqKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLnVhLnVzZXJBZ2VudENvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoQ29uc3RhbnRzXzEuQy5QVUJMSVNILCBydXJpLCBwYXJhbXMuZnJvbVVyaSA/IHBhcmFtcy5mcm9tVXJpIDogdGhpcy51YS51c2VyQWdlbnRDb3JlLmNvbmZpZ3VyYXRpb24uYW9yLCBwYXJhbXMudG9VcmkgPyBwYXJhbXMudG9VcmkgOiB0aGlzLnRhcmdldCwgcGFyYW1zLCByZXFPcHRpb25zLmV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFB1Ymxpc2hDb250ZXh0O1xufShDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dCkpO1xuZXhwb3J0cy5QdWJsaXNoQ29udGV4dCA9IFB1Ymxpc2hDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDbGllbnRDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9DbGllbnRDb250ZXh0XCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xudmFyIEV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvbnNcIik7XG52YXIgU2VydmVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vU2VydmVyQ29udGV4dFwiKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxudmFyIFJlZmVyQ2xpZW50Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWZlckNsaWVudENvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmZXJDbGllbnRDb250ZXh0KHVhLCBhcHBsaWNhbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodWEgPT09IHVuZGVmaW5lZCB8fCBhcHBsaWNhbnQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdWEsIENvbnN0YW50c18xLkMuUkVGRVIsIGFwcGxpY2FudC5yZW1vdGVJZGVudGl0eS51cmkudG9TdHJpbmcoKSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuUmVmZXJDbGllbnRDb250ZXh0O1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMuZXh0cmFIZWFkZXJzID0gKF90aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBfdGhpcy5hcHBsaWNhbnQgPSBhcHBsaWNhbnQ7XG4gICAgICAgIF90aGlzLnRhcmdldCA9IF90aGlzLmluaXRSZWZlclRvKHRhcmdldCk7XG4gICAgICAgIGlmIChfdGhpcy51YSkge1xuICAgICAgICAgICAgX3RoaXMuZXh0cmFIZWFkZXJzLnB1c2goXCJSZWZlcnJlZC1CeTogPFwiICsgX3RoaXMudWEuY29uZmlndXJhdGlvbi51cmkgKyBcIj5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgdGhhdCB0aGlzIGlzIGNvcnJlY3QgaXNjL2ljY1xuICAgICAgICBfdGhpcy5leHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgYXBwbGljYW50LmNvbnRhY3QpO1xuICAgICAgICAvLyB0aGlzIGlzIFVBLkMuQUxMT1dFRF9NRVRIT0RTLCByZW1vdmVkIHRvIGdldCBhcm91bmQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICBfdGhpcy5leHRyYUhlYWRlcnMucHVzaChcIkFsbG93OiBcIiArIFtcbiAgICAgICAgICAgIFwiQUNLXCIsXG4gICAgICAgICAgICBcIkNBTkNFTFwiLFxuICAgICAgICAgICAgXCJJTlZJVEVcIixcbiAgICAgICAgICAgIFwiTUVTU0FHRVwiLFxuICAgICAgICAgICAgXCJCWUVcIixcbiAgICAgICAgICAgIFwiT1BUSU9OU1wiLFxuICAgICAgICAgICAgXCJJTkZPXCIsXG4gICAgICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICAgICAgXCJSRUZFUlwiXG4gICAgICAgIF0udG9TdHJpbmcoKSk7XG4gICAgICAgIF90aGlzLmV4dHJhSGVhZGVycy5wdXNoKFwiUmVmZXItVG86IFwiICsgX3RoaXMudGFyZ2V0KTtcbiAgICAgICAgX3RoaXMuZXJyb3JMaXN0ZW5lciA9IF90aGlzLm9uVHJhbnNwb3J0RXJyb3IuYmluZChfdGhpcyk7XG4gICAgICAgIGlmICh1YS50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHVhLnRyYW5zcG9ydC5vbihcInRyYW5zcG9ydEVycm9yXCIsIF90aGlzLmVycm9yTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVmZXJDbGllbnRDb250ZXh0LnByb3RvdHlwZS5yZWZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAodGhpcy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLmNvbmNhdChvcHRpb25zLmV4dHJhSGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBsaWNhbnQuc2VuZFJlcXVlc3QoQ29uc3RhbnRzXzEuQy5SRUZFUiwge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXNDb2RlID8gcmVzcG9uc2Uuc3RhdHVzQ29kZS50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWZlclJlcXVlc3RQcm9ncmVzc1wiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVmZXJSZXF1ZXN0QWNjZXB0ZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvXls0LTZdWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWZlclJlcXVlc3RSZWplY3RlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSZWZlckNsaWVudENvbnRleHQucHJvdG90eXBlLnJlY2VpdmVOb3RpZnkgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4gY29ycmVjdGx5IGhhbmRsZSB0aGlzLCB0aGVuIHdlIG5lZWQgdG8gc2VuZCBhIDIwMCBPSyFcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5tZXNzYWdlLmhhc0hlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSA/XG4gICAgICAgICAgICByZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuc2VhcmNoKC9ebWVzc2FnZVxcL3NpcGZyYWcvKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlQm9keSA9IGNvcmVfMS5HcmFtbWFyLnBhcnNlKHJlcXVlc3QubWVzc2FnZS5ib2R5LCBcInNpcGZyYWdcIik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUJvZHkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0ODksXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogXCJCYWQgRXZlbnRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgKC9eMVswLTldezJ9JC8udGVzdChtZXNzYWdlQm9keS5zdGF0dXNfY29kZSkpOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWZlclByb2dyZXNzXCIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICgvXjJbMC05XXsyfSQvLnRlc3QobWVzc2FnZUJvZHkuc3RhdHVzX2NvZGUpKTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVmZXJBY2NlcHRlZFwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWN0aXZlQWZ0ZXJUcmFuc2ZlciAmJiB0aGlzLmFwcGxpY2FudC50ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYW50LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlZmVyUmVqZWN0ZWRcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vdGlmeVwiLCByZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QucmVqZWN0KHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQ4OSxcbiAgICAgICAgICAgIHJlYXNvblBocmFzZTogXCJCYWQgRXZlbnRcIlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlZmVyQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuaW5pdFJlZmVyVG8gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBzdHJpbmdPclVSSTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFJFRkVSIHdpdGhvdXQgUmVwbGFjZXMgKEJsaW5kIFRyYW5zZmVyKVxuICAgICAgICAgICAgdmFyIHRhcmdldFN0cmluZyA9IGNvcmVfMS5HcmFtbWFyLnBhcnNlKHRhcmdldCwgXCJSZWZlcl9Ub1wiKTtcbiAgICAgICAgICAgIHN0cmluZ09yVVJJID0gdGFyZ2V0U3RyaW5nICYmIHRhcmdldFN0cmluZy51cmkgPyB0YXJnZXRTdHJpbmcudXJpIDogdGFyZ2V0O1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGFyZ2V0IHZhbGlkaXR5XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VXJpID0gdGhpcy51YS5ub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0VXJpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFyZ2V0OiBcIiArIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmdPclVSSSA9IHRhcmdldFVyaTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJFRkVSIHdpdGggUmVwbGFjZXMgKEF0dGVuZGVkIFRyYW5zZmVyKVxuICAgICAgICAgICAgaWYgKCF0YXJnZXQuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHRhcmdldC5yZW1vdGVJZGVudGl0eS5mcmllbmRseU5hbWU7XG4gICAgICAgICAgICB2YXIgcmVtb3RlVGFyZ2V0ID0gdGFyZ2V0LnNlc3Npb24ucmVtb3RlVGFyZ2V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgY2FsbElkID0gdGFyZ2V0LnNlc3Npb24uY2FsbElkO1xuICAgICAgICAgICAgdmFyIHJlbW90ZVRhZyA9IHRhcmdldC5zZXNzaW9uLnJlbW90ZVRhZztcbiAgICAgICAgICAgIHZhciBsb2NhbFRhZyA9IHRhcmdldC5zZXNzaW9uLmxvY2FsVGFnO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VzID0gZW5jb2RlVVJJQ29tcG9uZW50KGNhbGxJZCArIFwiO3RvLXRhZz1cIiArIHJlbW90ZVRhZyArIFwiO2Zyb20tdGFnPVwiICsgbG9jYWxUYWcpO1xuICAgICAgICAgICAgc3RyaW5nT3JVUkkgPSBcIlxcXCJcIiArIGRpc3BsYXlOYW1lICsgXCJcXFwiIDxcIiArIHJlbW90ZVRhcmdldCArIFwiP1JlcGxhY2VzPVwiICsgcmVwbGFjZXMgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nT3JVUkk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJDbGllbnRDb250ZXh0O1xufShDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dCkpO1xuZXhwb3J0cy5SZWZlckNsaWVudENvbnRleHQgPSBSZWZlckNsaWVudENvbnRleHQ7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbnZhciBSZWZlclNlcnZlckNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVmZXJTZXJ2ZXJDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmVyU2VydmVyQ29udGV4dCh1YSwgaW5jb21pbmdSZXF1ZXN0LCBzZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVhLCBpbmNvbWluZ1JlcXVlc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5SZWZlclNlcnZlckNvbnRleHQ7XG4gICAgICAgIF90aGlzLnVhID0gdWE7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfSU5WSVRFX1JFQ0VJVkVEO1xuICAgICAgICBfdGhpcy5mcm9tVGFnID0gX3RoaXMucmVxdWVzdC5mcm9tVGFnO1xuICAgICAgICBfdGhpcy5pZCA9IF90aGlzLnJlcXVlc3QuY2FsbElkICsgX3RoaXMuZnJvbVRhZztcbiAgICAgICAgX3RoaXMuY29udGFjdCA9IF90aGlzLnVhLmNvbnRhY3QudG9TdHJpbmcoKTtcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKFwic2lwLnJlZmVyc2VydmVyY29udGV4dFwiLCBfdGhpcy5pZCk7XG4gICAgICAgIC8vIE5lZWRlZCB0byBzZW5kIHRoZSBOT1RJRlknc1xuICAgICAgICBfdGhpcy5jc2VxID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICBfdGhpcy5jYWxsSWQgPSBfdGhpcy5yZXF1ZXN0LmNhbGxJZDtcbiAgICAgICAgX3RoaXMuZnJvbVVyaSA9IF90aGlzLnJlcXVlc3QudG8udXJpO1xuICAgICAgICBfdGhpcy5mcm9tVGFnID0gX3RoaXMucmVxdWVzdC50by5wYXJhbWV0ZXJzLnRhZztcbiAgICAgICAgX3RoaXMucmVtb3RlVGFyZ2V0ID0gX3RoaXMucmVxdWVzdC5oZWFkZXJzLkNvbnRhY3RbMF0ucGFyc2VkLnVyaTtcbiAgICAgICAgX3RoaXMudG9VcmkgPSBfdGhpcy5yZXF1ZXN0LmZyb20udXJpO1xuICAgICAgICBfdGhpcy50b1RhZyA9IF90aGlzLnJlcXVlc3QuZnJvbVRhZztcbiAgICAgICAgX3RoaXMucm91dGVTZXQgPSBfdGhpcy5yZXF1ZXN0LmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIik7XG4gICAgICAgIC8vIFJGQyAzNTE1IDIuNC4xXG4gICAgICAgIGlmICghX3RoaXMucmVxdWVzdC5oYXNIZWFkZXIoXCJyZWZlci10b1wiKSkge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJJbnZhbGlkIFJFRkVSIHBhY2tldC4gQSByZWZlci10byBoZWFkZXIgaXMgcmVxdWlyZWQuIFJlamVjdGluZyByZWZlci5cIik7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5yZWZlclRvID0gX3RoaXMucmVxdWVzdC5wYXJzZUhlYWRlcihcInJlZmVyLXRvXCIpO1xuICAgICAgICAvLyBUT0RPOiBNdXN0IHNldCBleHBpcmF0aW9uIHRpbWVyIGFuZCBzZW5kIDIwMiBpZiB0aGVyZSBpcyBubyByZXNwb25zZSBieSB0aGVuXG4gICAgICAgIF90aGlzLnJlZmVycmVkU2Vzc2lvbiA9IF90aGlzLnVhLmZpbmRTZXNzaW9uKF90aGlzLnJlcXVlc3QpO1xuICAgICAgICBpZiAoX3RoaXMucmVxdWVzdC5oYXNIZWFkZXIoXCJyZWZlcnJlZC1ieVwiKSkge1xuICAgICAgICAgICAgX3RoaXMucmVmZXJyZWRCeSA9IF90aGlzLnJlcXVlc3QuZ2V0SGVhZGVyKFwicmVmZXJyZWQtYnlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnJlZmVyVG8udXJpLmhhc0hlYWRlcihcInJlcGxhY2VzXCIpKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXBsYWNlcyA9IF90aGlzLnJlZmVyVG8udXJpLmdldEhlYWRlcihcInJlcGxhY2VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVycm9yTGlzdGVuZXIgPSBfdGhpcy5vblRyYW5zcG9ydEVycm9yLmJpbmQoX3RoaXMpO1xuICAgICAgICBpZiAodWEudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB1YS50cmFuc3BvcnQub24oXCJ0cmFuc3BvcnRFcnJvclwiLCBfdGhpcy5lcnJvckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWZlclNlcnZlckNvbnRleHQucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LnRyeWluZygpO1xuICAgIH07XG4gICAgUmVmZXJTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJSZWplY3RpbmcgcmVmZXJcIik7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWZlclJlcXVlc3RSZWplY3RlZFwiLCB0aGlzKTtcbiAgICB9O1xuICAgIFJlZmVyU2VydmVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG1vZGlmaWVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiAyMDIsXG4gICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiQWNjZXB0ZWRcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVmZXJSZXF1ZXN0QWNjZXB0ZWRcIiwgdGhpcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmZvbGxvd1JlZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJBY2NlcHRlZCByZWZlciwgYXR0ZW1wdGluZyB0byBhdXRvbWF0aWNhbGx5IGZvbGxvdyBpdFwiKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnJlZmVyVG8udXJpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQuc2NoZW1lIHx8ICF0YXJnZXQuc2NoZW1lLm1hdGNoKFwiXnNpcHM/JFwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU0lQLmpzIGNhbiBvbmx5IGF1dG9tYXRpY2FsbHkgZm9sbG93IFNJUCByZWZlciB0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW52aXRlT3B0aW9ucyA9IG9wdGlvbnMuaW52aXRlT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAoaW52aXRlT3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBsYWNlcykge1xuICAgICAgICAgICAgICAgIC8vIGRlY29kZVVSSUNvbXBvbmVudCBpcyBhIGhvbGRvdmVyIGZyb20gMmMwODZlYjQuIE5vdCBzdXJlIHRoYXQgaXQgaXMgYWN0dWFsbHkgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZXBsYWNlczogXCIgKyBkZWNvZGVVUklDb21wb25lbnQodGhpcy5yZXBsYWNlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVmZXJyZWRCeSkge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVmZXJyZWQtQnk6IFwiICsgdGhpcy5yZWZlcnJlZEJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludml0ZU9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICAgICAgdGFyZ2V0LmNsZWFySGVhZGVycygpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTZXNzaW9uID0gdGhpcy51YS5pbnZpdGUodGFyZ2V0LnRvU3RyaW5nKCksIGludml0ZU9wdGlvbnMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWZlckludml0ZVNlbnRcIiwgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTZXNzaW9uLm9uY2UoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlIHx8IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IHJlc3BvbnNlLnJlYXNvblBocmFzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZE5vdGlmeSgoXCJTSVAvMi4wIFwiICsgc3RhdHVzQ29kZSArIFwiIFwiICsgcmVhc29uUGhyYXNlKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVmZXJQcm9ncmVzc1wiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWZlcnJlZFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZmVycmVkU2Vzc2lvbi5lbWl0KFwicmVmZXJQcm9ncmVzc1wiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNlc3Npb24ub25jZShcImFjY2VwdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlN1Y2Nlc3NmdWxseSBmb2xsb3dlZCB0aGUgcmVmZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmROb3RpZnkoXCJTSVAvMi4wIDIwMCBPS1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZmVyQWNjZXB0ZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVmZXJyZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZlcnJlZFNlc3Npb24uZW1pdChcInJlZmVyQWNjZXB0ZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyRmFpbGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBObyB0aHJvdyBoZXJlIGJlY2F1c2UgaXQgaXMgcG9zc2libGUgdGhpcyBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJSZWZlciB3YXMgbm90IHN1Y2Nlc3NmdWwuIFJlc3VtaW5nIHNlc3Npb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJBbGVydGluZyByZWZlcnJlciB0aGF0IGlkZW50aXR5IGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmROb3RpZnkoXCJTSVAvMi4wIDQyOSBQcm92aWRlIFJlZmVycmVyIElkZW50aXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmROb3RpZnkoXCJTSVAvMi4wIDYwMyBEZWNsaW5lZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBjaGFuZ2UgdGhlIHN0YXR1cyBhZnRlciBzZW5kaW5nIHRoZSBmaW5hbCBOb3RpZnkgb3IgaXQgd2lsbCBub3Qgc2VuZCBkdWUgdG8gY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVmZXJSZWplY3RlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWZlcnJlZFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZmVycmVkU2Vzc2lvbi5lbWl0KFwicmVmZXJSZWplY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTZXNzaW9uLm9uY2UoXCJyZWplY3RlZFwiLCByZWZlckZhaWxlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTZXNzaW9uLm9uY2UoXCJmYWlsZWRcIiwgcmVmZXJGYWlsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiQWNjZXB0ZWQgcmVmZXIsIGJ1dCBkaWQgbm90IGF1dG9tYXRpY2FsbHkgZm9sbG93IGl0XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZ5KFwiU0lQLzIuMCAyMDAgT0tcIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWZlckFjY2VwdGVkXCIsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmZXJyZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcnJlZFNlc3Npb24uZW1pdChcInJlZmVyQWNjZXB0ZWRcIiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZmVyU2VydmVyQ29udGV4dC5wcm90b3R5cGUuc2VuZE5vdGlmeSA9IGZ1bmN0aW9uIChib2R5U3RyKSB7XG4gICAgICAgIC8vIEZJWE1FOiBQb3J0ZWQgdGhpcy4gQ2xlYW4gaXQgdXAuIFNlc3Npb24ga25vd3MgaXRzIHN0YXRlLlxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcmVfMS5HcmFtbWFyLnBhcnNlKGJvZHlTdHIsIFwic2lwZnJhZ1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNpcGZyYWcgYm9keSBpcyByZXF1aXJlZCB0byBzZW5kIG5vdGlmeSBmb3IgcmVmZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSB7XG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IFwicmVuZGVyXCIsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJtZXNzYWdlL3NpcGZyYWdcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlTdHJcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3RzIHNlbnQgaW4gc2FtZSBkaWFsb2cgYXMgaW4gZGlhbG9nIFJFRkVSLlxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ubm90aWZ5KHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBcIkV2ZW50OiByZWZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcIlN1YnNjcmlwdGlvbi1TdGF0ZTogdGVybWluYXRlZFwiLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGltcGxpY2l0IHN1YnNjcmlwdGlvbiBjcmVhdGVkIGJ5IGEgUkVGRVIgaXMgdGhlIHNhbWUgYXMgYVxuICAgICAgICAvLyBzdWJzY3JpcHRpb24gY3JlYXRlZCB3aXRoIGEgU1VCU0NSSUJFIHJlcXVlc3QuICBUaGUgYWdlbnQgaXNzdWluZyB0aGVcbiAgICAgICAgLy8gUkVGRVIgY2FuIHRlcm1pbmF0ZSB0aGlzIHN1YnNjcmlwdGlvbiBwcmVtYXR1cmVseSBieSB1bnN1YnNjcmliaW5nXG4gICAgICAgIC8vIHVzaW5nIHRoZSBtZWNoYW5pc21zIGRlc2NyaWJlZCBpbiBbMl0uICBUZXJtaW5hdGluZyBhIHN1YnNjcmlwdGlvbixcbiAgICAgICAgLy8gZWl0aGVyIGJ5IGV4cGxpY2l0bHkgdW5zdWJzY3JpYmluZyBvciByZWplY3RpbmcgTk9USUZZLCBpcyBub3QgYW5cbiAgICAgICAgLy8gaW5kaWNhdGlvbiB0aGF0IHRoZSByZWZlcmVuY2VkIHJlcXVlc3Qgc2hvdWxkIGJlIHdpdGhkcmF3biBvclxuICAgICAgICAvLyBhYmFuZG9uZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjRcbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3RzIHNlbnQgaW4gbmV3IGRpYWxvZyBmb3Igb3V0IG9mIGRpYWxvZyBSRUZFUi5cbiAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIGJlIGRvbmUgaW4gYSBzdWJzY3JpYmUgZGlhbG9nIHRvIHNhdGlzZnkgdGhlIGFib3ZlLlxuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMudWEudXNlckFnZW50Q29yZS5tYWtlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShDb25zdGFudHNfMS5DLk5PVElGWSwgdGhpcy5yZW1vdGVUYXJnZXQsIHRoaXMuZnJvbVVyaSwgdGhpcy50b1VyaSwge1xuICAgICAgICAgICAgY3NlcTogdGhpcy5jc2VxICs9IDEsXG4gICAgICAgICAgICBjYWxsSWQ6IHRoaXMuY2FsbElkLFxuICAgICAgICAgICAgZnJvbVRhZzogdGhpcy5mcm9tVGFnLFxuICAgICAgICAgICAgdG9UYWc6IHRoaXMudG9UYWcsXG4gICAgICAgICAgICByb3V0ZVNldDogdGhpcy5yb3V0ZVNldFxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBcIkV2ZW50OiByZWZlclwiLFxuICAgICAgICAgICAgXCJTdWJzY3JpcHRpb24tU3RhdGU6IHRlcm1pbmF0ZWRcIixcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlOiBtZXNzYWdlL3NpcGZyYWdcIlxuICAgICAgICBdLCBib2R5KTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudWEudHJhbnNwb3J0O1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZXIgPSB7XG4gICAgICAgICAgICBsb2dnZXJGYWN0b3J5OiB0aGlzLnVhLmdldExvZ2dlckZhY3RvcnkoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmljID0gbmV3IGNvcmVfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbihyZXF1ZXN0LCB0cmFuc3BvcnQsIHVzZXIpO1xuICAgIH07XG4gICAgUmVmZXJTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykgeyByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIG5hbWUsIGNhbGxiYWNrKTsgfTtcbiAgICByZXR1cm4gUmVmZXJTZXJ2ZXJDb250ZXh0O1xufShTZXJ2ZXJDb250ZXh0XzEuU2VydmVyQ29udGV4dCkpO1xuZXhwb3J0cy5SZWZlclNlcnZlckNvbnRleHQgPSBSZWZlclNlcnZlckNvbnRleHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIENsaWVudENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NsaWVudENvbnRleHRcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uc1wiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gbG9hZC5cbiAqIEBwcml2YXRlXG4gKiByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGxvYWRDb25maWcoY29uZmlndXJhdGlvbikge1xuICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgZXhwaXJlczogNjAwLFxuICAgICAgICBleHRyYUNvbnRhY3RIZWFkZXJQYXJhbXM6IFtdLFxuICAgICAgICBpbnN0YW5jZUlkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHJlZ0lkOiB1bmRlZmluZWQsXG4gICAgICAgIHJlZ2lzdHJhcjogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgdmFyIGNvbmZpZ0NoZWNrID0gZ2V0Q29uZmlndXJhdGlvbkNoZWNrKCk7XG4gICAgLy8gQ2hlY2sgTWFuZGF0b3J5IHBhcmFtZXRlcnNcbiAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gY29uZmlnQ2hlY2subWFuZGF0b3J5KSB7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG4gICAgICAgICAgICB2YXIgY2hlY2tlZFZhbHVlID0gY29uZmlnQ2hlY2subWFuZGF0b3J5W3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBjb25maWdDaGVjay5vcHRpb25hbCkge1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5LCBidXQgc2hvdWxkbid0IGJlLCBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBudWxsLCBlbXB0eSBzdHJpbmcsIG9yIHVuZGVmaW5lZCB0aGVuIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgLy8gSWYgaXQncyBhIG51bWJlciB3aXRoIE5hTiB2YWx1ZSB0aGVuIGFsc28gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAvLyBOT1RFOiBKUyBkb2VzIG5vdCBhbGxvdyBcInZhbHVlID09PSBOYU5cIiwgdGhlIGZvbGxvd2luZyBkb2VzIHRoZSB3b3JrOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoZWNrZWRWYWx1ZSA9IGNvbmZpZ0NoZWNrLm9wdGlvbmFsW3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzO1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbkNoZWNrKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmRhdG9yeToge30sXG4gICAgICAgIG9wdGlvbmFsOiB7XG4gICAgICAgICAgICBleHBpcmVzOiBmdW5jdGlvbiAoZXhwaXJlcykge1xuICAgICAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChleHBpcmVzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBOdW1iZXIoZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXh0cmFDb250YWN0SGVhZGVyUGFyYW1zOiBmdW5jdGlvbiAoZXh0cmFDb250YWN0SGVhZGVyUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQ29udGFjdEhlYWRlclBhcmFtcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRyYUNvbnRhY3RIZWFkZXJQYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChjb250YWN0SGVhZGVyUGFyYW0pIHsgcmV0dXJuICh0eXBlb2YgY29udGFjdEhlYWRlclBhcmFtID09PSBcInN0cmluZ1wiKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgvXnV1aWQ6L2kudGVzdChpbnN0YW5jZUlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQuc3Vic3RyKDUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29yZV8xLkdyYW1tYXIucGFyc2UoaW5zdGFuY2VJZCwgXCJ1dWlkXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnSWQ6IGZ1bmN0aW9uIChyZWdJZCkge1xuICAgICAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChyZWdJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHJlZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RyYXI6IGZ1bmN0aW9uIChyZWdpc3RyYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdHJhciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghL15zaXA6L2kudGVzdChyZWdpc3RyYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJhciA9IENvbnN0YW50c18xLkMuU0lQICsgXCI6XCIgKyByZWdpc3RyYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBjb3JlXzEuR3JhbW1hci5VUklQYXJzZShyZWdpc3RyYXIpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VkLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIFJlZ2lzdGVyQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWdpc3RlckNvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVnaXN0ZXJDb250ZXh0KHVhLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IGxvYWRDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZWdJZCAmJiAhc2V0dGluZ3MuaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuaW5zdGFuY2VJZCA9IFV0aWxzXzEuVXRpbHMubmV3VVVJRCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzZXR0aW5ncy5yZWdJZCAmJiBzZXR0aW5ncy5pbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5yZWdJZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3MucGFyYW1zLnRvVXJpID0gc2V0dGluZ3MucGFyYW1zLnRvVXJpIHx8IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuICAgICAgICBzZXR0aW5ncy5wYXJhbXMudG9EaXNwbGF5TmFtZSA9IHNldHRpbmdzLnBhcmFtcy50b0Rpc3BsYXlOYW1lIHx8IHVhLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWU7XG4gICAgICAgIHNldHRpbmdzLnBhcmFtcy5jYWxsSWQgPSBzZXR0aW5ncy5wYXJhbXMuY2FsbElkIHx8IFV0aWxzXzEuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMjIpO1xuICAgICAgICBzZXR0aW5ncy5wYXJhbXMuY3NlcSA9IHNldHRpbmdzLnBhcmFtcy5jc2VxIHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgLyogSWYgbm8gJ3JlZ2lzdHJhclNlcnZlcicgaXMgc2V0IHVzZSB0aGUgJ3VyaScgdmFsdWUgd2l0aG91dCB1c2VyIHBvcnRpb24uICovXG4gICAgICAgIGlmICghc2V0dGluZ3MucmVnaXN0cmFyKSB7XG4gICAgICAgICAgICB2YXIgcmVnaXN0cmFyU2VydmVyID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVhLmNvbmZpZ3VyYXRpb24udXJpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0cmFyU2VydmVyID0gdWEuY29uZmlndXJhdGlvbi51cmkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICByZWdpc3RyYXJTZXJ2ZXIudXNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJhclNlcnZlciA9IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0dGluZ3MucmVnaXN0cmFyID0gcmVnaXN0cmFyU2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdWEsIENvbnN0YW50c18xLkMuUkVHSVNURVIsIHNldHRpbmdzLnJlZ2lzdHJhciwgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlJlZ2lzdGVyQ29udGV4dDtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHNldHRpbmdzO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoXCJzaXAucmVnaXN0ZXJjb250ZXh0XCIpO1xuICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciBSZWdpc3RlckNvbnRleHQgYWZ0ZXIgdmFsaWRhdGlvbjpcIik7XG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBwYXJhbWV0ZXIgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShzZXR0aW5nc1twYXJhbWV0ZXJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVnaXN0cmF0aW9uIGV4cGlyZXNcbiAgICAgICAgX3RoaXMuZXhwaXJlcyA9IHNldHRpbmdzLmV4cGlyZXM7XG4gICAgICAgIC8vIENvbnRhY3QgaGVhZGVyXG4gICAgICAgIF90aGlzLmNvbnRhY3QgPSB1YS5jb250YWN0LnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIFNldCBzdGF0dXNcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB1YS50cmFuc3BvcnQub24oXCJkaXNjb25uZWN0ZWRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25UcmFuc3BvcnREaXNjb25uZWN0ZWQoKTsgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIEhhbmRsZSBPcHRpb25zXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAodGhpcy5vcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuZ2VuZXJhdGVDb250YWN0SGVhZGVyKHRoaXMuZXhwaXJlcykpO1xuICAgICAgICAvLyB0aGlzIGlzIFVBLkMuQUxMT1dFRF9NRVRIT0RTLCByZW1vdmVkIHRvIGdldCBhcm91bmQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkFsbG93OiBcIiArIFtcbiAgICAgICAgICAgIFwiQUNLXCIsXG4gICAgICAgICAgICBcIkNBTkNFTFwiLFxuICAgICAgICAgICAgXCJJTlZJVEVcIixcbiAgICAgICAgICAgIFwiTUVTU0FHRVwiLFxuICAgICAgICAgICAgXCJCWUVcIixcbiAgICAgICAgICAgIFwiT1BUSU9OU1wiLFxuICAgICAgICAgICAgXCJJTkZPXCIsXG4gICAgICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICAgICAgXCJSRUZFUlwiXG4gICAgICAgIF0udG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgZXh0cmFIZWFkZXJzIHRvIGJlIHVzZWQgaW4gLmNsb3NlXG4gICAgICAgIHRoaXMuY2xvc2VIZWFkZXJzID0gdGhpcy5vcHRpb25zLmNsb3NlV2l0aEhlYWRlcnMgP1xuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgcmVzcG9uc2VzIHRvIG9sZGVyIFJFR0lTVEVSL3VuLVJFR0lTVEVSIHJlcXVlc3RzLlxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNzZXEgIT09IF90aGlzLnJlcXVlc3QuY3NlcSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFyIHJlZ2lzdHJhdGlvbiB0aW1lclxuICAgICAgICAgICAgaWYgKF90aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSAocmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYWNjZXB0ZWRcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwaXJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhhc0hlYWRlcihcImV4cGlyZXNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSBOdW1iZXIocmVzcG9uc2UuZ2V0SGVhZGVyKFwiZXhwaXJlc1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdGhlIENvbnRhY3QgcG9pbnRpbmcgdG8gdXMgYW5kIHVwZGF0ZSB0aGUgZXhwaXJlcyB2YWx1ZSBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RzID0gcmVzcG9uc2UuZ2V0SGVhZGVycyhcImNvbnRhY3RcIikubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIm5vIENvbnRhY3QgaGVhZGVyIGluIHJlc3BvbnNlIHRvIFJFR0lTVEVSLCByZXNwb25zZSBpZ25vcmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb250YWN0cy0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0ID0gcmVzcG9uc2UucGFyc2VIZWFkZXIoXCJjb250YWN0XCIsIGNvbnRhY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LnVyaS51c2VyID09PSBfdGhpcy51YS5jb250YWN0LnVyaS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9IGNvbnRhY3QuZ2V0UGFyYW0oXCJleHBpcmVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwibm8gQ29udGFjdCBoZWFkZXIgcG9pbnRpbmcgdG8gdXMsIHJlc3BvbnNlIGlnbm9yZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwaXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gX3RoaXMuZXhwaXJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZS1SZWdpc3RlciBiZWZvcmUgdGhlIGV4cGlyYXRpb24gaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGF0LCBkZWNyZWFzZSB0aGUgZXhwaXJlcyB2YWx1ZS4gaWU6IDMgc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RlcihfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGV4cGlyZXMgKiAxMDAwKSAtIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwicmVnaXN0cmF0aW9uIGV4cGlyZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVucmVnaXN0ZXJlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBleHBpcmVzICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgZ3J1dSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuaGFzUGFyYW0oXCJ0ZW1wLWdydXVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVhLmNvbnRhY3QudGVtcEdydXUgPSBjb3JlXzEuR3JhbW1hci5VUklQYXJzZShjb250YWN0LmdldFBhcmFtKFwidGVtcC1ncnV1XCIpLnJlcGxhY2UoL1wiL2csIFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5oYXNQYXJhbShcInB1Yi1ncnV1XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51YS5jb250YWN0LnB1YkdydXUgPSBjb3JlXzEuR3JhbW1hci5VUklQYXJzZShjb250YWN0LmdldFBhcmFtKFwicHViLWdydXVcIikucmVwbGFjZSgvXCIvZywgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVnaXN0ZXJlZFwiLCByZXNwb25zZSB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBJbnRlcnZhbCB0b28gYnJpZWYgUkZDMzI2MSAxMC4yLjhcbiAgICAgICAgICAgICAgICBjYXNlIC9eNDIzJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhhc0hlYWRlcihcIm1pbi1leHBpcmVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZWFzZSBvdXIgcmVnaXN0cmF0aW9uIGludGVydmFsIHRvIHRoZSBzdWdnZXN0ZWQgbWluaW11bVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXhwaXJlcyA9IE51bWJlcihyZXNwb25zZS5nZXRIZWFkZXIoXCJtaW4tZXhwaXJlc1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRoZSByZWdpc3RyYXRpb24gYWdhaW4gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyKF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBUaGlzIHJlc3BvbnNlIE1VU1QgY29udGFpbiBhIE1pbi1FeHBpcmVzIGhlYWRlciBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCI0MjMgcmVzcG9uc2UgcmVjZWl2ZWQgZm9yIFJFR0lTVEVSIHdpdGhvdXQgTWluLUV4cGlyZXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHJlc3BvbnNlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5TSVBfRkFJTFVSRV9DT0RFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHJlc3BvbnNlLCBVdGlsc18xLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVxdWVzdC5jc2VxKys7XG4gICAgICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoXCJjc2VxXCIsIHRoaXMucmVxdWVzdC5jc2VxICsgXCIgUkVHSVNURVJcIik7XG4gICAgICAgIHRoaXMucmVxdWVzdC5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH07XG4gICAgUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGw6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiB0aGlzLmNsb3NlSGVhZGVyc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRCZWZvcmUgPSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlcihvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyZWQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQWxyZWFkeSB1bnJlZ2lzdGVyZWQsIGJ1dCBzZW5kaW5nIGFuIHVucmVnaXN0ZXIgYW55d2F5cy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgIC8vIENsZWFyIHRoZSByZWdpc3RyYXRpb24gdGltZXIuXG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6ICpcIik7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5nZW5lcmF0ZUNvbnRhY3RIZWFkZXIoMCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IChyZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXNDb2RlKSA/IHJlc3BvbnNlLnN0YXR1c0NvZGUudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInByb2dyZXNzXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJhY2NlcHRlZFwiLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5yZWdpc3RlcmVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5yZWdpc3RlcmVkKHJlc3BvbnNlLCBVdGlsc18xLlV0aWxzLnNpcEVycm9yQ2F1c2UocmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vdCBhY3R1YWxseSB1bnJlZ2lzdGVyZWQuLi5cbiAgICAgICAgICAgIC8vIHRoaXMudW5yZWdpc3RlcmVkKHVuZGVmaW5lZCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVxdWVzdC5jc2VxKys7XG4gICAgICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoXCJjc2VxXCIsIHRoaXMucmVxdWVzdC5jc2VxICsgXCIgUkVHSVNURVJcIik7XG4gICAgICAgIHRoaXMucmVxdWVzdC5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH07XG4gICAgUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZS51bnJlZ2lzdGVyZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1bnJlZ2lzdGVyZWRcIiwgcmVzcG9uc2UgfHwgdW5kZWZpbmVkLCBjYXVzZSB8fCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgUmVnaXN0ZXJDb250ZXh0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnVhLnVzZXJBZ2VudENvcmUucmVnaXN0ZXIodGhpcy5yZXF1ZXN0LCB7XG4gICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25Ucnlpbmc6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUucmVnaXN0cmF0aW9uRmFpbHVyZSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY2F1c2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHJlc3BvbnNlIHx8IHVuZGVmaW5lZCwgY2F1c2UgfHwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnREaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEJlZm9yZSA9IHRoaXMucmVnaXN0ZXJlZDtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBGdW5jdGlvbiB0byBnZW5lcmF0ZSBDb250YWN0IEhlYWRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUuZ2VuZXJhdGVDb250YWN0SGVhZGVyID0gZnVuY3Rpb24gKGV4cGlyZXMpIHtcbiAgICAgICAgaWYgKGV4cGlyZXMgPT09IHZvaWQgMCkgeyBleHBpcmVzID0gMDsgfVxuICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMuY29udGFjdDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWdJZCAmJiB0aGlzLm9wdGlvbnMuaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgY29udGFjdCArPSBcIjtyZWctaWQ9XCIgKyB0aGlzLm9wdGlvbnMucmVnSWQ7XG4gICAgICAgICAgICBjb250YWN0ICs9ICc7K3NpcC5pbnN0YW5jZT1cIjx1cm46dXVpZDonICsgdGhpcy5vcHRpb25zLmluc3RhbmNlSWQgKyAnPlwiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dHJhQ29udGFjdEhlYWRlclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dHJhQ29udGFjdEhlYWRlclBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0ICs9IFwiO1wiICsgaGVhZGVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFjdCArPSBcIjtleHBpcmVzPVwiICsgZXhwaXJlcztcbiAgICAgICAgcmV0dXJuIGNvbnRhY3Q7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnaXN0ZXJDb250ZXh0O1xufShDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dCkpO1xuZXhwb3J0cy5SZWdpc3RlckNvbnRleHQgPSBSZWdpc3RlckNvbnRleHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG52YXIgU2VydmVyQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTZXJ2ZXJDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcnZlckNvbnRleHQodWEsIGluY29taW5nUmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmNvbWluZ1JlcXVlc3QgPSBpbmNvbWluZ1JlcXVlc3Q7XG4gICAgICAgIF90aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgU2VydmVyQ29udGV4dC5pbml0aWFsaXplcihfdGhpcywgdWEsIGluY29taW5nUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gaGFjayB0byBnZXQgYXJvdW5kIG91ciBtdWx0aXBsZSBpbmhlcml0YW5jZSBpc3N1ZXNcbiAgICBTZXJ2ZXJDb250ZXh0LmluaXRpYWxpemVyID0gZnVuY3Rpb24gKG9iamVjdFRvQ29uc3RydWN0LCB1YSwgaW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2U7XG4gICAgICAgIG9iamVjdFRvQ29uc3RydWN0LnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlcnZlckNvbnRleHQ7XG4gICAgICAgIG9iamVjdFRvQ29uc3RydWN0LnVhID0gdWE7XG4gICAgICAgIG9iamVjdFRvQ29uc3RydWN0LmxvZ2dlciA9IHVhLmdldExvZ2dlcihcInNpcC5zZXJ2ZXJjb250ZXh0XCIpO1xuICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgICAgICAgICAgb2JqZWN0VG9Db25zdHJ1Y3QuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5oYXNIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdFRvQ29uc3RydWN0LmNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0VG9Db25zdHJ1Y3QubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIG9iamVjdFRvQ29uc3RydWN0LmxvY2FsSWRlbnRpdHkgPSByZXF1ZXN0LnRvO1xuICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC5yZW1vdGVJZGVudGl0eSA9IHJlcXVlc3QuZnJvbTtcbiAgICAgICAgdmFyIGhhc0Fzc2VydGVkSWRlbnRpdHkgPSByZXF1ZXN0Lmhhc0hlYWRlcihcIlAtQXNzZXJ0ZWQtSWRlbnRpdHlcIik7XG4gICAgICAgIGlmIChoYXNBc3NlcnRlZElkZW50aXR5KSB7XG4gICAgICAgICAgICB2YXIgYXNzZXJ0ZWRJZGVudGl0eSA9IHJlcXVlc3QuZ2V0SGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKTtcbiAgICAgICAgICAgIGlmIChhc3NlcnRlZElkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0VG9Db25zdHJ1Y3QuYXNzZXJ0ZWRJZGVudGl0eSA9IGNvcmVfMS5HcmFtbWFyLm5hbWVBZGRySGVhZGVyUGFyc2UoYXNzZXJ0ZWRJZGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlcnZlckNvbnRleHQucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgb3B0aW9ucy5zdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MDtcbiAgICAgICAgb3B0aW9ucy5taW5Db2RlID0gMTAwO1xuICAgICAgICBvcHRpb25zLm1heENvZGUgPSAxOTk7XG4gICAgICAgIG9wdGlvbnMuZXZlbnRzID0gW1wicHJvZ3Jlc3NcIl07XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2VydmVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgb3B0aW9ucy5zdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDIwMDtcbiAgICAgICAgb3B0aW9ucy5taW5Db2RlID0gMjAwO1xuICAgICAgICBvcHRpb25zLm1heENvZGUgPSAyOTk7XG4gICAgICAgIG9wdGlvbnMuZXZlbnRzID0gW1wiYWNjZXB0ZWRcIl07XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgb3B0aW9ucy5zdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDQ4MDtcbiAgICAgICAgb3B0aW9ucy5taW5Db2RlID0gMzAwO1xuICAgICAgICBvcHRpb25zLm1heENvZGUgPSA2OTk7XG4gICAgICAgIG9wdGlvbnMuZXZlbnRzID0gW1wicmVqZWN0ZWRcIiwgXCJmYWlsZWRcIl07XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVwbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxMDA7XG4gICAgICAgIHZhciBtaW5Db2RlID0gb3B0aW9ucy5taW5Db2RlIHx8IDEwMDtcbiAgICAgICAgdmFyIG1heENvZGUgPSBvcHRpb25zLm1heENvZGUgfHwgNjk5O1xuICAgICAgICB2YXIgcmVhc29uUGhyYXNlID0gVXRpbHNfMS5VdGlscy5nZXRSZWFzb25QaHJhc2Uoc3RhdHVzQ29kZSwgb3B0aW9ucy5yZWFzb25QaHJhc2UpO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5ID8gY29yZV8xLmZyb21Cb2R5TGVnYWN5KG9wdGlvbnMuYm9keSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCBtaW5Db2RlIHx8IHN0YXR1c0NvZGUgPiBtYXhDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgcmVhc29uUGhyYXNlOiByZWFzb25QaHJhc2UsXG4gICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZVN0cmluZyA9IHN0YXR1c0NvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlU3RyaW5nKTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuaW5jb21pbmdSZXF1ZXN0LnRyeWluZyhyZXNwb25zZU9wdGlvbnMpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlU3RyaW5nKTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuaW5jb21pbmdSZXF1ZXN0LnByb2dyZXNzKHJlc3BvbnNlT3B0aW9ucykubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGVTdHJpbmcpOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5pbmNvbWluZ1JlcXVlc3QuYWNjZXB0KHJlc3BvbnNlT3B0aW9ucykubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14zWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGVTdHJpbmcpOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5pbmNvbWluZ1JlcXVlc3QucmVkaXJlY3QoW10sIHJlc3BvbnNlT3B0aW9ucykubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL15bNC02XVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlU3RyaW5nKTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuaW5jb21pbmdSZXF1ZXN0LnJlamVjdChyZXNwb25zZU9wdGlvbnMpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoZXZlbnQsIHJlc3BvbnNlLCByZWFzb25QaHJhc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgdW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH07XG4gICAgU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfTtcbiAgICByZXR1cm4gU2VydmVyQ29udGV4dDtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlNlcnZlckNvbnRleHQgPSBTZXJ2ZXJDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgQ2xpZW50Q29udGV4dF8xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29udGV4dFwiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbnZhciBFeGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25zXCIpO1xudmFyIFJlZmVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vUmVmZXJDb250ZXh0XCIpO1xudmFyIFNlcnZlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1NlcnZlckNvbnRleHRcIik7XG52YXIgRFRNRl8xID0gcmVxdWlyZShcIi4vU2Vzc2lvbi9EVE1GXCIpO1xudmFyIERUTUZWYWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuL1Nlc3Npb24vRFRNRlZhbGlkYXRvclwiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG4vKlxuICogQHBhcmFtIHtmdW5jdGlvbiByZXR1cm5pbmcgU0lQLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJ9IFtzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeV1cbiAqICAgICAgICAoU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkgYXJndW1lbnQgb2YgdGhlIFVBIGNvbnN0cnVjdG9yLilcbiAqL1xudmFyIFNlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Vzc2lvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXNzaW9uKHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbjtcbiAgICAgICAgaWYgKCFzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcIkEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGlzIHJlcXVpcmVkIGZvciB0aGUgc2Vzc2lvbiB0byBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zdGF0dXMgPSBTZXNzaW9uLkMuU1RBVFVTX05VTEw7XG4gICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSA9IHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5O1xuICAgICAgICBfdGhpcy5oYXNPZmZlciA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5oYXNBbnN3ZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gU2Vzc2lvbiBUaW1lcnNcbiAgICAgICAgX3RoaXMudGltZXJzID0ge1xuICAgICAgICAgICAgYWNrVGltZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4cGlyZXNUaW1lcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW52aXRlMnh4VGltZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVzZXJOb0Fuc3dlclRpbWVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWwxeHhUaW1lcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJhY2tUaW1lcjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNlc3Npb24gaW5mb1xuICAgICAgICBfdGhpcy5zdGFydFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmVuZFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnRvbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBIb2xkIHN0YXRlXG4gICAgICAgIF90aGlzLmxvY2FsSG9sZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5lYXJseVNkcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMucmVsMTAwID0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZHRtZiA9IGZ1bmN0aW9uICh0b25lcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0b25lcycgdmFsaWRpdHlcbiAgICAgICAgRFRNRlZhbGlkYXRvcl8xLkRUTUZWYWxpZGF0b3IudmFsaWRhdGUodG9uZXMpO1xuICAgICAgICB2YXIgc2VuZERUTUYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQgfHwgIV90aGlzLnRvbmVzIHx8IF90aGlzLnRvbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFN0b3Agc2VuZGluZyBEVE1GXG4gICAgICAgICAgICAgICAgX3RoaXMudG9uZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR0bWYgPSBfdGhpcy50b25lcy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAoZHRtZi50b25lID09PSBcIixcIikge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZHRtZi5vbihcImZhaWxlZFwiLCBmdW5jdGlvbiAoKSB7IF90aGlzLnRvbmVzID0gdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgICAgICAgICBkdG1mLnNlbmQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IGR0bWYuZHVyYXRpb24gKyBkdG1mLmludGVyVG9uZUdhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aW1lb3V0IGZvciB0aGUgbmV4dCB0b25lXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHNlbmREVE1GLCB0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdG9uZXMgPSB0b25lcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgZHRtZlR5cGUgPSB0aGlzLnVhLmNvbmZpZ3VyYXRpb24uZHRtZlR5cGU7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgJiYgZHRtZlR5cGUgPT09IENvbnN0YW50c18xLkMuZHRtZlR5cGUuUlRQKSB7XG4gICAgICAgICAgICB2YXIgc2VudCA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5zZW5kRHRtZih0b25lcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQXR0ZW1wdCB0byB1c2UgZHRtZlR5cGUgJ1JUUCcgaGFzIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIElORk8gcGFja2V0IG1ldGhvZFwiKTtcbiAgICAgICAgICAgICAgICBkdG1mVHlwZSA9IENvbnN0YW50c18xLkMuZHRtZlR5cGUuSU5GTztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHRtZlR5cGUgPT09IENvbnN0YW50c18xLkMuZHRtZlR5cGUuSU5GTykge1xuICAgICAgICAgICAgdmFyIGR0bWZzID0gW107XG4gICAgICAgICAgICB2YXIgdG9uZXNBcnJheSA9IHRvbmVzLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgd2hpbGUgKHRvbmVzQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGR0bWZzLnB1c2gobmV3IERUTUZfMS5EVE1GKHRoaXMsIHRvbmVzQXJyYXkuc2hpZnQoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50b25lcykgJiYgdGhpcy50b25lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUb25lcyBhcmUgYWxyZWFkeSBxdWV1ZWQsIGp1c3QgYWRkIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgIHRoaXMudG9uZXMgPSB0aGlzLnRvbmVzLmNvbmNhdChkdG1mcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvbmVzID0gZHRtZnM7XG4gICAgICAgICAgICBzZW5kRFRNRigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuYnllID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRXJyb3I6IEF0dGVtcHRlZCB0byBzZW5kIEJZRSBpbiBhIHRlcm1pbmF0ZWQgc2Vzc2lvbi5cIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJ0ZXJtaW5hdGluZyBTZXNzaW9uXCIpO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgJiYgKHN0YXR1c0NvZGUgPCAyMDAgfHwgc3RhdHVzQ29kZSA+PSA3MDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdChDb25zdGFudHNfMS5DLkJZRSwgb3B0aW9ucykudGVybWluYXRlZCgpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVmZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZlckNvbnRleHQgPSBuZXcgUmVmZXJDb250ZXh0XzEuUmVmZXJDbGllbnRDb250ZXh0KHRoaXMudWEsIHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdChcInJlZmVyUmVxdWVzdGVkXCIsIHRoaXMucmVmZXJDb250ZXh0KTtcbiAgICAgICAgdGhpcy5yZWZlckNvbnRleHQucmVmZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyQ29udGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGluIGRpYWxvZyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBtZXRob2QgUmVxdWVzdCBtZXRob2QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCBhbnkgXCJib2R5XCIgb3B0aW9uIHRvIGEgQm9keS5cbiAgICAgICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaihvcHRpb25zLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgYW55IFwicmVjZWl2ZVJlc3BvbnNlXCIgY2FsbGJhY2sgb3B0aW9uIHBhc3NlZCB0byBhbiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZS5cbiAgICAgICAgdmFyIGRlbGVnYXRlO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLnJlY2VpdmVSZXNwb25zZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBjYWxsYmFjayhyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIGNhbGxiYWNrKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gY2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gY2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICAgICAgb25Ucnlpbmc6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gY2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3Q7XG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuQllFOlxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnNlc3Npb24uYnllKGRlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuSU5WSVRFOlxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnNlc3Npb24uaW52aXRlKGRlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuTUVTU0FHRTpcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zZXNzaW9uLm1lc3NhZ2UoZGVsZWdhdGUsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5SRUZFUjpcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zZXNzaW9uLnJlZmVyKGRlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBtZXRob2QgKyBcIi4gTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBieSB1c2VyIGFnZW50IGNvcmUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcnRlZCAtIEVtaXQgdGhlIHJlcXVlc3QgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KG1ldGhvZC50b0xvd2VyQ2FzZSgpLCByZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiY2xvc2luZyBJTlZJVEUgc2Vzc2lvbiBcIiArIHRoaXMuaWQpO1xuICAgICAgICAvLyAxc3QgU3RlcC4gVGVybWluYXRlIG1lZGlhLlxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAybmQgU3RlcC4gVGVybWluYXRlIHNpZ25hbGluZy5cbiAgICAgICAgLy8gQ2xlYXIgc2Vzc2lvbiB0aW1lcnNcbiAgICAgICAgZm9yICh2YXIgdGltZXIgaW4gdGhpcy50aW1lcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyc1t0aW1lcl0pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnNbdGltZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRDtcbiAgICAgICAgaWYgKHRoaXMudWEudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnVhLnRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInRyYW5zcG9ydEVycm9yXCIsIHRoaXMuZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuaG9sZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IFtdOyB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiYgdGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsSG9sZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbiBpcyBhbHJlYWR5IG9uIGhvbGQsIGNhbm5vdCBwdXQgaXQgb24gaG9sZCBhZ2FpblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5tb2RpZmllcnMucHVzaCh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuaG9sZE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsSG9sZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudW5ob2xkID0gZnVuY3Rpb24gKG9wdGlvbnMsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gW107IH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyAmJiB0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsSG9sZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbiBpcyBub3Qgb24gaG9sZCwgY2Fubm90IHVuaG9sZCBpdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgdGhpcy5sb2NhbEhvbGQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kUmVpbnZpdGUob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWludml0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IFtdOyB9XG4gICAgICAgIG9wdGlvbnMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVpbnZpdGUob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBoZXJlIGZvciB0eXBlcyBhbmQgdG8gYmUgb3ZlcnJpZGRlblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vbkRpYWxvZ0Vycm9yID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vbkFjayA9IGZ1bmN0aW9uIChpbmNvbWluZ1JlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpcm1TZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnREaXNwID0gaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50RGlzcCAmJiBjb250ZW50RGlzcC50eXBlID09PSBcInJlbmRlclwiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyYm9keSA9IGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmJvZHk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVydHlwZSA9IGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJjb25maXJtZWRcIiwgaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmhhc0Rlc2NyaXB0aW9uKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuc2V0RGVzY3JpcHRpb24oaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuYm9keSwgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgdGhpcy5tb2RpZmllcnMpLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogXCI0ODhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmFpbGVkKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlybVNlc3Npb24oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maXJtU2Vzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIChpbmNvbWluZ1JlcXVlc3QpIHtcbiAgICAgICAgc3dpdGNoIChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5tZXRob2QpIHsgLy8gVE9ETzogVGhpcyBuZWVkcyBhIGRlZmF1bHQgY2FzZVxuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLkJZRTpcbiAgICAgICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJieWVcIiwgaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UsIENvbnN0YW50c18xLkMuQllFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuSU5WSVRFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwicmUtSU5WSVRFIHJlY2VpdmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVSZWludml0ZShpbmNvbWluZ1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5JTkZPOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQgfHwgdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25JbmZvKGluY29taW5nUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5nZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLm1hdGNoKC9eYXBwbGljYXRpb25cXC9kdG1mLXJlbGF5L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5ib2R5LnNwbGl0KFwiXFxyXFxuXCIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b25lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ1RvbmUgPSAvXihTaWduYWxcXHMqPz1cXHMqPykoWzAtOUEtRCMqXXsxfSkoXFxzKT8uKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnVG9uZS50ZXN0KGJvZHlbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9uZSA9IGJvZHlbMF0ucmVwbGFjZShyZWdUb25lLCBcIiQyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ0R1cmF0aW9uID0gL14oRHVyYXRpb25cXHM/PVxccz8pKFswLTldezEsNH0pKFxccyk/LiovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ0R1cmF0aW9uLnRlc3QoYm9keVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHBhcnNlSW50KGJvZHlbMV0ucmVwbGFjZShyZWdEdXJhdGlvbiwgXCIkMlwiKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvbmUgJiYgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRFRNRl8xLkRUTUYodGhpcywgdG9uZSwgeyBkdXJhdGlvbjogZHVyYXRpb24gfSkuaW5pdF9pbmNvbWluZyhpbmNvbWluZ1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LnJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbXCJBY2NlcHQ6IGFwcGxpY2F0aW9uL2R0bWYtcmVsYXlcIl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5SRUZFUjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlJFRkVSIHJlY2VpdmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVyQ29udGV4dCA9IG5ldyBSZWZlckNvbnRleHRfMS5SZWZlclNlcnZlckNvbnRleHQodGhpcy51YSwgaW5jb21pbmdSZXF1ZXN0LCB0aGlzLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMoXCJyZWZlclJlcXVlc3RlZFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlZmVyUmVxdWVzdGVkXCIsIHRoaXMucmVmZXJDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIk5vIHJlZmVyUmVxdWVzdGVkIGxpc3RlbmVycywgYXV0b21hdGljYWxseSBhY2NlcHRpbmcgYW5kIGZvbGxvd2luZyB0aGUgcmVmZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsgZm9sbG93UmVmZXI6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhc3NlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmludml0ZU9wdGlvbnMgPSB0aGlzLnBhc3NlZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVyQ29udGV4dC5hY2NlcHQob3B0aW9ucywgdGhpcy5tb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLk5PVElGWTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZlckNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZlckNvbnRleHQudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5SZWZlckNsaWVudENvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuaGFzSGVhZGVyKFwiZXZlbnRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgL15yZWZlcig7LiopPyQvLnRlc3QoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiZXZlbnRcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmZXJDb250ZXh0LnJlY2VpdmVOb3RpZnkoaW5jb21pbmdSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibm90aWZ5XCIsIGluY29taW5nUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5NRVNTQUdFOlxuICAgICAgICAgICAgICAgIGluY29taW5nUmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIGluY29taW5nUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSW4gZGlhbG9nIElOVklURSBSZWNlcHRpb25cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWNlaXZlUmVpbnZpdGUgPSBmdW5jdGlvbiAoaW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBwcm9iYWJseSBjaGVjayBzdGF0ZSBvZiB0aGUgc2Vzc2lvblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWludml0ZVwiLCB0aGlzLCBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgIGlmIChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5oYXNIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydGVkSWRlbnRpdHkgPVxuICAgICAgICAgICAgICAgIGNvcmVfMS5HcmFtbWFyLm5hbWVBZGRySGVhZGVyUGFyc2UoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciB0byByZWludml0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAhaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKSB7IC8vIEludml0ZSB3L28gU0RQXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmdldERlc2NyaXB0aW9uKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuaGFzRGVzY3JpcHRpb24oaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAvLyBJbnZpdGUgdy8gU0RQXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnNldERlc2NyaXB0aW9uKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmJvZHksIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKS50aGVuKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5nZXREZXNjcmlwdGlvbi5iaW5kKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciwgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgdGhpcy5tb2RpZmllcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQmFkIFBhY2tldCAoc2hvdWxkIG5ldmVyIGdldCBoaXQpXG4gICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDE1IH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVpbnZpdGVGYWlsZWRcIiwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHN0YXR1c0NvZGU7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuUmVuZWdvdGlhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlbmVnb3RpYXRpb25FcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSA0ODg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IDQ4ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluY29taW5nUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIH0pO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlaW52aXRlRmFpbGVkXCIsIF90aGlzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgYmV0dGVyXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtcIkNvbnRhY3Q6IFwiICsgX3RoaXMuY29udGFjdF07XG4gICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QuYWNjZXB0KHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaihkZXNjcmlwdGlvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVpbnZpdGVBY2NlcHRlZFwiLCBfdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc2VuZFJlaW52aXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1JlaW52aXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUmVpbnZpdGUgaW4gcHJvZ3Jlc3MuIFBsZWFzZSB3YWl0IHVudGlsIGNvbXBsZXRlLCB0aGVuIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLCBjYW4ndCByZWludml0ZS4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ1JlaW52aXRlID0gdHJ1ZTtcbiAgICAgICAgb3B0aW9ucy5tb2RpZmllcnMgPSBvcHRpb25zLm1vZGlmaWVycyB8fCBbXTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuY29udGFjdCk7XG4gICAgICAgIC8vIHRoaXMgaXMgVUEuQy5BTExPV0VEX01FVEhPRFMsIHJlbW92ZWQgdG8gZ2V0IGFyb3VuZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQWxsb3c6IFwiICsgW1xuICAgICAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgICAgICBcIklOVklURVwiLFxuICAgICAgICAgICAgXCJNRVNTQUdFXCIsXG4gICAgICAgICAgICBcIkJZRVwiLFxuICAgICAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgICAgICBcIklORk9cIixcbiAgICAgICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgICAgICBcIlJFRkVSXCJcbiAgICAgICAgXS50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmdldERlc2NyaXB0aW9uKG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIG9wdGlvbnMubW9kaWZpZXJzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlJlY2VpdmVkIHJlaW52aXRlIHJlc3BvbnNlLCBidXQgaW4gU1RBVFVTX1RFUk1JTkFURURcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIHNlbmQgYSBTSVAgcmVzcG9uc2U/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wZW5kaW5nUmVpbnZpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlJlY2VpdmVkIHJlaW52aXRlIHJlc3BvbnNlLCBidXQgaGF2ZSBubyBwZW5kaW5nIHJlaW52aXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBzZW5kIGEgU0lQIHJlc3BvbnNlP1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBXaHkgaXMgdGhpcyBzZXQgaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE3LjEuMS4xIC0gRm9yIGVhY2ggZmluYWwgcmVzcG9uc2UgdGhhdCBpcyByZWNlaXZlZCBhdCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHNlbmRzIGFuIEFDSyxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImFja1wiLCByZXNwb25zZS5hY2soKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbGwgb2YgdGhlc2UgdGltZXJzIHNob3VsZCBtb3ZlIGludG8gdGhlIFRyYW5zYWN0aW9uIGxheWVyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmhhc0Rlc2NyaXB0aW9uKHJlc3BvbnNlLm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCIyWFggcmVzcG9uc2UgcmVjZWl2ZWQgdG8gcmUtaW52aXRlIGJ1dCBkaWQgbm90IGhhdmUgYSBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWludml0ZUZhaWxlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVuZWdvdGlhdGlvbkVycm9yXCIsIG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5SZW5lZ290aWF0aW9uRXJyb3IoXCIyWFggcmVzcG9uc2UgcmVjZWl2ZWQgdG8gcmUtaW52aXRlIGJ1dCBkaWQgbm90IGhhdmUgYSBkZXNjcmlwdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLm1lc3NhZ2UuYm9keSwgX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIF90aGlzLm1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiQ291bGQgbm90IHNldCB0aGUgZGVzY3JpcHRpb24gaW4gMlhYIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlaW52aXRlRmFpbGVkXCIsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZW5lZ290aWF0aW9uRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kUmVxdWVzdChDb25zdGFudHNfMS5DLkJZRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1wiUmVhc29uOiBcIiArIFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNDg4LCBcIk5vdCBBY2NlcHRhYmxlIEhlcmVcIildXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRlcm1pbmF0ZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5JTkNPTVBBVElCTEVfU0RQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVpbnZpdGVBY2NlcHRlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogRG9lcyBBQ0sgbmVlZCB0byBiZSBzZW50P1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlJlY2VpdmVkIGEgbm9uIDFYWCBvciAyWFggcmVzcG9uc2UgdG8gYSByZS1pbnZpdGVcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWludml0ZUZhaWxlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZW5lZ290aWF0aW9uRXJyb3JcIiwgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlJlbmVnb3RpYXRpb25FcnJvcihcIkludmFsaWQgcmVzcG9uc2UgdG8gYSByZS1pbnZpdGVcIikpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogRG9lcyBBQ0sgbmVlZCB0byBiZSBzZW50P1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlJlY2VpdmVkIGEgbm9uIDFYWCBvciAyWFggcmVzcG9uc2UgdG8gYSByZS1pbnZpdGVcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWludml0ZUZhaWxlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZW5lZ290aWF0aW9uRXJyb3JcIiwgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlJlbmVnb3RpYXRpb25FcnJvcihcIkludmFsaWQgcmVzcG9uc2UgdG8gYSByZS1pbnZpdGVcIikpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25Ucnlpbmc6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBVdGlsc18xLlV0aWxzLmZyb21Cb2R5T2JqKGRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLnNlc3Npb24uaW52aXRlKGRlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlJlbmVnb3RpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZW5lZ290aWF0aW9uRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJSZW5lZ290aWF0aW9uIEVycm9yXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcInNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgZXJyb3JcIik7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmZhaWxlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY2F1c2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWplY3RlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmNhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJjYW5jZWxcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuYWNjZXB0ZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgY2F1c2UgPSBVdGlsc18xLlV0aWxzLmdldFJlYXNvblBocmFzZSgocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSkgfHwgMCwgY2F1c2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMucmVwbGFjZWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZWUuZW1pdChcInJlcGxhY2VkXCIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJhY2NlcHRlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnRlcm1pbmF0ZWQgPSBmdW5jdGlvbiAobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidGVybWluYXRlZFwiLCBtZXNzYWdlLCBjYXVzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuY29ubmVjdGluZyA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RpbmdcIiwgeyByZXF1ZXN0OiByZXF1ZXN0IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24uQyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cztcbiAgICByZXR1cm4gU2Vzc2lvbjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1jbGFzc2VzLXBlci1maWxlXG52YXIgSW52aXRlU2VydmVyQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZpdGVTZXJ2ZXJDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludml0ZVNlcnZlckNvbnRleHQodWEsIGluY29taW5nSW52aXRlUmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXVhLmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkpIHtcbiAgICAgICAgICAgIHVhLmxvZ2dlci53YXJuKFwiQ2FuJ3QgYnVpbGQgSVNDIHdpdGhvdXQgU0RIIEZhY3RvcnlcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJU0MgQ29uc3RydWN0b3IgRmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdWEuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJzZXEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgICAgIF90aGlzLmluY29taW5nUmVxdWVzdCA9IGluY29taW5nSW52aXRlUmVxdWVzdDtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBpbmNvbWluZ0ludml0ZVJlcXVlc3QubWVzc2FnZTtcbiAgICAgICAgU2VydmVyQ29udGV4dF8xLlNlcnZlckNvbnRleHQuaW5pdGlhbGl6ZXIoX3RoaXMsIHVhLCBpbmNvbWluZ0ludml0ZVJlcXVlc3QpO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5JbnZpdGVTZXJ2ZXJDb250ZXh0O1xuICAgICAgICB2YXIgY29udGVudERpc3AgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgICAgICAgaWYgKGNvbnRlbnREaXNwICYmIGNvbnRlbnREaXNwLnR5cGUgPT09IFwicmVuZGVyXCIpIHtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlcmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJ0eXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19JTlZJVEVfUkVDRUlWRUQ7XG4gICAgICAgIF90aGlzLmZyb21UYWcgPSByZXF1ZXN0LmZyb21UYWc7XG4gICAgICAgIF90aGlzLmlkID0gcmVxdWVzdC5jYWxsSWQgKyBfdGhpcy5mcm9tVGFnO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgX3RoaXMuY29udGFjdCA9IF90aGlzLnVhLmNvbnRhY3QudG9TdHJpbmcoKTtcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKFwic2lwLmludml0ZXNlcnZlcmNvbnRleHRcIiwgX3RoaXMuaWQpO1xuICAgICAgICAvLyBTYXZlIHRoZSBzZXNzaW9uIGludG8gdGhlIHVhIHNlc3Npb25zIGNvbGxlY3Rpb24uXG4gICAgICAgIF90aGlzLnVhLnNlc3Npb25zW190aGlzLmlkXSA9IF90aGlzO1xuICAgICAgICAvLyBTZXQgMTAwcmVsIGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgc2V0MTAwcmVsID0gZnVuY3Rpb24gKGhlYWRlciwgcmVsU2V0dGluZykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuaGFzSGVhZGVyKGhlYWRlcikgJiYgcmVxdWVzdC5nZXRIZWFkZXIoaGVhZGVyKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCIxMDByZWxcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbDEwMCA9IHJlbFNldHRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldDEwMHJlbChcInJlcXVpcmVcIiwgQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpO1xuICAgICAgICBzZXQxMDByZWwoXCJzdXBwb3J0ZWRcIiwgQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKTtcbiAgICAgICAgLy8gU2V0IHRoZSB0b1RhZyBvbiB0aGUgaW5jb21pbmcgcmVxdWVzdCB0byB0aGUgdG9UYWcgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSB1c2VkIGluIHRoZSByZXNwb25zZSB0byB0aGUgaW5jb21pbmcgcmVxdWVzdCEhIVxuICAgICAgICAvLyBGSVhNRTogSEFDSzogVGhpcyBpcyBhIGhhY2sgdG8gcG9ydCBhbiBleGlzdGluZyBiZWhhdmlvci5cbiAgICAgICAgLy8gVGhlIGJlaGF2aW9yIGJlaW5nIHBvcnRlZCBhcHBlYXJzIHRvIGJlIGEgaGFjayBpdHNlbGYsXG4gICAgICAgIC8vIHNvIHRoaXMgaXMgYSBoYWNrIHRvIHBvcnQgYSBoYWNrLiBBdCBsZWFzdCBvbmUgdGVzdCBzcGVjXG4gICAgICAgIC8vIHJlbGllcyBvbiBpdCAod2hpY2ggaXMgeWV0IGFub3RoZXIgaGFjaykuXG4gICAgICAgIF90aGlzLnJlcXVlc3QudG9UYWcgPSBpbmNvbWluZ0ludml0ZVJlcXVlc3QudG9UYWc7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSO1xuICAgICAgICAvLyBTZXQgdXNlck5vQW5zd2VyVGltZXJcbiAgICAgICAgX3RoaXMudGltZXJzLnVzZXJOb0Fuc3dlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbmNvbWluZ0ludml0ZVJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDA4IH0pO1xuICAgICAgICAgICAgX3RoaXMuZmFpbGVkKHJlcXVlc3QsIENvbnN0YW50c18xLkMuY2F1c2VzLk5PX0FOU1dFUik7XG4gICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIENvbnN0YW50c18xLkMuY2F1c2VzLk5PX0FOU1dFUik7XG4gICAgICAgIH0sIF90aGlzLnVhLmNvbmZpZ3VyYXRpb24ubm9BbnN3ZXJUaW1lb3V0IHx8IDYwKTtcbiAgICAgICAgLyogU2V0IGV4cGlyZXNUaW1lclxuICAgICAgICAqIFJGQzMyNjEgMTMuMy4xXG4gICAgICAgICovXG4gICAgICAgIC8vIEdldCB0aGUgRXhwaXJlcyBoZWFkZXIgdmFsdWUgaWYgZXhpc3RzXG4gICAgICAgIGlmIChyZXF1ZXN0Lmhhc0hlYWRlcihcImV4cGlyZXNcIikpIHtcbiAgICAgICAgICAgIHZhciBleHBpcmVzID0gTnVtYmVyKHJlcXVlc3QuZ2V0SGVhZGVyKFwiZXhwaXJlc1wiKSB8fCAwKSAqIDEwMDA7XG4gICAgICAgICAgICBfdGhpcy50aW1lcnMuZXhwaXJlc1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdJbnZpdGVSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4NyB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmFpbGVkKHJlcXVlc3QsIENvbnN0YW50c18xLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIENvbnN0YW50c18xLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVycm9yTGlzdGVuZXIgPSBfdGhpcy5vblRyYW5zcG9ydEVycm9yLmJpbmQoX3RoaXMpO1xuICAgICAgICBpZiAodWEudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB1YS50cmFuc3BvcnQub24oXCJ0cmFuc3BvcnRFcnJvclwiLCBfdGhpcy5lcnJvckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZSwgXCJhdXRvU2VuZEFuSW5pdGlhbFByb3Zpc2lvbmFsUmVzcG9uc2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgYSBmaXJzdCBwcm92aXNpb25hbCByZXNwb25zZSBhZnRlciB0aGUgMTAwIFRyeWluZ1xuICAgICAgICAgKiB3aWxsIGJlIHNlbnQgYXV0b21hdGljYWxseS4gVGhpcyBpcyBmYWxzZSBpdCB0aGUgVUFDIHJlcXVpcmVkXG4gICAgICAgICAqIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyAoMTAwcmVsIGluIFJlcXVpcmUgaGVhZGVyKSxcbiAgICAgICAgICogb3RoZXJ3aXNlIGl0IGlzIHRydWUuIFRoZSBwcm92aXNpb25hbCBpcyBzZW50IGJ5IGNhbGxpbmdcbiAgICAgICAgICogYHByb2dyZXNzKClgIHdpdGhvdXQgYW55IG9wdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZJWE1FOiBUT0RPOiBJdCBzZWVtcyByZWFzb25hYmxlIHRoYXQgdGhlIElTQyB1c2VyIHNob3VsZFxuICAgICAgICAgKiBiZSBhYmxlIHRvIG9wdGlvbmFsbHkgZGlzYWJsZSB0aGlzIGJlaGF2aW9yLiBBcyB0aGUgcHJvdmlzaW9uYWxcbiAgICAgICAgICogaXMgc2VudCBwcmlvciB0byB0aGUgXCJpbnZpdGVcIiBldmVudCBiZWluZyBlbWl0dGVkLCBpdCdzIGEga25vd25cbiAgICAgICAgICogaXNzdWUgdGhhdCB0aGUgSVNDIHVzZXIgY2Fubm90IHJlZ2lzdGVyIGxpc3RlbmVycyBvciBkbyBhbnkgb3RoZXJcbiAgICAgICAgICogc2V0dXAgcHJpb3IgdG8gdGhlIGNhbGwgdG8gYHByb2dyZXNzKClgLiBBcyBhbiBleGFtcGxlIHdoeSB0aGlzIGlzXG4gICAgICAgICAqIGFuIGlzc3VlLCBzZXR0aW5nIGB1YS5jb25maWd1cmF0aW9uLnJlbDEwMGAgdG8gUkVRVUlSRUQgd2lsbCByZXN1bHRcbiAgICAgICAgICogaW4gYW4gYXR0ZW1wdCBieSBgcHJvZ3Jlc3MoKWAgdG8gc2VuZCBhIDE4MyB3aXRoIFNEUCBwcm9kdWNlZCBieVxuICAgICAgICAgKiBjYWxsaW5nIGBnZXREZXNjcmlwdGlvbigpYCBvbiBhIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciwgYnV0XG4gICAgICAgICAqIHRoZSBJU0MgdXNlciBjYW5ub3QgcGVyZm9ybSBhbnkgcG90ZW50aWFsbHkgcmVxdWlyZWQgc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgICAgICAgKiBoYW5kbGVyIGluaXRpYWxpemF0aW9uICh0aHVzIHByZXZlbnRpbmcgdGhlIHV0aWxpemF0aW9uIG9mIHNldHRpbmdcbiAgICAgICAgICogYHVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwYCB0byBSRVFVSVJFRCkuIFRoYXQgYmVncyB0aGUgcXVlc3Rpb24gb2ZcbiAgICAgICAgICogd2h5IHRoaXMgYmVoYXZpb3IgaXMgZGlzYWJsZWQgd2hlbiB0aGUgVUFDIHJlcXVpcmVzIDEwMHJlbCBidXQgbm90XG4gICAgICAgICAqIHdoZW4gdGhlIFVBUyByZXF1aXJlcyAxMDByZWw/IEJ1dCBpZ25vcmluZyB0aGF0LCBpdCdzIGp1c3Qgb25lIGV4YW1wbGVcbiAgICAgICAgICogb2YgYSBjbGFzcyBvZiBjYXNlcyB3aGVyZSB0aGUgSVNDIHVzZXIgbmVlZHMgdG8gZG8gc29tZXRoaW5nIHByaW9yXG4gICAgICAgICAqIHRvIHRoZSBmaXJzdCBjYWxsIHRvIGBwcm9ncmVzcygpYCBhbmQgaXMgdW5hYmxlIHRvIGRvIHNvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWwxMDAgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyB0eXBlIGhhY2sgZm9yIHNlcnZlcmNvbnRleHQgaW50ZXJmYWNlXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVwbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIHR5cGluZyBub3RlOiB0aGlzIHdhcyB0aGUgb25seSBmdW5jdGlvbiB1c2luZyBpdHMgc3VwZXIgaW4gU2VydmVyQ29udGV4dFxuICAgIC8vIHNvIHRoZSBib3R0b20gaGFsZiBvZiB0aGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBhbmQgcGFpcmVkIGRvd24gZnJvbSB0aGF0XG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwicmVqZWN0aW5nIFJUQ1Nlc3Npb25cIik7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDQ4MDtcbiAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUsIG9wdGlvbnMucmVhc29uUGhyYXNlKTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCB8fCBzdGF0dXNDb2RlID4gNjk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5ID8gY29yZV8xLmZyb21Cb2R5TGVnYWN5KG9wdGlvbnMuYm9keSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEZJWE1FOiBOZWVkIHRvIHJlZGlyZWN0IHRvIHNvbWVwbGFlXG4gICAgICAgIHZhciByZXNwb25zZSA9IHN0YXR1c0NvZGUgPCA0MDAgP1xuICAgICAgICAgICAgdGhpcy5pbmNvbWluZ1JlcXVlc3QucmVkaXJlY3QoW10sIHsgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlOiByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pIDpcbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZTogcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycywgYm9keTogYm9keSB9KTtcbiAgICAgICAgKFtcInJlamVjdGVkXCIsIFwiZmFpbGVkXCJdKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChldmVudCwgcmVzcG9uc2UubWVzc2FnZSwgcmVhc29uUGhyYXNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmF0ZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFjY2VwdCB0aGUgaW5jb21pbmcgSU5WSVRFIHJlcXVlc3QgdG8gc3RhcnQgYSBTZXNzaW9uLlxuICAgICAqIFJlcGxpZXMgdG8gdGhlIElOVklURSByZXF1ZXN0IHdpdGggYSAyMDAgT2sgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gRklYTUU6IE5lZWQgZ3VhcmQgYWdhaW5zdCBjYWxsaW5nIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICB0aGlzLl9hY2NlcHQob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfYS5tZXNzYWdlLCBzZXNzaW9uID0gX2Euc2Vzc2lvbjtcbiAgICAgICAgICAgIHNlc3Npb24uZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgb25BY2s6IGZ1bmN0aW9uIChhY2tSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5vbkFjayhhY2tSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgICAgICBvbkFja1RpbWVvdXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uQWNrVGltZW91dCgpOyB9LFxuICAgICAgICAgICAgICAgIG9uQnllOiBmdW5jdGlvbiAoYnllUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QoYnllUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICAgICAgb25JbmZvOiBmdW5jdGlvbiAoaW5mb1JlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KGluZm9SZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgICAgICBvbkludml0ZTogZnVuY3Rpb24gKGludml0ZVJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KGludml0ZVJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2VSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChtZXNzYWdlUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICAgICAgb25Ob3RpZnk6IGZ1bmN0aW9uIChub3RpZnlSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChub3RpZnlSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgICAgICBvblByYWNrOiBmdW5jdGlvbiAocHJhY2tSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChwcmFja1JlcXVlc3QpOyB9LFxuICAgICAgICAgICAgICAgIG9uUmVmZXI6IGZ1bmN0aW9uIChyZWZlclJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KHJlZmVyUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSztcbiAgICAgICAgICAgIF90aGlzLmFjY2VwdGVkKG1lc3NhZ2UsIFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKDIwMCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMub25Db250ZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgLy8gRklYTUU6IEFzc3VtaW5nIGVycm9yIGR1ZSB0byBhc3luYyByYWNlIG9uIENBTkNFTCBhbmQgZWF0aW5nIGVycm9yLlxuICAgICAgICAgICAgaWYgKCFfdGhpcy5fY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwb3J0IHByb2dyZXNzIHRvIHRoZSB0aGUgY2FsbGVyLlxuICAgICAqIFJlcGxpZXMgdG8gdGhlIElOVklURSByZXF1ZXN0IHdpdGggYSAxeHggcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBQb3J0ZWRcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgwO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDEwMCB8fCBzdGF0dXNDb2RlID4gMTk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcnRlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVuZXhwZWN0ZWQgY2FsbCBmb3IgcHJvZ3Jlc3Mgd2hpbGUgdGVybWluYXRlZCwgaWdub3JpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGRlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVbmV4cGVjdGVkIGNhbGwgZm9yIHByb2dyZXNzIHdoaWxlIGFuc3dlcmVkLCBpZ25vcmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVuZXhwZWN0ZWQgY2FsbCBmb3IgcHJvZ3Jlc3Mgd2hpbGUgYW5zd2VyZWQgKHdhaXRpbmcgZm9yIHByYWNrKSwgaWdub3JpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZnRlciB0aGUgZmlyc3QgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgZm9yIGEgcmVxdWVzdCBoYXMgYmVlblxuICAgICAgICAvLyBhY2tub3dsZWRnZWQsIHRoZSBVQVMgTUFZIHNlbmQgYWRkaXRpb25hbCByZWxpYWJsZSBwcm92aXNpb25hbFxuICAgICAgICAvLyByZXNwb25zZXMuICBUaGUgVUFTIE1VU1QgTk9UIHNlbmQgYSBzZWNvbmQgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gcmVzcG9uc2UgdW50aWwgdGhlIGZpcnN0IGlzIGFja25vd2xlZGdlZC4gIEFmdGVyIHRoZSBmaXJzdCwgaXQgaXNcbiAgICAgICAgLy8gUkVDT01NRU5ERUQgdGhhdCB0aGUgVUFTIG5vdCBzZW5kIGFuIGFkZGl0aW9uYWwgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gcmVzcG9uc2UgdW50aWwgdGhlIHByZXZpb3VzIGlzIGFja25vd2xlZGdlZC4gIFRoZSBmaXJzdCByZWxpYWJsZVxuICAgICAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZSByZWNlaXZlcyBzcGVjaWFsIHRyZWF0bWVudCBiZWNhdXNlIGl0IGNvbnZleXNcbiAgICAgICAgLy8gdGhlIGluaXRpYWwgc2VxdWVuY2UgbnVtYmVyLiAgSWYgYWRkaXRpb25hbCByZWxpYWJsZSBwcm92aXNpb25hbFxuICAgICAgICAvLyByZXNwb25zZXMgd2VyZSBzZW50IGJlZm9yZSB0aGUgZmlyc3Qgd2FzIGFja25vd2xlZGdlZCwgdGhlIFVBUyBjb3VsZFxuICAgICAgICAvLyBub3QgYmUgY2VydGFpbiB0aGVzZSB3ZXJlIHJlY2VpdmVkIGluIG9yZGVyLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTNcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5leHBlY3RlZCBjYWxsIGZvciBwcm9ncmVzcyB3aGlsZSB3YWl0aW5nIGZvciBwcmFjaywgaWdub3JpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3J0ZWRcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LnRyeWluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbnRleHRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEFzc3VtaW5nIGVycm9yIGR1ZSB0byBhc3luYyByYWNlIG9uIENBTkNFTCBhbmQgZWF0aW5nIGVycm9yLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhbmRhcmQgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICAgIGlmICghKHRoaXMucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRCkgJiZcbiAgICAgICAgICAgICEodGhpcy5yZWwxMDAgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCAmJiBvcHRpb25zLnJlbDEwMCkgJiZcbiAgICAgICAgICAgICEodGhpcy5yZWwxMDAgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCAmJiB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uQ29udGV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogQXNzdW1pbmcgZXJyb3IgZHVlIHRvIGFzeW5jIHJhY2Ugb24gQ0FOQ0VMIGFuZCBlYXRpbmcgZXJyb3IuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICAgICAgdGhpcy5fcmVsaWFibGVQcm9ncmVzc1dhaXRGb3JQcmFjayhvcHRpb25zKVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMub25Db250ZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgLy8gRklYTUU6IEFzc3VtaW5nIGVycm9yIGR1ZSB0byBhc3luYyByYWNlIG9uIENBTkNFTCBhbmQgZWF0aW5nIGVycm9yLlxuICAgICAgICAgICAgaWYgKCFfdGhpcy5fY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVqZWN0IGFuIHVuYWNjZXB0ZWQgaW5jb21pbmcgSU5WSVRFIHJlcXVlc3Qgb3Igc2VuZCBCWUUgaWYgZXN0YWJsaXNoZWQgc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGJ1Y2tldC4gRklYTUU6IFRoaXMgb3B0aW9ucyBidWNrZXQgbmVlZHMgdG8gYmUgdHlwZWQuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVGhlIGNhbGxlcidzIFVBIE1BWSBzZW5kIGEgQllFIGZvciBlaXRoZXIgY29uZmlybWVkIG9yIGVhcmx5IGRpYWxvZ3MsXG4gICAgICAgIC8vIGFuZCB0aGUgY2FsbGVlJ3MgVUEgTUFZIHNlbmQgYSBCWUUgb24gY29uZmlybWVkIGRpYWxvZ3MsIGJ1dCBNVVNUIE5PVFxuICAgICAgICAvLyBzZW5kIGEgQllFIG9uIGVhcmx5IGRpYWxvZ3MuIEhvd2V2ZXIsIHRoZSBjYWxsZWUncyBVQSBNVVNUIE5PVCBzZW5kIGFcbiAgICAgICAgLy8gQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZyB1bnRpbCBpdCBoYXMgcmVjZWl2ZWQgYW4gQUNLIGZvciBpdHMgMnh4XG4gICAgICAgIC8vIHJlc3BvbnNlIG9yIHVudGlsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIFdlIGRvbid0IHlldCBoYXZlIGEgZGlhbG9nLCBzbyByZWplY3QgcmVxdWVzdC5cbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnNlc3Npb24uc2Vzc2lvblN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5FYXJseTpcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5BY2tXYWl0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBBQ0sgc2hvd3MgdXAsIHNheSBCWUUuXG4gICAgICAgICAgICAgICAgICAgIG9uQWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kUmVxdWVzdChDb25zdGFudHNfMS5DLkJZRSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0IGJlZm9yZSB0aGUgQUNLIGFycml2ZXMuXG4gICAgICAgICAgICAgICAgICAgIG9uQWNrVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZFJlcXVlc3QoQ29uc3RhbnRzXzEuQy5CWUUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBQb3J0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJieWVcIiwgdGhpcy5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5Db25maXJtZWQ6XG4gICAgICAgICAgICAgICAgdGhpcy5ieWUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uQ2FuY2VsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUiB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0sgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19FQVJMWV9NRURJQSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DQU5DRUxFRDtcbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4NyB9KTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsZWQoKTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQobWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQobWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKG1lc3NhZ2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbiAoaW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuUFJBQ0s6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHRoaXMuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLWNyZWF0ZWRcIiwgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuaGFzRGVzY3JpcHRpb24oaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5zZXREZXNjcmlwdGlvbihpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5ib2R5LCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lcnMucmVsMXh4VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZXJzLnByYWNrVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogXCI0ODhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmFpbGVkKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBcIjQ4OFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMucmVsMXh4VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnByYWNrVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdC5jYWxsKHRoaXMsIGluY29taW5nUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEludGVybmFsIEZ1bmN0aW9uIHRvIHNldHVwIHRoZSBoYW5kbGVyIGNvbnNpc3RlbnRseVxuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSh0aGlzLCB0aGlzLnVhLmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zKTtcbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGNvcmVfMS5nZXRCb2R5KHRoaXMuaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCFib2R5IHx8IGJvZHkuY29udGVudERpc3Bvc2l0aW9uICE9PSBcInNlc3Npb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIoYm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgICAgICAgICAgICAvLyBvICBPbmNlIHRoZSBVQVMgaGFzIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYXRpb24gYWxvbmUgY2FuIG5ldmVyIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIHVudGlsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uLm9mZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIG9mZmVyIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRPZmZlckFuZEdldEFuc3dlcih0aGlzLnNlc3Npb24ub2ZmZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLnNlc3Npb24uc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLnNlc3Npb24uc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLmhhbmRsZVByYWNrT2ZmZXJBbnN3ZXIgPSBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBQUkFDSyBkb2Vzbid0IGhhdmUgYW4gb2ZmZXIvYW5zd2VyLCBub3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIHZhciBib2R5ID0gY29yZV8xLmdldEJvZHkocmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgaWYgKCFib2R5IHx8IGJvZHkuY29udGVudERpc3Bvc2l0aW9uICE9PSBcInNlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBVQUMgcmVjZWl2ZXMgYSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFuIG9mZmVyXG4gICAgICAgIC8vICh0aGlzIHdvdWxkIG9jY3VyIGlmIHRoZSBVQUMgc2VudCBhbiBJTlZJVEUgd2l0aG91dCBhbiBvZmZlciwgaW5cbiAgICAgICAgLy8gd2hpY2ggY2FzZSB0aGUgZmlyc3QgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZVxuICAgICAgICAvLyBvZmZlciksIGl0IE1VU1QgZ2VuZXJhdGUgYW4gYW5zd2VyIGluIHRoZSBQUkFDSy4gIElmIHRoZSBVQUMgcmVjZWl2ZXNcbiAgICAgICAgLy8gYSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFuIGFuc3dlciwgaXQgTUFZIGdlbmVyYXRlIGFuXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgb2ZmZXIgaW4gdGhlIFBSQUNLLiAgSWYgdGhlIFVBUyByZWNlaXZlcyBhIFBSQUNLIHdpdGggYW5cbiAgICAgICAgLy8gb2ZmZXIsIGl0IE1VU1QgcGxhY2UgdGhlIGFuc3dlciBpbiB0aGUgMnh4IHRvIHRoZSBQUkFDSy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi01XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXNzaW9uLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIHNob3VsZCBuZXZlciBiZSByZWFjaGVkIGFzIGZpcnN0IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIG11c3QgaGF2ZSBhbnN3ZXIvb2ZmZXIuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLnNlc3Npb24uc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgICAgICAgICAgLy8gUmVjZXZlZCBhbnN3ZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QW5zd2VyKGJvZHksIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIHNob3VsZCBuZXZlciBiZSByZWFjaGVkIGFzIGxvY2FsIG9mZmVyIHdvdWxkIGJlIGFuc3dlcmVkIGJ5IHRoaXMgUFJBQ0tcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSBcIiArIHRoaXMuc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjpcbiAgICAgICAgICAgICAgICAvLyBSZWNldmVkIG9mZmVyLCBnZW5lcmF0ZSBhbnN3ZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIoYm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLnNlc3Npb24uc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5zZXNzaW9uLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBzZXNzaW9uIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLmNhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNhbmNlbGVkLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBzZXNzaW9uIHRlcm1pbmF0ZWQuXG4gICAgICogVXNpbmcgaXQgaGVyZSBqdXN0IGZvciB0aGUgUFJBQ0sgdGltZW91dC5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS50ZXJtaW5hdGVkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIHRoaXMucHJhY2tOZXZlckFycml2ZWQoKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudGVybWluYXRlZC5jYWxsKHRoaXMsIG1lc3NhZ2UsIGNhdXNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgdmVyc2lvbiBvZiBgYWNjZXB0YCB3aGljaCByZXNvbHZlcyBhIHNlc3Npb24gd2hlbiB0aGUgMjAwIE9rIHJlc3BvbnNlIGlzIHNlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICogQHRocm93cyB7Q2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yfSBUaGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGNsb3NlZCBiZWZvcmUgbWV0aG9kIGNvbXBsZXRlZC5cbiAgICAgKiBAdGhyb3dzIHtUcmFuc2FjdGlvblN0YXRlRXJyb3J9IFRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBkb2VzIG5vdCBhbGxvdyBmb3IgYGFjY2VwdCgpYCB0byBiZSBjYWxsZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHN0YXRlIGNhbiBjaGFuZ2Ugd2hpbGUgdGhpcyBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLl9hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBGSVhNRTogUG9ydGVkIC0gY2FsbGJhY2sgZm9yIGluIGRpYWxvZyBJTkZPIHJlcXVlc3RzLlxuICAgICAgICAvLyBUdXJucyBvdXQgYWNjZXB0KCkgY2FuIGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBpZiB3ZSBhcmUgd2FpdGluZ1xuICAgICAgICAvLyBmb3IgYSBQUkFDSyBpbiB3aGljaCBjYXNlIFwib3B0aW9uc1wiIGdldCBjb21wbGV0ZWx5IHRvc3NlZCBhd2F5LlxuICAgICAgICAvLyBTbyB0aGlzIGlzIGJyb2tlbiBpbiB0aGF0IGNhc2UgKGFuZCBwb3RlbnRpYWxseSBvdGhlciB1c2VzIG9mIG9wdGlvbnMpLlxuICAgICAgICAvLyBUZW1wdGVkIHRvIGp1c3QgdHJ5IHRvIGZpeCBpdCBub3csIGJ1dCBsZWF2aW5nIGl0IGJyb2tlbiBmb3IgdGhlIG1vbWVudC5cbiAgICAgICAgdGhpcy5vbkluZm8gPSBvcHRpb25zLm9uSW5mbztcbiAgICAgICAgLy8gVGhlIFVBUyBNQVkgc2VuZCBhIGZpbmFsIHJlc3BvbnNlIHRvIHRoZSBpbml0aWFsIHJlcXVlc3QgYmVmb3JlXG4gICAgICAgIC8vIGhhdmluZyByZWNlaXZlZCBQUkFDS3MgZm9yIGFsbCB1bmFja25vd2xlZGdlZCByZWxpYWJsZSBwcm92aXNpb25hbFxuICAgICAgICAvLyByZXNwb25zZXMsIHVubGVzcyB0aGUgZmluYWwgcmVzcG9uc2UgaXMgMnh4IGFuZCBhbnkgb2YgdGhlXG4gICAgICAgIC8vIHVuYWNrbm93bGVkZ2VkIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBjb250YWluZWQgYSBzZXNzaW9uXG4gICAgICAgIC8vIGRlc2NyaXB0aW9uLiAgSW4gdGhhdCBjYXNlLCBpdCBNVVNUIE5PVCBzZW5kIGEgZmluYWwgcmVzcG9uc2UgdW50aWxcbiAgICAgICAgLy8gdGhvc2UgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIGFyZSBhY2tub3dsZWRnZWQuICBJZiB0aGUgVUFTIGRvZXMgc2VuZCBhXG4gICAgICAgIC8vIGZpbmFsIHJlc3BvbnNlIHdoZW4gcmVsaWFibGUgcmVzcG9uc2VzIGFyZSBzdGlsbCB1bmFja25vd2xlZGdlZCwgaXRcbiAgICAgICAgLy8gU0hPVUxEIE5PVCBjb250aW51ZSB0byByZXRyYW5zbWl0IHRoZSB1bmFja25vd2xlZGdlZCByZWxpYWJsZVxuICAgICAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZXMsIGJ1dCBpdCBNVVNUIGJlIHByZXBhcmVkIHRvIHByb2Nlc3MgUFJBQ0tcbiAgICAgICAgLy8gcmVxdWVzdHMgZm9yIHRob3NlIG91dHN0YW5kaW5nIHJlc3BvbnNlcy4gIEEgVUFTIE1VU1QgTk9UIHNlbmQgbmV3XG4gICAgICAgIC8vIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyAoYXMgb3Bwb3NlZCB0byByZXRyYW5zbWlzc2lvbnMgb2ZcbiAgICAgICAgLy8gdW5hY2tub3dsZWRnZWQgb25lcykgYWZ0ZXIgc2VuZGluZyBhIGZpbmFsIHJlc3BvbnNlIHRvIGEgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvckFycml2YWxPZlByYWNrKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRDtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZXJzLnVzZXJOb0Fuc3dlclRpbWVyKTsgLy8gUG9ydGVkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlcihvcHRpb25zKTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keSkgeyByZXR1cm4gX3RoaXMuaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCh7IHN0YXR1c0NvZGU6IDIwMCwgYm9keTogYm9keSB9KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9ydGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lcik7IC8vIFBvcnRlZFxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5KSB7IHJldHVybiBfdGhpcy5pbmNvbWluZ1JlcXVlc3QuYWNjZXB0KHsgc3RhdHVzQ29kZTogMjAwLCBib2R5OiBib2R5IH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgdmVyc2lvbiBvZiBgcHJvZ3Jlc3NgIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHNlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICogQHRocm93cyB7Q2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yfSBUaGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGNsb3NlZCBiZWZvcmUgbWV0aG9kIGNvbXBsZXRlZC5cbiAgICAgKiBAdGhyb3dzIHtUcmFuc2FjdGlvblN0YXRlRXJyb3J9IFRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBkb2VzIG5vdCBhbGxvdyBmb3IgYHByb2dyZXNzKClgIHRvIGJlIGNhbGxlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCB0aGUgdHJhbnNhY3Rpb24gc3RhdGUgY2FuIGNoYW5nZSB3aGlsZSB0aGlzIGNhbGwgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUuX3Byb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gUG9ydGVkXG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MDtcbiAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSA/IGNvcmVfMS5mcm9tQm9keUxlZ2FjeShvcHRpb25zLmJvZHkpIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGUgMTgzIChTZXNzaW9uIFByb2dyZXNzKSByZXNwb25zZSBpcyB1c2VkIHRvIGNvbnZleSBpbmZvcm1hdGlvblxuICAgICAgICAvLyBhYm91dCB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGNhbGwgdGhhdCBpcyBub3Qgb3RoZXJ3aXNlIGNsYXNzaWZpZWQuICBUaGVcbiAgICAgICAgLy8gUmVhc29uLVBocmFzZSwgaGVhZGVyIGZpZWxkcywgb3IgbWVzc2FnZSBib2R5IE1BWSBiZSB1c2VkIHRvIGNvbnZleVxuICAgICAgICAvLyBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGNhbGwgcHJvZ3Jlc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjEuMS41XG4gICAgICAgIC8vIEl0IGlzIHRoZSBkZSBmYWN0byBpbmR1c3RyeSBzdGFuZGFyZCB0byB1dGlsaXplIDE4MyB3aXRoIFNEUCB0byBwcm92aWRlIFwiZWFybHkgbWVkaWFcIi5cbiAgICAgICAgLy8gV2hpbGUgaXQgaXMgdW5saWtlbHkgc29tZW9uZSB3b3VsZCB3YW50IHRvIHNlbmQgYSAxODMgd2l0aG91dCBTRFAsIHNvIGl0IHNob3VsZCBiZSBhbiBvcHRpb24uXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAxODMgJiYgIWJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc1dpdGhTRFAob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc1Jlc3BvbnNlID0gdGhpcy5pbmNvbWluZ1JlcXVlc3QucHJvZ3Jlc3MoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2U6IHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCBwcm9ncmVzc1Jlc3BvbnNlLm1lc3NhZ2UsIHJlYXNvblBocmFzZSk7IC8vIFBvcnRlZFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gcHJvZ3Jlc3NSZXNwb25zZS5zZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9ncmVzc1Jlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgdmVyc2lvbiBvZiBgcHJvZ3Jlc3NgIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggc2RwIGlzIHNlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICogQHRocm93cyB7Q2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yfSBUaGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGNsb3NlZCBiZWZvcmUgbWV0aG9kIGNvbXBsZXRlZC5cbiAgICAgKiBAdGhyb3dzIHtUcmFuc2FjdGlvblN0YXRlRXJyb3J9IFRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBkb2VzIG5vdCBhbGxvdyBmb3IgYHByb2dyZXNzKClgIHRvIGJlIGNhbGxlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCB0aGUgdHJhbnNhY3Rpb24gc3RhdGUgY2FuIGNoYW5nZSB3aGlsZSB0aGlzIGNhbGwgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUuX3Byb2dyZXNzV2l0aFNEUCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MztcbiAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICAvLyBHZXQgYW4gb2ZmZXIvYW5zd2VyIGFuZCBzZW5kIGEgcmVwbHkuXG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlcihvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHsgcmV0dXJuIF90aGlzLmluY29taW5nUmVxdWVzdC5wcm9ncmVzcyh7IHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZTogcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycywgYm9keTogYm9keSB9KTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcm9ncmVzc1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcHJvZ3Jlc3NSZXNwb25zZS5tZXNzYWdlLCByZWFzb25QaHJhc2UpOyAvLyBQb3J0ZWRcbiAgICAgICAgICAgIF90aGlzLnNlc3Npb24gPSBwcm9ncmVzc1Jlc3BvbnNlLnNlc3Npb247XG4gICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3NSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHZlcnNpb24gb2YgYHByb2dyZXNzYCB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBpcyBzZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqIEB0aHJvd3Mge0Nsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcn0gVGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBjbG9zZWQgYmVmb3JlIG1ldGhvZCBjb21wbGV0ZWQuXG4gICAgICogQHRocm93cyB7VHJhbnNhY3Rpb25TdGF0ZUVycm9yfSBUaGUgdHJhbnNhY3Rpb24gc3RhdGUgZG9lcyBub3QgYWxsb3cgZm9yIGBwcm9ncmVzcygpYCB0byBiZSBjYWxsZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHN0YXRlIGNhbiBjaGFuZ2Ugd2hpbGUgdGhpcyBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLl9yZWxpYWJsZVByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgzO1xuICAgICAgICB2YXIgcmVhc29uUGhyYXNlID0gb3B0aW9ucy5yZWFzb25QaHJhc2U7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVxdWlyZTogMTAwcmVsXCIpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJTZXE6IFwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApKTtcbiAgICAgICAgLy8gR2V0IGFuIG9mZmVyL2Fuc3dlciBhbmQgc2VuZCBhIHJlcGx5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5KSB7IHJldHVybiBfdGhpcy5pbmNvbWluZ1JlcXVlc3QucHJvZ3Jlc3MoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2U6IHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJvZ3Jlc3NSZXNwb25zZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInByb2dyZXNzXCIsIHByb2dyZXNzUmVzcG9uc2UubWVzc2FnZSwgcmVhc29uUGhyYXNlKTsgLy8gUG9ydGVkXG4gICAgICAgICAgICBfdGhpcy5zZXNzaW9uID0gcHJvZ3Jlc3NSZXNwb25zZS5zZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzUmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSB2ZXJzaW9uIG9mIGBwcm9ncmVzc2Agd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgYWNrbm93bGVkZ2VkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqIEB0aHJvd3Mge0Nsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcn0gVGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBjbG9zZWQgYmVmb3JlIG1ldGhvZCBjb21wbGV0ZWQuXG4gICAgICogQHRocm93cyB7VHJhbnNhY3Rpb25TdGF0ZUVycm9yfSBUaGUgdHJhbnNhY3Rpb24gc3RhdGUgZG9lcyBub3QgYWxsb3cgZm9yIGBwcm9ncmVzcygpYCB0byBiZSBjYWxsZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHN0YXRlIGNhbiBjaGFuZ2Ugd2hpbGUgdGhpcyBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLl9yZWxpYWJsZVByb2dyZXNzV2FpdEZvclByYWNrID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgzO1xuICAgICAgICB2YXIgcmVhc29uUGhyYXNlID0gb3B0aW9ucy5yZWFzb25QaHJhc2U7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVxdWlyZTogMTAwcmVsXCIpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJTZXE6IFwiICsgdGhpcy5yc2VxKyspO1xuICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgLy8gUG9ydGVkIC0gc2V0IHN0YXR1cy5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHdhaXRpbmdGb3JQcmFjayA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VyKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9mZmVyQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IG9mZmVyQW5zd2VyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbmNvbWluZ1JlcXVlc3QucHJvZ3Jlc3MoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2U6IHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcm9ncmVzc1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInByb2dyZXNzXCIsIHByb2dyZXNzUmVzcG9uc2UubWVzc2FnZSwgcmVhc29uUGhyYXNlKTsgLy8gUG9ydGVkXG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbiA9IHByb2dyZXNzUmVzcG9uc2Uuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB2YXIgcHJhY2tSZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHZhciBwcmFja1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHByb2dyZXNzUmVzcG9uc2Uuc2Vzc2lvbi5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb25QcmFjazogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByYWNrUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocHJhY2tXYWl0VGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZWwxeHhSZXRyYW5zbWlzc2lvblRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2FpdGluZ0ZvclByYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0ZvclByYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQcmFja09mZmVyQW5zd2VyKHByYWNrUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJhY2tSZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmFja1Jlc3BvbnNlID0gcHJhY2tSZXF1ZXN0LmFjY2VwdCh7IHN0YXR1c0NvZGU6IDIwMCwgYm9keTogcHJhY2tSZXNwb25zZUJvZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcnRlZCAtIHNldCBzdGF0dXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByYWNrQXJyaXZlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgcHJhY2tSZXF1ZXN0OiBwcmFja1JlcXVlc3QsIHByYWNrUmVzcG9uc2U6IHByYWNrUmVzcG9uc2UsIHByb2dyZXNzUmVzcG9uc2U6IHByb2dyZXNzUmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTNcbiAgICAgICAgICAgICAgICB2YXIgcHJhY2tXYWl0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3YWl0aW5nRm9yUHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nRm9yUHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJObyBQUkFDSyByZWNlaXZlZCwgcmVqZWN0aW5nIElOVklURS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZWwxeHhSZXRyYW5zbWlzc2lvblRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmluY29taW5nUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA1MDQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuTk9fUFJBQ0spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5UZXJtaW5hdGVkU2Vzc2lvbkVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHByYWNrV2FpdFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQocHJhY2tXYWl0VGltZW91dCwgY29yZV8xLlRpbWVycy5UMSAqIDY0KTtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTNcbiAgICAgICAgICAgICAgICB2YXIgcmVsMXh4UmV0cmFuc21pc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmNvbWluZ1JlcXVlc3QucHJvZ3Jlc3MoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2U6IHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nRm9yUHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVsMXh4UmV0cmFuc21pc3Npb25UaW1lciA9IHNldFRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb24sIHRpbWVvdXQgKj0gMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IGNvcmVfMS5UaW1lcnMuVDE7XG4gICAgICAgICAgICAgICAgdmFyIHJlbDF4eFJldHJhbnNtaXNzaW9uVGltZXIgPSBzZXRUaW1lb3V0KHJlbDF4eFJldHJhbnNtaXNzaW9uLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciB3aGVuIEFDSyBmb3IgYSAyeHggcmVzcG9uc2UgaXMgbmV2ZXIgcmVjZWl2ZWQuXG4gICAgICogQHBhcmFtIHNlc3Npb24gU2Vzc2lvbiB0aGUgQUNLIG5ldmVyIGFycml2ZWQgZm9yXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25BY2tUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJubyBBQ0sgcmVjZWl2ZWQgZm9yIGFuIGV4dGVuZGVkIHBlcmlvZCBvZiB0aW1lLCB0ZXJtaW5hdGluZyB0aGUgY2FsbFwiKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmJ5ZSgpO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuTk9fQUNLKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRklYTUU6IFRPRE86IFRoZSBjdXJyZW50IGxpYnJhcnkgaW50ZXJmYWNlIHByZXNlbnRzIGFzeW5jIG1ldGhvZHMgd2l0aG91dCBhXG4gICAgICogcHJvcGVyIGFzeW5jIGVycm9yIGhhbmRsaW5nIG1lY2hhbmlzbS4gQXJndWFibHkgYSBwcm9taXNlIGJhc2VkIGludGVyZmFjZVxuICAgICAqIHdvdWxkIGJlIGFuIGltcHJvdmVtZW50IG92ZXIgdGhlIHBhdHRlcm4gb2YgcmV0dXJuaW5nIGB0aGlzYC4gVGhlIGFwcHJvYWNoIGhhc1xuICAgICAqIGJlZW4gZ2VuZXJhbGx5IGFsb25nIHRoZSBsaW5lcyBvZiBsb2cgYSBlcnJvciBhbmQgdGVybWluYXRlLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uQ29udGV4dEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gNDgwO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBjb3JlXzEuRXhjZXB0aW9uKSB7IC8vIFRoZXJlIG1pZ2h0IGJlIGludGVyZXN0IGluIGNhdGNoaW5nIHRoZXNlIEV4Y2VwdGlvbnMuXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuVGVybWluYXRlZFNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFBSQUNLIG5ldmVyIGFycml2ZWQsIHNvIHdlIHRpbWVkIG91dCB3YWl0aW5nIGZvciBpdC5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSW5jb21pbmcgc2Vzc2lvbiB0ZXJtaW5hdGVkIHdoaWxlIHdhaXRpbmcgZm9yIFBSQUNLLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IDQxNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgY29yZV8xLkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHsgLy8gT3RoZXIgRXJyb3JzIGhvdWxkIGdvIHVuY2F1Z2h0LlxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBrbm93IHdoYXQgYSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgaW1wbGVtZW50YXRpb24gbWlnaHQgdGhyb3dcbiAgICAgICAgICAgIC8vIG91ciB3YXksIHNvIGFzIGEgbGFzdCByZXNvcnQsIGp1c3QgYXNzdW1lIHdlIGFyZSBnZXR0aW5nIGFuIFwiYW55XCIgYW5kIGxvZyBpdC5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlci5cIik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfSk7IC8vIFwiVGVtcG9yYXJpbHkgVW5hdmFpbGFibGVcIlxuICAgICAgICAgICAgdGhpcy5mYWlsZWQodGhpcy5pbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQodGhpcy5pbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnByYWNrQXJyaXZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMud2FpdGluZ0ZvclByYWNrUmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JQcmFja1Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUucHJhY2tOZXZlckFycml2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLndhaXRpbmdGb3JQcmFja1JlamVjdCkge1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZWplY3QobmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlRlcm1pbmF0ZWRTZXNzaW9uRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JQcmFja1Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7RXhjZXB0aW9ucy5UZXJtaW5hdGVkU2Vzc2lvbkVycm9yfSBUaGUgc2Vzc2lvbiB0ZXJtaW5hdGVkIGJlZm9yZSBiZWluZyBhY2NlcHRlZCAoaS5lLiBjYW5jZWwgYXJyaXZlZCkuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUud2FpdEZvckFycml2YWxPZlByYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy53YWl0aW5nRm9yUHJhY2tQcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHdhaXRpbmcgZm9yIFBSQUNLXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLndhaXRpbmdGb3JQcmFja1Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgX3RoaXMud2FpdGluZ0ZvclByYWNrUmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZTtcbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLmdldE9mZmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgIHZhciBzZGggPSB0aGlzLmdldFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgcmV0dXJuIHNkaFxuICAgICAgICAgICAgLmdldERlc2NyaXB0aW9uKG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIG9wdGlvbnMubW9kaWZpZXJzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHlPYmopIHsgcmV0dXJuIFV0aWxzXzEuVXRpbHMuZnJvbUJvZHlPYmooYm9keU9iaik7IH0pO1xuICAgIH07XG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUuc2V0QW5zd2VyID0gZnVuY3Rpb24gKGFuc3dlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgIHZhciBzZGggPSB0aGlzLmdldFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgaWYgKCFzZGguaGFzRGVzY3JpcHRpb24oYW5zd2VyLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5VbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNkaFxuICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKGFuc3dlci5jb250ZW50LCBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBvcHRpb25zLm1vZGlmaWVycyk7XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5zZXRPZmZlckFuZEdldEFuc3dlciA9IGZ1bmN0aW9uIChvZmZlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICB2YXIgc2RoID0gdGhpcy5nZXRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIGlmICghc2RoLmhhc0Rlc2NyaXB0aW9uKG9mZmVyLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5VbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNkaFxuICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKG9mZmVyLmNvbnRlbnQsIG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIG9wdGlvbnMubW9kaWZpZXJzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2RoLmdldERlc2NyaXB0aW9uKG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIG9wdGlvbnMubW9kaWZpZXJzKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5T2JqKSB7IHJldHVybiBVdGlsc18xLlV0aWxzLmZyb21Cb2R5T2JqKGJvZHlPYmopOyB9KTtcbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLmdldFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvdXIgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGlmIG5vdCBhbHJlYWR5IGRvbmUgc28uLi5cbiAgICAgICAgdmFyIHNkaCA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHRoaXMuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIC8vIEZJWE1FOiBQb3J0ZWQgLSB0aGlzIGNhbiBnZXQgZW1pdHRlZCBtdWx0aXBsZSB0aW1lcyBldmVuIHdoZW4gb25seSBjcmVhdGVkIG9uY2UuLi4gZG9uJ3Qgd2UgY2FyZT9cbiAgICAgICAgdGhpcy5lbWl0KFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci1jcmVhdGVkXCIsIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcik7XG4gICAgICAgIC8vIFJldHVybi5cbiAgICAgICAgcmV0dXJuIHNkaDtcbiAgICB9O1xuICAgIHJldHVybiBJbnZpdGVTZXJ2ZXJDb250ZXh0O1xufShTZXNzaW9uKSk7XG5leHBvcnRzLkludml0ZVNlcnZlckNvbnRleHQgPSBJbnZpdGVTZXJ2ZXJDb250ZXh0O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1jbGFzc2VzLXBlci1maWxlXG52YXIgSW52aXRlQ2xpZW50Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZpdGVDbGllbnRDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludml0ZUNsaWVudENvbnRleHQodWEsIHRhcmdldCwgb3B0aW9ucywgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXVhLmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkpIHtcbiAgICAgICAgICAgIHVhLmxvZ2dlci53YXJuKFwiQ2FuJ3QgYnVpbGQgSVNDIHdpdGhvdXQgU0RIIEZhY3RvcnlcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJQ0MgQ29uc3RydWN0b3IgRmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwge307XG4gICAgICAgIHZhciBhbm9ueW1vdXMgPSBvcHRpb25zLmFub255bW91cyB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGZyb21UYWcgPSBVdGlsc18xLlV0aWxzLm5ld1RhZygpO1xuICAgICAgICBvcHRpb25zLnBhcmFtcy5mcm9tVGFnID0gZnJvbVRhZztcbiAgICAgICAgLyogRG8gbm90IGFkZCA7b2IgaW4gaW5pdGlhbCBmb3JtaW5nIGRpYWxvZyByZXF1ZXN0cyBpZiB0aGUgcmVnaXN0cmF0aW9uIG92ZXJcbiAgICAgICAgKiAgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBnb3QgYSBHUlVVIFVSSS5cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIGNvbnRhY3QgPSB1YS5jb250YWN0LnRvU3RyaW5nKHtcbiAgICAgICAgICAgIGFub255bW91czogYW5vbnltb3VzLFxuICAgICAgICAgICAgb3V0Ym91bmQ6IGFub255bW91cyA/ICF1YS5jb250YWN0LnRlbXBHcnV1IDogIXVhLmNvbnRhY3QucHViR3J1dVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgaWYgKGFub255bW91cyAmJiB1YS5jb25maWd1cmF0aW9uLnVyaSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuZnJvbURpc3BsYXlOYW1lID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLmZyb21VcmkgPSBcInNpcDphbm9ueW1vdXNAYW5vbnltb3VzLmludmFsaWRcIjtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUC1QcmVmZXJyZWQtSWRlbnRpdHk6IFwiICsgdWEuY29uZmlndXJhdGlvbi51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlByaXZhY3k6IGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyBjb250YWN0KTtcbiAgICAgICAgLy8gdGhpcyBpcyBVQS5DLkFMTE9XRURfTUVUSE9EUywgcmVtb3ZlZCB0byBnZXQgYXJvdW5kIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJBbGxvdzogXCIgKyBbXG4gICAgICAgICAgICBcIkFDS1wiLFxuICAgICAgICAgICAgXCJDQU5DRUxcIixcbiAgICAgICAgICAgIFwiSU5WSVRFXCIsXG4gICAgICAgICAgICBcIk1FU1NBR0VcIixcbiAgICAgICAgICAgIFwiQllFXCIsXG4gICAgICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgICAgIFwiSU5GT1wiLFxuICAgICAgICAgICAgXCJOT1RJRllcIixcbiAgICAgICAgICAgIFwiUkVGRVJcIlxuICAgICAgICBdLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAodWEuY29uZmlndXJhdGlvbi5yZWwxMDAgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcXVpcmU6IDEwMHJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWEuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVxdWlyZTogcmVwbGFjZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdWEuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSkgfHwgdGhpcztcbiAgICAgICAgQ2xpZW50Q29udGV4dF8xLkNsaWVudENvbnRleHQuaW5pdGlhbGl6ZXIoX3RoaXMsIHVhLCBDb25zdGFudHNfMS5DLklOVklURSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuZWFybHlNZWRpYVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5JbnZpdGVDbGllbnRDb250ZXh0O1xuICAgICAgICBfdGhpcy5wYXNzZWRPcHRpb25zID0gb3B0aW9uczsgLy8gU2F2ZSBmb3IgbGF0ZXIgdG8gdXNlIHdpdGggcmVmZXJcbiAgICAgICAgX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zIHx8IHt9O1xuICAgICAgICBfdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIF90aGlzLmludml0ZVdpdGhvdXRTZHAgPSBvcHRpb25zLmludml0ZVdpdGhvdXRTZHAgfHwgZmFsc2U7XG4gICAgICAgIC8vIFNldCBhbm9ueW1vdXMgcHJvcGVydHlcbiAgICAgICAgX3RoaXMuYW5vbnltb3VzID0gb3B0aW9ucy5hbm9ueW1vdXMgfHwgZmFsc2U7XG4gICAgICAgIC8vIEN1c3RvbSBkYXRhIHRvIGJlIHNlbnQgZWl0aGVyIGluIElOVklURSBvciBpbiBBQ0tcbiAgICAgICAgX3RoaXMucmVuZGVyYm9keSA9IG9wdGlvbnMucmVuZGVyYm9keSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnJlbmRlcnR5cGUgPSBvcHRpb25zLnJlbmRlcnR5cGUgfHwgXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIC8vIFNlc3Npb24gcGFyYW1ldGVyIGluaXRpYWxpemF0aW9uXG4gICAgICAgIF90aGlzLmZyb21UYWcgPSBmcm9tVGFnO1xuICAgICAgICBfdGhpcy5jb250YWN0ID0gY29udGFjdDtcbiAgICAgICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgaWYgKF90aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19OVUxMKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IoX3RoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXRnb2luZ1Nlc3Npb24gc3BlY2lmaWMgcGFyYW1ldGVyc1xuICAgICAgICBfdGhpcy5pc0NhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlY2VpdmVkMTAwID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm1ldGhvZCA9IENvbnN0YW50c18xLkMuSU5WSVRFO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoXCJzaXAuaW52aXRlY2xpZW50Y29udGV4dFwiKTtcbiAgICAgICAgdWEuYXBwbGljYW50c1tfdGhpcy50b1N0cmluZygpXSA9IF90aGlzO1xuICAgICAgICBfdGhpcy5pZCA9IF90aGlzLnJlcXVlc3QuY2FsbElkICsgX3RoaXMuZnJvbVRhZztcbiAgICAgICAgX3RoaXMub25JbmZvID0gb3B0aW9ucy5vbkluZm87XG4gICAgICAgIF90aGlzLmVycm9yTGlzdGVuZXIgPSBfdGhpcy5vblRyYW5zcG9ydEVycm9yLmJpbmQoX3RoaXMpO1xuICAgICAgICBpZiAodWEudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB1YS50cmFuc3BvcnQub24oXCJ0cmFuc3BvcnRFcnJvclwiLCBfdGhpcy5lcnJvckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkLlwiKTtcbiAgICB9O1xuICAgIC8vIGhhY2sgZm9yIGdldHRpbmcgYXJvdW5kIENsaWVudENvbnRleHQgaW50ZXJmYWNlXG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZW5kSW52aXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTYXZlIHRoZSBzZXNzaW9uIGludG8gdGhlIHVhIHNlc3Npb25zIGNvbGxlY3Rpb24uXG4gICAgICAgIC8vIE5vdGU6IHBsYWNpbmcgaW4gY29uc3RydWN0b3IgYnJlYWtzIGNhbGwgdG8gcmVxdWVzdC5jYW5jZWwgb24gY2xvc2UuLi4gVXNlciBkb2VzIG5vdCBuZWVkIHRoaXMgYW55d2F5XG4gICAgICAgIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBhbGxvdyB0aGUgZnVuY3Rpb24gdG8gcmV0dXJuIHNvIHRoYXQgbGlzdGVuZXJzIGNhbiBiZSBzZXQgdXAgZm9yIHRoZXNlIGV2ZW50c1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGVyZSBpcyBhIHJhY2UgY29uZGl0aW9uIHdoZXJlIGNhbmNlbCAob3IgdGVybWluYXRlKSBjYW4gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXIgaW52aXRlLlxuICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2FuY2VsZWQgfHwgX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW52aXRlV2l0aG91dFNkcCkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3Qgc2VuZCBhbiBpbnZpdGUgd2l0aCBubyBzZHAuLi5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVuZGVyYm9keSAmJiBfdGhpcy5yZW5kZXJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3QuYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IF90aGlzLnJlbmRlcmJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogX3RoaXMucmVuZGVydHlwZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0lOVklURV9TRU5UO1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgTWVkaWEgU2Vzc2lvblxuICAgICAgICAgICAgICAgIF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSBfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeShfdGhpcywgX3RoaXMudWEuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLWNyZWF0ZWRcIiwgX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5nZXREZXNjcmlwdGlvbihfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgX3RoaXMubW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFRoZXJlIGlzIGEgcmFjZSBjb25kaXRpb24gd2hlcmUgY2FuY2VsIChvciB0ZXJtaW5hdGUpIGNhbiBiZSBjYWxsZWQgKGEpc3luY2hyb25vdXNseSBhZnRlciBpbnZpdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0NhbmNlbGVkIHx8IF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0LmJvZHkgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19JTlZJVEVfU0VOVDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZCgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhlcnIuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRlcm1pbmF0ZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCB8fCB0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ0FOQ0VMRUQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkNhbmNlbGluZyBzZXNzaW9uXCIpO1xuICAgICAgICB2YXIgY2FuY2VsUmVhc29uID0gVXRpbHNfMS5VdGlscy5nZXRDYW5jZWxSZWFzb24ob3B0aW9ucy5zdGF0dXNDb2RlLCBvcHRpb25zLnJlYXNvblBocmFzZSk7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcy5vdXRnb2luZ0ludml0ZVJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJDYW5jZWxpbmcgc2Vzc2lvbiBiZWZvcmUgaXQgd2FzIGNyZWF0ZWRcIik7XG4gICAgICAgICAgICB0aGlzLm91dGdvaW5nSW52aXRlUmVxdWVzdC5jYW5jZWwoY2FuY2VsUmVhc29uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWxlZCgpO1xuICAgIH07XG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgfHwgdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICB0aGlzLmJ5ZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogMTMuMi4xIENyZWF0aW5nIHRoZSBJbml0aWFsIElOVklURVxuICAgICAqXG4gICAgICogU2luY2UgdGhlIGluaXRpYWwgSU5WSVRFIHJlcHJlc2VudHMgYSByZXF1ZXN0IG91dHNpZGUgb2YgYSBkaWFsb2csXG4gICAgICogaXRzIGNvbnN0cnVjdGlvbiBmb2xsb3dzIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gOC4xLjEuICBBZGRpdGlvbmFsXG4gICAgICogcHJvY2Vzc2luZyBpcyByZXF1aXJlZCBmb3IgdGhlIHNwZWNpZmljIGNhc2Ugb2YgSU5WSVRFLlxuICAgICAqXG4gICAgICogQW4gQWxsb3cgaGVhZGVyIGZpZWxkIChTZWN0aW9uIDIwLjUpIFNIT1VMRCBiZSBwcmVzZW50IGluIHRoZSBJTlZJVEUuXG4gICAgICogSXQgaW5kaWNhdGVzIHdoYXQgbWV0aG9kcyBjYW4gYmUgaW52b2tlZCB3aXRoaW4gYSBkaWFsb2csIG9uIHRoZSBVQVxuICAgICAqIHNlbmRpbmcgdGhlIElOVklURSwgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGlhbG9nLiAgRm9yIGV4YW1wbGUsIGFcbiAgICAgKiBVQSBjYXBhYmxlIG9mIHJlY2VpdmluZyBJTkZPIHJlcXVlc3RzIHdpdGhpbiBhIGRpYWxvZyBbMzRdIFNIT1VMRFxuICAgICAqIGluY2x1ZGUgYW4gQWxsb3cgaGVhZGVyIGZpZWxkIGxpc3RpbmcgdGhlIElORk8gbWV0aG9kLlxuICAgICAqXG4gICAgICogQSBTdXBwb3J0ZWQgaGVhZGVyIGZpZWxkIChTZWN0aW9uIDIwLjM3KSBTSE9VTEQgYmUgcHJlc2VudCBpbiB0aGVcbiAgICAgKiBJTlZJVEUuICBJdCBlbnVtZXJhdGVzIGFsbCB0aGUgZXh0ZW5zaW9ucyB1bmRlcnN0b29kIGJ5IHRoZSBVQUMuXG4gICAgICpcbiAgICAgKiBBbiBBY2NlcHQgKFNlY3Rpb24gMjAuMSkgaGVhZGVyIGZpZWxkIE1BWSBiZSBwcmVzZW50IGluIHRoZSBJTlZJVEUuXG4gICAgICogSXQgaW5kaWNhdGVzIHdoaWNoIENvbnRlbnQtVHlwZXMgYXJlIGFjY2VwdGFibGUgdG8gdGhlIFVBLCBpbiBib3RoXG4gICAgICogdGhlIHJlc3BvbnNlIHJlY2VpdmVkIGJ5IGl0LCBhbmQgaW4gYW55IHN1YnNlcXVlbnQgcmVxdWVzdHMgc2VudCB0b1xuICAgICAqIGl0IHdpdGhpbiBkaWFsb2dzIGVzdGFibGlzaGVkIGJ5IHRoZSBJTlZJVEUuICBUaGUgQWNjZXB0IGhlYWRlciBmaWVsZFxuICAgICAqIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBpbmRpY2F0aW5nIHN1cHBvcnQgb2YgdmFyaW91cyBzZXNzaW9uXG4gICAgICogZGVzY3JpcHRpb24gZm9ybWF0cy5cbiAgICAgKlxuICAgICAqIFRoZSBVQUMgTUFZIGFkZCBhbiBFeHBpcmVzIGhlYWRlciBmaWVsZCAoU2VjdGlvbiAyMC4xOSkgdG8gbGltaXQgdGhlXG4gICAgICogdmFsaWRpdHkgb2YgdGhlIGludml0YXRpb24uICBJZiB0aGUgdGltZSBpbmRpY2F0ZWQgaW4gdGhlIEV4cGlyZXNcbiAgICAgKiBoZWFkZXIgZmllbGQgaXMgcmVhY2hlZCBhbmQgbm8gZmluYWwgYW5zd2VyIGZvciB0aGUgSU5WSVRFIGhhcyBiZWVuXG4gICAgICogcmVjZWl2ZWQsIHRoZSBVQUMgY29yZSBTSE9VTEQgZ2VuZXJhdGUgYSBDQU5DRUwgcmVxdWVzdCBmb3IgdGhlXG4gICAgICogSU5WSVRFLCBhcyBwZXIgU2VjdGlvbiA5LlxuICAgICAqXG4gICAgICogQSBVQUMgTUFZIGFsc28gZmluZCBpdCB1c2VmdWwgdG8gYWRkLCBhbW9uZyBvdGhlcnMsIFN1YmplY3QgKFNlY3Rpb25cbiAgICAgKiAyMC4zNiksIE9yZ2FuaXphdGlvbiAoU2VjdGlvbiAyMC4yNSkgYW5kIFVzZXItQWdlbnQgKFNlY3Rpb24gMjAuNDEpXG4gICAgICogaGVhZGVyIGZpZWxkcy4gIFRoZXkgYWxsIGNvbnRhaW4gaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgSU5WSVRFLlxuICAgICAqXG4gICAgICogVGhlIFVBQyBNQVkgY2hvb3NlIHRvIGFkZCBhIG1lc3NhZ2UgYm9keSB0byB0aGUgSU5WSVRFLiAgU2VjdGlvblxuICAgICAqIDguMS4xLjEwIGRlYWxzIHdpdGggaG93IHRvIGNvbnN0cnVjdCB0aGUgaGVhZGVyIGZpZWxkcyAtLSBDb250ZW50LVxuICAgICAqIFR5cGUgYW1vbmcgb3RoZXJzIC0tIG5lZWRlZCB0byBkZXNjcmliZSB0aGUgbWVzc2FnZSBib2R5LlxuICAgICAqXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5zZW5kSW52aXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAgICBUaGVyZSBhcmUgc3BlY2lhbCBydWxlcyBmb3IgbWVzc2FnZSBib2RpZXMgdGhhdCBjb250YWluIGEgc2Vzc2lvblxuICAgICAgICAvLyAgICBkZXNjcmlwdGlvbiAtIHRoZWlyIGNvcnJlc3BvbmRpbmcgQ29udGVudC1EaXNwb3NpdGlvbiBpcyBcInNlc3Npb25cIi5cbiAgICAgICAgLy8gICAgU0lQIHVzZXMgYW4gb2ZmZXIvYW5zd2VyIG1vZGVsIHdoZXJlIG9uZSBVQSBzZW5kcyBhIHNlc3Npb25cbiAgICAgICAgLy8gICAgZGVzY3JpcHRpb24sIGNhbGxlZCB0aGUgb2ZmZXIsIHdoaWNoIGNvbnRhaW5zIGEgcHJvcG9zZWQgZGVzY3JpcHRpb25cbiAgICAgICAgLy8gICAgb2YgdGhlIHNlc3Npb24uICBUaGUgb2ZmZXIgaW5kaWNhdGVzIHRoZSBkZXNpcmVkIGNvbW11bmljYXRpb25zIG1lYW5zXG4gICAgICAgIC8vICAgIChhdWRpbywgdmlkZW8sIGdhbWVzKSwgcGFyYW1ldGVycyBvZiB0aG9zZSBtZWFucyAoc3VjaCBhcyBjb2RlY1xuICAgICAgICAvLyAgICB0eXBlcykgYW5kIGFkZHJlc3NlcyBmb3IgcmVjZWl2aW5nIG1lZGlhIGZyb20gdGhlIGFuc3dlcmVyLiAgVGhlXG4gICAgICAgIC8vICAgIG90aGVyIFVBIHJlc3BvbmRzIHdpdGggYW5vdGhlciBzZXNzaW9uIGRlc2NyaXB0aW9uLCBjYWxsZWQgdGhlXG4gICAgICAgIC8vICAgIGFuc3dlciwgd2hpY2ggaW5kaWNhdGVzIHdoaWNoIGNvbW11bmljYXRpb25zIG1lYW5zIGFyZSBhY2NlcHRlZCwgdGhlXG4gICAgICAgIC8vICAgIHBhcmFtZXRlcnMgdGhhdCBhcHBseSB0byB0aG9zZSBtZWFucywgYW5kIGFkZHJlc3NlcyBmb3IgcmVjZWl2aW5nXG4gICAgICAgIC8vICAgIG1lZGlhIGZyb20gdGhlIG9mZmVyZXIuIEFuIG9mZmVyL2Fuc3dlciBleGNoYW5nZSBpcyB3aXRoaW4gdGhlXG4gICAgICAgIC8vICAgIGNvbnRleHQgb2YgYSBkaWFsb2csIHNvIHRoYXQgaWYgYSBTSVAgSU5WSVRFIHJlc3VsdHMgaW4gbXVsdGlwbGVcbiAgICAgICAgLy8gICAgZGlhbG9ncywgZWFjaCBpcyBhIHNlcGFyYXRlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gIFRoZSBvZmZlci9hbnN3ZXJcbiAgICAgICAgLy8gICAgbW9kZWwgZGVmaW5lcyByZXN0cmljdGlvbnMgb24gd2hlbiBvZmZlcnMgYW5kIGFuc3dlcnMgY2FuIGJlIG1hZGVcbiAgICAgICAgLy8gICAgKGZvciBleGFtcGxlLCB5b3UgY2Fubm90IG1ha2UgYSBuZXcgb2ZmZXIgd2hpbGUgb25lIGlzIGluIHByb2dyZXNzKS5cbiAgICAgICAgLy8gICAgVGhpcyByZXN1bHRzIGluIHJlc3RyaWN0aW9ucyBvbiB3aGVyZSB0aGUgb2ZmZXJzIGFuZCBhbnN3ZXJzIGNhblxuICAgICAgICAvLyAgICBhcHBlYXIgaW4gU0lQIG1lc3NhZ2VzLiAgSW4gdGhpcyBzcGVjaWZpY2F0aW9uLCBvZmZlcnMgYW5kIGFuc3dlcnNcbiAgICAgICAgLy8gICAgY2FuIG9ubHkgYXBwZWFyIGluIElOVklURSByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLCBhbmQgQUNLLiAgVGhlIHVzYWdlXG4gICAgICAgIC8vICAgIG9mIG9mZmVycyBhbmQgYW5zd2VycyBpcyBmdXJ0aGVyIHJlc3RyaWN0ZWQuICBGb3IgdGhlIGluaXRpYWwgSU5WSVRFXG4gICAgICAgIC8vICAgIHRyYW5zYWN0aW9uLCB0aGUgcnVsZXMgYXJlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICBvICBUaGUgaW5pdGlhbCBvZmZlciBNVVNUIGJlIGluIGVpdGhlciBhbiBJTlZJVEUgb3IsIGlmIG5vdCB0aGVyZSxcbiAgICAgICAgLy8gICAgICAgICAgaW4gdGhlIGZpcnN0IHJlbGlhYmxlIG5vbi1mYWlsdXJlIG1lc3NhZ2UgZnJvbSB0aGUgVUFTIGJhY2sgdG9cbiAgICAgICAgLy8gICAgICAgICAgdGhlIFVBQy4gIEluIHRoaXMgc3BlY2lmaWNhdGlvbiwgdGhhdCBpcyB0aGUgZmluYWwgMnh4XG4gICAgICAgIC8vICAgICAgICAgIHJlc3BvbnNlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICBvICBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiBhbiBJTlZJVEUsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiBhXG4gICAgICAgIC8vICAgICAgICAgIHJlbGlhYmxlIG5vbi1mYWlsdXJlIG1lc3NhZ2UgZnJvbSBVQVMgYmFjayB0byBVQUMgd2hpY2ggaXNcbiAgICAgICAgLy8gICAgICAgICAgY29ycmVsYXRlZCB0byB0aGF0IElOVklURS4gIEZvciB0aGlzIHNwZWNpZmljYXRpb24sIHRoYXQgaXNcbiAgICAgICAgLy8gICAgICAgICAgb25seSB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFLiAgVGhhdCBzYW1lIGV4YWN0XG4gICAgICAgIC8vICAgICAgICAgIGFuc3dlciBNQVkgYWxzbyBiZSBwbGFjZWQgaW4gYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBzZW50XG4gICAgICAgIC8vICAgICAgICAgIHByaW9yIHRvIHRoZSBhbnN3ZXIuICBUaGUgVUFDIE1VU1QgdHJlYXQgdGhlIGZpcnN0IHNlc3Npb25cbiAgICAgICAgLy8gICAgICAgICAgZGVzY3JpcHRpb24gaXQgcmVjZWl2ZXMgYXMgdGhlIGFuc3dlciwgYW5kIE1VU1QgaWdub3JlIGFueVxuICAgICAgICAvLyAgICAgICAgICBzZXNzaW9uIGRlc2NyaXB0aW9ucyBpbiBzdWJzZXF1ZW50IHJlc3BvbnNlcyB0byB0aGUgaW5pdGlhbFxuICAgICAgICAvLyAgICAgICAgICBJTlZJVEUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgIG8gIElmIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIHRoZSBmaXJzdCByZWxpYWJsZSBub24tZmFpbHVyZVxuICAgICAgICAvLyAgICAgICAgICBtZXNzYWdlIGZyb20gdGhlIFVBUyBiYWNrIHRvIFVBQywgdGhlIGFuc3dlciBNVVNUIGJlIGluIHRoZVxuICAgICAgICAvLyAgICAgICAgICBhY2tub3dsZWRnZW1lbnQgZm9yIHRoYXQgbWVzc2FnZSAoaW4gdGhpcyBzcGVjaWZpY2F0aW9uLCBBQ0tcbiAgICAgICAgLy8gICAgICAgICAgZm9yIGEgMnh4IHJlc3BvbnNlKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgbyAgQWZ0ZXIgaGF2aW5nIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBmaXJzdCBvZmZlciwgdGhlXG4gICAgICAgIC8vICAgICAgICAgIFVBQyBNQVkgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gcmVxdWVzdHMgYmFzZWQgb24gcnVsZXNcbiAgICAgICAgLy8gICAgICAgICAgc3BlY2lmaWVkIGZvciB0aGF0IG1ldGhvZCwgYnV0IG9ubHkgaWYgaXQgaGFzIHJlY2VpdmVkIGFuc3dlcnNcbiAgICAgICAgLy8gICAgICAgICAgdG8gYW55IHByZXZpb3VzIG9mZmVycywgYW5kIGhhcyBub3Qgc2VudCBhbnkgb2ZmZXJzIHRvIHdoaWNoIGl0XG4gICAgICAgIC8vICAgICAgICAgIGhhc24ndCBnb3R0ZW4gYW4gYW5zd2VyLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICBvICBPbmNlIHRoZSBVQVMgaGFzIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBpbml0aWFsXG4gICAgICAgIC8vICAgICAgICAgIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgIC8vICAgICAgICAgIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAgIC8vICAgICAgICAgIHNwZWNpZmljYXRpb24gYWxvbmUgY2FuIG5ldmVyIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIHVudGlsXG4gICAgICAgIC8vICAgICAgICAgIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIDUgVGhlIE9mZmVyL0Fuc3dlciBNb2RlbCBhbmQgUFJBQ0tcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgUkZDIDMyNjEgZGVzY3JpYmVzIGd1aWRlbGluZXMgZm9yIHRoZSBzZXRzIG9mIG1lc3NhZ2VzIGluIHdoaWNoXG4gICAgICAgIC8vICAgIG9mZmVycyBhbmQgYW5zd2VycyBbM10gY2FuIGFwcGVhci4gIEJhc2VkIG9uIHRob3NlIGd1aWRlbGluZXMsIHRoaXNcbiAgICAgICAgLy8gICAgZXh0ZW5zaW9uIHByb3ZpZGVzIGFkZGl0aW9uYWwgb3Bwb3J0dW5pdGllcyBmb3Igb2ZmZXIvYW5zd2VyXG4gICAgICAgIC8vICAgIGV4Y2hhbmdlcy5cbiAgICAgICAgLy8gICAgSWYgdGhlIElOVklURSBjb250YWluZWQgYW4gb2ZmZXIsIHRoZSBVQVMgTUFZIGdlbmVyYXRlIGFuIGFuc3dlciBpbiBhXG4gICAgICAgIC8vICAgIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIChhc3N1bWluZyB0aGVzZSBhcmUgc3VwcG9ydGVkIGJ5IHRoZVxuICAgICAgICAvLyAgICBVQUMpLiAgVGhhdCByZXN1bHRzIGluIHRoZSBlc3RhYmxpc2htZW50IG9mIHRoZSBzZXNzaW9uIGJlZm9yZVxuICAgICAgICAvLyAgICBjb21wbGV0aW9uIG9mIHRoZSBjYWxsLiAgU2ltaWxhcmx5LCBpZiBhIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgICAgIC8vICAgIHJlc3BvbnNlIGlzIHRoZSBmaXJzdCByZWxpYWJsZSBtZXNzYWdlIHNlbnQgYmFjayB0byB0aGUgVUFDLCBhbmQgdGhlXG4gICAgICAgIC8vICAgIElOVklURSBkaWQgbm90IGNvbnRhaW4gYW4gb2ZmZXIsIG9uZSBNVVNUIGFwcGVhciBpbiB0aGF0IHJlbGlhYmxlXG4gICAgICAgIC8vICAgIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlxuICAgICAgICAvLyAgICBJZiB0aGUgVUFDIHJlY2VpdmVzIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhbiBvZmZlclxuICAgICAgICAvLyAgICAodGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgVUFDIHNlbnQgYW4gSU5WSVRFIHdpdGhvdXQgYW4gb2ZmZXIsIGluXG4gICAgICAgIC8vICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpbGwgY29udGFpbiB0aGVcbiAgICAgICAgLy8gICAgb2ZmZXIpLCBpdCBNVVNUIGdlbmVyYXRlIGFuIGFuc3dlciBpbiB0aGUgUFJBQ0suICBJZiB0aGUgVUFDIHJlY2VpdmVzXG4gICAgICAgIC8vICAgIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhbiBhbnN3ZXIsIGl0IE1BWSBnZW5lcmF0ZSBhblxuICAgICAgICAvLyAgICBhZGRpdGlvbmFsIG9mZmVyIGluIHRoZSBQUkFDSy4gIElmIHRoZSBVQVMgcmVjZWl2ZXMgYSBQUkFDSyB3aXRoIGFuXG4gICAgICAgIC8vICAgIG9mZmVyLCBpdCBNVVNUIHBsYWNlIHRoZSBhbnN3ZXIgaW4gdGhlIDJ4eCB0byB0aGUgUFJBQ0suXG4gICAgICAgIC8vICAgIE9uY2UgYW4gYW5zd2VyIGhhcyBiZWVuIHNlbnQgb3IgcmVjZWl2ZWQsIHRoZSBVQSBTSE9VTEQgZXN0YWJsaXNoIHRoZVxuICAgICAgICAvLyAgICBzZXNzaW9uIGJhc2VkIG9uIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBvZmZlciBhbmQgYW5zd2VyLCBldmVuIGlmIHRoZVxuICAgICAgICAvLyAgICBvcmlnaW5hbCBJTlZJVEUgaXRzZWxmIGhhcyBub3QgYmVlbiByZXNwb25kZWQgdG8uXG4gICAgICAgIC8vICAgIElmIHRoZSBVQVMgaGFkIHBsYWNlZCBhIHNlc3Npb24gZGVzY3JpcHRpb24gaW4gYW55IHJlbGlhYmxlXG4gICAgICAgIC8vICAgIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHRoYXQgaXMgdW5hY2tub3dsZWRnZWQgd2hlbiB0aGUgSU5WSVRFIGlzXG4gICAgICAgIC8vICAgIGFjY2VwdGVkLCB0aGUgVUFTIE1VU1QgZGVsYXkgc2VuZGluZyB0aGUgMnh4IHVudGlsIHRoZSBwcm92aXNpb25hbFxuICAgICAgICAvLyAgICByZXNwb25zZSBpcyBhY2tub3dsZWRnZWQuICBPdGhlcndpc2UsIHRoZSByZWxpYWJpbGl0eSBvZiB0aGUgMXh4XG4gICAgICAgIC8vICAgIGNhbm5vdCBiZSBndWFyYW50ZWVkLCBhbmQgcmVsaWFiaWxpdHkgaXMgbmVlZGVkIGZvciBwcm9wZXIgb3BlcmF0aW9uXG4gICAgICAgIC8vICAgIG9mIHRoZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UuXG4gICAgICAgIC8vICAgIEFsbCB1c2VyIGFnZW50cyB0aGF0IHN1cHBvcnQgdGhpcyBleHRlbnNpb24gTVVTVCBzdXBwb3J0IGFsbFxuICAgICAgICAvLyAgICBvZmZlci9hbnN3ZXIgZXhjaGFuZ2VzIHRoYXQgYXJlIHBvc3NpYmxlIGJhc2VkIG9uIHRoZSBydWxlcyBpblxuICAgICAgICAvLyAgICBTZWN0aW9uIDEzLjIgb2YgUkZDIDMyNjEsIGJhc2VkIG9uIHRoZSBleGlzdGVuY2Ugb2YgSU5WSVRFIGFuZCBQUkFDS1xuICAgICAgICAvLyAgICBhcyByZXF1ZXN0cywgYW5kIDJ4eCBhbmQgcmVsaWFibGUgMXh4IGFzIG5vbi1mYWlsdXJlIHJlbGlhYmxlXG4gICAgICAgIC8vICAgIHJlc3BvbnNlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi01XG4gICAgICAgIC8vLy9cbiAgICAgICAgLy8gVGhlIE9mZmVyL0Fuc3dlciBNb2RlbCBJbXBsZW1lbnRhdGlvblxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgb2ZmZXIvYW5zd2VyIG1vZGVsIGlzIHN0cmFpZ2h0IGZvcndhcmQsIGJ1dCBvbmUgTVVTVCBSRUFEIHRoZSBzcGVjaWZpY2F0aW9ucy4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyAxMy4yLjEgQ3JlYXRpbmcgdGhlIEluaXRpYWwgSU5WSVRFIChwYXJhZ3JhcGggOCBpbiBwYXJ0aWN1bGFyKVxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAvL1xuICAgICAgICAvLyA1IFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgYW5kIFBSQUNLXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNVxuICAgICAgICAvL1xuICAgICAgICAvLyBTZXNzaW9uIEluaXRpYXRpb24gUHJvdG9jb2wgKFNJUCkgVXNhZ2Ugb2YgdGhlIE9mZmVyL0Fuc3dlciBNb2RlbFxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjMzN1xuICAgICAgICAvL1xuICAgICAgICAvLyAqKiogSU1QT1JUQU5UIElNUExFTUVOVEFUSU9OIENIT0lDRVMgKioqXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRMRFIuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIDEpIE9ubHkgb25lIG9mZmVyL2Fuc3dlciBleGNoYW5nZSBwZXJtaXR0ZWQgZHVyaW5nIGluaXRpYWwgSU5WSVRFLlxuICAgICAgICAvLyAgMikgTm8gXCJlYXJseSBtZWRpYVwiIGlmIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIGFuIElOVklURS5cbiAgICAgICAgLy9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMSkgSW5pdGlhbCBPZmZlci9BbnN3ZXIgUmVzdHJpY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE91ciBpbXBsZW1lbnRhdGlvbiByZXBsYWNlcyB0aGUgZm9sbG93aW5nIGJ1bGxldCBwb2ludC4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvICBBZnRlciBoYXZpbmcgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGZpcnN0IG9mZmVyLCB0aGVcbiAgICAgICAgLy8gICAgVUFDIE1BWSBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiByZXF1ZXN0cyBiYXNlZCBvbiBydWxlc1xuICAgICAgICAvLyAgICBzcGVjaWZpZWQgZm9yIHRoYXQgbWV0aG9kLCBidXQgb25seSBpZiBpdCBoYXMgcmVjZWl2ZWQgYW5zd2Vyc1xuICAgICAgICAvLyAgICB0byBhbnkgcHJldmlvdXMgb2ZmZXJzLCBhbmQgaGFzIG5vdCBzZW50IGFueSBvZmZlcnMgdG8gd2hpY2ggaXRcbiAgICAgICAgLy8gICAgaGFzbid0IGdvdHRlbiBhbiBhbnN3ZXIuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC4uLndpdGguLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbyAgQWZ0ZXIgaGF2aW5nIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBmaXJzdCBvZmZlciwgdGhlXG4gICAgICAgIC8vICAgIFVBQyBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiByZXF1ZXN0cyBiYXNlZCBvbiBydWxlc1xuICAgICAgICAvLyAgICBzcGVjaWZpZWQgZm9yIHRoYXQgbWV0aG9kLlxuICAgICAgICAvL1xuICAgICAgICAvLyAuLi53aGljaCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoaXMgYnVsbGV0IHBvaW50Li4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG8gIE9uY2UgdGhlIFVBUyBoYXMgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgLy8gICAgb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICAgICAgLy8gICAgdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICAgICAgLy8gICAgc3BlY2lmaWNhdGlvbiBhbG9uZSBjYW4gbmV2ZXIgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgdW50aWxcbiAgICAgICAgLy8gICAgY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLi4uZW5zdXJlcyB0aGF0IEVYQUNUTFkgT05FIG9mZmVyL2Fuc3dlciBleGNoYW5nZSB3aWxsIG9jY3VyXG4gICAgICAgIC8vIGR1cmluZyBhbiBpbml0aWFsIG91dCBvZiBkaWFsb2cgSU5WSVRFIHJlcXVlc3QgbWFkZSBieSBvdXIgVUFDLlxuICAgICAgICAvL1xuICAgICAgICAvL1xuICAgICAgICAvLyAyKSBFYXJseSBNZWRpYSBSZXN0cmljdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2hpbGUgb3VyIGltcGxlbWVudGF0aW9uIGFkaGVyZXMgdG8gdGhlIGZvbGxvd2luZyBidWxsZXQgcG9pbnQuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbyAgSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gYVxuICAgICAgICAvLyAgICByZWxpYWJsZSBub24tZmFpbHVyZSBtZXNzYWdlIGZyb20gVUFTIGJhY2sgdG8gVUFDIHdoaWNoIGlzXG4gICAgICAgIC8vICAgIGNvcnJlbGF0ZWQgdG8gdGhhdCBJTlZJVEUuICBGb3IgdGhpcyBzcGVjaWZpY2F0aW9uLCB0aGF0IGlzXG4gICAgICAgIC8vICAgIG9ubHkgdGhlIGZpbmFsIDJ4eCByZXNwb25zZSB0byB0aGF0IElOVklURS4gIFRoYXQgc2FtZSBleGFjdFxuICAgICAgICAvLyAgICBhbnN3ZXIgTUFZIGFsc28gYmUgcGxhY2VkIGluIGFueSBwcm92aXNpb25hbCByZXNwb25zZXMgc2VudFxuICAgICAgICAvLyAgICBwcmlvciB0byB0aGUgYW5zd2VyLiAgVGhlIFVBQyBNVVNUIHRyZWF0IHRoZSBmaXJzdCBzZXNzaW9uXG4gICAgICAgIC8vICAgIGRlc2NyaXB0aW9uIGl0IHJlY2VpdmVzIGFzIHRoZSBhbnN3ZXIsIGFuZCBNVVNUIGlnbm9yZSBhbnlcbiAgICAgICAgLy8gICAgc2Vzc2lvbiBkZXNjcmlwdGlvbnMgaW4gc3Vic2VxdWVudCByZXNwb25zZXMgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgLy8gICAgSU5WSVRFLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBoYXZlIG1hZGUgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBkZWNpc2lvbiB3aXRoIHJlZ2FyZCB0byBlYXJseSBtZWRpYS4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvICBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiB0aGUgSU5WSVRFLCB0aGUgYW5zd2VyIGZyb20gdGhlXG4gICAgICAgIC8vICAgIFVBUyBiYWNrIHRvIHRoZSBVQUMgd2lsbCBlc3RhYmxpc2ggYSBtZWRpYSBzZXNzaW9uIG9ubHlcbiAgICAgICAgLy8gICAgb25seSBhZnRlciB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFIGlzIHJlY2VpdmVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcmVhc29uIGZvciB0aGlzIGRlY2lzaW9uIGlzIHJvb3RlZCBpbiBhIHJlc3RyaWN0aW9uIGN1cnJlbnRseVxuICAgICAgICAvLyBpbmhlcmVudCBpbiBXZWJSVEMuIFNwZWNpZmljYWxseSwgd2hpbGUgYSBTSVAgSU5WSVRFIHJlcXVlc3Qgd2l0aCBhblxuICAgICAgICAvLyBpbml0aWFsIG9mZmVyIG1heSBmb3JrIHJlc3VsdGluZyBpbiBtb3JlIHRoYW4gb25lIHByb3Zpc2lvbmFsIGFuc3dlcixcbiAgICAgICAgLy8gdGhlcmUgaXMgY3VycmVudGx5IG5vIGVhc3kvZ29vZCB3YXkgdG8gdG8gXCJmb3JrXCIgYW4gb2ZmZXIgZ2VuZXJhdGVkXG4gICAgICAgIC8vIGJ5IGEgcGVlciBjb25uZWN0aW9uLiBJbiBwYXJ0aWN1bGFyLCBhIFdlYlJUQyBvZmZlciBjdXJyZW50bHkgbWF5IG9ubHlcbiAgICAgICAgLy8gYmUgbWF0Y2hlZCB3aXRoIG9uZSBhbnN3ZXIgYW5kIHdlIGhhdmUgbm8gZ29vZCB3YXkgdG8ga25vdyB3aGljaFxuICAgICAgICAvLyBcInByb3Zpc2lvbmFsIGFuc3dlclwiIGlzIGdvaW5nIHRvIGJlIHRoZSBcImZpbmFsIGFuc3dlclwiLiBTbyB3ZSBoYXZlXG4gICAgICAgIC8vIGRlY2lkZWQgdG8gcHVudCBhbmQgbm90IGNyZWF0ZSBhbnkgXCJlYXJseSBtZWRpYVwiIHNlc3Npb25zIGluIHRoaXMgY2FzZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHVwc2hvdCBpcyB0aGF0IGlmIHlvdSB3YW50IFwiZWFybHkgbWVkaWFcIiwgeW91IG11c3Qgbm90IHB1dCB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBvZmZlciBpbiB0aGUgSU5WSVRFLiBJbnN0ZWFkLCBmb3JjZSB0aGUgVUFTIHRvIHByb3ZpZGUgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgb2ZmZXIgYnkgc2VuZGluZyBhbiBJTlZJVEUgd2l0aG91dCBhbiBvZmZlci4gSW4gdGhlIFdlYlJUQ1xuICAgICAgICAvLyBjYXNlIHRoaXMgYWxsb3dzIHVzIHRvIGNyZWF0ZSBhIHVuaXF1ZSBwZWVyIGNvbm5lY3Rpb24gd2l0aCBhIHVuaXF1ZVxuICAgICAgICAvLyBhbnN3ZXIgZm9yIGV2ZXJ5IHByb3Zpc2lvbmFsIG9mZmVyIHdpdGggXCJlYXJseSBtZWRpYVwiIG9uIGFsbCBvZiB0aGVtLlxuICAgICAgICAvLy8vXG4gICAgICAgIC8vLy9cbiAgICAgICAgLy8gUk9BRE1BUDogVGhlIE9mZmVyL0Fuc3dlciBNb2RlbCBJbXBsZW1lbnRhdGlvblxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgXCJubyBlYXJseSBtZWRpYSBpZiBvZmZlciBpbiBJTlZJVEVcIiBpbXBsZW1lbnRhdGlvbiBpcyBub3QgYVxuICAgICAgICAvLyB3ZWxjb21lIG9uZS4gVGhlIG1hc3NlcyB3YW50IGl0LiBUaGUgd2FudCBpdCBhbmQgdGhleSB3YW50IGl0XG4gICAgICAgIC8vIHRvIHdvcmsgZm9yIFdlYlJUQyAoc28gdGhleSB3YW50IHRvIGhhdmUgdGhlaXIgY2FrZSBhbmQgZWF0IHRvbykuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNvIHdoaWxlIHdlIGN1cnJlbnRseSBjYW5ub3QgbWFrZSB0aGUgb2ZmZXIgaW4gSU5WSVRFK2Zvcmtpbmcrd2VicnRjXG4gICAgICAgIC8vIGNhc2Ugd29yaywgd2UgZGVjaWRlZCB0byBkbyB0aGUgZm9sbG93aW5nLi4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEpIG1vZGlmeSBTREggRmFjdG9yeSB0byBwcm92aWRlIGFuIGluaXRpYWwgb2ZmZXIgd2l0aG91dCBnaXZpbmcgdXMgdGhlIFNESCwgYW5kIHRoZW4uLi5cbiAgICAgICAgLy8gMikgc3RpY2sgdGhhdCBvZmZlciBpbiB0aGUgaW5pdGlhbCBJTlZJVEUsIGFuZCB3aGVuIDE4MyB3aXRoIGluaXRpYWwgYW5zd2VyIGlzIHJlY2VpdmVkLi4uXG4gICAgICAgIC8vIDMpIGFzayBTREggRmFjdG9yeSBpZiBpdCBzdXBwb3J0cyBcImVhcmx5UmVtb3RlQW5zd2VyXCJcbiAgICAgICAgLy8gICBhKSBpZiB0cnVlLCBhc2sgU0RIIEZhY3RvcnkgdG8gY3JlYXRlU0RIKGxvY2FsT2ZmZXIpLnRoZW4oKHNkaCkgPT4gc2RoLnNldERlc2NyaXB0aW9uKHJlbW90ZUFuc3dlcilcbiAgICAgICAgLy8gICBiKSBpZiBmYWxzZSwgZGVmZXIgZ2V0dGluZyBhIFNESCB1bnRpbCAyeHggcmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3VyIHN1cHBsaWVkIFdlYlJUQyBTREggd2lsbCBkZWZhdWx0IHRvIGJlaGF2aW9yIDNiIHdoaWNoIHdvcmtzIGluIGZvcmtpbmcgZW52aXJvbm1lbnQgKHdpdGhvdXQpXG4gICAgICAgIC8vIGVhcmx5IG1lZGlhIGlmIGluaXRpYWwgb2ZmZXIgaXMgaW4gdGhlIElOVklURSkuIFdlIHdpbGwsIGhvd2V2ZXIsIHByb3ZpZGUgYW4gXCJpbnZpdGVXaWxsTm90Rm9ya1wiXG4gICAgICAgIC8vIG9wdGlvbiB3aGljaCBpZiBzZXQgdG8gXCJ0cnVlXCIgd2lsbCBoYXZlIG91ciBzdXBwbGllZCBXZWJSVEMgU0RIIGJlaGF2ZSBpbiB0aGUgM2EgbWFubmVyLlxuICAgICAgICAvLyBUaGF0IHdpbGwgcmVzdWx0IGluXG4gICAgICAgIC8vICAtIGVhcmx5IG1lZGlhIHdvcmtpbmcgd2l0aCBpbml0aWFsIG9mZmVyIGluIHRoZSBJTlZJVEUsIGFuZC4uLlxuICAgICAgICAvLyAgLSBpZiB0aGUgSU5WSVRFIGZvcmtzLCB0aGUgc2Vzc2lvbiB0ZXJtaW5hdGluZyB3aXRoIGFuIEVSUk9SIHRoYXQgcmVhZHMgbGlrZVxuICAgICAgICAvLyAgICBcIllvdSBzZXQgJ2ludml0ZVdpbGxOb3RGb3JrJyB0byB0cnVlIGJ1dCB0aGUgSU5WSVRFIGZvcmtlZC4gWW91IGNhbid0IGVhdCB5b3VyIGNha2UsIGFuZCBoYXZlIGl0IHRvby5cIlxuICAgICAgICAvLyAgLSBmdXJ0aGVybW9yZSwgd2UgYWNjZXB0IHRoYXQgdXNlcnMgd2lsbCByZXBvcnQgdGhhdCBlcnJvciB0byB1cyBhcyBcImJ1Z1wiIHJlZ2FyZGxlc3NcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU28sIFNESCBGYWN0b3J5IGlzIGdvaW5nIHRvIGVuZCB1cCB3aXRoIGEgbmV3IGludGVyZmFjZSBhbG9uZyB0aGUgbGluZXMgb2YuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaW50ZXJmYWNlIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5IHtcbiAgICAgICAgLy8gICBtYWtlTG9jYWxPZmZlcigpOiBQcm9taXNlPENvbnRlbnRUeXBlQW5kQm9keT47XG4gICAgICAgIC8vICAgbWFrZVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoXG4gICAgICAgIC8vICAgICBpbml0aWFsT2ZmZXI6IENvbnRlbnRUeXBlQW5kQm9keSwgb2ZmZXJUeXBlOiBcImxvY2FsXCIgfCBcInJlbW90ZVwiXG4gICAgICAgIC8vICAgKTogUHJvbWlzZTxTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyPjtcbiAgICAgICAgLy8gICBzdXBwb3J0c0Vhcmx5UmVtb3RlQW5zd2VyOiBib29sZWFuO1xuICAgICAgICAvLyAgIHN1cHBvcnRzQ29udGVudFR5cGUoY29udGVudFR5cGU6IHN0cmluZyk6IGJvb2xlYW47XG4gICAgICAgIC8vICAgZ2V0RGVzY3JpcHRpb24oZGVzY3JpcHRpb246IENvbnRlbnRUeXBlQW5kQm9keSk6IFByb21pc2U8Q29udGVudFR5cGVBbmRCb2R5PlxuICAgICAgICAvLyAgIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBDb250ZW50VHlwZUFuZEJvZHkpOiBQcm9taXNlPHZvaWQ+XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiBhbGwgdGhlIGhhc09mZmVyL2hhc0Fuc3dlciB0cmFja2luZyBjb2RlIGFuZCBvdGhlcndpc2UgY29kZVxuICAgICAgICAvLyBpdCB1cCB0byB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoIHRoZSBTREggRmFjdG9yeSBhbmQgU0RIIHJlZ2FyZGxlc3Mgb2Ygc2lnbmFsaW5nIHNjZW5hcmlvLlxuICAgICAgICAvLy8vXG4gICAgICAgIC8vIFNlbmQgdGhlIElOVklURSByZXF1ZXN0LlxuICAgICAgICB0aGlzLm91dGdvaW5nSW52aXRlUmVxdWVzdCA9IHRoaXMudWEudXNlckFnZW50Q29yZS5pbnZpdGUodGhpcy5yZXF1ZXN0LCB7XG4gICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vbkFjY2VwdChpbnZpdGVSZXNwb25zZSk7IH0sXG4gICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLm9uUHJvZ3Jlc3MoaW52aXRlUmVzcG9uc2UpOyB9LFxuICAgICAgICAgICAgb25SZWRpcmVjdDogZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vblJlZGlyZWN0KGludml0ZVJlc3BvbnNlKTsgfSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLm9uUmVqZWN0KGludml0ZVJlc3BvbnNlKTsgfSxcbiAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLm9uVHJ5aW5nKGludml0ZVJlc3BvbnNlKTsgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLmFja0FuZEJ5ZSA9IGZ1bmN0aW9uIChpbnZpdGVSZXNwb25zZSwgc2Vzc2lvbiwgc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlKSB7XG4gICAgICAgIGlmICghdGhpcy51YS51c2VyQWdlbnRDb3JlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgcmVxdWlyZXMgdXNlciBhZ2VudCBjb3JlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG4gICAgICAgIGlmIChzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlYXNvbjogXCIgKyBVdGlsc18xLlV0aWxzLmdldFJlYXNvbkhlYWRlclZhbHVlKHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRnb2luZ0Fja1JlcXVlc3QgPSBpbnZpdGVSZXNwb25zZS5hY2soKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiYWNrXCIsIG91dGdvaW5nQWNrUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgdmFyIG91dGdvaW5nQnllUmVxdWVzdCA9IHNlc3Npb24uYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwiYnllXCIsIG91dGdvaW5nQnllUmVxdWVzdC5tZXNzYWdlKTtcbiAgICB9O1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLmRpc3Bvc2VFYXJseU1lZGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWFybHlNZWRpYVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYXJseSBtZWRpYSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXJzIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBmaW5hbCByZXNwb25zZSB0byBpbml0aWFsIElOVklURS5cbiAgICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgMnh4IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLm9uQWNjZXB0ID0gZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVhcmx5IG1lZGlhIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlcnMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBpbnZpdGVSZXNwb25zZS5tZXNzYWdlO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IGludml0ZVJlc3BvbnNlLnNlc3Npb247XG4gICAgICAgIC8vIE91ciB0cmFuc2FjdGlvbiBsYXllciBpcyBcIm5vbi1zdGFuZGFyZFwiIGluIHRoYXQgaXQgd2lsbCBvbmx5XG4gICAgICAgIC8vIHBhc3MgdXMgYSAyeHggcmVzcG9uc2Ugb25jZSBwZXIgYnJhbmNoLCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvXG4gICAgICAgIC8vIHdvcnJ5IGFib3V0IGRlYWxpbmcgd2l0aCAyeHggcmV0cmFuc21pc3Npb25zLiBIb3dldmVyLCB3ZSBjYW5cbiAgICAgICAgLy8gYW5kIGRvIHN0aWxsIGdldCAyeHggcmVzcG9uc2VzIGZvciBtdWx0aXBsZSBicmFuY2hlcyAod2hlbiBhblxuICAgICAgICAvLyBJTlZJVEUgaXMgZm9ya2VkKSB3aGljaCBtYXkgY3JlYXRlIG11bHRpcGxlIGNvbmZpcm1lZCBkaWFsb2dzLlxuICAgICAgICAvLyBIZXJlaW4gd2UgYXJlIGFja2luZyBhbmQgc2VuZGluZyBhIGJ5ZSB0byBhbnkgY29uZmlybWVkIGRpYWxvZ3NcbiAgICAgICAgLy8gd2hpY2ggYXJyaXZlIGJleW9uZCB0aGUgZmlyc3Qgb25lLiBUaGlzIGlzIHRoZSBkZXNpcmVkIGJlaGF2aW9yXG4gICAgICAgIC8vIGZvciBtb3N0IGFwcGxpY2F0aW9ucyAoYnV0IGNlcnRhaW5seSBub3QgYWxsKS5cbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSByZWNlaXZlZCBhIGNvbmZpcm1lZCBkaWFsb2csIGFjayAmIGJ5ZSB0aGlzIHNlc3Npb24uXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWNrQW5kQnllKGludml0ZVJlc3BvbnNlLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXNlciByZXF1ZXN0ZWQgY2FuY2VsbGF0aW9uLCBhY2sgJiBieWUgdGhpcyBzZXNzaW9uLlxuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSwgc2Vzc2lvbik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJieWVcIiwgdGhpcy5yZXF1ZXN0KTsgLy8gRklYTUU6IFBvcnRlZCB0aGlzIG9kZCBzZWNvbmQgXCJieWVcIiBlbWl0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9ydGVkIGJlaGF2aW9yLlxuICAgICAgICBpZiAocmVzcG9uc2UuaGFzSGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRlZElkZW50aXR5ID0gY29yZV8xLkdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShyZXNwb25zZS5nZXRIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGEgY29uZmlybWVkIGRpYWxvZy5cbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgb25BY2s6IGZ1bmN0aW9uIChhY2tSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5vbkFjayhhY2tSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgIG9uQnllOiBmdW5jdGlvbiAoYnllUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QoYnllUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICBvbkluZm86IGZ1bmN0aW9uIChpbmZvUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QoaW5mb1JlcXVlc3QpOyB9LFxuICAgICAgICAgICAgb25JbnZpdGU6IGZ1bmN0aW9uIChpbnZpdGVSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChpbnZpdGVSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2VSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChtZXNzYWdlUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICBvbk5vdGlmeTogZnVuY3Rpb24gKG5vdGlmeVJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KG5vdGlmeVJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgb25QcmFjazogZnVuY3Rpb24gKHByYWNrUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QocHJhY2tSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgIG9uUmVmZXI6IGZ1bmN0aW9uIChyZWZlclJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KHJlZmVyUmVxdWVzdCk7IH0sXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICAvLyBJTlZJVEUgd2l0aG91dCBPZmZlciwgc28gTVVTVCBoYXZlIE9mZmVyIGF0IHRoaXMgcG9pbnQsIHNvIGludmFsaWQgc3RhdGUuXG4gICAgICAgICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIHNlc3Npb24sIDQwMCwgXCJNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgICAgICAgICAvLyBJTlZJVEUgd2l0aCBPZmZlciwgc28gTVVTVCBoYXZlIEFuc3dlciBhdCB0aGlzIHBvaW50LCBzbyBpbnZhbGlkIHN0YXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuYWNrQW5kQnllKGludml0ZVJlc3BvbnNlLCBzZXNzaW9uLCA0MDAsIFwiTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgICAgICAgIC8vIElOVklURSB3aXRob3V0IE9mZmVyLCByZWNlaXZlZCBvZmZlciBpbiAyeHgsIHNvIE1VU1Qgc2VuZCBBbnN3ZXIgaW4gQUNLLlxuICAgICAgICAgICAgICAgIHZhciBzZGhfMSA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkodGhpcywgdGhpcy51YS5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gc2RoXzE7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci1jcmVhdGVkXCIsIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFzZGhfMS5oYXNEZXNjcmlwdGlvbihyZXNwb25zZS5nZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIikgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIHNlc3Npb24sIDQwMCwgXCJNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2RoXzFcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHksIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzZGhfMS5nZXREZXNjcmlwdGlvbihfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgX3RoaXMubW9kaWZpZXJzKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0NhbmNlbGVkIHx8IF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBcInNlc3Npb25cIiwgY29udGVudFR5cGU6IGRlc2NyaXB0aW9uLmNvbnRlbnRUeXBlLCBjb250ZW50OiBkZXNjcmlwdGlvbi5ib2R5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2tSZXF1ZXN0ID0gaW52aXRlUmVzcG9uc2UuYWNrKHsgYm9keTogYm9keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImFja1wiLCBhY2tSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcImludmFsaWQgZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBtZXNzYWdlIGlzIGluY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNrQW5kQnllKGludml0ZVJlc3BvbnNlLCBzZXNzaW9uLCA0ODgsIFwiSW52YWxpZCBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmFpbGVkKHJlc3BvbnNlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlOlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2Vzc2lvbiBoYXMgY29tcGxldGVkIGFuIGluaXRpYWwgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLi4uXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnNfMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJib2R5ICYmIHRoaXMucmVuZGVydHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXzEgPSB7IGJvZHk6IHsgY29udGVudERpc3Bvc2l0aW9uOiBcInJlbmRlclwiLCBjb250ZW50VHlwZTogdGhpcy5yZW5kZXJ0eXBlLCBjb250ZW50OiB0aGlzLnJlbmRlcmJvZHkgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBJTlZJVEUgd2l0aCBPZmZlciBhbmQgd2UgaGF2ZSBiZWVuIHdhaXRpbmcgdGlsbCBub3cgdG8gYXBwbHkgdGhlIGFuc3dlci5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPZmZlciAmJiAhdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnN3ZXIgPSBzZXNzaW9uLmFuc3dlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuc3dlciBpcyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKGFuc3dlci5jb250ZW50LCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY2tSZXF1ZXN0ID0gaW52aXRlUmVzcG9uc2UuYWNrKG9wdGlvbnNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYWNrXCIsIGFja1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNrQW5kQnllKGludml0ZVJlc3BvbnNlLCBzZXNzaW9uLCA0ODgsIFwiTm90IEFjY2VwdGFibGUgSGVyZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJTUU6IERPTidUIEVBVCBVTkhBTkRMRUQgRVJST1JTIVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBJTlZJVEUgd2l0aCBvciB3aXRob3V0IE9mZmVyIGFuZCB3ZSBoYXZlIGFscmVhZHkgY29tcGxldGVkIHRoZSBpbml0aWFsIGV4Y2hhbmdlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSB0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycy5nZXQoc2Vzc2lvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycy5kZWxldGUoc2Vzc2lvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2tSZXF1ZXN0ID0gaW52aXRlUmVzcG9uc2UuYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImFja1wiLCBhY2tSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2VwdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgICAgICAgICAgLy8gRGlhbG9nIGhhcyB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNlc3Npb24gc2lnbmFsaW5nIHN0YXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3Bvc2VFYXJseU1lZGlhKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgdG8gaW5pdGlhbCBJTlZJVEUuXG4gICAgICogQHBhcmFtIGludml0ZVJlc3BvbnNlIDF4eCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5vblByb2dyZXNzID0gZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFBvcnRlZCAtIFVzZXIgcmVxdWVzdGVkIGNhbmNlbGxhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vdXRnb2luZ0ludml0ZVJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dGdvaW5nIElOVklURSByZXF1ZXN0IHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFybHkgbWVkaWEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVycyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGludml0ZVJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgICAgIHZhciBzZXNzaW9uID0gaW52aXRlUmVzcG9uc2Uuc2Vzc2lvbjtcbiAgICAgICAgLy8gUG9ydGVkIC0gU2V0IHN0YXR1cy5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTXzFYWF9SRUNFSVZFRDtcbiAgICAgICAgLy8gUG9ydGVkIC0gU2V0IGFzc2VydGVkSWRlbnRpdHkuXG4gICAgICAgIGlmIChyZXNwb25zZS5oYXNIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydGVkSWRlbnRpdHkgPSBjb3JlXzEuR3JhbW1hci5uYW1lQWRkckhlYWRlclBhcnNlKHJlc3BvbnNlLmdldEhlYWRlcihcIlAtQXNzZXJ0ZWQtSWRlbnRpdHlcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwcm92aXNpb25hbCByZXNwb25zZSBNVVNUIGVzdGFibGlzaCBhIGRpYWxvZyBpZiBvbmUgaXMgbm90IHlldCBjcmVhdGVkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBBIHJlc3BvbnNlIHdpdGggYSB0byB0YWcgTVVTVCBjcmVhdGUgYSBzZXNzaW9uIChzaG91bGQgbmV2ZXIgZ2V0IGhlcmUpLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgZm9yIGFuIGluaXRpYWwgcmVxdWVzdCwgYW5kXG4gICAgICAgIC8vIHRoYXQgcmVzcG9uc2UgY29udGFpbnMgYSBSZXF1aXJlIGhlYWRlciBmaWVsZCBjb250YWluaW5nIHRoZSBvcHRpb25cbiAgICAgICAgLy8gdGFnIDEwMHJlbCwgdGhlIHJlc3BvbnNlIGlzIHRvIGJlIHNlbnQgcmVsaWFibHkuICBJZiB0aGUgcmVzcG9uc2UgaXNcbiAgICAgICAgLy8gYSAxMDAgKFRyeWluZykgKGFzIG9wcG9zZWQgdG8gMTAxIHRvIDE5OSksIHRoaXMgb3B0aW9uIHRhZyBNVVNUIGJlXG4gICAgICAgIC8vIGlnbm9yZWQsIGFuZCB0aGUgcHJvY2VkdXJlcyBiZWxvdyBNVVNUIE5PVCBiZSB1c2VkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgdmFyIHJlcXVpcmVIZWFkZXIgPSByZXNwb25zZS5nZXRIZWFkZXIoXCJyZXF1aXJlXCIpO1xuICAgICAgICB2YXIgcnNlcUhlYWRlciA9IHJlc3BvbnNlLmdldEhlYWRlcihcInJzZXFcIik7XG4gICAgICAgIHZhciByc2VxID0gcmVxdWlyZUhlYWRlciAmJiByZXF1aXJlSGVhZGVyLmluY2x1ZGVzKFwiMTAwcmVsXCIpICYmIHJzZXFIZWFkZXIgPyBOdW1iZXIocnNlcUhlYWRlcikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXNwb25zZVJlbGlhYmxlID0gISFyc2VxO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG4gICAgICAgIGlmIChyZXNwb25zZVJlbGlhYmxlKSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJBY2s6IFwiICsgcmVzcG9uc2UuZ2V0SGVhZGVyKFwicnNlcVwiKSArIFwiIFwiICsgcmVzcG9uc2UuZ2V0SGVhZGVyKFwiY3NlcVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSU5WSVRFIHdpdGhvdXQgT2ZmZXIgYW5kIHNlc3Npb24gc3RpbGwgaGFzIG5vIG9mZmVyIChhbmQgbm8gYW5zd2VyKS5cbiAgICAgICAgaWYgKHNlc3Npb24uc2lnbmFsaW5nU3RhdGUgPT09IGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsKSB7XG4gICAgICAgICAgICAvLyBTaW1pbGFybHksIGlmIGEgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIGlzIHRoZSBmaXJzdCByZWxpYWJsZSBtZXNzYWdlIHNlbnQgYmFjayB0byB0aGUgVUFDLCBhbmQgdGhlXG4gICAgICAgICAgICAvLyBJTlZJVEUgZGlkIG5vdCBjb250YWluIGFuIG9mZmVyLCBvbmUgTVVTVCBhcHBlYXIgaW4gdGhhdCByZWxpYWJsZVxuICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTVcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVJlbGlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkZpcnN0IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHJlY2VpdmVkIE1VU1QgY29udGFpbiBhbiBvZmZlciB3aGVuIElOVklURSBkb2VzIG5vdCBjb250YWluIGFuIG9mZmVyLlwiKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogS25vd24gcG9wdWxhciBVQSdzIGN1cnJlbnRseSBlbmQgdXAgaGVyZS4uLlxuICAgICAgICAgICAgICAgIGludml0ZVJlc3BvbnNlLnByYWNrKHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSU5WSVRFIHdpdGggT2ZmZXIgYW5kIHNlc3Npb24gb25seSBoYXMgdGhhdCBpbml0aWFsIGxvY2FsIG9mZmVyLlxuICAgICAgICBpZiAoc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSA9PT0gY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VSZWxpYWJsZSkge1xuICAgICAgICAgICAgICAgIGludml0ZVJlc3BvbnNlLnByYWNrKHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSU5WSVRFIHdpdGhvdXQgT2ZmZXIgYW5kIHJlY2VpdmVkIGluaXRpYWwgb2ZmZXIgaW4gcHJvdmlzaW9uYWwgcmVzcG9uc2VcbiAgICAgICAgaWYgKHNlc3Npb24uc2lnbmFsaW5nU3RhdGUgPT09IGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBpbml0aWFsIG9mZmVyIE1VU1QgYmUgaW4gZWl0aGVyIGFuIElOVklURSBvciwgaWYgbm90IHRoZXJlLFxuICAgICAgICAgICAgLy8gaW4gdGhlIGZpcnN0IHJlbGlhYmxlIG5vbi1mYWlsdXJlIG1lc3NhZ2UgZnJvbSB0aGUgVUFTIGJhY2sgdG9cbiAgICAgICAgICAgIC8vIHRoZSBVQUMuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIFNlY3Rpb24gMTMuMi4xIG9mIFtSRkMzMjYxXSwgJ1RoZSBmaXJzdCByZWxpYWJsZVxuICAgICAgICAgICAgLy8gbm9uLWZhaWx1cmUgbWVzc2FnZScgbXVzdCBoYXZlIGFuIG9mZmVyIGlmIHRoZXJlIGlzIG5vIG9mZmVyIGluIHRoZVxuICAgICAgICAgICAgLy8gSU5WSVRFIHJlcXVlc3QuICBUaGlzIG1lYW5zIHRoYXQgdGhlIFVzZXIgQWdlbnQgKFVBKSB0aGF0IHJlY2VpdmVzXG4gICAgICAgICAgICAvLyB0aGUgSU5WSVRFIHJlcXVlc3Qgd2l0aG91dCBhbiBvZmZlciBtdXN0IGluY2x1ZGUgYW4gb2ZmZXIgaW4gdGhlXG4gICAgICAgICAgICAvLyBmaXJzdCByZWxpYWJsZSByZXNwb25zZSB3aXRoIDEwMHJlbCBleHRlbnNpb24uICBJZiBubyByZWxpYWJsZVxuICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2UgaGFzIGJlZW4gc2VudCwgdGhlIFVzZXIgQWdlbnQgU2VydmVyIChVQVMpIG11c3RcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgYW4gb2ZmZXIgd2hlbiBzZW5kaW5nIDJ4eCByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MzM3I3NlY3Rpb24tMi4yXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlUmVsaWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm9uLXJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIE1VU1QgTk9UIGNvbnRhaW4gYW4gaW5pdGlhbCBvZmZlciwgZGlzY2FyZGluZyByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gdGhlIGZpcnN0IHJlbGlhYmxlIG5vbi1mYWlsdXJlXG4gICAgICAgICAgICAvLyBtZXNzYWdlIGZyb20gdGhlIFVBUyBiYWNrIHRvIFVBQywgdGhlIGFuc3dlciBNVVNUIGJlIGluIHRoZVxuICAgICAgICAgICAgLy8gYWNrbm93bGVkZ2VtZW50IGZvciB0aGF0IG1lc3NhZ2VcbiAgICAgICAgICAgIHZhciBzZGhfMiA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkodGhpcywgdGhpcy51YS5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLWNyZWF0ZWRcIiwgc2RoXzIpO1xuICAgICAgICAgICAgdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMuc2V0KHNlc3Npb24uaWQsIHNkaF8yKTtcbiAgICAgICAgICAgIHNkaF8yXG4gICAgICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHksIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNkaF8yLmdldERlc2NyaXB0aW9uKF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBfdGhpcy5tb2RpZmllcnMpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IFwic2Vzc2lvblwiLCBjb250ZW50VHlwZTogZGVzY3JpcHRpb24uY29udGVudFR5cGUsIGNvbnRlbnQ6IGRlc2NyaXB0aW9uLmJvZHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGludml0ZVJlc3BvbnNlLnByYWNrKHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZmFpbGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgc2Vzc2lvbiBoYXMgY29tcGxldGVkIGFuIGluaXRpYWwgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLCBzby4uLlxuICAgICAgICAvLyAtIElOVklURSB3aXRoIFNEUCBhbmQgdGhpcyBwcm92aXNpb25hbCByZXNwb25zZSBNQVkgYmUgcmVsaWFibGVcbiAgICAgICAgLy8gLSBJTlZJVEUgd2l0aG91dCBTRFAgYW5kIHRoaXMgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTUFZIGJlIHJlbGlhYmxlXG4gICAgICAgIGlmIChzZXNzaW9uLnNpZ25hbGluZ1N0YXRlID09PSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VSZWxpYWJsZSkge1xuICAgICAgICAgICAgICAgIGludml0ZVJlc3BvbnNlLnByYWNrKHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlOiBBcyBkb2N1bWVudGVkLCBubyBlYXJseSBtZWRpYSBpZiBvZmZlciB3YXMgaW4gSU5WSVRFLCBzbyBub3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogQWRkIGEgZmxhZy9oYWNrIHRvIGFsbG93IGVhcmx5IG1lZGlhIGluIHRoaXMgY2FzZS4gVGhlcmUgYXJlIHBlb3BsZVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGluIG5vbi1mb3JraW5nIGVudmlyb25tZW50cyAodGhpbmsgc3RyYWlnaHQgdG8gRnJlZVNXSVRDSCkgd2hvIHdhbnRcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBlYXJseSBtZWRpYSBvbiBhIDE4My4gTm90IHN1cmUgaG93IHRvIGFjdHVhbGx5IG1ha2UgaXQgd29yaywgYmFzaWNhbGx5XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgc29tZXRoaW5nIGxpa2UuLi5cbiAgICAgICAgICAgIGlmICgwIC8qIGZsYWcgKi8gJiYgdGhpcy5oYXNPZmZlciAmJiAhdGhpcy5oYXNBbnN3ZXIgJiYgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHksIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mYWlsZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcInByb2dyZXNzXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGZpbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgICAqIEBwYXJhbSBpbnZpdGVSZXNwb25zZSAzeHggcmVzcG9uc2UuXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25SZWRpcmVjdCA9IGZ1bmN0aW9uIChpbnZpdGVSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VFYXJseU1lZGlhKCk7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGludml0ZVJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgdmFyIGNhdXNlID0gVXRpbHNfMS5VdGlscy5zaXBFcnJvckNhdXNlKHN0YXR1c0NvZGUgfHwgMCk7XG4gICAgICAgIHRoaXMucmVqZWN0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZmluYWwgcmVzcG9uc2UgdG8gaW5pdGlhbCBJTlZJVEUuXG4gICAgICogQHBhcmFtIGludml0ZVJlc3BvbnNlIDR4eCwgNXh4LCBvciA2eHggcmVzcG9uc2UuXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25SZWplY3QgPSBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlRWFybHlNZWRpYSgpO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBpbnZpdGVSZXNwb25zZS5tZXNzYWdlO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuc2lwRXJyb3JDYXVzZShzdGF0dXNDb2RlIHx8IDApO1xuICAgICAgICB0aGlzLnJlamVjdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGZpbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgICAqIEBwYXJhbSBpbnZpdGVSZXNwb25zZSAxMDAgcmVzcG9uc2UuXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25UcnlpbmcgPSBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlZDEwMCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcInByb2dyZXNzXCIsIGludml0ZVJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEludml0ZUNsaWVudENvbnRleHQ7XG59KFNlc3Npb24pKTtcbmV4cG9ydHMuSW52aXRlQ2xpZW50Q29udGV4dCA9IEludml0ZUNsaWVudENvbnRleHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9Db25zdGFudHNcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbnZhciBFeGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uc1wiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xudmFyIERUTUZWYWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuL0RUTUZWYWxpZGF0b3JcIik7XG4vKipcbiAqIEBjbGFzcyBEVE1GXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKi9cbnZhciBEVE1GID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKERUTUYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRFRNRihzZXNzaW9uLCB0b25lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkMgPSB7XG4gICAgICAgICAgICBNSU5fRFVSQVRJT046IDcwLFxuICAgICAgICAgICAgTUFYX0RVUkFUSU9OOiA2MDAwLFxuICAgICAgICAgICAgREVGQVVMVF9EVVJBVElPTjogMTAwLFxuICAgICAgICAgICAgTUlOX0lOVEVSX1RPTkVfR0FQOiA1MCxcbiAgICAgICAgICAgIERFRkFVTFRfSU5URVJfVE9ORV9HQVA6IDUwMFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5EVE1GO1xuICAgICAgICBpZiAodG9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9nZ2VyID0gc2Vzc2lvbi51YS5nZXRMb2dnZXIoXCJzaXAuaW52aXRlY29udGV4dC5kdG1mXCIsIHNlc3Npb24uaWQpO1xuICAgICAgICBfdGhpcy5vd25lciA9IHNlc3Npb247XG4gICAgICAgIHZhciBtb3JlVGhhbk9uZVRvbmUgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgdG9uZSBpcyBpbnZhbGlkLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSB0b25lIGluIHRoZSBjb3JyZWN0IGZvcm1hdC5cbiAgICAgICAgX3RoaXMudG9uZSA9IERUTUZWYWxpZGF0b3JfMS5EVE1GVmFsaWRhdG9yLnZhbGlkYXRlKHRvbmUsIG1vcmVUaGFuT25lVG9uZSk7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gICAgICAgIHZhciBpbnRlclRvbmVHYXAgPSBvcHRpb25zLmludGVyVG9uZUdhcDtcbiAgICAgICAgLy8gQ2hlY2sgZHVyYXRpb25cbiAgICAgICAgaWYgKGR1cmF0aW9uICYmICFVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRvbmUgZHVyYXRpb246IFwiICsgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfdGhpcy5DLkRFRkFVTFRfRFVSQVRJT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHVyYXRpb24gPCBfdGhpcy5DLk1JTl9EVVJBVElPTikge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCInZHVyYXRpb24nIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIG1pbmltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byBcIiArXG4gICAgICAgICAgICAgICAgX3RoaXMuQy5NSU5fRFVSQVRJT04gKyBcIiBtaWxsaXNlY29uZHNcIik7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF90aGlzLkMuTUlOX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR1cmF0aW9uID4gX3RoaXMuQy5NQVhfRFVSQVRJT04pIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiJ2R1cmF0aW9uJyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byBcIiArXG4gICAgICAgICAgICAgICAgX3RoaXMuQy5NQVhfRFVSQVRJT04gKyBcIiBtaWxsaXNlY29uZHNcIik7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF90aGlzLkMuTUFYX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLmFicyhkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgLy8gQ2hlY2sgaW50ZXJUb25lR2FwXG4gICAgICAgIGlmIChpbnRlclRvbmVHYXAgJiYgIVV0aWxzXzEuVXRpbHMuaXNEZWNpbWFsKGludGVyVG9uZUdhcCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGludGVyVG9uZUdhcDogXCIgKyBpbnRlclRvbmVHYXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbnRlclRvbmVHYXApIHtcbiAgICAgICAgICAgIGludGVyVG9uZUdhcCA9IF90aGlzLkMuREVGQVVMVF9JTlRFUl9UT05FX0dBUDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnRlclRvbmVHYXAgPCBfdGhpcy5DLk1JTl9JTlRFUl9UT05FX0dBUCkge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCInaW50ZXJUb25lR2FwJyB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gXCIgK1xuICAgICAgICAgICAgICAgIF90aGlzLkMuTUlOX0lOVEVSX1RPTkVfR0FQICsgXCIgbWlsbGlzZWNvbmRzXCIpO1xuICAgICAgICAgICAgaW50ZXJUb25lR2FwID0gX3RoaXMuQy5NSU5fSU5URVJfVE9ORV9HQVA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnRlclRvbmVHYXAgPSBNYXRoLmFicyhpbnRlclRvbmVHYXApO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmludGVyVG9uZUdhcCA9IGludGVyVG9uZUdhcDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEVE1GLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gQ2hlY2sgUlRDU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgaWYgKHRoaXMub3duZXIuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCAmJlxuICAgICAgICAgICAgdGhpcy5vd25lci5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5vd25lci5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBEVE1GIG9wdGlvbnNcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzID8gb3B0aW9ucy5leHRyYUhlYWRlcnMuc2xpY2UoKSA6IFtdO1xuICAgICAgICB2YXIgYm9keSA9IHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2R0bWYtcmVsYXlcIixcbiAgICAgICAgICAgIGJvZHk6IFwiU2lnbmFsPSBcIiArIHRoaXMudG9uZSArIFwiXFxyXFxuRHVyYXRpb249IFwiICsgdGhpcy5kdXJhdGlvblxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vd25lci5zZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMub3duZXIuc2Vzc2lvbi5pbmZvKHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IFV0aWxzXzEuVXRpbHMuZnJvbUJvZHlPYmooYm9keSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vd25lci5lbWl0KFwiZHRtZlwiLCByZXF1ZXN0Lm1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEVE1GLnByb3RvdHlwZS5pbml0X2luY29taW5nID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgaWYgKCF0aGlzLnRvbmUgfHwgIXRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJpbnZhbGlkIElORk8gRFRNRiByZWNlaXZlZCwgZGlzY2FyZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vd25lci5lbWl0KFwiZHRtZlwiLCByZXF1ZXN0Lm1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEVE1GLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXNDb2RlID8gcmVzcG9uc2Uuc3RhdHVzQ29kZSA6IDA7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJzdWNjZWVkZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hdG9yOiBcInJlbW90ZVwiLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIGNhdXNlID0gVXRpbHNfMS5VdGlscy5zaXBFcnJvckNhdXNlKHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEVE1GLnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgdW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgICB0aGlzLm93bmVyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICB9O1xuICAgIERUTUYucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCB1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICB0aGlzLm93bmVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICB9O1xuICAgIERUTUYucHJvdG90eXBlLm9uRGlhbG9nRXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHJlc3BvbnNlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICAgICAgICB0aGlzLm93bmVyLm9uRGlhbG9nRXJyb3IocmVzcG9uc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIERUTUY7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5EVE1GID0gRFRNRjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERUTUZWYWxpZGF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRFRNRlZhbGlkYXRvcigpIHtcbiAgICB9XG4gICAgRFRNRlZhbGlkYXRvci52YWxpZGF0ZSA9IGZ1bmN0aW9uICh0b25lLCBtb3JlVGhhbk9uZVRvbmUpIHtcbiAgICAgICAgaWYgKG1vcmVUaGFuT25lVG9uZSA9PT0gdm9pZCAwKSB7IG1vcmVUaGFuT25lVG9uZSA9IHRydWU7IH1cbiAgICAgICAgLy8gQ2hlY2sgdG9uZSB0eXBlXG4gICAgICAgIGlmICh0eXBlb2YgdG9uZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdG9uZSA9IHRvbmUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9uZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdG9uZSA9IHRvbmUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIERUTUZWYWxpZGF0b3IuZ2VuZXJhdGVJbnZhbGlkVG9uZUVycm9yKHRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleCA9IG1vcmVUaGFuT25lVG9uZSA/IC9eWzAtOUEtRCMqLF0rJC9pIDogL15bMC05QS1EIypdJC9pO1xuICAgICAgICAvLyBDaGVjayB0b25lIHZhbHVlXG4gICAgICAgIGlmICghdG9uZS5tYXRjaChyZWdleCkpIHtcbiAgICAgICAgICAgIERUTUZWYWxpZGF0b3IuZ2VuZXJhdGVJbnZhbGlkVG9uZUVycm9yKHRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b25lO1xuICAgIH07XG4gICAgRFRNRlZhbGlkYXRvci5nZW5lcmF0ZUludmFsaWRUb25lRXJyb3IgPSBmdW5jdGlvbiAodG9uZSkge1xuICAgICAgICB2YXIgdG9uZUZvck1zZyA9ICghIXRvbmUgJiYgdHlwZW9mIHRvbmUgIT09IFwiYm9vbGVhblwiID8gdG9uZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiB0b25lKTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdG9uZShzKTogXCIgKyB0b25lRm9yTXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBEVE1GVmFsaWRhdG9yO1xufSgpKTtcbmV4cG9ydHMuRFRNRlZhbGlkYXRvciA9IERUTUZWYWxpZGF0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIGFsbG93ZWRfbWV0aG9kc18xID0gcmVxdWlyZShcIi4vY29yZS91c2VyLWFnZW50LWNvcmUvYWxsb3dlZC1tZXRob2RzXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG4vKipcbiAqIFdoaWxlIHRoaXMgY2xhc3MgaXMgbmFtZWQgYFN1YnNjcmlwdGlvbmAsIGl0IGlzIGNsb3NlciB0b1xuICogYW4gaW1wbGVtZW50YXRpb24gb2YgYSBcInN1YnNjcmliZXJcIiBhcyBkZWZpbmVkIGluIFJGQyA2NjY1XG4gKiBcIlNJUC1TcGVjaWZpYyBFdmVudCBOb3RpZmljYXRpb25zXCIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NVxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIFN1YnNjcmliZXIuXG4gKi9cbnZhciBTdWJzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB1YSBVc2VyIGFnZW50LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgU3Vic2NyaXB0aW9uIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgU3Vic2NyaXB0aW9uIGV2ZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1YSwgdGFyZ2V0LCBldmVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0ge307XG4gICAgICAgIF90aGlzLm1ldGhvZCA9IENvbnN0YW50c18xLkMuU1VCU0NSSUJFO1xuICAgICAgICBfdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBDbGllbnRDb250ZXh0IGludGVyZmFjZVxuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5TdWJzY3JpcHRpb247XG4gICAgICAgIF90aGlzLnVhID0gdWE7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcihcInNpcC5zdWJzY3JpcHRpb25cIik7XG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIF90aGlzLmJvZHkgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zLmNvbnRlbnRUeXBlID8gb3B0aW9ucy5jb250ZW50VHlwZSA6IFwiYXBwbGljYXRpb24vc2RwXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFyZ2V0IFVSSVxuICAgICAgICB2YXIgdXJpID0gdWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghdXJpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YXJnZXQ6IFwiICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiBldmVudFxuICAgICAgICBfdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICAvLyBTdWJzY3JpcHRpb24gZXhwaXJlc1xuICAgICAgICBpZiAob3B0aW9ucy5leHBpcmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLmV4cGlyZXMgPSAzNjAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgIT09IFwibnVtYmVyXCIpIHsgLy8gcHJlLXR5cGVzY3JpcHQgdHlwZSBndWFyZFxuICAgICAgICAgICAgdWEubG9nZ2VyLndhcm4oXCJPcHRpb24gXFxcImV4cGlyZXNcXFwiIG11c3QgYmUgYSBudW1iZXIuIFVzaW5nIGRlZmF1bHQgb2YgMzYwMC5cIik7XG4gICAgICAgICAgICBfdGhpcy5leHBpcmVzID0gMzYwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIGV4dHJhIGhlYWRlcnNcbiAgICAgICAgX3RoaXMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICAvLyBTdWJzY3JpcHRpb24gY29udGV4dC5cbiAgICAgICAgX3RoaXMuY29udGV4dCA9IF90aGlzLmluaXRDb250ZXh0KCk7XG4gICAgICAgIF90aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIENsaWVudENvbnRleHQgaW50ZXJmYWNlXG4gICAgICAgIF90aGlzLnJlcXVlc3QgPSBfdGhpcy5jb250ZXh0Lm1lc3NhZ2U7XG4gICAgICAgIGlmICghX3RoaXMucmVxdWVzdC5mcm9tKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpcy5yZXF1ZXN0LnRvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9jYWxJZGVudGl0eSA9IF90aGlzLnJlcXVlc3QuZnJvbTtcbiAgICAgICAgX3RoaXMucmVtb3RlSWRlbnRpdHkgPSBfdGhpcy5yZXF1ZXN0LnRvO1xuICAgICAgICAvLyBBZGQgdG8gVUEncyBjb2xsZWN0aW9uXG4gICAgICAgIF90aGlzLmlkID0gX3RoaXMucmVxdWVzdC5jYWxsSWQgKyBfdGhpcy5yZXF1ZXN0LmZyb20ucGFyYW1ldGVycy50YWcgKyBfdGhpcy5ldmVudDtcbiAgICAgICAgX3RoaXMudWEuc3Vic2NyaXB0aW9uc1tfdGhpcy5pZF0gPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cnVjdG9yLlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXRyeUFmdGVyVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5QWZ0ZXJUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJldHJ5QWZ0ZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHQuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gVUEncyBjb2xsZWN0aW9uXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgbmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVtaXQuYXBwbHkodGhpcywgdHNsaWJfMS5fX3NwcmVhZEFycmF5cyhbZXZlbnRdLCBhcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IHRlcm1pbmF0ZS5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29udGV4dC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZzpcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU6XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlLVNVQlNDUklCRSByZXF1ZXN0IGlmIHRoZXJlIGlzIGFuIFwiYWN0aXZlXCIgc3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRleHQuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnN1YnNjcmlwdGlvbi5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkFjY2VwdDogKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMub25BY2NlcHRlZChyZXNwb25zZSk7IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWRpcmVjdDogKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMub25GYWlsZWQocmVzcG9uc2UpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0OiAoZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vbkZhaWxlZChyZXNwb25zZSk7IH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIGluaXRpYWwgU1VCU0NSSUJFIHJlcXVlc3QgaWYgbm8gc3Vic2NyaXB0aW9uLlxuICAgICAqIFNlbmQgYSByZS1TVUJTQ1JJQkUgcmVxdWVzdCBpZiB0aGVyZSBpcyBhbiBcImFjdGl2ZVwiIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRleHQuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN1YnNjcmliZSgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb24gPSByZXN1bHQuc3VjY2Vzcy5zdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk5vdGlmeTogZnVuY3Rpb24gKHJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLm9uTm90aWZ5KHJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlZnJlc2g6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5vblJlZnJlc2gocmVxdWVzdCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVGVybWluYXRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbk5vdGlmeShyZXN1bHQuc3VjY2Vzcy5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25GYWlsZWQocmVzdWx0LmZhaWx1cmUucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZTpcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlLVNVQlNDUklCRSByZXF1ZXN0IGlmIHRoZXJlIGlzIGEgXCJwZW5kaW5nXCIgb3IgXCJhY3RpdmVcIiBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb250ZXh0LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlcyBpbnRlbnRpb25hbGx5IGlnbm9yZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlcyBpbnRlbnRpb25hbGx5IGlnbm9yZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5vbkFjY2VwdGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlID8gcmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlIDogMDtcbiAgICAgICAgdmFyIGNhdXNlID0gVXRpbHNfMS5VdGlscy5nZXRSZWFzb25QaHJhc2Uoc3RhdHVzQ29kZSk7XG4gICAgICAgIHRoaXMuZW1pdChcImFjY2VwdGVkXCIsIHJlc3BvbnNlLm1lc3NhZ2UsIGNhdXNlKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUub25GYWlsZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlID8gcmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlIDogMDtcbiAgICAgICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHJlc3BvbnNlLm1lc3NhZ2UsIGNhdXNlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlamVjdGVkXCIsIHJlc3BvbnNlLm1lc3NhZ2UsIGNhdXNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5vbk5vdGlmeSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7IC8vIFNlbmQgMjAwIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLmVtaXQoXCJub3RpZnlcIiwgeyByZXF1ZXN0OiByZXF1ZXN0Lm1lc3NhZ2UgfSk7XG4gICAgICAgIC8vIElmIHdlJ3ZlIHNldCBzdGF0ZSB0byBkb25lLCBubyBmdXJ0aGVyIHByb2Nlc3Npbmcgc2hvdWxkIHRha2UgcGxhY2VcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gY2xlYW5pbmcgdXAgYWZ0ZXIgdGhlIGFwcHJvcHJpYXRlIE5PVElGWS5cbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyAgSWYgdGhlIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgdmFsdWUgaXMgXCJ0ZXJtaW5hdGVkXCIsIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vICBNVVNUIGNvbnNpZGVyIHRoZSBzdWJzY3JpcHRpb24gdGVybWluYXRlZC4gIFRoZSBcImV4cGlyZXNcIiBwYXJhbWV0ZXJcbiAgICAgICAgLy8gIGhhcyBubyBzZW1hbnRpY3MgZm9yIFwidGVybWluYXRlZFwiIC0tIG5vdGlmaWVycyBTSE9VTEQgTk9UIGluY2x1ZGUgYW5cbiAgICAgICAgLy8gIFwiZXhwaXJlc1wiIHBhcmFtZXRlciBvbiBhIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgaGVhZGVyIGZpZWxkIHdpdGggYVxuICAgICAgICAvLyAgdmFsdWUgb2YgXCJ0ZXJtaW5hdGVkXCIsIGFuZCBzdWJzY3JpYmVycyBNVVNUIGlnbm9yZSBhbnkgc3VjaFxuICAgICAgICAvLyAgcGFyYW1ldGVyLCBpZiBwcmVzZW50LiAgSWYgYSByZWFzb24gY29kZSBpcyBwcmVzZW50LCB0aGUgY2xpZW50XG4gICAgICAgIC8vICBzaG91bGQgYmVoYXZlIGFzIGRlc2NyaWJlZCBiZWxvdy4gIElmIG5vIHJlYXNvbiBjb2RlIG9yIGFuIHVua25vd25cbiAgICAgICAgLy8gIHJlYXNvbiBjb2RlIGlzIHByZXNlbnQsIHRoZSBjbGllbnQgTUFZIGF0dGVtcHQgdG8gcmUtc3Vic2NyaWJlIGF0IGFueVxuICAgICAgICAvLyAgdGltZSAodW5sZXNzIGEgXCJyZXRyeS1hZnRlclwiIHBhcmFtZXRlciBpcyBwcmVzZW50LCBpbiB3aGljaCBjYXNlIHRoZVxuICAgICAgICAvLyAgY2xpZW50IFNIT1VMRCBOT1QgYXR0ZW1wdCByZS1zdWJzY3JpcHRpb24gdW50aWwgYWZ0ZXIgdGhlIG51bWJlciBvZlxuICAgICAgICAvLyAgc2Vjb25kcyBzcGVjaWZpZWQgYnkgdGhlIFwicmV0cnktYWZ0ZXJcIiBwYXJhbWV0ZXIpLiAgVGhlIHJlYXNvbiBjb2Rlc1xuICAgICAgICAvLyAgZGVmaW5lZCBieSB0aGlzIGRvY3VtZW50IGFyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuM1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uU3RhdGUgPSByZXF1ZXN0Lm1lc3NhZ2UucGFyc2VIZWFkZXIoXCJTdWJzY3JpcHRpb24tU3RhdGVcIik7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0ZSAmJiBzdWJzY3JpcHRpb25TdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb25TdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0ZS5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlRlcm1pbmF0ZWQgc3Vic2NyaXB0aW9uIHdpdGggcmVhc29uIFwiICsgc3Vic2NyaXB0aW9uU3RhdGUucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uU3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlYWN0aXZhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpbWVvdXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInByb2JhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnaXZldXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUucGFyYW1zICYmIHN1YnNjcmlwdGlvblN0YXRlLnBhcmFtc1tcInJldHJ5LWFmdGVyXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5QWZ0ZXJUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3Vic2NyaWJlKCk7IH0sIHN1YnNjcmlwdGlvblN0YXRlLnBhcmFtc1tcInJldHJ5LWFmdGVyXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub3Jlc291cmNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludmFyaWFudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLm9uUmVmcmVzaCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlcXVlc3QuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vbkFjY2VwdGVkKHJlc3BvbnNlKTsgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5vblRlcm1pbmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInRlcm1pbmF0ZWRcIik7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmluaXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiB0aGlzLmJvZHkgPyBVdGlsc18xLlV0aWxzLmZyb21Cb2R5T2JqKHRoaXMuYm9keSkgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IFN1YnNjcmliZUNsaWVudENvbnRleHQodGhpcy51YS51c2VyQWdlbnRDb3JlLCB0aGlzLnVyaSwgdGhpcy5ldmVudCwgdGhpcy5leHBpcmVzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgb25BY2NlcHQ6IChmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLm9uQWNjZXB0ZWQocmVzcG9uc2UpOyB9KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxudmFyIFN1YnNjcmliZUNsaWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlQ2xpZW50Q29udGV4dChjb3JlLCB0YXJnZXQsIGV2ZW50LCBleHBpcmVzLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmNvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmV4cGlyZXMgPSBleHBpcmVzO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb3JlLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLnN1YnNjcmlwdGlvblwiKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB2YXIgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goYWxsb3dIZWFkZXIpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkV2ZW50OiBcIiArIHRoaXMuZXZlbnQpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IFwiICsgdGhpcy5leHBpcmVzKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuY29yZS5jb25maWd1cmF0aW9uLmNvbnRhY3QudG9TdHJpbmcoKSk7XG4gICAgICAgIHZhciBib2R5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmJvZHk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGNvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoQ29uc3RhbnRzXzEuQy5TVUJTQ1JJQkUsIHRoaXMudGFyZ2V0LCB0aGlzLmNvcmUuY29uZmlndXJhdGlvbi5hb3IsIHRoaXMudGFyZ2V0LCB7fSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICB9XG4gICAgLyoqIERlc3RydWN0b3IuICovXG4gICAgU3Vic2NyaWJlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LndhaXROb3RpZnlTdG9wKCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Vic2NyaWJlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgICAgICAvKiogU3Vic2NyaXB0aW9uIHN0YXRlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25TdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoIHN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJOb3QgaW4gaW5pdGlhbCBzdGF0ZS4gRGlkIHlvdSBjYWxsIHN1YnNjcmliZSBtb3JlIHRoYW4gb25jZT9cIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXNzYWdlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gX3RoaXMuY29yZS5zdWJzY3JpYmUoX3RoaXMubWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgU1VCU0NSSUJFIHJlcXVlc3Qgd2lsbCBiZSBjb25maXJtZWQgd2l0aCBhIGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vIDIwMC1jbGFzcyByZXNwb25zZXMgaW5kaWNhdGUgdGhhdCB0aGUgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoYXQgYSBOT1RJRlkgcmVxdWVzdCB3aWxsIGJlIHNlbnQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVsZWdhdGUgJiYgX3RoaXMuZGVsZWdhdGUub25BY2NlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uQWNjZXB0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRHVlIHRvIHRoZSBwb3RlbnRpYWwgZm9yIG91dC1vZi1vcmRlciBtZXNzYWdlcywgcGFja2V0IGxvc3MsIGFuZFxuICAgICAgICAgICAgICAgIC8vIGZvcmtpbmcsIHRoZSBzdWJzY3JpYmVyIE1VU1QgYmUgcHJlcGFyZWQgdG8gcmVjZWl2ZSBOT1RJRlkgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGhlIFNVQlNDUklCRSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuNFxuICAgICAgICAgICAgICAgIG9uTm90aWZ5OiBmdW5jdGlvbiAocmVxdWVzdFdpdGhTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uID0gcmVxdWVzdFdpdGhTdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb24uYXV0b1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBzdWNjZXNzOiByZXF1ZXN0V2l0aFN1YnNjcmlwdGlvbiB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgVGltZXIgTiBleHBpcmVzIHByaW9yIHRvIHRoZSByZWNlaXB0IG9mIGEgTk9USUZZIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1YnNjcmliZXIgY29uc2lkZXJzIHRoZSBzdWJzY3JpcHRpb24gZmFpbGVkLCBhbmQgY2xlYW5zIHVwXG4gICAgICAgICAgICAgICAgLy8gYW55IHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3Vic2NyaXB0aW9uIGF0dGVtcHQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi40XG4gICAgICAgICAgICAgICAgb25Ob3RpZnlUaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBmYWlsdXJlOiB7fSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgU1VCU0NSSUJFIHJlcXVlc3Qgd2lsbCBiZSBjb25maXJtZWQgd2l0aCBhIGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vIE5vbi0yMDAtY2xhc3MgZmluYWwgcmVzcG9uc2VzIGluZGljYXRlIHRoYXQgbm8gc3Vic2NyaXB0aW9uIG9yIG5ld1xuICAgICAgICAgICAgICAgIC8vIGRpYWxvZyB1c2FnZSBoYXMgYmVlbiBjcmVhdGVkLCBhbmQgbm8gc3Vic2VxdWVudCBOT1RJRlkgcmVxdWVzdCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgc2VudC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjFcbiAgICAgICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGZhaWx1cmU6IHsgcmVzcG9uc2U6IHJlc3BvbnNlIH0gfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBUaGlzIFNVQlNDUklCRSByZXF1ZXN0IHdpbGwgYmUgY29uZmlybWVkIHdpdGggYSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyBOb24tMjAwLWNsYXNzIGZpbmFsIHJlc3BvbnNlcyBpbmRpY2F0ZSB0aGF0IG5vIHN1YnNjcmlwdGlvbiBvciBuZXdcbiAgICAgICAgICAgICAgICAvLyBkaWFsb2cgdXNhZ2UgaGFzIGJlZW4gY3JlYXRlZCwgYW5kIG5vIHN1YnNlcXVlbnQgTk9USUZZIHJlcXVlc3Qgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIHNlbnQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgZmFpbHVyZTogeyByZXNwb25zZTogcmVzcG9uc2UgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlQ2xpZW50Q29udGV4dDtcbn0oKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbi8qKlxuICogTGVnYWN5IFRyYW5zcG9ydC5cbiAqIEByZW1hcmtzXG4gKiBBYnN0cmFjdCB0cmFuc3BvcnQgbGF5ZXIgYmFzZSBjbGFzcy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gbG9nZ2VyIC0gTG9nZ2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIERlcHJlY2F0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0KGxvZ2dlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zcG9ydC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb3RvY29sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVtYXJrc1xuICAgICAgICAgKiBGb3JtYXR0ZWQgYXMgZGVmaW5lZCBmb3IgdGhlIFZpYSBoZWFkZXIgc2VudC1wcm90b2NvbCB0cmFuc3BvcnQuXG4gICAgICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjAuNDJcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyICYmIHRoaXMuc2VydmVyLnNjaGVtZSA/IHRoaXMuc2VydmVyLnNjaGVtZSA6IFwiV1NTXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb21pc2UgZGVzaWduYXRlZCBieSB0aGUgY2hpbGQgbGF5ZXIgdGhlbiBlbWl0cyBhIGNvbm5lY3RlZCBldmVudC5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGVtaXRzIGFuIGV2ZW50IHVwb24gcmVzb2x1dGlvbiwgdW5sZXNzIG92ZXJyaWRlRXZlbnQgaXMgc2V0LiBJZiB5b3VcbiAgICAgKiBvdmVycmlkZSB0aGUgZXZlbnQgaW4gdGhpcyBmYXNoaW9uLCB5b3Ugc2hvdWxkIGVtaXQgaXQgaW4geW91ciBpbXBsZW1lbnRhdGlvbiBvZiBjb25uZWN0UHJvbWlzZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2Uob3B0aW9ucykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLm92ZXJyaWRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiY29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0aGVuIGVtaXRzIGEgJ21lc3NhZ2VTZW50JyBldmVudC4gQXV0b21hdGljYWxseSBlbWl0cyBhblxuICAgICAqIGV2ZW50IHVwb24gcmVzb2x1dGlvbiwgdW5sZXNzIGRhdGEub3ZlcnJpZGVFdmVudCBpcyBzZXQuIElmIHlvdSBvdmVycmlkZVxuICAgICAqIHRoZSBldmVudCBpbiB0aGlzIGZhc2hpb24sIHlvdSBzaG91bGQgZW1pdCBpdCBpbiB5b3VyIGltcGxlbWVudGF0aW9uIG9mIHNlbmRQcm9taXNlXG4gICAgICogUmVqZWN0cyB3aXRoIGFuIEVycm9yIGlmIG1lc3NhZ2UgZmFpbHMgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBFcnJvciBoYW5kbGluZyBpcyBpbmRlcGVuZGVudCBvZiB3aGV0aGVyIHRoZSBtZXNzYWdlIHdhcyBhIHJlcXVlc3Qgb3JcbiAgICAgICAgLy8gcmVzcG9uc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgdXNlciBhc2tzIGZvciBhIG1lc3NhZ2UgdG8gYmUgc2VudCBvdmVyIGFuXG4gICAgICAgIC8vIHVucmVsaWFibGUgdHJhbnNwb3J0LCBhbmQgdGhlIHJlc3VsdCBpcyBhbiBJQ01QIGVycm9yLCB0aGUgYmVoYXZpb3JcbiAgICAgICAgLy8gZGVwZW5kcyBvbiB0aGUgdHlwZSBvZiBJQ01QIGVycm9yLiAgSG9zdCwgbmV0d29yaywgcG9ydCBvciBwcm90b2NvbFxuICAgICAgICAvLyB1bnJlYWNoYWJsZSBlcnJvcnMsIG9yIHBhcmFtZXRlciBwcm9ibGVtIGVycm9ycyBTSE9VTEQgY2F1c2UgdGhlXG4gICAgICAgIC8vIHRyYW5zcG9ydCBsYXllciB0byBpbmZvcm0gdGhlIHRyYW5zcG9ydCB1c2VyIG9mIGEgZmFpbHVyZSBpbiBzZW5kaW5nLlxuICAgICAgICAvLyBTb3VyY2UgcXVlbmNoIGFuZCBUVEwgZXhjZWVkZWQgSUNNUCBlcnJvcnMgU0hPVUxEIGJlIGlnbm9yZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgdXNlciBhc2tzIGZvciBhIHJlcXVlc3QgdG8gYmUgc2VudCBvdmVyIGEgcmVsaWFibGVcbiAgICAgICAgLy8gdHJhbnNwb3J0LCBhbmQgdGhlIHJlc3VsdCBpcyBhIGNvbm5lY3Rpb24gZmFpbHVyZSwgdGhlIHRyYW5zcG9ydFxuICAgICAgICAvLyBsYXllciBTSE9VTEQgaW5mb3JtIHRoZSB0cmFuc3BvcnQgdXNlciBvZiBhIGZhaWx1cmUgaW4gc2VuZGluZy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xOC40XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRQcm9taXNlKG1lc3NhZ2UpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQub3ZlcnJpZGVFdmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJtZXNzYWdlU2VudFwiLCByZXN1bHQubXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9taXNlIGRlc2lnbmF0ZWQgYnkgdGhlIGNoaWxkIGxheWVyIHRoZW4gZW1pdHMgYVxuICAgICAqIGRpc2Nvbm5lY3RlZCBldmVudC4gQXV0b21hdGljYWxseSBlbWl0cyBhbiBldmVudCB1cG9uIHJlc29sdXRpb24sXG4gICAgICogdW5sZXNzIG92ZXJyaWRlRXZlbnQgaXMgc2V0LiBJZiB5b3Ugb3ZlcnJpZGUgdGhlIGV2ZW50IGluIHRoaXMgZmFzaGlvbixcbiAgICAgKiB5b3Ugc2hvdWxkIGVtaXQgaXQgaW4geW91ciBpbXBsZW1lbnRhdGlvbiBvZiBkaXNjb25uZWN0UHJvbWlzZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXRcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0UHJvbWlzZShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEub3ZlcnJpZGVFdmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5hZnRlckNvbm5lY3RlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwiY29ubmVjdGVkXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb25jZSB0aGUgVUEgaXMgY29ubmVjdGVkLiBERVBSRUNBVElPTiBXQVJOSU5HOiBqdXN0IHVzZSBhZnRlckNvbm5lY3RlZCgpXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS53YWl0Rm9yQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXCJERVBSRUNBVElPTiBXQVJOSU5HIFRyYW5zcG9ydC53YWl0Rm9yQ29ubmVjdGVkKCk6IHVzZSBhZnRlckNvbm5lY3RlZCgpIGluc3RlYWRcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuYWZ0ZXJDb25uZWN0ZWQocmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydDtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIENsaWVudENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NsaWVudENvbnRleHRcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uc1wiKTtcbnZhciBQdWJsaXNoQ29udGV4dF8xID0gcmVxdWlyZShcIi4vUHVibGlzaENvbnRleHRcIik7XG52YXIgUmVmZXJDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9SZWZlckNvbnRleHRcIik7XG52YXIgUmVnaXN0ZXJDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9SZWdpc3RlckNvbnRleHRcIik7XG52YXIgU2VydmVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vU2VydmVyQ29udGV4dFwiKTtcbnZhciBTZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9TZXNzaW9uXCIpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uXCIpO1xudmFyIFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbnZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9XZWIvU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiKTtcbnZhciBUcmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL1dlYi9UcmFuc3BvcnRcIik7XG4vKipcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBVc2VyIEFnZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbiByZXR1cm5pbmcgU0lQLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJ9IFtjb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5XVxuICogIEEgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJ5IGVhY2ggb2YgdGhlIFVBJ3MgU2Vzc2lvbnMgdG8gYnVpbGQgdGhlIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgZm9yIHRoYXQgU2Vzc2lvbi5cbiAqICBJZiBubyAob3IgYSBmYWxzeSkgdmFsdWUgaXMgcHJvdmlkZWQsIGVhY2ggU2Vzc2lvbiB3aWxsIHVzZSBhIGRlZmF1bHQgKFdlYlJUQykgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5cbiAqL1xudmFyIFVBID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFVBLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVBKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqIFVubG9hZCBsaXN0ZW5lci4gKi9cbiAgICAgICAgX3RoaXMudW5sb2FkTGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkgeyBfdGhpcy5zdG9wKCk7IH0pO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5VQTtcbiAgICAgICAgX3RoaXMubG9nID0gbmV3IGNvcmVfMS5Mb2dnZXJGYWN0b3J5KCk7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IF90aGlzLmdldExvZ2dlcihcInNpcC51YVwiKTtcbiAgICAgICAgX3RoaXMuY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAvLyBVc2VyIGFjdGlvbnMgb3V0c2lkZSBhbnkgc2Vzc2lvbi9kaWFsb2cgKE1FU1NBR0UpXG4gICAgICAgIF90aGlzLmFwcGxpY2FudHMgPSB7fTtcbiAgICAgICAgX3RoaXMuZGF0YSA9IHt9O1xuICAgICAgICBfdGhpcy5zZXNzaW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLnB1Ymxpc2hlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfSU5JVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgY29uZmlndXJhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIHtTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3J9XG4gICAgICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbiA9PT0gXCJzdHJpbmdcIiB8fCBjb25maWd1cmF0aW9uIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHVyaTogY29uZmlndXJhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBsb2cgY29uZmlndXJhdGlvbiBpZiBwcmVzZW50XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uLmxvZykge1xuICAgICAgICAgICAgX3RoaXMubG9nLmJ1aWx0aW5FbmFibGVkID0gY29uZmlndXJhdGlvbi5sb2cuYnVpbHRpbkVuYWJsZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cuaGFzT3duUHJvcGVydHkoXCJjb25uZWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2cuY29ubmVjdG9yID0gY29uZmlndXJhdGlvbi5sb2cuY29ubmVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KFwibGV2ZWxcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBjb25maWd1cmF0aW9uLmxvZy5sZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndhcm5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLmxvZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLmRlYnVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLndhcm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IGNvcmVfMS5MZXZlbHMubG9nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLmRlYnVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIGxldmVsIHdoZW4gaW52YWxpZCwgdXNlIGRlZmF1bHQgbGV2ZWwgaW5zdGVhZFxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiSW52YWxpZCBcXFwibGV2ZWxcXFwiIHBhcmFtZXRlciB2YWx1ZTogXCIgKyBKU09OLnN0cmluZ2lmeShsZXZlbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nLmxldmVsID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHJlY2F0ZWRNZXNzYWdlID0gXCJUaGUgVUEgY2xhc3MgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlIHN0YXJ0aW5nIHdpdGggU0lQLmpzIHJlbGVhc2UgMC4xNi4wLiBcIiArXG4gICAgICAgICAgICBcIlRoZSBVQSBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgVXNlckFnZW50IGNsYXNzLiBQbGVhc2UgdXBkYXRlIGFjY29yZGluZ2x5LlwiO1xuICAgICAgICBfdGhpcy5sb2dnZXIud2FybihkZXByZWNhdGVkTWVzc2FnZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfdGhpcy5sb2FkQ29uZmlnKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19OT1RfUkVBRFk7XG4gICAgICAgICAgICBfdGhpcy5lcnJvciA9IFVBLkMuQ09ORklHVVJBVElPTl9FUlJPUjtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcG9ydENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV8xLlRyYW5zcG9ydEVycm9yKFwiVHJhbnNwb3J0IGNvbnN0cnVjdG9yIG5vdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudHJhbnNwb3J0ID0gbmV3IF90aGlzLmNvbmZpZ3VyYXRpb24udHJhbnNwb3J0Q29uc3RydWN0b3IoX3RoaXMuZ2V0TG9nZ2VyKFwic2lwLnRyYW5zcG9ydFwiKSwgX3RoaXMuY29uZmlndXJhdGlvbi50cmFuc3BvcnRPcHRpb25zKTtcbiAgICAgICAgdmFyIHVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uID0gbWFrZVVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uRnJvbVVBKF90aGlzKTtcbiAgICAgICAgLy8gVGhlIFJlcGxhY2VzIGhlYWRlciBjb250YWlucyBpbmZvcm1hdGlvbiB1c2VkIHRvIG1hdGNoIGFuIGV4aXN0aW5nXG4gICAgICAgIC8vIFNJUCBkaWFsb2cgKGNhbGwtaWQsIHRvLXRhZywgYW5kIGZyb20tdGFnKS4gIFVwb24gcmVjZWl2aW5nIGFuIElOVklURVxuICAgICAgICAvLyB3aXRoIGEgUmVwbGFjZXMgaGVhZGVyLCB0aGUgVXNlciBBZ2VudCAoVUEpIGF0dGVtcHRzIHRvIG1hdGNoIHRoaXNcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gd2l0aCBhIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2cuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzODkxI3NlY3Rpb24tM1xuICAgICAgICB2YXIgaGFuZGxlSW52aXRlV2l0aFJlcGxhY2VzSGVhZGVyID0gZnVuY3Rpb24gKGNvbnRleHQsIHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWd1cmF0aW9uLnJlcGxhY2VzICE9PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCkge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlcyA9IHJlcXVlc3QucGFyc2VIZWFkZXIoXCJyZXBsYWNlc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFNlc3Npb24gPSBfdGhpcy5zZXNzaW9uc1tyZXBsYWNlcy5jYWxsX2lkICsgcmVwbGFjZXMucmVwbGFjZXNfZnJvbV90YWddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXNzaW9uc1tyZXBsYWNlcy5jYWxsX2lkICsgcmVwbGFjZXMucmVwbGFjZXNfdG9fdGFnXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVzZXJBZ2VudENvcmUucmVwbHlTdGF0ZWxlc3MocmVxdWVzdCwgeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFNlc3Npb24uc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVzZXJBZ2VudENvcmUucmVwbHlTdGF0ZWxlc3MocmVxdWVzdCwgeyBzdGF0dXNDb2RlOiA2MDMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldERpYWxvZ0lkID0gcmVwbGFjZXMuY2FsbF9pZCArIHJlcGxhY2VzLnJlcGxhY2VzX3RvX3RhZyArIHJlcGxhY2VzLnJlcGxhY2VzX2Zyb21fdGFnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RGlhbG9nID0gX3RoaXMudXNlckFnZW50Q29yZS5kaWFsb2dzLmdldCh0YXJnZXREaWFsb2dJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0RGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyQWdlbnRDb3JlLnJlcGx5U3RhdGVsZXNzKHJlcXVlc3QsIHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0RGlhbG9nLmVhcmx5ICYmIHJlcGxhY2VzLmVhcmx5X29ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVzZXJBZ2VudENvcmUucmVwbHlTdGF0ZWxlc3MocmVxdWVzdCwgeyBzdGF0dXNDb2RlOiA0ODYgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXBsYWNlZSA9IHRhcmdldFNlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdXNlckFnZW50Q29yZURlbGVnYXRlID0ge1xuICAgICAgICAgICAgb25JbnZpdGU6IGZ1bmN0aW9uIChpbmNvbWluZ0ludml0ZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogUG9ydGVkIC0gMTAwIFRyeWluZyBzZW5kIHNob3VsZCBiZSBjb25maWd1cmFibGUuXG4gICAgICAgICAgICAgICAgLy8gT25seSByZXF1aXJlZCBpZiBUVSB3aWxsIG5vdCByZXNwb25kIGluIDIwMG1zLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgICAgICAgICAgaW5jb21pbmdJbnZpdGVSZXF1ZXN0LnRyeWluZygpO1xuICAgICAgICAgICAgICAgIGluY29taW5nSW52aXRlUmVxdWVzdC5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uIChjYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25DYW5jZWwoY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgU2Vzc2lvbl8xLkludml0ZVNlcnZlckNvbnRleHQoX3RoaXMsIGluY29taW5nSW52aXRlUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgLy8gUG9ydGVkIC0gaGFuZGxpbmcgb2Ygb3V0IG9mIGRpYWxvZyBJTlZJVEUgd2l0aCBSZXBsYWNlcy5cbiAgICAgICAgICAgICAgICBoYW5kbGVJbnZpdGVXaXRoUmVwbGFjZXNIZWFkZXIoY29udGV4dCwgaW5jb21pbmdJbnZpdGVSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIFBvcnRlZCAtIG1ha2UgdGhlIGZpcnN0IGNhbGwgdG8gcHJvZ3Jlc3MgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5hdXRvU2VuZEFuSW5pdGlhbFByb3Zpc2lvbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiaW52aXRlXCIsIGNvbnRleHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogZnVuY3Rpb24gKGluY29taW5nTWVzc2FnZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3J0ZWQgLSBoYW5kbGluZyBvZiBvdXQgb2YgZGlhbG9nIE1FU1NBR0UuXG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckNvbnRleHQgPSBuZXcgU2VydmVyQ29udGV4dF8xLlNlcnZlckNvbnRleHQoX3RoaXMsIGluY29taW5nTWVzc2FnZVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHNlcnZlckNvbnRleHQuYm9keSA9IGluY29taW5nTWVzc2FnZVJlcXVlc3QubWVzc2FnZS5ib2R5O1xuICAgICAgICAgICAgICAgIHNlcnZlckNvbnRleHQuY29udGVudFR5cGUgPSBpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgICAgICAgICAgIGluY29taW5nTWVzc2FnZVJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcIm1lc3NhZ2VcIiwgc2VydmVyQ29udGV4dCk7IC8vIFRPRE86IFJldmlldy4gV2h5IGlzIGEgXCJTZXJ2ZXJDb250ZXh0XCIgZW1pdHRlZD8gV2hhdCB1c2UgaXQgaXM/XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Ob3RpZnk6IGZ1bmN0aW9uIChpbmNvbWluZ05vdGlmeVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBERVBSRUNBVEVEOiBPdXQgb2YgZGlhbG9nIE5PVElGWSBpcyBhbiBvYnNvbGV0ZSB1c2FnZS5cbiAgICAgICAgICAgICAgICAvLyBQb3J0ZWQgLSBoYW5kbGluZyBvZiBvdXQgb2YgZGlhbG9nIE5PVElGWS5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlndXJhdGlvbi5hbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnMgJiYgX3RoaXMubGlzdGVuZXJzKFwibm90aWZ5XCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdOb3RpZnlSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwibm90aWZ5XCIsIHsgcmVxdWVzdDogaW5jb21pbmdOb3RpZnlSZXF1ZXN0Lm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmNvbWluZ05vdGlmeVJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlZmVyOiBmdW5jdGlvbiAoaW5jb21pbmdSZWZlclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3J0ZWQgLSBoYW5kbGluZyBvZiBvdXQgb2YgZGlhbG9nIFJFRkVSLlxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJSZWNlaXZlZCBhbiBvdXQgb2YgZGlhbG9nIHJlZmVyXCIpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuY29uZmlndXJhdGlvbi5hbGxvd091dE9mRGlhbG9nUmVmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY29taW5nUmVmZXJSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQwNSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIkFsbG93IG91dCBvZiBkaWFsb2cgcmVmZXJzIGlzIGVuYWJsZWQgb24gdGhlIFVBXCIpO1xuICAgICAgICAgICAgICAgIHZhciByZWZlckNvbnRleHQgPSBuZXcgUmVmZXJDb250ZXh0XzEuUmVmZXJTZXJ2ZXJDb250ZXh0KF90aGlzLCBpbmNvbWluZ1JlZmVyUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmxpc3RlbmVycyhcIm91dE9mRGlhbG9nUmVmZXJSZXF1ZXN0ZWRcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJvdXRPZkRpYWxvZ1JlZmVyUmVxdWVzdGVkXCIsIHJlZmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiTm8gb3V0T2ZEaWFsb2dSZWZlclJlcXVlc3QgbGlzdGVuZXJzLCBhdXRvbWF0aWNhbGx5IGFjY2VwdGluZyBhbmQgZm9sbG93aW5nIHRoZSBvdXQgb2YgZGlhbG9nIHJlZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICByZWZlckNvbnRleHQuYWNjZXB0KHsgZm9sbG93UmVmZXI6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU3Vic2NyaWJlOiBmdW5jdGlvbiAoaW5jb21pbmdTdWJzY3JpYmVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInN1YnNjcmliZVwiLCBpbmNvbWluZ1N1YnNjcmliZVJlcXVlc3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudXNlckFnZW50Q29yZSA9IG5ldyBjb3JlXzEuVXNlckFnZW50Q29yZSh1c2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbiwgdXNlckFnZW50Q29yZURlbGVnYXRlKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSByZWdpc3RlckNvbnRleHRcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJDb250ZXh0ID0gbmV3IFJlZ2lzdGVyQ29udGV4dF8xLlJlZ2lzdGVyQ29udGV4dChfdGhpcywgY29uZmlndXJhdGlvbi5yZWdpc3Rlck9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlckNvbnRleHQub24oXCJmYWlsZWRcIiwgX3RoaXMuZW1pdC5iaW5kKF90aGlzLCBcInJlZ2lzdHJhdGlvbkZhaWxlZFwiKSk7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyQ29udGV4dC5vbihcInJlZ2lzdGVyZWRcIiwgX3RoaXMuZW1pdC5iaW5kKF90aGlzLCBcInJlZ2lzdGVyZWRcIikpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlckNvbnRleHQub24oXCJ1bnJlZ2lzdGVyZWRcIiwgX3RoaXMuZW1pdC5iaW5kKF90aGlzLCBcInVucmVnaXN0ZXJlZFwiKSk7XG4gICAgICAgIGlmIChfdGhpcy5jb25maWd1cmF0aW9uLmF1dG9zdGFydCkge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vID09PT09PT09PT09PT09PT09XG4gICAgLy8gIEhpZ2ggTGV2ZWwgQVBJXG4gICAgLy8gPT09PT09PT09PT09PT09PT1cbiAgICBVQS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZWdpc3Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5yZWdpc3RlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWxsXSB1bnJlZ2lzdGVyIGFsbCB1c2VyIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYWZ0ZXJDb25uZWN0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVnaXN0ZXJDb250ZXh0LnVucmVnaXN0ZXIob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFVBLnByb3RvdHlwZS5pc1JlZ2lzdGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyQ29udGV4dC5yZWdpc3RlcmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFrZSBhbiBvdXRnb2luZyBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICpcbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgbW9kaWZpZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IFNlc3Npb25fMS5JbnZpdGVDbGllbnRDb250ZXh0KHRoaXMsIHRhcmdldCwgb3B0aW9ucywgbW9kaWZpZXJzKTtcbiAgICAgICAgLy8gRGVsYXkgc2VuZGluZyBhY3R1YWwgaW52aXRlIHVudGlsIHRoZSBuZXh0ICd0aWNrJyBpZiB3ZSBhcmUgYWxyZWFkeVxuICAgICAgICAvLyBjb25uZWN0ZWQsIHNvIHRoYXQgQVBJIGNvbnN1bWVycyBjYW4gcmVnaXN0ZXIgdG8gZXZlbnRzIGZpcmVkIGJ5IHRoZVxuICAgICAgICAvLyB0aGUgc2Vzc2lvbi5cbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYWZ0ZXJDb25uZWN0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dC5pbnZpdGUoKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJpbnZpdGVTZW50XCIsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfTtcbiAgICBVQS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN1YiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24odGhpcywgdGFyZ2V0LCBldmVudCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmFmdGVyQ29ubmVjdGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIFBVQkxJU0ggRXZlbnQgU3RhdGUgUHVibGljYXRpb24gKFJGQzM5MDMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTSVAuRXhjZXB0aW9ucy5NZXRob2RQYXJhbWV0ZXJFcnJvcn1cbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwdWIgPSBuZXcgUHVibGlzaENvbnRleHRfMS5QdWJsaXNoQ29udGV4dCh0aGlzLCB0YXJnZXQsIGV2ZW50LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYWZ0ZXJDb25uZWN0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHViLnB1Ymxpc2goYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHViO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBpcyBubyBNZXNzYWdlIG1vZHVsZSwgc28gaXQgaXMgb2theSB0aGF0IHRoZSBVQSBoYW5kbGVzIGRlZmF1bHRzIGhlcmUuXG4gICAgICAgIG9wdGlvbnMuY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KENvbnN0YW50c18xLkMuTUVTU0FHRSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFVBLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXEgPSBuZXcgQ2xpZW50Q29udGV4dF8xLkNsaWVudENvbnRleHQodGhpcywgbWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5hZnRlckNvbm5lY3RlZChmdW5jdGlvbiAoKSB7IHJldHVybiByZXEuc2VuZCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdyYWNlZnVsbHkgY2xvc2UuXG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInVzZXIgcmVxdWVzdGVkIGNsb3N1cmUuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVQSBhbHJlYWR5IGNsb3NlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlIHJlZ2lzdGVyQ29udGV4dFxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJjbG9zaW5nIHJlZ2lzdGVyQ29udGV4dFwiKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRleHQuY2xvc2UoKTtcbiAgICAgICAgLy8gUnVuIHRlcm1pbmF0ZSBvbiBldmVyeSBTZXNzaW9uXG4gICAgICAgIGZvciAodmFyIHNlc3Npb24gaW4gdGhpcy5zZXNzaW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbnNbc2Vzc2lvbl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJjbG9zaW5nIHNlc3Npb24gXCIgKyBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zW3Nlc3Npb25dLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biB1bnN1YnNjcmliZSBvbiBldmVyeSBTdWJzY3JpcHRpb25cbiAgICAgICAgZm9yICh2YXIgc3Vic2NyaXB0aW9uIGluIHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb25dKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwidW5zdWJzY3JpYmUgXCIgKyBzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb25dLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVuIGNsb3NlIG9uIGV2ZXJ5IFB1Ymxpc2hlclxuICAgICAgICBmb3IgKHZhciBwdWJsaXNoZXIgaW4gdGhpcy5wdWJsaXNoZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaXNoZXJzW3B1Ymxpc2hlcl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJ1bnB1Ymxpc2ggXCIgKyBwdWJsaXNoZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyc1twdWJsaXNoZXJdLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVuIGNsb3NlIG9uIGV2ZXJ5IGFwcGxpY2FudFxuICAgICAgICBmb3IgKHZhciBhcHBsaWNhbnQgaW4gdGhpcy5hcHBsaWNhbnRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBsaWNhbnRzW2FwcGxpY2FudF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2FudHNbYXBwbGljYW50XS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfVVNFUl9DTE9TRUQ7XG4gICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCBhbmQgcmVzZXQgdXNlciBhZ2VudCBjb3JlXG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy51c2VyQWdlbnRDb3JlLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b3N0b3ApIHtcbiAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWUgUGFja2FnZWQgQXBwcyBkb24ndCBhbGxvdyAndW5sb2FkJyBsaXN0ZW5lcnM6IHVubG9hZCBpcyBub3QgYXZhaWxhYmxlIGluIHBhY2thZ2VkIGFwcHNcbiAgICAgICAgICAgIHZhciBnb29nbGVDaHJvbWVQYWNrYWdlZEFwcCA9IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lLmFwcCAmJiBjaHJvbWUuYXBwLnJ1bnRpbWUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgIWdvb2dsZUNocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdGhpcy51bmxvYWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBXUyBzZXJ2ZXIgaWYgc3RhdHVzID0gU1RBVFVTX0lOSVQuXG4gICAgICogUmVzdW1lIFVBIGFmdGVyIGJlaW5nIGNsb3NlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwidXNlciByZXF1ZXN0ZWQgc3RhcnR1cC4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19JTklUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX1NUQVJUSU5HO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydENyZWF0ZWRcIiwgdGhpcy50cmFuc3BvcnQpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwicmVzdW1pbmdcIik7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX1JFQURZO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19TVEFSVElORykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiVUEgaXMgaW4gU1RBUlRJTkcgc3RhdHVzLCBub3Qgb3BlbmluZyBuZXcgY29ubmVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfUkVBRFkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlVBIGlzIGluIFJFQURZIHN0YXR1cywgbm90IHJlc3VtaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJDb25uZWN0aW9uIGlzIGRvd24uIEF1dG8tUmVjb3Zlcnkgc3lzdGVtIGlzIHRyeWluZyB0byBjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b3N0b3ApIHtcbiAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWUgUGFja2FnZWQgQXBwcyBkb24ndCBhbGxvdyAndW5sb2FkJyBsaXN0ZW5lcnM6IHVubG9hZCBpcyBub3QgYXZhaWxhYmxlIGluIHBhY2thZ2VkIGFwcHNcbiAgICAgICAgICAgIHZhciBnb29nbGVDaHJvbWVQYWNrYWdlZEFwcCA9IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lLmFwcCAmJiBjaHJvbWUuYXBwLnJ1bnRpbWUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgIWdvb2dsZUNocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdGhpcy51bmxvYWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYSBzdHJpbmcgaW50byBhIHZhbGlkIFNJUCByZXF1ZXN0IFVSSVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICAgICAqXG4gICAgICogQHJldHVybnMge1NJUC5VUkl8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5ub3JtYWxpemVUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBVdGlsc18xLlV0aWxzLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQsIHRoaXMuY29uZmlndXJhdGlvbi5ob3N0cG9ydFBhcmFtcyk7XG4gICAgfTtcbiAgICBVQS5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKGNhdGVnb3J5LCBsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2cuZ2V0TG9nZ2VyKGNhdGVnb3J5LCBsYWJlbCk7XG4gICAgfTtcbiAgICBVQS5wcm90b3R5cGUuZ2V0TG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nO1xuICAgIH07XG4gICAgVUEucHJvdG90eXBlLmdldFN1cHBvcnRlZFJlc3BvbnNlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvblRhZ3MgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFjdC5wdWJHcnV1IHx8IHRoaXMuY29udGFjdC50ZW1wR3J1dSkge1xuICAgICAgICAgICAgb3B0aW9uVGFncy5wdXNoKFwiZ3J1dVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICBvcHRpb25UYWdzLnB1c2goXCIxMDByZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICBvcHRpb25UYWdzLnB1c2goXCJyZXBsYWNlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25UYWdzLnB1c2goXCJvdXRib3VuZFwiKTtcbiAgICAgICAgb3B0aW9uVGFncyA9IG9wdGlvblRhZ3MuY29uY2F0KHRoaXMuY29uZmlndXJhdGlvbi5leHRyYVN1cHBvcnRlZCB8fCBbXSk7XG4gICAgICAgIHZhciBhbGxvd1VucmVnaXN0ZXJlZCA9IHRoaXMuY29uZmlndXJhdGlvbi5oYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzIHx8IGZhbHNlO1xuICAgICAgICB2YXIgb3B0aW9uVGFnU2V0ID0ge307XG4gICAgICAgIG9wdGlvblRhZ3MgPSBvcHRpb25UYWdzLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uVGFnKSB7XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZCA9IENvbnN0YW50c18xLkMuT1BUSU9OX1RBR1Nbb3B0aW9uVGFnXTtcbiAgICAgICAgICAgIHZhciB1bmlxdWUgPSAhb3B0aW9uVGFnU2V0W29wdGlvblRhZ107XG4gICAgICAgICAgICBvcHRpb25UYWdTZXRbb3B0aW9uVGFnXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gKHJlZ2lzdGVyZWQgfHwgYWxsb3dVbnJlZ2lzdGVyZWQpICYmIHVuaXF1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25UYWdzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZXNzaW9uIHRvIHdoaWNoIHRoZSByZXF1ZXN0IGJlbG9uZ3MgdG8sIGlmIGFueS5cbiAgICAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1NJUC5PdXRnb2luZ1Nlc3Npb258U0lQLkluY29taW5nU2Vzc2lvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLmZpbmRTZXNzaW9uID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbnNbcmVxdWVzdC5jYWxsSWQgKyByZXF1ZXN0LmZyb21UYWddIHx8XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25zW3JlcXVlc3QuY2FsbElkICsgcmVxdWVzdC50b1RhZ10gfHxcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFVBLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykgeyByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIG5hbWUsIGNhbGxiYWNrKTsgfTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGVyc1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIFVBLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmVycm9yIHx8IHRoaXMuZXJyb3IgIT09IFVBLkMuTkVUV09SS19FUlJPUikge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19OT1RfUkVBRFk7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gVUEuQy5ORVRXT1JLX0VSUk9SO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24uIFNldHMgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5zZXRUcmFuc3BvcnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiY29ubmVjdGVkXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uVHJhbnNwb3J0Q29ubmVjdGVkKCk7IH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLm9uVHJhbnNwb3J0UmVjZWl2ZU1zZyhtZXNzYWdlKTsgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwidHJhbnNwb3J0RXJyb3JcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25UcmFuc3BvcnRFcnJvcigpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBjb25uZWN0aW9uIGV2ZW50LlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5vblRyYW5zcG9ydENvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3Rlcikge1xuICAgICAgICAgICAgLy8gSW4gYW4gZWZmb3IgdG8gbWFpbnRhaW4gYmVoYXZpb3IgZnJvbSB3aGVuIHdlIFwiaW5pdGlhbGl6ZWRcIiBhblxuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gZmFjdG9yeSwgdGhpcyBpcyBpbiBhIFByb21pc2UudGhlblxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXIoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBTSVAgbWVzc2FnZSByZWNlaXZlZCBmcm9tIHRoZSB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VTdHJpbmcgVGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0UmVjZWl2ZU1zZyA9IGZ1bmN0aW9uIChtZXNzYWdlU3RyaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gY29yZV8xLlBhcnNlci5wYXJzZU1lc3NhZ2UobWVzc2FnZVN0cmluZywgdGhpcy5nZXRMb2dnZXIoXCJzaXAucGFyc2VyXCIpKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVUEgZmFpbGVkIHRvIHBhcnNlIGluY29taW5nIFNJUCBtZXNzYWdlIC0gZGlzY2FyZGluZy5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19VU0VSX0NMT1NFRCAmJiBtZXNzYWdlIGluc3RhbmNlb2YgY29yZV8xLkluY29taW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVQSByZWNlaXZlZCBtZXNzYWdlIHdoZW4gc3RhdHVzID0gVVNFUl9DTE9TRUQgLSBhYm9ydGluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHZhbGlkIFNJUCByZXF1ZXN0IGZvcm11bGF0ZWQgYnkgYSBVQUMgTVVTVCwgYXQgYSBtaW5pbXVtLCBjb250YWluXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgaGVhZGVyIGZpZWxkczogVG8sIEZyb20sIENTZXEsIENhbGwtSUQsIE1heC1Gb3J3YXJkcyxcbiAgICAgICAgLy8gYW5kIFZpYTsgYWxsIG9mIHRoZXNlIGhlYWRlciBmaWVsZHMgYXJlIG1hbmRhdG9yeSBpbiBhbGwgU0lQXG4gICAgICAgIC8vIHJlcXVlc3RzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4xXG4gICAgICAgIHZhciBoYXNNaW5pbXVtSGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYW5kYXRvcnlIZWFkZXJzID0gW1wiZnJvbVwiLCBcInRvXCIsIFwiY2FsbF9pZFwiLCBcImNzZXFcIiwgXCJ2aWFcIl07XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hbmRhdG9yeUhlYWRlcnNfMSA9IG1hbmRhdG9yeUhlYWRlcnM7IF9pIDwgbWFuZGF0b3J5SGVhZGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBtYW5kYXRvcnlIZWFkZXJzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5oYXNIZWFkZXIoaGVhZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIk1pc3NpbmcgbWFuZGF0b3J5IGhlYWRlciBmaWVsZCA6IFwiICsgaGVhZGVyICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlcXVlc3QgQ2hlY2tzXG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgY29yZV8xLkluY29taW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5taW5pbXVtSGVhZGVycygpLlxuICAgICAgICAgICAgaWYgKCFoYXNNaW5pbXVtSGVhZGVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlJlcXVlc3QgbWlzc2luZyBtYW5kYXRvcnkgaGVhZGVyIGZpZWxkLiBEcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgaXMgbm9uLXN0YW5kYXJkIGFuZCBzaG91bGQgYmUgYSBjb25maWdydWFibGUgYmVoYXZpb3IgKGRlc2lyYWJsZSByZWdhcmRsZXNzKS5cbiAgICAgICAgICAgIC8vIEN1c3RvbSBTSVAuanMgY2hlY2sgdG8gcmVqZWN0IHJlcXVlc3QgZnJvbSBvdXJzZWxmICh0aGlzIGluc3RhbmNlIG9mIFNJUC5qcykuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2sucmZjMzI2MV8xNl8zXzQoKS5cbiAgICAgICAgICAgIGlmICghbWVzc2FnZS50b1RhZyAmJiBtZXNzYWdlLmNhbGxJZC5zdWJzdHIoMCwgNSkgPT09IHRoaXMuY29uZmlndXJhdGlvbi5zaXBqc0lkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWdlbnRDb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDgyIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBiZSBUcmFuc3BvcnQgY2hlY2sgYmVmb3JlIHdlIGdldCBoZXJlIChTZWN0aW9uIDE4KS5cbiAgICAgICAgICAgIC8vIEN1c3RvbSBTSVAuanMgY2hlY2sgdG8gcmVqZWN0IHJlcXVlc3RzIGlmIGJvZHkgbGVuZ3RoIHdyb25nLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3J0IG9mIFNhbml0eUNoZWNrLnJmYzMyNjFfMThfM19yZXF1ZXN0KCkuXG4gICAgICAgICAgICB2YXIgbGVuID0gVXRpbHNfMS5VdGlscy5zdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KTtcbiAgICAgICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoICYmIGxlbiA8IE51bWJlcihjb250ZW50TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwMCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwb25zZSBDaGVja3NcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBjb3JlXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5taW5pbXVtSGVhZGVycygpLlxuICAgICAgICAgICAgaWYgKCFoYXNNaW5pbXVtSGVhZGVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlJlc3BvbnNlIG1pc3NpbmcgbWFuZGF0b3J5IGhlYWRlciBmaWVsZC4gRHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEN1c3RvbSBTSVAuanMgY2hlY2sgdG8gZHJvcCByZXNwb25zZXMgaWYgbXVsdGlwbGUgVmlhIGhlYWRlcnMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2sucmZjMzI2MV84XzFfM18zKCkuXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5nZXRIZWFkZXJzKFwidmlhXCIpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTW9yZSB0aGFuIG9uZSBWaWEgaGVhZGVyIGZpZWxkIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlLiBEcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgc2hvdWxkIGJlIFRyYW5zcG9ydCBjaGVjayBiZWZvcmUgd2UgZ2V0IGhlcmUgKFNlY3Rpb24gMTgpLlxuICAgICAgICAgICAgLy8gQ3VzdG9tIFNJUC5qcyBjaGVjayB0byBkcm9wIHJlc3BvbnNlcyBpZiBiYWQgVmlhIGhlYWRlci5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5yZmMzMjYxXzE4XzFfMigpLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmlhLmhvc3QgIT09IHRoaXMuY29uZmlndXJhdGlvbi52aWFIb3N0IHx8IG1lc3NhZ2UudmlhLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJWaWEgc2VudC1ieSBpbiB0aGUgcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggVUEgVmlhIGhvc3QgdmFsdWUuIERyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogVGhpcyBzaG91bGQgYmUgVHJhbnNwb3J0IGNoZWNrIGJlZm9yZSB3ZSBnZXQgaGVyZSAoU2VjdGlvbiAxOCkuXG4gICAgICAgICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIHJlamVjdCByZXF1ZXN0cyBpZiBib2R5IGxlbmd0aCB3cm9uZy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5yZmMzMjYxXzE4XzNfcmVzcG9uc2UoKS5cbiAgICAgICAgICAgIHZhciBsZW4gPSBVdGlsc18xLlV0aWxzLnN0cl91dGY4X2xlbmd0aChtZXNzYWdlLmJvZHkpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRMZW5ndGggPSBtZXNzYWdlLmdldEhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggJiYgbGVuIDwgTnVtYmVyKGNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk1lc3NhZ2UgYm9keSBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgdmFsdWUgaW4gQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkLiBEcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBSZXF1ZXN0XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgY29yZV8xLkluY29taW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZWNlaXZlSW5jb21pbmdSZXF1ZXN0RnJvbVRyYW5zcG9ydChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgUmVzcG9uc2VcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBjb3JlXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZWNlaXZlSW5jb21pbmdSZXNwb25zZUZyb21UcmFuc3BvcnQobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlIHR5cGUuXCIpO1xuICAgIH07XG4gICAgLy8gPT09PT09PT09PT09PT09PT1cbiAgICAvLyBVdGlsc1xuICAgIC8vID09PT09PT09PT09PT09PT09XG4gICAgVUEucHJvdG90eXBlLmNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5ID0gZnVuY3Rpb24gKGF1dGhlbnRpY2F0aW9uRmFjdG9yeSkge1xuICAgICAgICBpZiAoIShhdXRoZW50aWNhdGlvbkZhY3RvcnkgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplKSB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoZW50aWNhdGlvbkZhY3Rvcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGxvYWQuXG4gICAgICogcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUubG9hZENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFNldHRpbmdzIGFuZCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAvKiBIb3N0IGFkZHJlc3NcbiAgICAgICAgICAgICAqIFZhbHVlIHRvIGJlIHNldCBpbiBWaWEgc2VudF9ieSBhbmQgaG9zdCBwYXJ0IG9mIENvbnRhY3QgRlFETlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aWFIb3N0OiBVdGlsc18xLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDEyKSArIFwiLmludmFsaWRcIixcbiAgICAgICAgICAgIHVyaTogbmV3IGNvcmVfMS5VUkkoXCJzaXBcIiwgXCJhbm9ueW1vdXMuXCIgKyBVdGlsc18xLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDYpLCBcImFub255bW91cy5pbnZhbGlkXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIC8vIEN1c3RvbSBDb25maWd1cmF0aW9uIFNldHRpbmdzXG4gICAgICAgICAgICBjdXN0b206IHt9LFxuICAgICAgICAgICAgLy8gRGlzcGxheSBuYW1lXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogXCJcIixcbiAgICAgICAgICAgIC8vIFBhc3N3b3JkXG4gICAgICAgICAgICBwYXNzd29yZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVnaXN0ZXI6IHRydWUsXG4gICAgICAgICAgICAvLyBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIC8vIFRyYW5zcG9ydCByZWxhdGVkIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRyYW5zcG9ydENvbnN0cnVjdG9yOiBUcmFuc3BvcnRfMS5UcmFuc3BvcnQsXG4gICAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHVzZVByZWxvYWRlZFJvdXRlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHN0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIFVzZXItQWdlbnQgcmVxdWVzdCBoZWFkZXJcbiAgICAgICAgICAgIHVzZXJBZ2VudFN0cmluZzogQ29uc3RhbnRzXzEuQy5VU0VSX0FHRU5ULFxuICAgICAgICAgICAgLy8gU2Vzc2lvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBub0Fuc3dlclRpbWVvdXQ6IDYwLFxuICAgICAgICAgICAgLy8gSGFja3NcbiAgICAgICAgICAgIGhhY2tWaWFUY3A6IGZhbHNlLFxuICAgICAgICAgICAgaGFja0lwSW5Db250YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGhhY2tXc3NJblRyYW5zcG9ydDogZmFsc2UsXG4gICAgICAgICAgICBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIFNlc3Npb24gRGVzY3JpcHRpb24gSGFuZGxlciBPcHRpb25zXG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50czoge30sXG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25PcHRpb25zOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dHJhU3VwcG9ydGVkOiBbXSxcbiAgICAgICAgICAgIGNvbnRhY3ROYW1lOiBVdGlsc18xLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDgpLFxuICAgICAgICAgICAgY29udGFjdFRyYW5zcG9ydDogXCJ3c1wiLFxuICAgICAgICAgICAgZm9yY2VScG9ydDogZmFsc2UsXG4gICAgICAgICAgICAvLyBhdXRvc3RhcnRpbmdcbiAgICAgICAgICAgIGF1dG9zdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGF1dG9zdG9wOiB0cnVlLFxuICAgICAgICAgICAgLy8gUmVsaWFibGUgUHJvdmlzaW9uYWwgUmVzcG9uc2VzXG4gICAgICAgICAgICByZWwxMDA6IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVELFxuICAgICAgICAgICAgLy8gRFRNRiB0eXBlOiAnaW5mbycgb3IgJ3J0cCcgKFJGQyA0NzMzKVxuICAgICAgICAgICAgLy8gUlRQIFBheWxvYWQgU3BlYzogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ3MzNcbiAgICAgICAgICAgIC8vIFdlYlJUQyBBdWRpbyBTcGVjOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzg3NFxuICAgICAgICAgICAgZHRtZlR5cGU6IENvbnN0YW50c18xLkMuZHRtZlR5cGUuSU5GTyxcbiAgICAgICAgICAgIC8vIFJlcGxhY2VzIGhlYWRlciAoUkZDIDM4OTEpXG4gICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzODkxXG4gICAgICAgICAgICByZXBsYWNlczogQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQsXG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcl8xLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuZGVmYXVsdEZhY3RvcnksXG4gICAgICAgICAgICBhdXRoZW50aWNhdGlvbkZhY3Rvcnk6IHRoaXMuY2hlY2tBdXRoZW50aWNhdGlvbkZhY3RvcnkoZnVuY3Rpb24gKHVhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuRGlnZXN0QXV0aGVudGljYXRpb24odWEuZ2V0TG9nZ2VyRmFjdG9yeSgpLCBfdGhpcy5jb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25Vc2VyLCBfdGhpcy5jb25maWd1cmF0aW9uLnBhc3N3b3JkKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWxsb3dMZWdhY3lOb3RpZmljYXRpb25zOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93T3V0T2ZEaWFsb2dSZWZlcnM6IGZhbHNlLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsRmVhdHVyZXM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb25maWdDaGVjayA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbkNoZWNrKCk7XG4gICAgICAgIC8vIENoZWNrIE1hbmRhdG9yeSBwYXJhbWV0ZXJzXG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBjb25maWdDaGVjay5tYW5kYXRvcnkpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBjb25maWdDaGVjay5tYW5kYXRvcnlbcGFyYW1ldGVyXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBjb25maWdDaGVjay5vcHRpb25hbCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5LCBidXQgc2hvdWxkbid0IGJlLCBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG51bGwsIGVtcHR5IHN0cmluZywgb3IgdW5kZWZpbmVkIHRoZW4gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIG51bWJlciB3aXRoIE5hTiB2YWx1ZSB0aGVuIGFsc28gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogSlMgZG9lcyBub3QgYWxsb3cgXCJ2YWx1ZSA9PT0gTmFOXCIsIHRoZSBmb2xsb3dpbmcgZG9lcyB0aGUgd29yazpcbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBjb25maWdDaGVjay5vcHRpb25hbFtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBvc3QgQ29uZmlndXJhdGlvbiBQcm9jZXNzXG4gICAgICAgIC8vIEFsbG93IHBhc3NpbmcgMCBudW1iZXIgYXMgZGlzcGxheU5hbWUuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaXNwbGF5TmFtZSA9PT0gMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuZGlzcGxheU5hbWUgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaXBqc0lkIGluc3RhbmNlIHBhcmFtZXRlci4gU3RhdGljIHJhbmRvbSB0YWcgb2YgbGVuZ3RoIDVcbiAgICAgICAgc2V0dGluZ3Muc2lwanNJZCA9IFV0aWxzXzEuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oNSk7XG4gICAgICAgIC8vIFN0cmluZyBjb250YWluaW5nIHNldHRpbmdzLnVyaSB3aXRob3V0IHNjaGVtZSBhbmQgdXNlci5cbiAgICAgICAgdmFyIGhvc3Rwb3J0UGFyYW1zID0gc2V0dGluZ3MudXJpLmNsb25lKCk7XG4gICAgICAgIGhvc3Rwb3J0UGFyYW1zLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNldHRpbmdzLmhvc3Rwb3J0UGFyYW1zID0gaG9zdHBvcnRQYXJhbXMudG9SYXcoKS5yZXBsYWNlKC9ec2lwOi9pLCBcIlwiKTtcbiAgICAgICAgLyogQ2hlY2sgd2hldGhlciBhdXRob3JpemF0aW9uVXNlciBpcyBleHBsaWNpdGx5IGRlZmluZWQuXG4gICAgICAgICAqIFRha2UgJ3NldHRpbmdzLnVyaS51c2VyJyB2YWx1ZSBpZiBub3QuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXNldHRpbmdzLmF1dGhvcml6YXRpb25Vc2VyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hdXRob3JpemF0aW9uVXNlciA9IHNldHRpbmdzLnVyaS51c2VyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZXIgbm9BbnN3ZXJUaW1lb3V0XG4gICAgICAgIHNldHRpbmdzLm5vQW5zd2VyVGltZW91dCA9IHNldHRpbmdzLm5vQW5zd2VyVGltZW91dCAqIDEwMDA7XG4gICAgICAgIC8vIFZpYSBIb3N0XG4gICAgICAgIGlmIChzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGFja0lwSW5Db250YWN0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSAyNTQ7XG4gICAgICAgICAgICAgICAgdmFyIG9jdGV0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRvIC0gZnJvbSArIDEpICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgLy8gcmFuZG9tIFRlc3QtTmV0IElQIChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NzM1KVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnZpYUhvc3QgPSBcIjE5Mi4wLjIuXCIgKyBvY3RldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy52aWFIb3N0ID0gc2V0dGluZ3MuaGFja0lwSW5Db250YWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRhY3QgdHJhbnNwb3J0IHBhcmFtZXRlclxuICAgICAgICBpZiAoc2V0dGluZ3MuaGFja1dzc0luVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jb250YWN0VHJhbnNwb3J0ID0gXCJ3c3NcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhY3QgPSB7XG4gICAgICAgICAgICBwdWJHcnV1OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0ZW1wR3J1dTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdXJpOiBuZXcgY29yZV8xLlVSSShcInNpcFwiLCBzZXR0aW5ncy5jb250YWN0TmFtZSwgc2V0dGluZ3MudmlhSG9zdCwgdW5kZWZpbmVkLCB7IHRyYW5zcG9ydDogc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCB9KSxcbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICAgICAgdmFyIGFub255bW91cyA9IG9wdGlvbnMuYW5vbnltb3VzIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IG9wdGlvbnMub3V0Ym91bmQgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBcIjxcIjtcbiAgICAgICAgICAgICAgICBpZiAoYW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QgKz0gKF90aGlzLmNvbnRhY3QudGVtcEdydXUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChcInNpcDphbm9ueW1vdXNAYW5vbnltb3VzLmludmFsaWQ7dHJhbnNwb3J0PVwiICsgc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0ICs9IChfdGhpcy5jb250YWN0LnB1YkdydXUgfHwgX3RoaXMuY29udGFjdC51cmkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0ICs9IFwiO29iXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRhY3QgKz0gXCI+XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBza2VsZXRvbiA9IHt9O1xuICAgICAgICAvLyBGaWxsIHRoZSB2YWx1ZSBvZiB0aGUgY29uZmlndXJhdGlvbl9za2VsZXRvblxuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgc2tlbGV0b25bcGFyYW1ldGVyXSA9IHNldHRpbmdzW3BhcmFtZXRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZ3VyYXRpb24sIHNrZWxldG9uKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGFmdGVyIHZhbGlkYXRpb246XCIpO1xuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVyaVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIsK3IFwiICsgcGFyYW1ldGVyICsgXCI6IFwiICsgc2V0dGluZ3NbcGFyYW1ldGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCLCtyBcIiArIHBhcmFtZXRlciArIFwiOiBcIiArIFwiTk9UIFNIT1dOXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc3BvcnRDb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBwYXJhbWV0ZXIgKyBcIjogXCIgKyBzZXR0aW5nc1twYXJhbWV0ZXJdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCLCtyBcIiArIHBhcmFtZXRlciArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzW3BhcmFtZXRlcl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBjaGVja2VyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLmdldENvbmZpZ3VyYXRpb25DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hbmRhdG9yeToge30sXG4gICAgICAgICAgICBvcHRpb25hbDoge1xuICAgICAgICAgICAgICAgIHVyaTogZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgvXnNpcDovaSkudGVzdCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmkgPSBDb25zdGFudHNfMS5DLlNJUCArIFwiOlwiICsgdXJpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBjb3JlXzEuR3JhbW1hci5VUklQYXJzZSh1cmkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCB8fCAhcGFyc2VkLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydENvbnN0cnVjdG9yOiBmdW5jdGlvbiAodHJhbnNwb3J0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydENvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnRDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0T3B0aW9uczogZnVuY3Rpb24gKHRyYW5zcG9ydE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFuc3BvcnRPcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvblVzZXI6IGZ1bmN0aW9uIChhdXRob3JpemF0aW9uVXNlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29yZV8xLkdyYW1tYXIucGFyc2UoJ1wiJyArIGF1dGhvcml6YXRpb25Vc2VyICsgJ1wiJywgXCJxdW90ZWRfc3RyaW5nXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25Vc2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JlXzEuR3JhbW1hci5wYXJzZSgnXCInICsgZGlzcGxheU5hbWUgKyAnXCInLCBcImRpc3BsYXlOYW1lXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkdG1mVHlwZTogZnVuY3Rpb24gKGR0bWZUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZHRtZlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5kdG1mVHlwZS5SVFA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuZHRtZlR5cGUuUlRQO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLmR0bWZUeXBlLklORk86XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuZHRtZlR5cGUuSU5GTztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFja1ZpYVRjcDogZnVuY3Rpb24gKGhhY2tWaWFUY3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYWNrVmlhVGNwID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhY2tWaWFUY3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhY2tJcEluQ29udGFjdDogZnVuY3Rpb24gKGhhY2tJcEluQ29udGFjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhY2tJcEluQ29udGFjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYWNrSXBJbkNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhhY2tJcEluQ29udGFjdCA9PT0gXCJzdHJpbmdcIiAmJiBjb3JlXzEuR3JhbW1hci5wYXJzZShoYWNrSXBJbkNvbnRhY3QsIFwiaG9zdFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYWNrSXBJbkNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhY2tXc3NJblRyYW5zcG9ydDogZnVuY3Rpb24gKGhhY2tXc3NJblRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhY2tXc3NJblRyYW5zcG9ydCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYWNrV3NzSW5UcmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M6IGZ1bmN0aW9uIChoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250YWN0VHJhbnNwb3J0OiBmdW5jdGlvbiAoY29udGFjdFRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRhY3RUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWN0VHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHRyYVN1cHBvcnRlZDogZnVuY3Rpb24gKG9wdGlvblRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEob3B0aW9uVGFncyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgb3B0aW9uVGFnc18xID0gb3B0aW9uVGFnczsgX2kgPCBvcHRpb25UYWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gb3B0aW9uVGFnc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25UYWdzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9yY2VScG9ydDogZnVuY3Rpb24gKGZvcmNlUnBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JjZVJwb3J0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcmNlUnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5vQW5zd2VyVGltZW91dDogZnVuY3Rpb24gKG5vQW5zd2VyVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwobm9BbnN3ZXJUaW1lb3V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKG5vQW5zd2VyVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcocGFzc3dvcmQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVsMTAwOiBmdW5jdGlvbiAocmVsMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWwxMDAgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuUkVRVUlSRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcGxhY2VzOiBmdW5jdGlvbiAocmVwbGFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VzID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VzID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAocmVnaXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWdpc3RlciA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiBmdW5jdGlvbiAocmVnaXN0ZXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXJPcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1c2VQcmVsb2FkZWRSb3V0ZTogZnVuY3Rpb24gKHVzZVByZWxvYWRlZFJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlUHJlbG9hZGVkUm91dGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlUHJlbG9hZGVkUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudFN0cmluZzogZnVuY3Rpb24gKHVzZXJBZ2VudFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJBZ2VudFN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJBZ2VudFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXV0b3N0YXJ0OiBmdW5jdGlvbiAoYXV0b3N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXV0b3N0YXJ0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXV0b3N0b3A6IGZ1bmN0aW9uIChhdXRvc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF1dG9zdG9wID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9zdG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTogZnVuY3Rpb24gKHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb25GYWN0b3J5OiB0aGlzLmNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5LFxuICAgICAgICAgICAgICAgIGFsbG93TGVnYWN5Tm90aWZpY2F0aW9uczogZnVuY3Rpb24gKGFsbG93TGVnYWN5Tm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFsbG93TGVnYWN5Tm90aWZpY2F0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGN1c3RvbTogZnVuY3Rpb24gKGN1c3RvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udGFjdE5hbWU6IGZ1bmN0aW9uIChjb250YWN0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRhY3ROYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbEZlYXR1cmVzOiBmdW5jdGlvbiAoZXhwZXJpbWVudGFsRmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBlcmltZW50YWxGZWF0dXJlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBlcmltZW50YWxGZWF0dXJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBVQS5DID0ge1xuICAgICAgICAvLyBVQSBzdGF0dXMgY29kZXNcbiAgICAgICAgU1RBVFVTX0lOSVQ6IDAsXG4gICAgICAgIFNUQVRVU19TVEFSVElORzogMSxcbiAgICAgICAgU1RBVFVTX1JFQURZOiAyLFxuICAgICAgICBTVEFUVVNfVVNFUl9DTE9TRUQ6IDMsXG4gICAgICAgIFNUQVRVU19OT1RfUkVBRFk6IDQsXG4gICAgICAgIC8vIFVBIGVycm9yIGNvZGVzXG4gICAgICAgIENPTkZJR1VSQVRJT05fRVJST1I6IDEsXG4gICAgICAgIE5FVFdPUktfRVJST1I6IDIsXG4gICAgICAgIEFMTE9XRURfTUVUSE9EUzogW1xuICAgICAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgICAgICBcIklOVklURVwiLFxuICAgICAgICAgICAgXCJNRVNTQUdFXCIsXG4gICAgICAgICAgICBcIkJZRVwiLFxuICAgICAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgICAgICBcIklORk9cIixcbiAgICAgICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgICAgICBcIlJFRkVSXCJcbiAgICAgICAgXSxcbiAgICAgICAgQUNDRVBURURfQk9EWV9UWVBFUzogW1xuICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9zZHBcIixcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vZHRtZi1yZWxheVwiXG4gICAgICAgIF0sXG4gICAgICAgIE1BWF9GT1JXQVJEUzogNzAsXG4gICAgICAgIFRBR19MRU5HVEg6IDEwXG4gICAgfTtcbiAgICByZXR1cm4gVUE7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5VQSA9IFVBO1xuKGZ1bmN0aW9uIChVQSkge1xuICAgIHZhciBEdG1mVHlwZTtcbiAgICAoZnVuY3Rpb24gKER0bWZUeXBlKSB7XG4gICAgICAgIER0bWZUeXBlW1wiUlRQXCJdID0gXCJydHBcIjtcbiAgICAgICAgRHRtZlR5cGVbXCJJTkZPXCJdID0gXCJpbmZvXCI7XG4gICAgfSkoRHRtZlR5cGUgPSBVQS5EdG1mVHlwZSB8fCAoVUEuRHRtZlR5cGUgPSB7fSkpO1xufSkoVUEgPSBleHBvcnRzLlVBIHx8IChleHBvcnRzLlVBID0ge30pKTtcbmV4cG9ydHMuVUEgPSBVQTtcbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjb25maWd1cmF0aW9uIGdpdmUgYSBVQS5cbiAqIEBwYXJhbSB1YSBVQVxuICovXG5mdW5jdGlvbiBtYWtlVXNlckFnZW50Q29yZUNvbmZpZ3VyYXRpb25Gcm9tVUEodWEpIHtcbiAgICAvLyBGSVhNRTogQ29uZmlndXJhdGlvbiBVUkkgaXMgYSBiYWQgbWl4IG9mIHR5cGVzIGN1cnJlbnRseS4gSXQgYWxzbyBuZWVkcyB0byBleGlzdC5cbiAgICBpZiAoISh1YS5jb25maWd1cmF0aW9uLnVyaSBpbnN0YW5jZW9mIGNvcmVfMS5VUkkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZ3VyYXRpb24gVVJJIG5vdCBpbnN0YW5jZSBvZiBVUkkuXCIpO1xuICAgIH1cbiAgICB2YXIgYW9yID0gdWEuY29uZmlndXJhdGlvbi51cmk7XG4gICAgdmFyIGNvbnRhY3QgPSB1YS5jb250YWN0O1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IHVhLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWUgPyB1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lIDogXCJcIjtcbiAgICB2YXIgaGFja1ZpYVRjcCA9IHVhLmNvbmZpZ3VyYXRpb24uaGFja1ZpYVRjcCA/IHRydWUgOiBmYWxzZTtcbiAgICB2YXIgcm91dGVTZXQgPSB1YS5jb25maWd1cmF0aW9uLnVzZVByZWxvYWRlZFJvdXRlICYmIHVhLnRyYW5zcG9ydC5zZXJ2ZXIgJiYgdWEudHJhbnNwb3J0LnNlcnZlci5zaXBVcmkgP1xuICAgICAgICBbdWEudHJhbnNwb3J0LnNlcnZlci5zaXBVcmldIDpcbiAgICAgICAgW107XG4gICAgdmFyIHNpcGpzSWQgPSB1YS5jb25maWd1cmF0aW9uLnNpcGpzSWQgfHwgVXRpbHNfMS5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbig1KTtcbiAgICB2YXIgc3VwcG9ydGVkT3B0aW9uVGFncyA9IFtdO1xuICAgIHN1cHBvcnRlZE9wdGlvblRhZ3MucHVzaChcIm91dGJvdW5kXCIpOyAvLyBUT0RPOiBpcyB0aGlzIHJlYWxseSBzdXBwb3J0ZWQ/XG4gICAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICAgICAgc3VwcG9ydGVkT3B0aW9uVGFncy5wdXNoKFwiMTAwcmVsXCIpO1xuICAgIH1cbiAgICBpZiAodWEuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgIHN1cHBvcnRlZE9wdGlvblRhZ3MucHVzaChcInJlcGxhY2VzXCIpO1xuICAgIH1cbiAgICBpZiAodWEuY29uZmlndXJhdGlvbi5leHRyYVN1cHBvcnRlZCkge1xuICAgICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLnB1c2guYXBwbHkoc3VwcG9ydGVkT3B0aW9uVGFncywgdWEuY29uZmlndXJhdGlvbi5leHRyYVN1cHBvcnRlZCk7XG4gICAgfVxuICAgIGlmICghdWEuY29uZmlndXJhdGlvbi5oYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzKSB7XG4gICAgICAgIHN1cHBvcnRlZE9wdGlvblRhZ3MgPSBzdXBwb3J0ZWRPcHRpb25UYWdzLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uVGFnKSB7IHJldHVybiBDb25zdGFudHNfMS5DLk9QVElPTl9UQUdTW29wdGlvblRhZ107IH0pO1xuICAgIH1cbiAgICBzdXBwb3J0ZWRPcHRpb25UYWdzID0gQXJyYXkuZnJvbShuZXcgU2V0KHN1cHBvcnRlZE9wdGlvblRhZ3MpKTsgLy8gYXJyYXkgb2YgdW5pcXVlIHZhbHVlc1xuICAgIHZhciBzdXBwb3J0ZWRPcHRpb25UYWdzUmVzcG9uc2UgPSB1YS5nZXRTdXBwb3J0ZWRSZXNwb25zZU9wdGlvbnMoKTtcbiAgICB2YXIgdXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZSA9IHVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nIHx8IFwic2lwanNcIjtcbiAgICBpZiAoISh1YS5jb25maWd1cmF0aW9uLnZpYUhvc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZ3VyYXRpb24gdmlhIGhvc3QgdW5kZWZpbmVkXCIpO1xuICAgIH1cbiAgICB2YXIgdmlhRm9yY2VScG9ydCA9IHVhLmNvbmZpZ3VyYXRpb24uZm9yY2VScG9ydCA/IHRydWUgOiBmYWxzZTtcbiAgICB2YXIgdmlhSG9zdCA9IHVhLmNvbmZpZ3VyYXRpb24udmlhSG9zdDtcbiAgICB2YXIgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgYW9yOiBhb3IsXG4gICAgICAgIGNvbnRhY3Q6IGNvbnRhY3QsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgaGFja1ZpYVRjcDogaGFja1ZpYVRjcCxcbiAgICAgICAgbG9nZ2VyRmFjdG9yeTogdWEuZ2V0TG9nZ2VyRmFjdG9yeSgpLFxuICAgICAgICByb3V0ZVNldDogcm91dGVTZXQsXG4gICAgICAgIHNpcGpzSWQ6IHNpcGpzSWQsXG4gICAgICAgIHN1cHBvcnRlZE9wdGlvblRhZ3M6IHN1cHBvcnRlZE9wdGlvblRhZ3MsXG4gICAgICAgIHN1cHBvcnRlZE9wdGlvblRhZ3NSZXNwb25zZTogc3VwcG9ydGVkT3B0aW9uVGFnc1Jlc3BvbnNlLFxuICAgICAgICB1c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlOiB1c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlLFxuICAgICAgICB2aWFGb3JjZVJwb3J0OiB2aWFGb3JjZVJwb3J0LFxuICAgICAgICB2aWFIb3N0OiB2aWFIb3N0LFxuICAgICAgICBhdXRoZW50aWNhdGlvbkZhY3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1YS5jb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0aW9uRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1YS5jb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0aW9uRmFjdG9yeSh1YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc3BvcnRBY2Nlc3NvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWEudHJhbnNwb3J0OyB9XG4gICAgfTtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbjtcbn1cbmV4cG9ydHMubWFrZVVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uRnJvbVVBID0gbWFrZVVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uRnJvbVVBO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgZ3JhbW1hcl8xID0gcmVxdWlyZShcIi4vY29yZS9tZXNzYWdlcy9ncmFtbWFyXCIpO1xudmFyIHVyaV8xID0gcmVxdWlyZShcIi4vY29yZS9tZXNzYWdlcy91cmlcIik7XG52YXIgVXRpbHM7XG4oZnVuY3Rpb24gKFV0aWxzKSB7XG4gICAgZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHt9O1xuICAgICAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfVxuICAgIFV0aWxzLmRlZmVyID0gZGVmZXI7XG4gICAgZnVuY3Rpb24gcmVkdWNlUHJvbWlzZXMoYXJyLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZm4pIHtcbiAgICAgICAgICAgIGFjYyA9IGFjYy50aGVuKGZuKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFByb21pc2UucmVzb2x2ZSh2YWwpKTtcbiAgICB9XG4gICAgVXRpbHMucmVkdWNlUHJvbWlzZXMgPSByZWR1Y2VQcm9taXNlcztcbiAgICBmdW5jdGlvbiBzdHJfdXRmOF9sZW5ndGgoc3RyKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8lW0EtRlxcZF17Mn0vZywgXCJVXCIpLmxlbmd0aDtcbiAgICB9XG4gICAgVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoID0gc3RyX3V0ZjhfbGVuZ3RoO1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRmFrZVNEUChib2R5KSB7XG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IGJvZHkuaW5kZXhPZihcIm89XCIpO1xuICAgICAgICB2YXIgZW5kID0gYm9keS5pbmRleE9mKFwiXFxyXFxuXCIsIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFwidj0wXFxyXFxuXCIgKyBib2R5LnNsaWNlKHN0YXJ0LCBlbmQpICsgXCJcXHJcXG5zPS1cXHJcXG50PTAgMFxcclxcbmM9SU4gSVA0IDAuMC4wLjBcIjtcbiAgICB9XG4gICAgVXRpbHMuZ2VuZXJhdGVGYWtlU0RQID0gZ2VuZXJhdGVGYWtlU0RQO1xuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbChudW0pIHtcbiAgICAgICAgdmFyIG51bUFzTnVtID0gcGFyc2VJbnQobnVtLCAxMCk7XG4gICAgICAgIHJldHVybiAhaXNOYU4obnVtQXNOdW0pICYmIChwYXJzZUZsb2F0KG51bSkgPT09IG51bUFzTnVtKTtcbiAgICB9XG4gICAgVXRpbHMuaXNEZWNpbWFsID0gaXNEZWNpbWFsO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmRvbVRva2VuKHNpemUsIGJhc2UpIHtcbiAgICAgICAgaWYgKGJhc2UgPT09IHZvaWQgMCkgeyBiYXNlID0gMzI7IH1cbiAgICAgICAgdmFyIHRva2VuID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmFzZSk7XG4gICAgICAgICAgICB0b2tlbiArPSByLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4gPSBjcmVhdGVSYW5kb21Ub2tlbjtcbiAgICBmdW5jdGlvbiBuZXdUYWcoKSB7XG4gICAgICAgIC8vIHVzZWQgdG8gdXNlIHRoZSBjb25zdGFudCBpbiBVQVxuICAgICAgICByZXR1cm4gVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMTApO1xuICAgIH1cbiAgICBVdGlscy5uZXdUYWcgPSBuZXdUYWc7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzEwOTUzOC9icm9vZmFcbiAgICBmdW5jdGlvbiBuZXdVVUlEKCkge1xuICAgICAgICB2YXIgVVVJRCA9IFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNik7XG4gICAgICAgICAgICB2YXIgdiA9IGMgPT09IFwieFwiID8gciA6IChyICUgNCArIDgpO1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFVVSUQ7XG4gICAgfVxuICAgIFV0aWxzLm5ld1VVSUQgPSBuZXdVVUlEO1xuICAgIC8qXG4gICAgICogTm9ybWFsaXplIFNJUCBVUkkuXG4gICAgICogTk9URTogSXQgZG9lcyBub3QgYWxsb3cgYSBTSVAgVVJJIHdpdGhvdXQgdXNlcm5hbWUuXG4gICAgICogQWNjZXB0cyAnc2lwJywgJ3NpcHMnIGFuZCAndGVsJyBVUklzIGFuZCBjb252ZXJ0IHRoZW0gaW50byAnc2lwJy5cbiAgICAgKiBEZXRlY3RzIHRoZSBkb21haW4gcGFydCAoaWYgZ2l2ZW4pIGFuZCBwcm9wZXJseSBoZXgtZXNjYXBlcyB0aGUgdXNlciBwb3J0aW9uLlxuICAgICAqIElmIHRoZSB1c2VyIHBvcnRpb24gaGFzIG9ubHkgJ3RlbCcgbnVtYmVyIHN5bWJvbHMgdGhlIHVzZXIgcG9ydGlvbiBpcyBjbGVhbiBvZiAndGVsJyB2aXN1YWwgc2VwYXJhdG9ycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RvbWFpbl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVUYXJnZXQodGFyZ2V0LCBkb21haW4pIHtcbiAgICAgICAgLy8gSWYgbm8gdGFyZ2V0IGlzIGdpdmVuIHRoZW4gcmFpc2UgYW4gZXJyb3IuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBJZiBhIFNJUC5VUkkgaW5zdGFuY2UgaXMgZ2l2ZW4gdGhlbiByZXR1cm4gaXQuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgdXJpXzEuVVJJKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgLy8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gc3BsaXQgaXQgYnkgJ0AnOlxuICAgICAgICAgICAgLy8gLSBMYXN0IGZyYWdtZW50IGlzIHRoZSBkZXNpcmVkIGRvbWFpbi5cbiAgICAgICAgICAgIC8vIC0gT3RoZXJ3aXNlIGFwcGVuZCB0aGUgZ2l2ZW4gZG9tYWluIGFyZ3VtZW50LlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRBcnJheSA9IHRhcmdldC5zcGxpdChcIkBcIik7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VXNlciA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciB0YXJnZXREb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhcmdldEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVc2VyID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXREb21haW4gPSBkb21haW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXNlciA9IHRhcmdldEFycmF5WzBdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXREb21haW4gPSB0YXJnZXRBcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXNlciA9IHRhcmdldEFycmF5LnNsaWNlKDAsIHRhcmdldEFycmF5Lmxlbmd0aCAtIDEpLmpvaW4oXCJAXCIpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXREb21haW4gPSB0YXJnZXRBcnJheVt0YXJnZXRBcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgVVJJIHNjaGVtZSAoaWYgcHJlc2VudCkuXG4gICAgICAgICAgICB0YXJnZXRVc2VyID0gdGFyZ2V0VXNlci5yZXBsYWNlKC9eKHNpcHM/fHRlbCk6L2ksIFwiXCIpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlICd0ZWwnIHZpc3VhbCBzZXBhcmF0b3JzIGlmIHRoZSB1c2VyIHBvcnRpb24ganVzdCBjb250YWlucyAndGVsJyBudW1iZXIgc3ltYm9scy5cbiAgICAgICAgICAgIGlmICgvXltcXC1cXC5cXChcXCldKlxcKz9bMC05XFwtXFwuXFwoXFwpXSskLy50ZXN0KHRhcmdldFVzZXIpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VXNlciA9IHRhcmdldFVzZXIucmVwbGFjZSgvW1xcLVxcLlxcKFxcKV0vZywgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgY29tcGxldGUgU0lQIFVSSS5cbiAgICAgICAgICAgIHRhcmdldCA9IENvbnN0YW50c18xLkMuU0lQICsgXCI6XCIgKyBVdGlscy5lc2NhcGVVc2VyKHRhcmdldFVzZXIpICsgXCJAXCIgKyB0YXJnZXREb21haW47XG4gICAgICAgICAgICAvLyBGaW5hbGx5IHBhcnNlIHRoZSByZXN1bHRpbmcgVVJJLlxuICAgICAgICAgICAgcmV0dXJuIGdyYW1tYXJfMS5HcmFtbWFyLlVSSVBhcnNlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgVXRpbHMubm9ybWFsaXplVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0O1xuICAgIC8qXG4gICAgICogSGV4LWVzY2FwZSBhIFNJUCBVUkkgdXNlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlVXNlcih1c2VyKSB7XG4gICAgICAgIC8vIERvbid0IGhleC1lc2NhcGUgJzonICglM0EpLCAnKycgKCUyQiksICc/JyAoJTNGXCIpLCAnLycgKCUyRikuXG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVzZXIpKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUzQS9pZywgXCI6XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTJCL2lnLCBcIitcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lM0YvaWcsIFwiP1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUyRi9pZywgXCIvXCIpO1xuICAgIH1cbiAgICBVdGlscy5lc2NhcGVVc2VyID0gZXNjYXBlVXNlcjtcbiAgICBmdW5jdGlvbiBoZWFkZXJpemUoc3RyKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25zID0ge1xuICAgICAgICAgICAgXCJDYWxsLUlkXCI6IFwiQ2FsbC1JRFwiLFxuICAgICAgICAgICAgXCJDc2VxXCI6IFwiQ1NlcVwiLFxuICAgICAgICAgICAgXCJNaW4tU2VcIjogXCJNaW4tU0VcIixcbiAgICAgICAgICAgIFwiUmFja1wiOiBcIlJBY2tcIixcbiAgICAgICAgICAgIFwiUnNlcVwiOiBcIlJTZXFcIixcbiAgICAgICAgICAgIFwiV3d3LUF1dGhlbnRpY2F0ZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5hbWUgPSBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fL2csIFwiLVwiKS5zcGxpdChcIi1cIik7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWUubGVuZ3RoO1xuICAgICAgICB2YXIgaG5hbWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBwYXJ0ID0gMDsgcGFydCA8IHBhcnRzOyBwYXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaG5hbWUgKz0gXCItXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBobmFtZSArPSBuYW1lW3BhcnRdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZVtwYXJ0XS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2VwdGlvbnNbaG5hbWVdKSB7XG4gICAgICAgICAgICBobmFtZSA9IGV4Y2VwdGlvbnNbaG5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBobmFtZTtcbiAgICB9XG4gICAgVXRpbHMuaGVhZGVyaXplID0gaGVhZGVyaXplO1xuICAgIGZ1bmN0aW9uIHNpcEVycm9yQ2F1c2Uoc3RhdHVzQ29kZSkge1xuICAgICAgICBmb3IgKHZhciBjYXVzZSBpbiBDb25zdGFudHNfMS5DLlNJUF9FUlJPUl9DQVVTRVMpIHtcbiAgICAgICAgICAgIGlmIChDb25zdGFudHNfMS5DLlNJUF9FUlJPUl9DQVVTRVNbY2F1c2VdLmluZGV4T2Yoc3RhdHVzQ29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuY2F1c2VzW2NhdXNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29uc3RhbnRzXzEuQy5jYXVzZXMuU0lQX0ZBSUxVUkVfQ09ERTtcbiAgICB9XG4gICAgVXRpbHMuc2lwRXJyb3JDYXVzZSA9IHNpcEVycm9yQ2F1c2U7XG4gICAgZnVuY3Rpb24gZ2V0UmVhc29uUGhyYXNlKGNvZGUsIHNwZWNpZmljKSB7XG4gICAgICAgIHJldHVybiBzcGVjaWZpYyB8fCBDb25zdGFudHNfMS5DLlJFQVNPTl9QSFJBU0VbY29kZV0gfHwgXCJcIjtcbiAgICB9XG4gICAgVXRpbHMuZ2V0UmVhc29uUGhyYXNlID0gZ2V0UmVhc29uUGhyYXNlO1xuICAgIGZ1bmN0aW9uIGdldFJlYXNvbkhlYWRlclZhbHVlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICByZWFzb24gPSBVdGlscy5nZXRSZWFzb25QaHJhc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgcmV0dXJuIFwiU0lQO2NhdXNlPVwiICsgY29kZSArICc7dGV4dD1cIicgKyByZWFzb24gKyAnXCInO1xuICAgIH1cbiAgICBVdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZSA9IGdldFJlYXNvbkhlYWRlclZhbHVlO1xuICAgIGZ1bmN0aW9uIGdldENhbmNlbFJlYXNvbihjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKGNvZGUgJiYgY29kZSA8IDIwMCB8fCBjb2RlID4gNjk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZShjb2RlLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFV0aWxzLmdldENhbmNlbFJlYXNvbiA9IGdldENhbmNlbFJlYXNvbjtcbiAgICBmdW5jdGlvbiBidWlsZFN0YXR1c0xpbmUoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGNvZGUgYW5kIHJlYXNvbiB2YWx1ZXNcbiAgICAgICAgaWYgKCFjb2RlIHx8IChjb2RlIDwgMTAwIHx8IGNvZGUgPiA2OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uICE9PSBcInN0cmluZ1wiICYmICEocmVhc29uIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcmVhc29uOiBcIiArIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVhc29uID0gVXRpbHMuZ2V0UmVhc29uUGhyYXNlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIHJldHVybiBcIlNJUC8yLjAgXCIgKyBjb2RlICsgXCIgXCIgKyByZWFzb24gKyBcIlxcclxcblwiO1xuICAgIH1cbiAgICBVdGlscy5idWlsZFN0YXR1c0xpbmUgPSBidWlsZFN0YXR1c0xpbmU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQm9keSBnaXZlbiBhIEJvZHlPYmouXG4gICAgICogQHBhcmFtIGJvZHlPYmogQm9keSBPYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tQm9keU9iaihib2R5T2JqKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYm9keU9iai5ib2R5O1xuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBib2R5T2JqLmNvbnRlbnRUeXBlO1xuICAgICAgICB2YXIgY29udGVudERpc3Bvc2l0aW9uID0gY29udGVudFR5cGVUb0NvbnRlbnREaXNwb3NpdGlvbihjb250ZW50VHlwZSk7XG4gICAgICAgIHZhciBib2R5ID0geyBjb250ZW50RGlzcG9zaXRpb246IGNvbnRlbnREaXNwb3NpdGlvbiwgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlLCBjb250ZW50OiBjb250ZW50IH07XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgICBVdGlscy5mcm9tQm9keU9iaiA9IGZyb21Cb2R5T2JqO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJvZHlPYmogZ2l2ZW4gYSBCb2R5LlxuICAgICAqIEBwYXJhbSBib2R5T2JqIEJvZHkgT2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Cb2R5T2JqKGJvZHkpIHtcbiAgICAgICAgdmFyIGJvZHlPYmogPSB7XG4gICAgICAgICAgICBib2R5OiBib2R5LmNvbnRlbnQsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogYm9keS5jb250ZW50VHlwZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYm9keU9iajtcbiAgICB9XG4gICAgVXRpbHMudG9Cb2R5T2JqID0gdG9Cb2R5T2JqO1xuICAgIC8vIElmIHRoZSBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciBmaWVsZCBpcyBtaXNzaW5nLCBib2RpZXMgb2ZcbiAgICAvLyBDb250ZW50LVR5cGUgYXBwbGljYXRpb24vc2RwIGltcGx5IHRoZSBkaXNwb3NpdGlvbiBcInNlc3Npb25cIiwgd2hpbGVcbiAgICAvLyBvdGhlciBjb250ZW50IHR5cGVzIGltcGx5IFwicmVuZGVyXCIuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICBmdW5jdGlvbiBjb250ZW50VHlwZVRvQ29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9zZHBcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwic2Vzc2lvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwicmVuZGVyXCI7XG4gICAgICAgIH1cbiAgICB9XG59KShVdGlscyA9IGV4cG9ydHMuVXRpbHMgfHwgKGV4cG9ydHMuVXRpbHMgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3RyaXBQYXlsb2FkID0gZnVuY3Rpb24gKHNkcCwgcGF5bG9hZCkge1xuICAgIHZhciBtZWRpYURlc2NzID0gW107XG4gICAgdmFyIGxpbmVzID0gc2RwLnNwbGl0KC9cXHJcXG4vKTtcbiAgICB2YXIgY3VycmVudE1lZGlhRGVzYztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKC9ebT0oPzphdWRpb3x2aWRlbykvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNZWRpYURlc2MgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgc3RyaXBwZWQ6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWVkaWFEZXNjcy5wdXNoKGN1cnJlbnRNZWRpYURlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRNZWRpYURlc2MpIHtcbiAgICAgICAgICAgIHZhciBydHBtYXAgPSAvXmE9cnRwbWFwOihcXGQrKSAoW14vXSspXFwvLy5leGVjKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHJ0cG1hcCAmJiBwYXlsb2FkID09PSBydHBtYXBbMl0pIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1lZGlhRGVzYy5zdHJpcHBlZC5wdXNoKHJ0cG1hcFsxXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIERvbid0IGluY3JlbWVudCAnaSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgbWVkaWFEZXNjc18xID0gbWVkaWFEZXNjczsgX2kgPCBtZWRpYURlc2NzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtZWRpYURlc2MgPSBtZWRpYURlc2NzXzFbX2ldO1xuICAgICAgICB2YXIgbWxpbmUgPSBsaW5lc1ttZWRpYURlc2MuaW5kZXhdLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaXJzdCAzIHBhcmFtZXRlcnMgb2YgdGhlIG1saW5lLiBUaGUgY29kZWMgaW5mb3JtYXRpb24gaXMgYWZ0ZXIgdGhhdFxuICAgICAgICBmb3IgKHZhciBqID0gMzsgaiA8IG1saW5lLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGlmIChtZWRpYURlc2Muc3RyaXBwZWQuaW5kZXhPZihtbGluZVtqXSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbWxpbmUuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzW21lZGlhRGVzYy5pbmRleF0gPSBtbGluZS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXHJcXG5cIik7XG59O1xudmFyIHN0cmlwTWVkaWFEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzZHAsIGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uUmVnRXhwID0gbmV3IFJlZ0V4cChcIm09XCIgKyBkZXNjcmlwdGlvbiArIFwiLiokXCIsIFwiZ21cIik7XG4gICAgdmFyIGdyb3VwUmVnRXhwID0gbmV3IFJlZ0V4cChcIl5hPWdyb3VwOi4qJFwiLCBcImdtXCIpO1xuICAgIGlmIChkZXNjcmlwdGlvblJlZ0V4cC50ZXN0KHNkcCkpIHtcbiAgICAgICAgdmFyIG1pZExpbmVUb1JlbW92ZV8xO1xuICAgICAgICBzZHAgPSBzZHAuc3BsaXQoL15tPS9nbSkuZmlsdGVyKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5zdWJzdHIoMCwgZGVzY3JpcHRpb24ubGVuZ3RoKSA9PT0gZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBtaWRMaW5lVG9SZW1vdmVfMSA9IHNlY3Rpb24ubWF0Y2goL15hPW1pZDouKiQvZ20pO1xuICAgICAgICAgICAgICAgIGlmIChtaWRMaW5lVG9SZW1vdmVfMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IG1pZExpbmVUb1JlbW92ZV8xWzBdLm1hdGNoKC86LiskL2cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkTGluZVRvUmVtb3ZlXzEgPSBzdGVwWzBdLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuam9pbihcIm09XCIpO1xuICAgICAgICB2YXIgZ3JvdXBMaW5lID0gc2RwLm1hdGNoKGdyb3VwUmVnRXhwKTtcbiAgICAgICAgaWYgKGdyb3VwTGluZSAmJiBncm91cExpbmUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBMaW5lUG9ydGlvbiA9IGdyb3VwTGluZVswXTtcbiAgICAgICAgICAgIHZhciBncm91cFJlZ0V4cFJlcGxhY2UgPSBuZXcgUmVnRXhwKFwiXFwgKlwiICsgbWlkTGluZVRvUmVtb3ZlXzEgKyBcIlteXFwgXSpcIiwgXCJnXCIpO1xuICAgICAgICAgICAgZ3JvdXBMaW5lUG9ydGlvbiA9IGdyb3VwTGluZVBvcnRpb24ucmVwbGFjZShncm91cFJlZ0V4cFJlcGxhY2UsIFwiXCIpO1xuICAgICAgICAgICAgc2RwID0gc2RwLnNwbGl0KGdyb3VwUmVnRXhwKS5qb2luKGdyb3VwTGluZVBvcnRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG59O1xuZnVuY3Rpb24gc3RyaXBUY3BDYW5kaWRhdGVzKGRlc2NyaXB0aW9uKSB7XG4gICAgZGVzY3JpcHRpb24uc2RwID0gKGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiKS5yZXBsYWNlKC9eYT1jYW5kaWRhdGU6XFxkKyBcXGQrIHRjcCAuKj9cXHJcXG4vaW1nLCBcIlwiKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2NyaXB0aW9uKTtcbn1cbmV4cG9ydHMuc3RyaXBUY3BDYW5kaWRhdGVzID0gc3RyaXBUY3BDYW5kaWRhdGVzO1xuZnVuY3Rpb24gc3RyaXBUZWxlcGhvbmVFdmVudChkZXNjcmlwdGlvbikge1xuICAgIGRlc2NyaXB0aW9uLnNkcCA9IHN0cmlwUGF5bG9hZChkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIiwgXCJ0ZWxlcGhvbmUtZXZlbnRcIik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG59XG5leHBvcnRzLnN0cmlwVGVsZXBob25lRXZlbnQgPSBzdHJpcFRlbGVwaG9uZUV2ZW50O1xuZnVuY3Rpb24gY2xlYW5KaXRzaVNkcEltYWdlYXR0cihkZXNjcmlwdGlvbikge1xuICAgIGRlc2NyaXB0aW9uLnNkcCA9IChkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIikucmVwbGFjZSgvXihhPWltYWdlYXR0cjouKj8pKHh8eSk9XFxbMC0vZ20sIFwiJDEkMj1bMTpcIik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG59XG5leHBvcnRzLmNsZWFuSml0c2lTZHBJbWFnZWF0dHIgPSBjbGVhbkppdHNpU2RwSW1hZ2VhdHRyO1xuZnVuY3Rpb24gc3RyaXBHNzIyKGRlc2NyaXB0aW9uKSB7XG4gICAgZGVzY3JpcHRpb24uc2RwID0gc3RyaXBQYXlsb2FkKGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiLCBcIkc3MjJcIik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG59XG5leHBvcnRzLnN0cmlwRzcyMiA9IHN0cmlwRzcyMjtcbmZ1bmN0aW9uIHN0cmlwUnRwUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBzdHJpcFBheWxvYWQoZGVzY3JpcHRpb24uc2RwIHx8IFwiXCIsIHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2NyaXB0aW9uKTtcbiAgICB9O1xufVxuZXhwb3J0cy5zdHJpcFJ0cFBheWxvYWQgPSBzdHJpcFJ0cFBheWxvYWQ7XG5mdW5jdGlvbiBzdHJpcFZpZGVvKGRlc2NyaXB0aW9uKSB7XG4gICAgZGVzY3JpcHRpb24uc2RwID0gc3RyaXBNZWRpYURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiLCBcInZpZGVvXCIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5zdHJpcFZpZGVvID0gc3RyaXBWaWRlbztcbmZ1bmN0aW9uIGFkZE1pZExpbmVzKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHNkcCA9IGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiO1xuICAgIGlmIChzZHAuc2VhcmNoKC9eYT1taWQuKiQvZ20pID09PSAtMSkge1xuICAgICAgICB2YXIgbWxpbmVzXzEgPSBzZHAubWF0Y2goL15tPS4qJC9nbSk7XG4gICAgICAgIHZhciBzZHBBcnJheV8xID0gc2RwLnNwbGl0KC9ebT0uKiQvZ20pO1xuICAgICAgICBpZiAobWxpbmVzXzEpIHtcbiAgICAgICAgICAgIG1saW5lc18xLmZvckVhY2goZnVuY3Rpb24gKGVsZW0sIGlkeCkge1xuICAgICAgICAgICAgICAgIG1saW5lc18xW2lkeF0gPSBlbGVtICsgXCJcXG5hPW1pZDpcIiArIGlkeDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNkcEFycmF5XzEuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSwgaWR4KSB7XG4gICAgICAgICAgICBpZiAobWxpbmVzXzEgJiYgbWxpbmVzXzFbaWR4XSkge1xuICAgICAgICAgICAgICAgIHNkcEFycmF5XzFbaWR4XSA9IGVsZW0gKyBtbGluZXNfMVtpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2RwID0gc2RwQXJyYXlfMS5qb2luKFwiXCIpO1xuICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBzZHA7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5hZGRNaWRMaW5lcyA9IGFkZE1pZExpbmVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4uL2FwaS9zZXNzaW9uXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi4vRW51bXNcIik7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4uL0V4Y2VwdGlvbnNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbnZhciBNb2RpZmllcnMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9Nb2RpZmllcnNcIikpO1xudmFyIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlcl8xID0gcmVxdWlyZShcIi4vU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyXCIpO1xuLyogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclxuICogQGNsYXNzIFBlZXJDb25uZWN0aW9uIGhlbHBlciBDbGFzcy5cbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xudmFyIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKGxvZ2dlciwgb2JzZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhlIG9wdGlvbnNcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgX3RoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgX3RoaXMuZHRtZlNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuc2hvdWxkQWNxdWlyZU1lZGlhID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi9zZHBcIjtcbiAgICAgICAgX3RoaXMuQyA9IHtcbiAgICAgICAgICAgIERJUkVDVElPTjoge1xuICAgICAgICAgICAgICAgIE5VTEw6IG51bGwsXG4gICAgICAgICAgICAgICAgU0VORFJFQ1Y6IFwic2VuZHJlY3ZcIixcbiAgICAgICAgICAgICAgICBTRU5ET05MWTogXCJzZW5kb25seVwiLFxuICAgICAgICAgICAgICAgIFJFQ1ZPTkxZOiBcInJlY3Zvbmx5XCIsXG4gICAgICAgICAgICAgICAgSU5BQ1RJVkU6IFwiaW5hY3RpdmVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IFwiICsgSlNPTi5zdHJpbmdpZnkoX3RoaXMub3B0aW9ucykpO1xuICAgICAgICBfdGhpcy5kaXJlY3Rpb24gPSBfdGhpcy5DLkRJUkVDVElPTi5OVUxMO1xuICAgICAgICBfdGhpcy5tb2RpZmllcnMgPSBfdGhpcy5vcHRpb25zLm1vZGlmaWVycyB8fCBbXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF90aGlzLm1vZGlmaWVycykpIHtcbiAgICAgICAgICAgIF90aGlzLm1vZGlmaWVycyA9IFtfdGhpcy5tb2RpZmllcnNdO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmljZUdhdGhlcmluZ1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaW5pdFBlZXJDb25uZWN0aW9uKF90aGlzLm9wdGlvbnMucGVlckNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgX3RoaXMuY29uc3RyYWludHMgPSBfdGhpcy5jaGVja0FuZERlZmF1bHRDb25zdHJhaW50cyhfdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuZGVmYXVsdEZhY3RvcnkgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbG9nZ2VyID0gKHNlc3Npb24gaW5zdGFuY2VvZiBzZXNzaW9uXzEuU2Vzc2lvbikgP1xuICAgICAgICAgICAgc2Vzc2lvbi51c2VyQWdlbnQuZ2V0TG9nZ2VyKFwic2lwLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcIiwgc2Vzc2lvbi5pZCkgOlxuICAgICAgICAgICAgc2Vzc2lvbi51YS5nZXRMb2dnZXIoXCJzaXAuaW52aXRlY29udGV4dC5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyXCIsIHNlc3Npb24uaWQpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyXzEuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyKHNlc3Npb24sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIobG9nZ2VyLCBvYnNlcnZlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvLyBGdW5jdGlvbnMgdGhlIHNlc3NzaW9uIGNhbiB1c2VcbiAgICAvKipcbiAgICAgKiBEZXN0cnVjdG9yXG4gICAgICovXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImNsb3NpbmcgUGVlckNvbm5lY3Rpb25cIik7XG4gICAgICAgIC8vIGhhdmUgdG8gY2hlY2sgc2lnbmFsaW5nU3RhdGUgc2luY2UgdGhpcy5jbG9zZSgpIGdldHMgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMucGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbmRlci50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyLnRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVzaW5nIGdldExvY2FsU3RyZWFtcyB3aGljaCBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0TG9jYWxTdHJlYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAocmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlci50cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVc2luZyBnZXRSZW1vdGVTdHJlYW1zIHdoaWNoIGlzIGRlcHJlY2F0ZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRSZW1vdGVTdHJlYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXRJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb2NhbCBkZXNjcmlwdGlvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIG1lZGlhIGltcGxlbWVudGF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB0byBiZSB1c2VkIGJ5IGdldERlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbUNvbnN0cmFpbnRzfSBbb3B0aW9ucy5jb25zdHJhaW50c10gTWVkaWFTdHJlYW1Db25zdHJhaW50c1xuICAgICAqICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU3RyZWFtQ29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGVlckNvbm5lY3Rpb25PcHRpb25zXSBJZiB0aGlzIGlzIHNldCBpdCB3aWxsIHJlY3JlYXRlIHRoZSBwZWVyXG4gICAgICogICBjb25uZWN0aW9uIHdpdGggdGhlIG5ldyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gW21vZGlmaWVyc10gQXJyYXkgd2l0aCBvbmUgdGltZSB1c2UgZGVzY3JpcHRpb24gbW9kaWZpZXJzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2NhbCBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvblxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMsIG1vZGlmaWVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gW107IH1cbiAgICAgICAgaWYgKG9wdGlvbnMucGVlckNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRQZWVyQ29ubmVjdGlvbihvcHRpb25zLnBlZXJDb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVyZ2UgcGFzc2VkIGNvbnN0cmFpbnRzIHdpdGggc2F2ZWQgY29uc3RyYWludHMgYW5kIHNhdmVcbiAgICAgICAgdmFyIG5ld0NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25zdHJhaW50cywgb3B0aW9ucy5jb25zdHJhaW50cyk7XG4gICAgICAgIG5ld0NvbnN0cmFpbnRzID0gdGhpcy5jaGVja0FuZERlZmF1bHRDb25zdHJhaW50cyhuZXdDb25zdHJhaW50cyk7XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShuZXdDb25zdHJhaW50cykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuY29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gbmV3Q29uc3RyYWludHM7XG4gICAgICAgICAgICB0aGlzLnNob3VsZEFjcXVpcmVNZWRpYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVycykpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycyA9IFttb2RpZmllcnNdO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5jb25jYXQodGhpcy5tb2RpZmllcnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2hvdWxkQWNxdWlyZU1lZGlhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjcXVpcmUoX3RoaXMuY29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG91bGRBY3F1aXJlTWVkaWEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jcmVhdGVPZmZlck9yQW5zd2VyKG9wdGlvbnMuUlRDT2ZmZXJPcHRpb25zLCBtb2RpZmllcnMpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24uc2RwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKFwiZ2V0RGVzY3JpcHRpb25cIiwgdW5kZWZpbmVkLCBcIlNEUCB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiZ2V0RGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBkZXNjcmlwdGlvbi5zZHAsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IF90aGlzLkNPTlRFTlRfVFlQRVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgU2Vzc2lvbiBEZXNjcmlwdGlvbiBIYW5kbGVyIGNhbiBoYW5kbGUgdGhlIENvbnRlbnQtVHlwZSBkZXNjcmliZWQgYnkgYSBTSVAgTWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50VHlwZSBUaGUgY29udGVudCB0eXBlIHRoYXQgaXMgaW4gdGhlIFNJUCBNZXNzYWdlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuaGFzRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRUeXBlID09PSB0aGlzLkNPTlRFTlRfVFlQRTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RpZmllciB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIHNlc3Npb24gd291bGQgbGlrZSB0byBwbGFjZSB0aGUgY2FsbCBvbiBob2xkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZHBdIFRoZSBkZXNjcmlwdGlvbiB0aGF0IHdpbGwgYmUgbW9kaWZpZWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggbW9kaWZpZWQgU0RQXG4gICAgICovXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuaG9sZE1vZGlmaWVyID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgvYT0oc2VuZHJlY3Z8c2VuZG9ubHl8cmVjdm9ubHl8aW5hY3RpdmUpLykudGVzdChkZXNjcmlwdGlvbi5zZHApKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBkZXNjcmlwdGlvbi5zZHAucmVwbGFjZSgvKG09W15cXHJdKlxcclxcbikvZywgXCIkMWE9c2VuZG9ubHlcXHJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBkZXNjcmlwdGlvbi5zZHAucmVwbGFjZSgvYT1zZW5kcmVjdlxcclxcbi9nLCBcImE9c2VuZG9ubHlcXHJcXG5cIik7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBkZXNjcmlwdGlvbi5zZHAucmVwbGFjZSgvYT1yZWN2b25seVxcclxcbi9nLCBcImE9aW5hY3RpdmVcXHJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlbW90ZSBkZXNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBtZWRpYSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXNzaW9uRGVzY3JpcHRpb24gVGhlIGRlc2NyaXB0aW9uIHByb3ZpZGVkIGJ5IGEgU0lQIG1lc3NhZ2UgdG8gYmUgc2V0IG9uIHRoZSBtZWRpYSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgdG8gYmUgdXNlZCBieSBnZXREZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1Db25zdHJhaW50c30gW29wdGlvbnMuY29uc3RyYWludHNdIE1lZGlhU3RyZWFtQ29uc3RyYWludHNcbiAgICAgKiAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVN0cmVhbUNvbnN0cmFpbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBlZXJDb25uZWN0aW9uT3B0aW9uc10gSWYgdGhpcyBpcyBzZXQgaXQgd2lsbCByZWNyZWF0ZSB0aGUgcGVlclxuICAgICAqICAgY29ubmVjdGlvbiB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttb2RpZmllcnNdIEFycmF5IHdpdGggb25lIHRpbWUgdXNlIGRlc2NyaXB0aW9uIG1vZGlmaWVyc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgZGVzY3JpcHRpb24gaXMgc2V0XG4gICAgICovXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuc2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoc2Vzc2lvbkRlc2NyaXB0aW9uLCBvcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IFtdOyB9XG4gICAgICAgIGlmIChvcHRpb25zLnBlZXJDb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5pbml0UGVlckNvbm5lY3Rpb24ob3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllcnMpKSB7XG4gICAgICAgICAgICBtb2RpZmllcnMgPSBbbW9kaWZpZXJzXTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMuY29uY2F0KHRoaXMubW9kaWZpZXJzKTtcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5oYXNPZmZlcihcImxvY2FsXCIpID8gXCJhbnN3ZXJcIiA6IFwib2ZmZXJcIixcbiAgICAgICAgICAgIHNkcDogc2Vzc2lvbkRlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1lZGlhIHNob3VsZCBiZSBhY3F1aXJlZCBpbiBnZXREZXNjcmlwdGlvbiB1bmxlc3Mgd2UgbmVlZCB0byBkbyBpdCBzb29uZXIgZm9yIHNvbWUgcmVhc29uIChGRjYxKylcbiAgICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRBY3F1aXJlTWVkaWEgJiYgX3RoaXMub3B0aW9ucy5hbHdheXNBY3F1aXJlTWVkaWFGaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hY3F1aXJlKF90aGlzLmNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvdWxkQWNxdWlyZU1lZGlhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gVXRpbHNfMS5VdGlscy5yZWR1Y2VQcm9taXNlcyhtb2RpZmllcnMsIGRlc2NyaXB0aW9uKTsgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcInNldERlc2NyaXB0aW9uXCIsIGUsIFwiVGhlIG1vZGlmaWVycyBkaWQgbm90IHJlc29sdmUgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInBlZXJDb25uZWN0aW9uLXNldFJlbW90ZURlc2NyaXB0aW9uRmFpbGVkXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChtb2RpZmllZERlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwic2V0RGVzY3JpcHRpb25cIiwgbW9kaWZpZWREZXNjcmlwdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24obW9kaWZpZWREZXNjcmlwdGlvbik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgb3JpZ2luYWwgU0RQIGZvciB2aWRlbywgYW5kIGVuc3VyZSB0aGF0IHdlIGhhdmUgd2FudCB0byBkbyBhdWRpbyBmYWxsYmFja1xuICAgICAgICAgICAgaWYgKCgvXm09dmlkZW8uKyQvZ20pLnRlc3Qoc2Vzc2lvbkRlc2NyaXB0aW9uKSAmJiAhb3B0aW9ucy5kaXNhYmxlQXVkaW9GYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cnkgdG8gYXVkaW8gZmFsbGJhY2sgYWdhaW5cbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpc2FibGVBdWRpb0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdmlkZW8gZmlyc3QsIHRoZW4gZG8gdGhlIG90aGVyIG1vZGlmaWVyc1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXREZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24sIG9wdGlvbnMsIFtNb2RpZmllcnMuc3RyaXBWaWRlb10uY29uY2F0KG1vZGlmaWVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcInNldERlc2NyaXB0aW9uXCIsIGUpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1zZXRSZW1vdGVEZXNjcmlwdGlvbkZhaWxlZFwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInNldFJlbW90ZURlc2NyaXB0aW9uXCIsIF90aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJzZXRSZW1vdGVEZXNjcmlwdGlvblwiLCBfdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRSZW1vdGVTdHJlYW1zKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdChcImNvbmZpcm1lZFwiLCBfdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBEVE1GIHZpYSBSVFAgKFJGQyA0NzMzKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b25lcyBBIHN0cmluZyBjb250YWluaW5nIERUTUYgZGlnaXRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB0byBiZSB1c2VkIGJ5IHNlbmREdG1mXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgRFRNRiBzZW5kIGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLnNlbmREdG1mID0gZnVuY3Rpb24gKHRvbmVzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICghdGhpcy5kdG1mU2VuZGVyICYmIHRoaXMuaGFzQnJvd3NlckdldFNlbmRlclN1cHBvcnQoKSkge1xuICAgICAgICAgICAgdmFyIHNlbmRlcnMgPSB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMoKTtcbiAgICAgICAgICAgIGlmIChzZW5kZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0bWZTZW5kZXIgPSBzZW5kZXJzWzBdLmR0bWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmR0bWZTZW5kZXIgJiYgdGhpcy5oYXNCcm93c2VyVHJhY2tTdXBwb3J0KCkpIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW1zID0gdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRMb2NhbFN0cmVhbXMoKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYXVkaW9UcmFja3MgPSBzdHJlYW1zWzBdLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdG1mU2VuZGVyID0gdGhpcy5wZWVyQ29ubmVjdGlvbi5jcmVhdGVEVE1GU2VuZGVyKGF1ZGlvVHJhY2tzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmR0bWZTZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kdG1mU2VuZGVyLmluc2VydERUTUYodG9uZXMsIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuaW50ZXJUb25lR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJJbnZhbGlkU3RhdGVFcnJvclwiIHx8IGUudHlwZSA9PT0gXCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiRFRNRiBzZW50IHZpYSBSVFA6IFwiICsgdG9uZXMudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBkaXJlY3Rpb24gb2YgdGhlIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykgeyByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIG5hbWUsIGNhbGxiYWNrKTsgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5nZXRNZWRpYVN0cmVhbSA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH07XG4gICAgLy8gSW50ZXJuYWwgZnVuY3Rpb25zXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlT2ZmZXJPckFuc3dlciA9IGZ1bmN0aW9uIChSVENPZmZlck9wdGlvbnMsIG1vZGlmaWVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoUlRDT2ZmZXJPcHRpb25zID09PSB2b2lkIDApIHsgUlRDT2ZmZXJPcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IFtdOyB9XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5oYXNPZmZlcihcInJlbW90ZVwiKSA/IFwiY3JlYXRlQW5zd2VyXCIgOiBcImNyZWF0ZU9mZmVyXCI7XG4gICAgICAgIHZhciBwYyA9IHRoaXMucGVlckNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhtZXRob2ROYW1lKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuaGFzT2ZmZXIoXCJyZW1vdGVcIikgPyBwYy5jcmVhdGVBbnN3ZXIgOiBwYy5jcmVhdGVPZmZlcjtcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShwYywgUlRDT2ZmZXJPcHRpb25zKS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcImNyZWF0ZU9mZmVyT3JBbnN3ZXJcIiwgZSwgXCJwZWVyQ29ubmVjdGlvbi1cIiArIG1ldGhvZE5hbWUgKyBcIkZhaWxlZFwiKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1cIiArIG1ldGhvZE5hbWUgKyBcIkZhaWxlZFwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoc2RwKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5yZWR1Y2VQcm9taXNlcyhtb2RpZmllcnMsIF90aGlzLmNyZWF0ZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQoc2RwKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNkcCkge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlNldHRpbmcgbG9jYWwgc2RwLlwiKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJzZHAgaXMgXCIgKyBzZHAuc2RwIHx8IFwidW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHBjLnNldExvY2FsRGVzY3JpcHRpb24oc2RwKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJjcmVhdGVPZmZlck9yQW5zd2VyXCIsIGUsIFwicGVlckNvbm5lY3Rpb24tU2V0TG9jYWxEZXNjcmlwdGlvbkZhaWxlZFwiKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1TZXRMb2NhbERlc2NyaXB0aW9uRmFpbGVkXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLndhaXRGb3JJY2VHYXRoZXJpbmdDb21wbGV0ZSgpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wZWVyQ29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcIk1pc3NpbmcgbG9jYWwgZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYWxEZXNjcmlwdGlvbiA9IF90aGlzLmNyZWF0ZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQoX3RoaXMucGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5yZWR1Y2VQcm9taXNlcyhtb2RpZmllcnMsIGxvY2FsRGVzY3JpcHRpb24pO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChsb2NhbERlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXREaXJlY3Rpb24obG9jYWxEZXNjcmlwdGlvbi5zZHAgfHwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxEZXNjcmlwdGlvbjtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJjcmVhdGVPZmZlck9yQW5zd2VyXCIsIGUpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gQ3JlYXRlcyBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IGZyb20gYW4gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCA9IGZ1bmN0aW9uIChSVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi50eXBlLFxuICAgICAgICAgICAgc2RwOiBSVENTZXNzaW9uRGVzY3JpcHRpb24uc2RwXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5hZGREZWZhdWx0SWNlQ2hlY2tpbmdUaW1lb3V0ID0gZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb25PcHRpb25zLmljZUNoZWNraW5nVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbk9wdGlvbnMuaWNlQ2hlY2tpbmdUaW1lb3V0ID0gNTAwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb25PcHRpb25zO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuYWRkRGVmYXVsdEljZVNlcnZlcnMgPSBmdW5jdGlvbiAocnRjQ29uZmlndXJhdGlvbikge1xuICAgICAgICBpZiAoIXJ0Y0NvbmZpZ3VyYXRpb24uaWNlU2VydmVycykge1xuICAgICAgICAgICAgcnRjQ29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gW3sgdXJsczogXCJzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyXCIgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ0Y0NvbmZpZ3VyYXRpb247XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5jaGVja0FuZERlZmF1bHRDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICAgICAgICB2YXIgZGVmYXVsdENvbnN0cmFpbnRzID0geyBhdWRpbzogdHJ1ZSwgdmlkZW86ICF0aGlzLm9wdGlvbnMuYWx3YXlzQWNxdWlyZU1lZGlhRmlyc3QgfTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cyB8fCBkZWZhdWx0Q29uc3RyYWludHM7XG4gICAgICAgIC8vIEVtcHR5IG9iamVjdCBjaGVja1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29uc3RyYWludHMpLmxlbmd0aCA9PT0gMCAmJiBjb25zdHJhaW50cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmhhc0Jyb3dzZXJUcmFja1N1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucGVlckNvbm5lY3Rpb24uYWRkVHJhY2spO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuaGFzQnJvd3NlckdldFNlbmRlclN1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycyk7XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5pbml0UGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBvcHRpb25zID0gdGhpcy5hZGREZWZhdWx0SWNlQ2hlY2tpbmdUaW1lb3V0KG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24gPSBvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24gfHwge307XG4gICAgICAgIG9wdGlvbnMucnRjQ29uZmlndXJhdGlvbiA9IHRoaXMuYWRkRGVmYXVsdEljZVNlcnZlcnMob3B0aW9ucy5ydGNDb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiaW5pdFBlZXJDb25uZWN0aW9uXCIpO1xuICAgICAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiQWxyZWFkeSBoYXZlIGEgcGVlciBjb25uZWN0aW9uIGZvciB0aGlzIHNlc3Npb24uIFRlYXJpbmcgZG93bi5cIik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKG9wdGlvbnMucnRjQ29uZmlndXJhdGlvbik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIk5ldyBwZWVyIGNvbm5lY3Rpb24gY3JlYXRlZFwiKTtcbiAgICAgICAgaWYgKFwib250cmFja1wiIGluIHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcInRyYWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcInRyYWNrIGFkZGVkXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9ic2VydmVyLnRyYWNrQWRkZWQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYWRkVHJhY2tcIiwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVc2luZyBvbmFkZHN0cmVhbSB3aGljaCBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcInN0cmVhbSBhZGRlZFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYWRkU3RyZWFtXCIsIGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJpY2VDYW5kaWRhdGVcIiwgZSk7XG4gICAgICAgICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiSUNFIGNhbmRpZGF0ZSByZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoZS5jYW5kaWRhdGUuY2FuZGlkYXRlID09PSBudWxsID8gbnVsbCA6IGUuY2FuZGlkYXRlLmNhbmRpZGF0ZS50cmltKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuY2FuZGlkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHRoZSBlbmQgb2YgY2FuZGlkYXRlIGdhdGhlcmluZ1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJJQ0UgY2FuZGlkYXRlIGdhdGhlcmluZyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VySWNlR2F0aGVyaW5nQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlJUQ0ljZUdhdGhlcmluZ1N0YXRlIGNoYW5nZWQ6IFwiICsgX3RoaXMucGVlckNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnYXRoZXJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImljZUdhdGhlcmluZ1wiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaWNlR2F0aGVyaW5nVGltZXIgJiYgb3B0aW9ucy5pY2VDaGVja2luZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmljZUdhdGhlcmluZ1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmljZUdhdGhlcmluZ1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlJUQ0ljZUNoZWNraW5nIFRpbWVvdXQgVHJpZ2dlcmVkIGFmdGVyIFwiICsgb3B0aW9ucy5pY2VDaGVja2luZ1RpbWVvdXQgKyBcIiBtaWxsaXNlY29uZHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWNlR2F0aGVyaW5nVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckljZUdhdGhlcmluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmljZUNoZWNraW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZUV2ZW50O1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibmV3XCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRXZlbnQgPSBcImljZUNvbm5lY3Rpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoZWNraW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRXZlbnQgPSBcImljZUNvbm5lY3Rpb25DaGVja2luZ1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRXZlbnQgPSBcImljZUNvbm5lY3Rpb25Db25uZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ29tcGxldGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVFdmVudCA9IFwiaWNlQ29ubmVjdGlvbkZhaWxlZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRXZlbnQgPSBcImljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiVW5rbm93biBpY2VDb25uZWN0aW9uIHN0YXRlOiBcIiArIF90aGlzLnBlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJJQ0UgQ29ubmVjdGlvbiBTdGF0ZSBjaGFuZ2VkIHRvIFwiICsgc3RhdGVFdmVudCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KHN0YXRlRXZlbnQsIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRGVmYXVsdCBhdWRpbyAmIHZpZGVvIHRvIHRydWVcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLmNoZWNrQW5kRGVmYXVsdENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBNYWtlIHRoZSBjYWxsIGFzeW5jaHJvbm91cywgc28gdGhhdCBJQ0NzIGhhdmUgYSBjaGFuY2VcbiAgICAgICAgICAgICAqIHRvIGRlZmluZSBjYWxsYmFja3MgdG8gYHVzZXJNZWRpYVJlcXVlc3RgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJhY3F1aXJpbmcgbG9jYWwgbWVkaWFcIik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwidXNlck1lZGlhUmVxdWVzdFwiLCBjb25zdHJhaW50cyk7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8gfHwgY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRNZWRpYVN0cmVhbShjb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoc3RyZWFtcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vYnNlcnZlci50cmFja0FkZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJ1c2VyTWVkaWFcIiwgc3RyZWFtcyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RyZWFtcyk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInVzZXJNZWRpYUZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9jYWwgc3RyZWFtcyB3ZXJlIGV4cGxpY2l0bHkgZXhjbHVkZWQuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKFwiYWNxdWlyZVwiLCBlLCBcInVuYWJsZSB0byBhY3F1aXJlIHN0cmVhbXNcIik7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN0cmVhbXMpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJhY3F1aXJlZCBsb2NhbCBtZWRpYSBzdHJlYW1zXCIpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB0cmFja3NcbiAgICAgICAgICAgIGlmIChfdGhpcy5wZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJlYW1zO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcImFjcXVpcmVcIiwgZSwgXCJlcnJvciByZW1vdmluZyBzdHJlYW1zXCIpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChzdHJlYW1zKSB7XG4gICAgICAgICAgICB2YXIgc3RyZWFtc0FyciA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICAgICAgICAgIHN0cmVhbXNBcnIuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVlckNvbm5lY3Rpb24uYWRkVHJhY2sodHJhY2ssIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIDU5IGRvZXMgbm90IHN1cHBvcnQgYWRkVHJhY2tcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKFwiYWNxdWlyZVwiLCBlLCBcImVycm9yIGFkZGluZyBzdHJlYW1cIik7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuaGFzT2ZmZXIgPSBmdW5jdGlvbiAod2hlcmUpIHtcbiAgICAgICAgdmFyIG9mZmVyU3RhdGUgPSBcImhhdmUtXCIgKyB3aGVyZSArIFwiLW9mZmVyXCI7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSBvZmZlclN0YXRlO1xuICAgIH07XG4gICAgLy8gSUNFIGdhdGhlcmluZyBzdGF0ZSBoYW5kbGluZ1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzSWNlR2F0aGVyaW5nQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgdGhpcy5pY2VHYXRoZXJpbmdUaW1lb3V0O1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUucmVzZXRJY2VHYXRoZXJpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGVcIik7XG4gICAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pY2VHYXRoZXJpbmdUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmljZUdhdGhlcmluZ1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkKSB7XG4gICAgICAgICAgICB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHNkcCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZHAubWF0Y2goL2E9KHNlbmRyZWN2fHNlbmRvbmx5fHJlY3Zvbmx5fGluYWN0aXZlKS8pO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5DLkRJUkVDVElPTi5OVUxMO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXJlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IG1hdGNoWzFdO1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLlNFTkRSRUNWOlxuICAgICAgICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLlNFTkRPTkxZOlxuICAgICAgICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLlJFQ1ZPTkxZOlxuICAgICAgICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLklOQUNUSVZFOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuQy5ESVJFQ1RJT04uTlVMTDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLmRpcmVjdGlvbkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLnRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJY2VHYXRoZXJpbmdDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJpY2VHYXRoZXJpbmdDb21wbGV0ZVwiLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ1RpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWNlR2F0aGVyaW5nVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLndhaXRGb3JJY2VHYXRoZXJpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwid2FpdEZvckljZUdhdGhlcmluZ0NvbXBsZXRlXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0ljZUdhdGhlcmluZ0NvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklDRSBpcyBhbHJlYWR5IGNvbXBsZXRlLiBSZXR1cm4gcmVzb2x2ZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkKSB7XG4gICAgICAgICAgICB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkID0gVXRpbHNfMS5VdGlscy5kZWZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklDRSBpcyBub3QgY29tcGxldGUuIFJldHVybmluZyBwcm9taXNlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCA/IHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQucHJvbWlzZSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuLi9hcGkvc2Vzc2lvblwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4uL0VudW1zXCIpO1xuLyogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyXG4gKiBAY2xhc3MgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciBPYnNlcnZlciBDbGFzcy5cbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xudmFyIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXIoc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyLnByb3RvdHlwZS50cmFja0FkZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uIGluc3RhbmNlb2Ygc2Vzc2lvbl8xLlNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24uZW1pdChcInRyYWNrQWRkZWRcIik7XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXIucHJvdG90eXBlLmRpcmVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gaW5zdGFuY2VvZiBzZXNzaW9uXzEuU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5lbWl0KFwiZGlyZWN0aW9uQ2hhbmdlZFwiKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXI7XG59KCkpO1xuZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXIgPSBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBVQV8xID0gcmVxdWlyZShcIi4uL1VBXCIpO1xudmFyIE1vZGlmaWVycyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL01vZGlmaWVyc1wiKSk7XG4vKiBTaW1wbGVcbiAqIEBjbGFzcyBTaW1wbGVcbiAqL1xudmFyIFNpbXBsZVN0YXR1cztcbihmdW5jdGlvbiAoU2ltcGxlU3RhdHVzKSB7XG4gICAgU2ltcGxlU3RhdHVzW1NpbXBsZVN0YXR1c1tcIlNUQVRVU19OVUxMXCJdID0gMF0gPSBcIlNUQVRVU19OVUxMXCI7XG4gICAgU2ltcGxlU3RhdHVzW1NpbXBsZVN0YXR1c1tcIlNUQVRVU19ORVdcIl0gPSAxXSA9IFwiU1RBVFVTX05FV1wiO1xuICAgIFNpbXBsZVN0YXR1c1tTaW1wbGVTdGF0dXNbXCJTVEFUVVNfQ09OTkVDVElOR1wiXSA9IDJdID0gXCJTVEFUVVNfQ09OTkVDVElOR1wiO1xuICAgIFNpbXBsZVN0YXR1c1tTaW1wbGVTdGF0dXNbXCJTVEFUVVNfQ09OTkVDVEVEXCJdID0gM10gPSBcIlNUQVRVU19DT05ORUNURURcIjtcbiAgICBTaW1wbGVTdGF0dXNbU2ltcGxlU3RhdHVzW1wiU1RBVFVTX0NPTVBMRVRFRFwiXSA9IDRdID0gXCJTVEFUVVNfQ09NUExFVEVEXCI7XG59KShTaW1wbGVTdGF0dXMgPSBleHBvcnRzLlNpbXBsZVN0YXR1cyB8fCAoZXhwb3J0cy5TaW1wbGVTdGF0dXMgPSB7fSkpO1xudmFyIFNpbXBsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTaW1wbGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2ltcGxlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLypcbiAgICAgICAgKiAge1xuICAgICAgICAqICAgIG1lZGlhOiB7XG4gICAgICAgICogICAgICByZW1vdGU6IHtcbiAgICAgICAgKiAgICAgICAgYXVkaW86IDxET00gZWxlbWVudD4sXG4gICAgICAgICogICAgICAgIHZpZGVvOiA8RE9NIGVsZW1lbnQ+XG4gICAgICAgICogICAgICB9LFxuICAgICAgICAqICAgICAgbG9jYWw6IHtcbiAgICAgICAgKiAgICAgICAgdmlkZW86IDxET00gZWxlbWVudD5cbiAgICAgICAgKiAgICAgIH1cbiAgICAgICAgKiAgICB9LFxuICAgICAgICAqICAgIHVhOiB7XG4gICAgICAgICogICAgICAgPFVBIENvbmZpZ3VyYXRpb24gT3B0aW9ucz5cbiAgICAgICAgKiAgICB9XG4gICAgICAgICogIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMubWVkaWEucmVtb3RlLnZpZGVvKSB7XG4gICAgICAgICAgICBfdGhpcy52aWRlbyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy52aWRlbyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpbykge1xuICAgICAgICAgICAgX3RoaXMuYXVkaW8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuYXVkaW8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV90aGlzLmF1ZGlvICYmICFfdGhpcy52aWRlbykge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBkbyBhdCBsZWFzdCBhdWRpbyBvciB2aWRlb1xuICAgICAgICAgICAgLy8gRXJyb3JcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSByZW1vdGUgYXVkaW8gb3IgdmlkZW8gZWxlbWVudCBpcyByZXF1aXJlZCBmb3IgU2ltcGxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzk0NDQ2MC9kZXRlY3Qtc2FmYXJpLWJyb3dzZXJcbiAgICAgICAgdmFyIGJyb3dzZXJVYSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGlzU2FmYXJpID0gZmFsc2U7XG4gICAgICAgIHZhciBpc0ZpcmVmb3ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGJyb3dzZXJVYS5pbmRleE9mKFwic2FmYXJpXCIpID4gLTEgJiYgYnJvd3NlclVhLmluZGV4T2YoXCJjaHJvbWVcIikgPCAwKSB7XG4gICAgICAgICAgICBpc1NhZmFyaSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJvd3NlclVhLmluZGV4T2YoXCJmaXJlZm94XCIpID4gLTEgJiYgYnJvd3NlclVhLmluZGV4T2YoXCJjaHJvbWVcIikgPCAwKSB7XG4gICAgICAgICAgICBpc0ZpcmVmb3ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMubW9kaWZpZXJzID0gW01vZGlmaWVycy5zdHJpcEc3MjJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZpcmVmb3gpIHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucy5hbHdheXNBY3F1aXJlTWVkaWFGaXJzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnVhLnVyaSkge1xuICAgICAgICAgICAgX3RoaXMuYW5vbnltb3VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmFub255bW91cyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnVhID0gbmV3IFVBXzEuVUEoe1xuICAgICAgICAgICAgLy8gVXNlciBDb25maWd1cmFibGUgT3B0aW9uc1xuICAgICAgICAgICAgdXJpOiBfdGhpcy5vcHRpb25zLnVhLnVyaSxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Vc2VyOiBfdGhpcy5vcHRpb25zLnVhLmF1dGhvcml6YXRpb25Vc2VyLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IF90aGlzLm9wdGlvbnMudWEucGFzc3dvcmQsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogX3RoaXMub3B0aW9ucy51YS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIC8vIFVuZG9jdW1lbnRlZCBcIkFkdmFuY2VkXCIgT3B0aW9uc1xuICAgICAgICAgICAgdXNlckFnZW50U3RyaW5nOiBfdGhpcy5vcHRpb25zLnVhLnVzZXJBZ2VudFN0cmluZyxcbiAgICAgICAgICAgIC8vIEZpeGVkIE9wdGlvbnNcbiAgICAgICAgICAgIHJlZ2lzdGVyOiB0cnVlLFxuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zOiBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMsXG4gICAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHJhY2VTaXA6IF90aGlzLm9wdGlvbnMudWEudHJhY2VTaXAsXG4gICAgICAgICAgICAgICAgd3NTZXJ2ZXJzOiBfdGhpcy5vcHRpb25zLnVhLndzU2VydmVyc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBTaW1wbGVTdGF0dXMuU1RBVFVTX05VTEw7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IF90aGlzLnVhLmdldExvZ2dlcihcInNpcC5zaW1wbGVcIik7XG4gICAgICAgIF90aGlzLnVhLm9uKFwicmVnaXN0ZXJlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVnaXN0ZXJlZFwiLCBfdGhpcy51YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy51YS5vbihcInVucmVnaXN0ZXJlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwidW5yZWdpc3RlcmVkXCIsIF90aGlzLnVhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnVhLm9uKFwicmVnaXN0cmF0aW9uRmFpbGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJ1bnJlZ2lzdGVyZWRcIiwgX3RoaXMudWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMudWEub24oXCJpbnZpdGVcIiwgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aXZlIHNlc3Npb24gcmVqZWN0IHRoZSBpbmNvbWluZyBzZXNzaW9uXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfTlVMTCAmJiBfdGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIlJlamVjdGluZyBpbmNvbWluZyBjYWxsLiBTaW1wbGUgb25seSBzdXBwb3J0cyAxIGNhbGwgYXQgYSB0aW1lXCIpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgICAgICBfdGhpcy5zZXR1cFNlc3Npb24oKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyaW5naW5nXCIsIF90aGlzLnNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMudWEub24oXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2ltcGxlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy51YSB8fCAhdGhpcy5jaGVja1JlZ2lzdHJhdGlvbigpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQSByZWdpc3RlcmVkIFVBIGlzIHJlcXVpcmVkIGZvciBjYWxsaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX05VTEwgJiYgdGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJDYW5ub3QgbWFrZSBtb3JlIHRoYW4gYSBzaW5nbGUgY2FsbCB3aXRoIFNpbXBsZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgaGFjaywgYmVjYXVzZSB5b3UgY2Fubm90IGNhbGwgLnBsYXkoKSBmcm9tIGEgbm9uIHVzZXIgYWN0aW9uXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlbykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbCAmJiB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8udm9sdW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24gPSB0aGlzLnVhLmludml0ZShkZXN0aW5hdGlvbiwge1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgICAgICBhdWRpbzogdGhpcy5hdWRpbyxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IHRoaXMudmlkZW9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldHVwU2Vzc2lvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5hbnN3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX05FVyAmJiB0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBjYWxsIHRvIGFuc3dlclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgaGFjaywgYmVjYXVzZSB5b3UgY2Fubm90IGNhbGwgLnBsYXkoKSBmcm9tIGEgbm9uIHVzZXIgYWN0aW9uXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlbykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5hY2NlcHQoe1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgICAgICBhdWRpbzogdGhpcy5hdWRpbyxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IHRoaXMudmlkZW9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlbWl0IGNhbGwgaXMgYWN0aXZlXG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfTkVXICYmIHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVElORykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkNhbGwgaXMgYWxyZWFkeSBhbnN3ZXJlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnJlamVjdCgpO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5oYW5ndXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNUSU5HICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX05FVykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vIGFjdGl2ZSBjYWxsIHRvIGhhbmcgdXAgb25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5ieWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5ob2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNURUQgfHwgIXRoaXMuc2Vzc2lvbiB8fCB0aGlzLnNlc3Npb24ubG9jYWxIb2xkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQ2Fubm90IHB1dCBjYWxsIG9uIGhvbGRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRlKCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlBsYWNpbmcgc2Vzc2lvbiBvbiBob2xkXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmhvbGQoKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUudW5ob2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNURUQgfHwgIXRoaXMuc2Vzc2lvbiB8fCAhdGhpcy5zZXNzaW9uLmxvY2FsSG9sZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkNhbm5vdCB1bmhvbGQgYSBjYWxsIHRoYXQgaXMgbm90IG9uIGhvbGRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bm11dGUoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiUGxhY2luZyBjYWxsIG9mZiBob2xkXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnVuaG9sZCgpO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5tdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJBbiBhY2l0dmUgY2FsbCBpcyByZXF1aXJlZCB0byBtdXRlIGF1ZGlvXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIk11dGluZyBBdWRpb1wiKTtcbiAgICAgICAgdGhpcy50b2dnbGVNdXRlKHRydWUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJtdXRlXCIsIHRoaXMpO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS51bm11dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFuIGFjdGl2ZSBjYWxsIGlzIHJlcXVpcmVkIHRvIHVubXV0ZSBhdWRpb1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJVbm11dGluZyBBdWRpb1wiKTtcbiAgICAgICAgdGhpcy50b2dnbGVNdXRlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidW5tdXRlXCIsIHRoaXMpO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5zZW5kRFRNRiA9IGZ1bmN0aW9uICh0b25lKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RFRCB8fCAhdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQW4gYWN0aXZlIGNhbGwgaXMgcmVxdWlyZWQgdG8gc2VuZCBhIERUTUYgdG9uZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZW5kaW5nIERUTUYgdG9uZTogXCIgKyB0b25lKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmR0bWYodG9uZSk7XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVhIHx8ICF0aGlzLmNoZWNrUmVnaXN0cmF0aW9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJBIHJlZ2lzdGVyZWQgVUEgaXMgcmVxdWlyZWQgdG8gc2VuZCBhIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbiB8fCAhbWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkEgZGVzdGluYXRpb24gYW5kIG1lc3NhZ2UgYXJlIHJlcXVpcmVkIHRvIHNlbmQgYSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudWEubWVzc2FnZShkZXN0aW5hdGlvbiwgbWVzc2FnZSk7XG4gICAgfTtcbiAgICAvLyBQcml2YXRlIEhlbHBlcnNcbiAgICBTaW1wbGUucHJvdG90eXBlLmNoZWNrUmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYW5vbnltb3VzIHx8ICh0aGlzLnVhICYmIHRoaXMudWEuaXNSZWdpc3RlcmVkKCkpKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuc2V0dXBSZW1vdGVNZWRpYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBzZXNzaW9uIHRvIHNldCByZW1vdGUgbWVkaWEgb25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2aWRlbyB0cmFjaywgaXQgd2lsbCBhdHRhY2ggdGhlIHZpZGVvIGFuZCBhdWRpbyB0byB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgIHZhciBwYyA9IHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICB2YXIgcmVtb3RlU3RyZWFtO1xuICAgICAgICBpZiAocGMuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICByZW1vdGVTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICAgIHBjLmdldFJlY2VpdmVycygpLmZvckVhY2goZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gcmVjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdGVTdHJlYW0gPSBwYy5nZXRSZW1vdGVTdHJlYW1zKClbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8uc3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlby5wbGF5KCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJwbGF5IHdhcyByZWplY3RlZFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXVkaW8pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUuYXVkaW8uc3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5wbGF5KCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJwbGF5IHdhcyByZWplY3RlZFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLnNldHVwTG9jYWxNZWRpYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBzZXNzaW9uIHRvIHNldCBsb2NhbCBtZWRpYSBvblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWRlbyAmJiB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwgJiYgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvKSB7XG4gICAgICAgICAgICB2YXIgcGMgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIHZhciBsb2NhbFN0cmVhbV8xO1xuICAgICAgICAgICAgaWYgKHBjLmdldFNlbmRlcnMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbV8xID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgcGMuZ2V0U2VuZGVycygpLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBzZW5kZXIudHJhY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5raW5kID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RyZWFtXzEuYWRkVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbV8xID0gcGMuZ2V0TG9jYWxTdHJlYW1zKClbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8uc3JjT2JqZWN0ID0gbG9jYWxTdHJlYW1fMTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby52b2x1bWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5jbGVhbnVwTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLnZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLnZpZGVvLnBhdXNlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsICYmIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlbykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuc2V0dXBTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vIHNlc3Npb24gdG8gc2V0IHVwXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTaW1wbGVTdGF0dXMuU1RBVFVTX05FVztcbiAgICAgICAgdGhpcy5lbWl0KFwibmV3XCIsIHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uUHJvZ3Jlc3MoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImFjY2VwdGVkXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uQWNjZXB0ZWQoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcInJlamVjdGVkXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uRW5kZWQoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImZhaWxlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkZhaWxlZCgpOyB9KTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwidGVybWluYXRlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkVuZGVkKCk7IH0pO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5kZXN0cm95TWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUudG9nZ2xlTXV0ZSA9IGZ1bmN0aW9uIChtdXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gc2Vzc2lvbiB0byB0b2dnbGUgbXV0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGMgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKHBjLmdldFNlbmRlcnMpIHtcbiAgICAgICAgICAgIHBjLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZGVyLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRlci50cmFjay5lbmFibGVkID0gIW11dGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYy5nZXRMb2NhbFN0cmVhbXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gIW11dGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUub25BY2NlcHRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBzZXNzaW9uIGZvciBhY2NlcHRpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVEVEO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIiwgdGhpcy5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5zZXR1cExvY2FsTWVkaWEoKTtcbiAgICAgICAgdGhpcy5zZXR1cFJlbW90ZU1lZGlhKCk7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIub24oXCJhZGRUcmFja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIkEgdHJhY2sgaGFzIGJlZW4gYWRkZWQsIHRyaWdnZXJpbmcgbmV3IHJlbW90ZU1lZGlhIHNldHVwXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldHVwUmVtb3RlTWVkaWEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIub24oXCJhZGRTdHJlYW1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJBIHN0cmVhbSBoYXMgYmVlbiBhZGRlZCwgdHJpZ2dlciBuZXcgcmVtb3RlTWVkaWEgc2V0dXBcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0dXBSZW1vdGVNZWRpYSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLm9uKFwiZHRtZlwiLCBmdW5jdGlvbiAocmVxdWVzdCwgZHRtZikge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImR0bWZcIiwgZHRtZi50b25lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImJ5ZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkVuZGVkKCk7IH0pO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5vblByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW5nXCIsIHRoaXMuc2Vzc2lvbik7XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLm9uRmFpbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uRW5kZWQoKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUub25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09NUExFVEVEO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRlZFwiLCB0aGlzLnNlc3Npb24pO1xuICAgICAgICB0aGlzLmNsZWFudXBNZWRpYSgpO1xuICAgIH07XG4gICAgU2ltcGxlLkMgPSBTaW1wbGVTdGF0dXM7XG4gICAgcmV0dXJuIFNpbXBsZTtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlNpbXBsZSA9IFNpbXBsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uL2NvcmVcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbnZhciBFeGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vRXhjZXB0aW9uc1wiKTtcbnZhciBUcmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi9UcmFuc3BvcnRcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbnZhciBUcmFuc3BvcnRTdGF0dXM7XG4oZnVuY3Rpb24gKFRyYW5zcG9ydFN0YXR1cykge1xuICAgIFRyYW5zcG9ydFN0YXR1c1tUcmFuc3BvcnRTdGF0dXNbXCJTVEFUVVNfQ09OTkVDVElOR1wiXSA9IDBdID0gXCJTVEFUVVNfQ09OTkVDVElOR1wiO1xuICAgIFRyYW5zcG9ydFN0YXR1c1tUcmFuc3BvcnRTdGF0dXNbXCJTVEFUVVNfT1BFTlwiXSA9IDFdID0gXCJTVEFUVVNfT1BFTlwiO1xuICAgIFRyYW5zcG9ydFN0YXR1c1tUcmFuc3BvcnRTdGF0dXNbXCJTVEFUVVNfQ0xPU0lOR1wiXSA9IDJdID0gXCJTVEFUVVNfQ0xPU0lOR1wiO1xuICAgIFRyYW5zcG9ydFN0YXR1c1tUcmFuc3BvcnRTdGF0dXNbXCJTVEFUVVNfQ0xPU0VEXCJdID0gM10gPSBcIlNUQVRVU19DTE9TRURcIjtcbn0pKFRyYW5zcG9ydFN0YXR1cyA9IGV4cG9ydHMuVHJhbnNwb3J0U3RhdHVzIHx8IChleHBvcnRzLlRyYW5zcG9ydFN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIENvbXB1dGUgYW4gYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzZW5kaW5nIGFub3RoZXJcbiAqIGtlZXAtYWxpdmUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG52YXIgY29tcHV0ZUtlZXBBbGl2ZVRpbWVvdXQgPSBmdW5jdGlvbiAodXBwZXJCb3VuZCkge1xuICAgIHZhciBsb3dlckJvdW5kID0gdXBwZXJCb3VuZCAqIDAuODtcbiAgICByZXR1cm4gMTAwMCAqIChNYXRoLnJhbmRvbSgpICogKHVwcGVyQm91bmQgLSBsb3dlckJvdW5kKSArIGxvd2VyQm91bmQpO1xufTtcbi8qKlxuICogQGNsYXNzIFRyYW5zcG9ydFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xudmFyIFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0KGxvZ2dlciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsb2dnZXIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlRyYW5zcG9ydDtcbiAgICAgICAgX3RoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSAwO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NPTk5FQ1RJTkc7XG4gICAgICAgIF90aGlzLmNvbmZpZ3VyYXRpb24gPSBfdGhpcy5sb2FkQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5zZXJ2ZXIgPSBfdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVyc1swXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfT1BFTjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gT3V0Z29pbmcgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZFByb21pc2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ1bmFibGUgdG8gc2VuZCBtZXNzYWdlIC0gV2ViU29ja2V0IHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXZWJTb2NrZXQgdW5kZWZpbmVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgY2hlY2sgaXMgbGlrZWx5IG5vdCBuZWNlc3NhcnkgYXMgV2ViU29ja2V0LnNlbmQoKSB3aWxsXG4gICAgICAgIC8vIHRocm93IElOVkFMSURfU1RBVEVfRVJSIGlmIHRoZSBjb25uZWN0aW9uIGlzIG5vdCBjdXJyZW50bHkgb3BlblxuICAgICAgICAvLyB3aGljaCBjb3VsZCBoYXBwZW4gcmVnYXJkbGVzcyBvZiB3aGF0IHdlIHRoaW5nIHRoZSBzdGF0ZSBpcy5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0Fzc2VydChUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX09QRU4sIG9wdGlvbnMuZm9yY2UpKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ1bmFibGUgdG8gc2VuZCBtZXNzYWdlIC0gV2ViU29ja2V0IG5vdCBvcGVuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldlYlNvY2tldCBub3Qgb3Blbi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInNlbmRpbmcgV2ViU29ja2V0IG1lc3NhZ2U6XFxuXFxuXCIgKyBtZXNzYWdlICsgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2ViU29ja2V0LnNlbmQoKSBjYW4gdGhyb3cuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIHNlbmQgbWVzc2FnZS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBtc2c6IG1lc3NhZ2UgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IHNvY2tldC5cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmRpc2Nvbm5lY3RQcm9taXNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UpIHsgLy8gQWxyZWFkeSBkaXNjb25uZWN0aW5nLiBKdXN0IHJldHVybiB0aGlzLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdGlvblByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5jb2RlID0gb3B0aW9ucy5jb2RlIHx8IDEwMDA7XG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNUcmFuc2l0aW9uKFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0lORywgb3B0aW9ucy5mb3JjZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TRUQpIHsgLy8gV2Vic29ja2V0IGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IG92ZXJyaWRlRXZlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKSB7IC8vIFdlYnNvY2tldCBpcyBjb25uZWN0aW5nLCBjYW5ub3QgbW92ZSB0byBkaXNjb25uZXRpbmcgeWV0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChcIlRoZSB3ZWJzb2NrZXQgZGlkIG5vdCBkaXNjb25uZWN0XCIpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgb3ZlcnJpZGVFdmVudDogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgbW92ZSB0byBkaXNjb25uZWN0aW5nLCBidXQgbm90IGluIGNvbm5lY3Rpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVGhlIHdlYnNvY2tldCBkaWQgbm90IGRpc2Nvbm5lY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGluZ1wiKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3REZWZlcnJlZFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgaWYgKF90aGlzLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy53cykge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0b3BTZW5kaW5nS2VlcEFsaXZlcygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJjbG9zaW5nIFdlYlNvY2tldCBcIiArIF90aGlzLnNlcnZlci53c1VyaSk7XG4gICAgICAgICAgICAgICAgX3RoaXMud3MuY2xvc2Uob3B0aW9ucy5jb2RlLCBvcHRpb25zLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJBdHRlbXB0ZWQgdG8gZGlzY29ubmVjdCBidXQgdGhlIHdlYnNvY2tldCBkb2Vzbid0IGV4aXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdGlvblByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHNvY2tldC5cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3RQcm9taXNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NJTkcgJiYgIW9wdGlvbnMuZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIldlYlNvY2tldCBcIiArIHRoaXMuc2VydmVyLndzVXJpICsgXCIgaXMgY2xvc2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSB0aGlzLnNlcnZlciB8fCB0aGlzLmdldE5leHRXc1NlcnZlcihvcHRpb25zLmZvcmNlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICgoX3RoaXMuc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX09QRU4gfHwgX3RoaXMuc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NJTkcpXG4gICAgICAgICAgICAgICAgJiYgIW9wdGlvbnMuZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIldlYlNvY2tldCBcIiArIF90aGlzLnNlcnZlci53c1VyaSArIFwiIGlzIGFscmVhZHkgY29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIHJlamVjdChcIkZhaWxlZCBzdGF0dXMgY2hlY2sgLSBhdHRlbXB0ZWQgdG8gb3BlbiBhIGNvbm5lY3Rpb24gYnV0IGFscmVhZHkgb3Blbi9jbG9zaW5nXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3REZWZlcnJlZFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdERlZmVycmVkUmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DT05ORUNUSU5HO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiY29ubmVjdGluZyB0byBXZWJTb2NrZXQgXCIgKyBfdGhpcy5zZXJ2ZXIud3NVcmkpO1xuICAgICAgICAgICAgX3RoaXMuZGlzcG9zZVdzKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF90aGlzLndzID0gbmV3IFdlYlNvY2tldChfdGhpcy5zZXJ2ZXIud3NVcmksIFwic2lwXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLndzLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7IC8vIHNldCBkYXRhIHR5cGUgb2YgcmVjZWl2ZWQgYmluYXJ5IG1lc3NhZ2VzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1c1RyYW5zaXRpb24oVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TRUQsIHRydWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRXJyb3IoXCJlcnJvciBjb25uZWN0aW5nIHRvIFdlYlNvY2tldCBcIiArIF90aGlzLnNlcnZlci53c1VyaSArIFwiOlwiICsgZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIGNyZWF0ZSBhIHdlYnNvY2tldFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3REZWZlcnJlZFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLndzKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiVW5leHBlY3RlZCBpbnN0YW5jZSB3ZWJzb2NrZXQgbm90IHNldFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3REZWZlcnJlZFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1c1RyYW5zaXRpb24oVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TRUQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwidG9vayB0b28gbG9uZyB0byBjb25uZWN0IC0gZXhjZWVkZWQgdGltZSBzZXQgaW4gY29uZmlndXJhdGlvbi5jb25uZWN0aW9uVGltZW91dDogXCIgK1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25UaW1lb3V0ICsgXCJzXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkaXNjb25uZWN0ZWRcIiwgeyBjb2RlOiAxMDAwIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJlamVjdChcIkNvbm5lY3Rpb24gdGltZW91dFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3REZWZlcnJlZFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgd3MgPSBfdGhpcy53cztcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwb3NlV3MoKTtcbiAgICAgICAgICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAgICAgICAgICAgd3MuY2xvc2UoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX3RoaXMuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uVGltZW91dCAqIDEwMDApO1xuICAgICAgICAgICAgX3RoaXMuYm91bmRPbk9wZW4gPSBfdGhpcy5vbk9wZW4uYmluZChfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5ib3VuZE9uTWVzc2FnZSA9IF90aGlzLm9uTWVzc2FnZS5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLmJvdW5kT25DbG9zZSA9IF90aGlzLm9uQ2xvc2UuYmluZChfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5ib3VuZE9uRXJyb3IgPSBfdGhpcy5vbldlYnNvY2tldEVycm9yLmJpbmQoX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMud3MuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgX3RoaXMuYm91bmRPbk9wZW4pO1xuICAgICAgICAgICAgX3RoaXMud3MuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgX3RoaXMuYm91bmRPbk1lc3NhZ2UpO1xuICAgICAgICAgICAgX3RoaXMud3MuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIF90aGlzLmJvdW5kT25DbG9zZSk7XG4gICAgICAgICAgICBfdGhpcy53cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgX3RoaXMuYm91bmRPbkVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgIHZhciBmaW5pc2hlZERhdGE7XG4gICAgICAgIC8vIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZSBmcm9tIHNlcnZlci4gQ2xlYXIgb3VyIGtlZXAgYWxpdmUgdGltZW91dC5cbiAgICAgICAgaWYgKC9eKFxcclxcbikrJC8udGVzdChkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcktlZXBBbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJyZWNlaXZlZCBXZWJTb2NrZXQgbWVzc2FnZSB3aXRoIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInJlY2VpdmVkIGVtcHR5IG1lc3NhZ2UsIG1lc3NhZ2UgZGlzY2FyZGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7IC8vIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIFVJbnQ4RGF0YSB3YXMgaGVyZSBwcmlvciB0byB0eXBlcywgYW5kIGRvZXNuJ3QgY2hlY2tcbiAgICAgICAgICAgICAgICBmaW5pc2hlZERhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwicmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlIGZhaWxlZCB0byBiZSBjb252ZXJ0ZWQgaW50byBzdHJpbmcsIG1lc3NhZ2UgZGlzY2FyZGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJyZWNlaXZlZCBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2U6XFxuXFxuXCIgKyBkYXRhICsgXCJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFdlYlNvY2tldCB0ZXh0IG1lc3NhZ2UuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwicmVjZWl2ZWQgV2ViU29ja2V0IHRleHQgbWVzc2FnZTpcXG5cXG5cIiArIGRhdGEgKyBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmlzaGVkRGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBmaW5pc2hlZERhdGEpO1xuICAgIH07XG4gICAgLy8gVHJhbnNwb3J0IEV2ZW50IEhhbmRsZXJzXG4gICAgLyoqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VEKSB7IC8vIEluZGljYXRlZCB0aGF0IHRoZSB0cmFuc3BvcnQgdGhpbmtzIHRoZSB3cyBpcyBkZWFkIGFscmVhZHlcbiAgICAgICAgICAgIHZhciB3cyA9IHRoaXMud3M7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VXcygpO1xuICAgICAgICAgICAgaWYgKHdzKSB7XG4gICAgICAgICAgICAgICAgd3MuY2xvc2UoMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXNUcmFuc2l0aW9uKFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfT1BFTiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RlZFwiKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiV2ViU29ja2V0IFwiICsgdGhpcy5zZXJ2ZXIud3NVcmkgKyBcIiBjb25uZWN0ZWRcIik7XG4gICAgICAgIC8vIENsZWFyIHJlY29ubmVjdFRpbWVyIHNpbmNlIHdlIGFyZSBub3QgZGlzY29ubmVjdGVkXG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgcmVjb25uZWN0aW9uQXR0ZW1wdHNcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IDA7XG4gICAgICAgIC8vIFJlc2V0IGRpc2Nvbm5lY3Rpb24gcHJvbWlzZSBzbyB3ZSBjYW4gZGlzY29ubmVjdCBmcm9tIGEgZnJlc2ggc3RhdGVcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzXG4gICAgICAgIHRoaXMuc3RhcnRTZW5kaW5nS2VlcEFsaXZlcygpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3REZWZlcnJlZFJlc29sdmUoeyBvdmVycmlkZUV2ZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5leHBlY3RlZCB3ZWJzb2NrZXQub25PcGVuIHdpdGggbm8gY29ubmVjdERlZmVycmVkUmVzb2x2ZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIldlYlNvY2tldCBkaXNjb25uZWN0ZWQgKGNvZGU6IFwiICsgZS5jb2RlICsgKGUucmVhc29uID8gXCJ8IHJlYXNvbjogXCIgKyBlLnJlYXNvbiA6IFwiXCIpICsgXCIpXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0lORykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIldlYlNvY2tldCBjbG9zZWQgd2l0aG91dCBTSVAuanMgcmVxdWVzdGluZyBpdFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gICAgICAgIC8vIENsZWFuIHVwIGNvbm5lY3Rpb24gdmFyaWFibGVzIHNvIHdlIGNhbiBjb25uZWN0IGFnYWluIGZyb20gYSBmcmVzaCBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3REZWZlcnJlZFJlamVjdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QoXCJXZWJzb2NrZXQgQ2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgcmVxdWVzdGVkIHRvIGNsb3NlLlxuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0RGVmZXJyZWRSZXNvbHZlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3REZWZlcnJlZFJlc29sdmUoeyBvdmVycmlkZUV2ZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNUcmFuc2l0aW9uKFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VEKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1c1RyYW5zaXRpb24oVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TRUQsIHRydWUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0ZWRcIiwgeyBjb2RlOiBlLmNvZGUsIHJlYXNvbjogZS5yZWFzb24gfSk7XG4gICAgICAgIHRoaXMuZGlzcG9zZVdzKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBhbmQgY2xlYXJzIHRoZSBpbnN0YW5jZSB3c1xuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZVdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy53cy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLCB0aGlzLmJvdW5kT25PcGVuKTtcbiAgICAgICAgICAgIHRoaXMud3MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5ib3VuZE9uTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLndzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCB0aGlzLmJvdW5kT25DbG9zZSk7XG4gICAgICAgICAgICB0aGlzLndzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLmJvdW5kT25FcnJvcik7XG4gICAgICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUcmFuc3BvcnQgZXJyb3I6IFwiICsgZSk7XG4gICAgICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydEVycm9yXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uV2Vic29ja2V0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihcIlRoZSBXZWJzb2NrZXQgaGFkIGFuIGVycm9yXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjb25uZWN0aW9uIGF0dGVtcHQgbG9naWMuXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiUmVjb25uZWN0aW9uIGF0dGVtcHQgXCIgKyB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzICsgXCIgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vQXZhaWxhYmxlU2VydmVycygpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiYXR0ZW1wdGVkIHRvIGdldCBuZXh0IHdzIHNlcnZlciBidXQgdGhlcmUgYXJlIG5vIGF2YWlsYWJsZSB3cyBzZXJ2ZXJzIGxlZnRcIik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibm8gYXZhaWxhYmxlIHdzIHNlcnZlcnMgbGVmdCAtIGdvaW5nIHRvIGNsb3NlZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVHJhbnNpdGlvbihUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NFRCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZWRcIik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VydmVyRXJyb3JTdGF0dXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiYXR0ZW1wdGVkIHRvIHJlY29ubmVjdCB3aGlsZSBjb25uZWN0ZWQgLSBmb3JjaW5nIGRpc2Nvbm5lY3RcIik7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoeyBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzICs9IDE7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzID4gdGhpcy5jb25maWd1cmF0aW9uLm1heFJlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgZm9yIFdlYlNvY2tldCBcIiArIHRoaXMuc2VydmVyLndzVXJpKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInRyYW5zcG9ydCBcIiArIHRoaXMuc2VydmVyLndzVXJpICsgXCIgZmFpbGVkIHwgY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJ2Vycm9yJ1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidHJhbnNwb3J0RXJyb3JcIik7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9BdmFpbGFibGVTZXJ2ZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlciA9IHRoaXMuZ2V0TmV4dFdzU2VydmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBubyBhdmFpbGFibGUgc2VydmVycywgdGhlIHJlY29ubmVjdCBmdW5jdGlvbiBlbmRzIG9uIHRoZSBuZXh0IHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICAvLyBhZnRlciBjaGVja2luZyBmb3Igbm8gYXZhaWxhYmxlIHNlcnZlcnMgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJ0cnlpbmcgdG8gcmVjb25uZWN0IHRvIFdlYlNvY2tldCBcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIud3NVcmkgKyBcIiAocmVjb25uZWN0aW9uIGF0dGVtcHQgXCIgKyB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzICsgXCIpXCIpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sICh0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzID09PSAxKSA/IDAgOiB0aGlzLmNvbmZpZ3VyYXRpb24ucmVjb25uZWN0aW9uVGltZW91dCAqIDEwMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGVycm9yIHN0YXRlIG9mIGFsbCBzZXJ2ZXJzIGluIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5yZXNldFNlcnZlckVycm9yU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB3ZWJzb2NrZXQgPSBfYVtfaV07XG4gICAgICAgICAgICB3ZWJzb2NrZXQuaXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBzZXJ2ZXIgdG8gd2hpY2ggY29ubmVjdC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIGFsbG93cyBieXBhc3Mgb2Ygc2VydmVyIGVycm9yIHN0YXR1cyBjaGVja2luZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFdzU2VydmVyXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5nZXROZXh0V3NTZXJ2ZXIgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodGhpcy5ub0F2YWlsYWJsZVNlcnZlcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImF0dGVtcHRlZCB0byBnZXQgbmV4dCB3cyBzZXJ2ZXIgYnV0IHRoZXJlIGFyZSBubyBhdmFpbGFibGUgd3Mgc2VydmVycyBsZWZ0XCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGdldCBuZXh0IHdzIHNlcnZlciwgYnV0IHRoZXJlIGFyZSBubyBhdmFpbGFibGUgd3Mgc2VydmVycyBsZWZ0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcmRlciBzZXJ2ZXJzIGJ5IHdlaWdodFxuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB3c1NlcnZlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICh3c1NlcnZlci5pc0Vycm9yICYmICFmb3JjZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2god3NTZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod3NTZXJ2ZXIud2VpZ2h0ID4gY2FuZGlkYXRlc1swXS53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gW3dzU2VydmVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdzU2VydmVyLndlaWdodCA9PT0gY2FuZGlkYXRlc1swXS53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2god3NTZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjYW5kaWRhdGVzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzW2lkeF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgYWxsIGNvbmZpZ3VyYXRpb24gc2VydmVycywgcmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGVtIGhhdmUgaXNFcnJvcjogdHJ1ZSBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5ub0F2YWlsYWJsZVNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlcnZlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghc2VydmVyLmlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBLZWVwQWxpdmUgU3R1ZmZcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEga2VlcC1hbGl2ZSAoYSBkb3VibGUtQ1JMRiBzZXF1ZW5jZSkuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kS2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBvdXRzdGFuZGluZyBrZWVwIGFsaXZlLCBkbyBub3Qgc2VuZCBhbm90aGVyLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwia2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0XCIpO1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJLZWVwQWxpdmVUaW1lb3V0KCk7XG4gICAgICAgIH0sIHRoaXMuY29uZmlndXJhdGlvbi5rZWVwQWxpdmVEZWJvdW5jZSAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5jbGVhcktlZXBBbGl2ZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IHNlbmRpbmcga2VlcC1hbGl2ZXMuXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5zdGFydFNlbmRpbmdLZWVwQWxpdmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmtlZXBBbGl2ZUludGVydmFsICYmICF0aGlzLmtlZXBBbGl2ZUludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBBbGl2ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRLZWVwQWxpdmUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gICAgICAgICAgICB9LCBjb21wdXRlS2VlcEFsaXZlVGltZW91dCh0aGlzLmNvbmZpZ3VyYXRpb24ua2VlcEFsaXZlSW50ZXJ2YWwpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc3RvcFNlbmRpbmdLZWVwQWxpdmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBTdGF0dXMgU3R1ZmZcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZ2l2ZW4gc3RhdHVzIGFnYWluc3QgaW5zdGFuY2UgY3VycmVudCBzdGF0dXMuIFJldHVybnMgdHJ1ZSBpZiB0aGV5IG1hdGNoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc3RhdHVzQXNzZXJ0ID0gZnVuY3Rpb24gKHN0YXR1cywgZm9yY2UpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gdGhpcy5zdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkF0dGVtcHRlZCB0byBhc3NlcnQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhUcmFuc3BvcnRTdGF0dXMpW3RoaXMuc3RhdHVzXSArIFwiIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoVHJhbnNwb3J0U3RhdHVzKVtzdGF0dXNdICsgXCItIGNvbnRpbnVpbmcgd2l0aCBvcHRpb246ICdmb3JjZSdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVHJpZWQgdG8gYXNzZXJ0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoVHJhbnNwb3J0U3RhdHVzKVtzdGF0dXNdICsgXCIgYnV0IGlzIGN1cnJlbnRseSBcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKFRyYW5zcG9ydFN0YXR1cylbdGhpcy5zdGF0dXNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb25zIHRoZSBzdGF0dXMuIENoZWNrcyBmb3IgbGVnYWwgdHJhbnNpdGlvbiB2aWEgYXNzZXJ0aW9uIGJlZm9yZWhhbmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5zdGF0dXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHN0YXR1cywgZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJBdHRlbXB0aW5nIHRvIHRyYW5zaXRpb24gc3RhdHVzIGZyb20gXCIgK1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoVHJhbnNwb3J0U3RhdHVzKVt0aGlzLnN0YXR1c10gKyBcIiB0byBcIiArXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhUcmFuc3BvcnRTdGF0dXMpW3N0YXR1c10pO1xuICAgICAgICBpZiAoKHN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DT05ORUNUSU5HICYmIHRoaXMuc3RhdHVzQXNzZXJ0KFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VELCBmb3JjZSkpIHx8XG4gICAgICAgICAgICAoc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX09QRU4gJiYgdGhpcy5zdGF0dXNBc3NlcnQoVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DT05ORUNUSU5HLCBmb3JjZSkpIHx8XG4gICAgICAgICAgICAoc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NJTkcgJiYgdGhpcy5zdGF0dXNBc3NlcnQoVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19PUEVOLCBmb3JjZSkpIHx8XG4gICAgICAgICAgICAoc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NFRCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiU3RhdHVzIHRyYW5zaXRpb24gZmFpbGVkIC0gcmVzdWx0OiBuby1vcCAtIHJlYXNvbjpcIiArXG4gICAgICAgICAgICAgICAgXCIgZWl0aGVyIGdhdmUgYW4gbm9uZXhpc3RlbnQgc3RhdHVzIG9yIGF0dGVtcHRlZCBpbGxlZ2FsIHRyYW5zaXRpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIENvbmZpZ3VyYXRpb24gSGFuZGxpbmdcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGxvYWQuXG4gICAgICogcmV0dXJucyB7Q29uZmlndXJhdGlvbn1cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmxvYWRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICB3c1NlcnZlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtZTogXCJXU1NcIixcbiAgICAgICAgICAgICAgICAgICAgc2lwVXJpOiBcIjxzaXA6ZWRnZS5zaXAub25zaXAuY29tO3RyYW5zcG9ydD13cztscj5cIixcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3c1VyaTogXCJ3c3M6Ly9lZGdlLnNpcC5vbnNpcC5jb21cIixcbiAgICAgICAgICAgICAgICAgICAgaXNFcnJvcjogZmFsc2VcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiA1LFxuICAgICAgICAgICAgbWF4UmVjb25uZWN0aW9uQXR0ZW1wdHM6IDMsXG4gICAgICAgICAgICByZWNvbm5lY3Rpb25UaW1lb3V0OiA0LFxuICAgICAgICAgICAga2VlcEFsaXZlSW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICBrZWVwQWxpdmVEZWJvdW5jZTogMTAsXG4gICAgICAgICAgICAvLyBMb2dnaW5nXG4gICAgICAgICAgICB0cmFjZVNpcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbmZpZ0NoZWNrID0gdGhpcy5nZXRDb25maWd1cmF0aW9uQ2hlY2soKTtcbiAgICAgICAgLy8gQ2hlY2sgTWFuZGF0b3J5IHBhcmFtZXRlcnNcbiAgICAgICAgZm9yICh2YXIgcGFyYW1ldGVyIGluIGNvbmZpZ0NoZWNrLm1hbmRhdG9yeSkge1xuICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrZWRWYWx1ZSA9IGNvbmZpZ0NoZWNrLm1hbmRhdG9yeVtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgZm9yICh2YXIgcGFyYW1ldGVyIGluIGNvbmZpZ0NoZWNrLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXksIGJ1dCBzaG91bGRuJ3QgYmUsIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbnVsbCwgZW1wdHkgc3RyaW5nLCBvciB1bmRlZmluZWQgdGhlbiBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgbnVtYmVyIHdpdGggTmFOIHZhbHVlIHRoZW4gYWxzbyBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBKUyBkb2VzIG5vdCBhbGxvdyBcInZhbHVlID09PSBOYU5cIiwgdGhlIGZvbGxvd2luZyBkb2VzIHRoZSB3b3JrOlxuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrZWRWYWx1ZSA9IGNvbmZpZ0NoZWNrLm9wdGlvbmFsW3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1twYXJhbWV0ZXJdID0gY2hlY2tlZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNrZWxldG9uID0ge307IC8vIEZpbGwgdGhlIHZhbHVlIG9mIHRoZSBjb25maWd1cmF0aW9uX3NrZWxldG9uXG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgICAgICBza2VsZXRvbltwYXJhbWV0ZXJdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3NbcGFyYW1ldGVyXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXR1cm5Db25maWd1cmF0aW9uID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHNrZWxldG9uKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGFmdGVyIHZhbGlkYXRpb246XCIpO1xuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBwYXJhbWV0ZXIgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShzZXR0aW5nc1twYXJhbWV0ZXJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybkNvbmZpZ3VyYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGNoZWNrZXIuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmdldENvbmZpZ3VyYXRpb25DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hbmRhdG9yeToge30sXG4gICAgICAgICAgICBvcHRpb25hbDoge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgZnVuY3Rpb24gdXNlZCB0byBjYWxsICd0aGlzLmxvZ2dlci5lcnJvcicgYnV0IGNhbGxpbmcgJ3RoaXMnIHdpdGggYW55dGhpbmcgaGVyZSBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgd3NTZXJ2ZXJzOiBmdW5jdGlvbiAod3NTZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEFsbG93IGRlZmluaW5nIHdzU2VydmVycyBwYXJhbWV0ZXIgYXM6XG4gICAgICAgICAgICAgICAgICAgICAqICBTdHJpbmc6IFwiaG9zdFwiXG4gICAgICAgICAgICAgICAgICAgICAqICBBcnJheSBvZiBTdHJpbmdzOiBbXCJob3N0MVwiLCBcImhvc3QyXCJdXG4gICAgICAgICAgICAgICAgICAgICAqICBBcnJheSBvZiBPYmplY3RzOiBbe3dzVXJpOlwiaG9zdDFcIiwgd2VpZ2h0OjF9LCB7d3NVcmk6XCJob3N0MlwiLCB3ZWlnaHQ6MH1dXG4gICAgICAgICAgICAgICAgICAgICAqICBBcnJheSBvZiBPYmplY3RzIGFuZCBTdHJpbmdzOiBbe3dzVXJpOlwiaG9zdDFcIn0sIFwiaG9zdDJcIl1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd3NTZXJ2ZXJzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3c1NlcnZlcnMgPSBbeyB3c1VyaTogd3NTZXJ2ZXJzIH1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdzU2VydmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB3c1NlcnZlcnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd3NTZXJ2ZXJzW2lkeF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0gPSB7IHdzVXJpOiB3c1NlcnZlcnNbaWR4XSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAod3NTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgd3NTZXJ2ZXJzXzEgPSB3c1NlcnZlcnM7IF9pIDwgd3NTZXJ2ZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3NTZXJ2ZXIgPSB3c1NlcnZlcnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdzU2VydmVyLndzVXJpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdzU2VydmVyLndlaWdodCAmJiAhTnVtYmVyKHdzU2VydmVyLndlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gY29yZV8xLkdyYW1tYXIucGFyc2Uod3NTZXJ2ZXIud3NVcmksIFwiYWJzb2x1dGVVUklcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFtcIndzc1wiLCBcIndzXCIsIFwidWRwXCJdLmluZGV4T2YodXJsLnNjaGVtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3NTZXJ2ZXIuc2lwVXJpID0gXCI8c2lwOlwiICsgdXJsLmhvc3QgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXJsLnBvcnQgPyBcIjpcIiArIHVybC5wb3J0IDogXCJcIikgKyBcIjt0cmFuc3BvcnQ9XCIgKyB1cmwuc2NoZW1lLnJlcGxhY2UoL153c3MkL2ksIFwid3NcIikgKyBcIjtscj5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdzU2VydmVyLndlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3c1NlcnZlci53ZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3c1NlcnZlci5pc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3NTZXJ2ZXIuc2NoZW1lID0gdXJsLnNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3c1NlcnZlcnM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVJbnRlcnZhbDogZnVuY3Rpb24gKGtlZXBBbGl2ZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChrZWVwQWxpdmVJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihrZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVEZWJvdW5jZTogZnVuY3Rpb24gKGtlZXBBbGl2ZURlYm91bmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChrZWVwQWxpdmVEZWJvdW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihrZWVwQWxpdmVEZWJvdW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFjZVNpcDogZnVuY3Rpb24gKHRyYWNlU2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2VTaXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VTaXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBmdW5jdGlvbiAoY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNEZWNpbWFsKGNvbm5lY3Rpb25UaW1lb3V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1heFJlY29ubmVjdGlvbkF0dGVtcHRzOiBmdW5jdGlvbiAobWF4UmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNEZWNpbWFsKG1heFJlY29ubmVjdGlvbkF0dGVtcHRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKG1heFJlY29ubmVjdGlvbkF0dGVtcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWNvbm5lY3Rpb25UaW1lb3V0OiBmdW5jdGlvbiAocmVjb25uZWN0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwocmVjb25uZWN0aW9uVGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihyZWNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUcmFuc3BvcnQuQyA9IFRyYW5zcG9ydFN0YXR1cztcbiAgICByZXR1cm4gVHJhbnNwb3J0O1xufShUcmFuc3BvcnRfMS5UcmFuc3BvcnQpKTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBNb2RpZmllcnMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9Nb2RpZmllcnNcIikpO1xuZXhwb3J0cy5Nb2RpZmllcnMgPSBNb2RpZmllcnM7XG52YXIgU2ltcGxlXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVcIik7XG5leHBvcnRzLlNpbXBsZSA9IFNpbXBsZV8xLlNpbXBsZTtcbnZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyXCIpO1xuZXhwb3J0cy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcl8xLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG52YXIgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9UcmFuc3BvcnRcIik7XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydF8xLlRyYW5zcG9ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZW5kIGEge0BsaW5rIFNlc3Npb259IChpbmNvbWluZyBCWUUpLlxuICogQHB1YmxpY1xuICovXG52YXIgQnllID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBCeWUoaW5jb21pbmdCeWVSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdCeWVSZXF1ZXN0ID0gaW5jb21pbmdCeWVSZXF1ZXN0O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnllLnByb3RvdHlwZSwgXCJyZXF1ZXN0XCIsIHtcbiAgICAgICAgLyoqIEluY29taW5nIEJZRSByZXF1ZXN0IG1lc3NhZ2UuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdCeWVSZXF1ZXN0Lm1lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBBY2NlcHQgdGhlIHJlcXVlc3QuICovXG4gICAgQnllLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluY29taW5nQnllUmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIC8qKiBSZWplY3QgdGhlIHJlcXVlc3QuICovXG4gICAgQnllLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluY29taW5nQnllUmVxdWVzdC5yZWplY3Qob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBCeWU7XG59KCkpO1xuZXhwb3J0cy5CeWUgPSBCeWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ3JlYXRlcyBhbiB7QGxpbmsgRW1pdHRlcn0uXG4gKiBAcGFyYW0gZXZlbnRFbWl0dGVyIC0gQW4gZXZlbnQgZW1pdHRlci5cbiAqIEBwYXJhbSBldmVudE5hbWUgLSBFdmVudCBuYW1lLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9tYWtlRW1pdHRlcihldmVudEVtaXR0ZXIsIGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUgPT09IHZvaWQgMCkgeyBldmVudE5hbWUgPSBcImV2ZW50XCI7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5vbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2ZmOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZTogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIub25jZShldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLl9tYWtlRW1pdHRlciA9IF9tYWtlRW1pdHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmVcIik7XG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIGFuIHVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZSBwcmV2ZW50ZWQgZXhlY3V0aW9uLlxuICogQHB1YmxpY1xuICovXG52YXIgQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbnRlbnRUeXBlVW5zdXBwb3J0ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3IobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZS5cIikgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlVW5zdXBwb3J0ZWRFcnJvcjtcbn0oY29yZV8xLkV4Y2VwdGlvbikpO1xuZXhwb3J0cy5Db250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3IgPSBDb250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udGVudC10eXBlLXVuc3VwcG9ydGVkXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlcXVlc3QtcGVuZGluZ1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXNzaW9uLWRlc2NyaXB0aW9uLWhhbmRsZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2Vzc2lvbi10ZXJtaW5hdGVkXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0YXRlLXRyYW5zaXRpb25cIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZVwiKTtcbi8qKlxuICogQW4gZXhjZXB0aW9uIGluZGljYXRpbmcgYW4gb3V0c3RhbmRpbmcgcHJpb3IgcmVxdWVzdCBwcmV2ZW50ZWQgZXhlY3V0aW9uLlxuICogQHB1YmxpY1xuICovXG52YXIgUmVxdWVzdFBlbmRpbmdFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZXF1ZXN0UGVuZGluZ0Vycm9yLCBfc3VwZXIpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBSZXF1ZXN0UGVuZGluZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgPyBtZXNzYWdlIDogXCJSZXF1ZXN0IHBlbmRpbmcuXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXF1ZXN0UGVuZGluZ0Vycm9yO1xufShjb3JlXzEuRXhjZXB0aW9uKSk7XG5leHBvcnRzLlJlcXVlc3RQZW5kaW5nRXJyb3IgPSBSZXF1ZXN0UGVuZGluZ0Vycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZVwiKTtcbi8qKlxuICogQW4gZXhjZXB0aW9uIGluZGljYXRpbmcgYSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgZXJyb3Igb2NjdXJlZC5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgPyBtZXNzYWdlIDogXCJVbnNwZWNpZmllZCBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgZXJyb3IuXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3I7XG59KGNvcmVfMS5FeGNlcHRpb24pKTtcbmV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yID0gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZVwiKTtcbi8qKlxuICogQW4gZXhjZXB0aW9uIGluZGljYXRpbmcgdGhlIHNlc3Npb24gdGVybWluYXRlZCBiZWZvcmUgdGhlIGFjdGlvbiBjb21wbGV0ZWQuXG4gKiBAcHVibGljXG4gKi9cbnZhciBTZXNzaW9uVGVybWluYXRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFNlc3Npb25UZXJtaW5hdGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Vzc2lvblRlcm1pbmF0ZWRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiVGhlIHNlc3Npb24gaGFzIHRlcm1pbmF0ZWQuXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZXNzaW9uVGVybWluYXRlZEVycm9yO1xufShjb3JlXzEuRXhjZXB0aW9uKSk7XG5leHBvcnRzLlNlc3Npb25UZXJtaW5hdGVkRXJyb3IgPSBTZXNzaW9uVGVybWluYXRlZEVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZVwiKTtcbi8qKlxuICogQW4gZXhjZXB0aW9uIGluZGljYXRpbmcgYW4gaW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGVycm9yIG9jY3VyZWQuXG4gKiBAcHVibGljXG4gKi9cbnZhciBTdGF0ZVRyYW5zaXRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGF0ZVRyYW5zaXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGF0ZVRyYW5zaXRpb25FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlID8gbWVzc2FnZSA6IFwiQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHN0YXRlIHRyYW5zaXRpb24uXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdGF0ZVRyYW5zaXRpb25FcnJvcjtcbn0oY29yZV8xLkV4Y2VwdGlvbikpO1xuZXhwb3J0cy5TdGF0ZVRyYW5zaXRpb25FcnJvciA9IFN0YXRlVHJhbnNpdGlvbkVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFuIGV4Y2hhbmdlIG9mIGluZm9ybWF0aW9uIChpbmNvbWluZyBJTkZPKS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIEluZm8oaW5jb21pbmdJbmZvUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmluY29taW5nSW5mb1JlcXVlc3QgPSBpbmNvbWluZ0luZm9SZXF1ZXN0O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5mby5wcm90b3R5cGUsIFwicmVxdWVzdFwiLCB7XG4gICAgICAgIC8qKiBJbmNvbWluZyBNRVNTQUdFIHJlcXVlc3QgbWVzc2FnZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmNvbWluZ0luZm9SZXF1ZXN0Lm1lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBBY2NlcHQgdGhlIHJlcXVlc3QuICovXG4gICAgSW5mby5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ0luZm9SZXF1ZXN0LmFjY2VwdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqIFJlamVjdCB0aGUgcmVxdWVzdC4gKi9cbiAgICBJbmZvLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluY29taW5nSW5mb1JlcXVlc3QucmVqZWN0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5mbztcbn0oKSk7XG5leHBvcnRzLkluZm8gPSBJbmZvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgcmVjZWl2ZWQgbWVzc2FnZSAoaW5jb21pbmcgTUVTU0FHRSkuXG4gKiBAcHVibGljXG4gKi9cbnZhciBNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlKGluY29taW5nTWVzc2FnZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VSZXF1ZXN0ID0gaW5jb21pbmdNZXNzYWdlUmVxdWVzdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UucHJvdG90eXBlLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAvKiogSW5jb21pbmcgTUVTU0FHRSByZXF1ZXN0IG1lc3NhZ2UuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdNZXNzYWdlUmVxdWVzdC5tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQWNjZXB0IHRoZSByZXF1ZXN0LiAqL1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlUmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIC8qKiBSZWplY3QgdGhlIHJlcXVlc3QuICovXG4gICAgTWVzc2FnZS5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VSZXF1ZXN0LnJlamVjdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5NZXNzYWdlID0gTWVzc2FnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBvZiBhbiBldmVudCAoaW5jb21pbmcgTk9USUZZKS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIE5vdGlmaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKGluY29taW5nTm90aWZ5UmVxdWVzdCkge1xuICAgICAgICB0aGlzLmluY29taW5nTm90aWZ5UmVxdWVzdCA9IGluY29taW5nTm90aWZ5UmVxdWVzdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vdGlmaWNhdGlvbi5wcm90b3R5cGUsIFwicmVxdWVzdFwiLCB7XG4gICAgICAgIC8qKiBJbmNvbWluZyBOT1RJRlkgcmVxdWVzdCBtZXNzYWdlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluY29taW5nTm90aWZ5UmVxdWVzdC5tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQWNjZXB0IHRoZSByZXF1ZXN0LiAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ05vdGlmeVJlcXVlc3QuYWNjZXB0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKiogUmVqZWN0IHRoZSByZXF1ZXN0LiAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ05vdGlmeVJlcXVlc3QucmVqZWN0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uL2NvcmVcIik7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBlc3RhYmxpc2ggYSB7QGxpbmsgU2Vzc2lvbn0gZWxzZXdoZXJlIChpbmNvbWluZyBSRUZFUikuXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWZlcnJhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gUmVmZXJyYWwoaW5jb21pbmdSZWZlclJlcXVlc3QsIHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdCA9IGluY29taW5nUmVmZXJSZXF1ZXN0O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJyYWwucHJvdG90eXBlLCBcInJlZmVyVG9cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWZlclRvID0gdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5tZXNzYWdlLnBhcnNlSGVhZGVyKFwicmVmZXItdG9cIik7XG4gICAgICAgICAgICBpZiAoIShyZWZlclRvIGluc3RhbmNlb2YgY29yZV8xLk5hbWVBZGRySGVhZGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBSZWZlci1UbyBoZWFkZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZmVyVG87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcnJhbC5wcm90b3R5cGUsIFwicmVmZXJyZWRCeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdSZWZlclJlcXVlc3QubWVzc2FnZS5nZXRIZWFkZXIoXCJyZWZlcnJlZC1ieVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVycmFsLnByb3RvdHlwZSwgXCJyZXBsYWNlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJUby51cmkuZ2V0SGVhZGVyKFwicmVwbGFjZXNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcnJhbC5wcm90b3R5cGUsIFwicmVxdWVzdFwiLCB7XG4gICAgICAgIC8qKiBJbmNvbWluZyBSRUZFUiByZXF1ZXN0IG1lc3NhZ2UuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdSZWZlclJlcXVlc3QubWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEFjY2VwdCB0aGUgcmVxdWVzdC4gKi9cbiAgICBSZWZlcnJhbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAyMDIgfTsgfVxuICAgICAgICB0aGlzLmluY29taW5nUmVmZXJSZXF1ZXN0LmFjY2VwdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqIFJlamVjdCB0aGUgcmVxdWVzdC4gKi9cbiAgICBSZWZlcnJhbC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5yZWplY3Qob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW52aXRlciB3aGljaCBtYXkgYmUgdXNlZCB0byBzZW5kIGFuIG91dCBvZiBkaWFsb2cgSU5WSVRFIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgYSBoZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhbiBJbnZpdGVyIHdoaWNoIHdpbGwgZXhlY3V0ZSB0aGUgcmVmZXJyYWxcbiAgICAgKiBvZiB0aGUgYFNlc3Npb25gIHdoaWNoIHdhcyByZWZlcnJlZC4gVGhlIGFwcHJvcHJpYXRlIGhlYWRlcnMgYXJlIHNldCBhbmRcbiAgICAgKiB0aGUgcmVmZXJyZWQgYFNlc3Npb25gIGlzIGxpbmtlZCB0byB0aGUgbmV3IGBTZXNzaW9uYC4gTm90ZSB0aGF0IG9ubHkgYVxuICAgICAqIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGUgYEludml0ZXJgIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQgKGlmIGNhbGxlZFxuICAgICAqIG1vcmUgdGhhbiBvbmNlIGEgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIGBJbnZpdGVyYCB3aWxsIGJlIHJldHVybmVkIGV2ZXJ5IHRpbWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAcGFyYW0gbW9kaWZpZXJzIC0gU2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIG1vZGlmaWVycy5cbiAgICAgKi9cbiAgICBSZWZlcnJhbC5wcm90b3R5cGUubWFrZUludml0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pbnZpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZpdGVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXRVUkkgPSB0aGlzLnJlZmVyVG8udXJpLmNsb25lKCk7XG4gICAgICAgIHRhcmdldFVSSS5jbGVhckhlYWRlcnMoKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHZhciByZXBsYWNlcyA9IHRoaXMucmVwbGFjZXM7XG4gICAgICAgIGlmIChyZXBsYWNlcykge1xuICAgICAgICAgICAgLy8gZGVjb2RlVVJJQ29tcG9uZW50IGlzIGEgaG9sZG92ZXIgZnJvbSAyYzA4NmViNC4gTm90IHN1cmUgdGhhdCBpdCBpcyBhY3R1YWxseSBuZWNlc3NhcnlcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVwbGFjZXM6IFwiICsgZGVjb2RlVVJJQ29tcG9uZW50KHJlcGxhY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZmVycmVkQnkgPSB0aGlzLnJlZmVycmVkQnk7XG4gICAgICAgIGlmIChyZWZlcnJlZEJ5KSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlZmVycmVkLUJ5OiBcIiArIHJlZmVycmVkQnkpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICB0aGlzLmludml0ZXIgPSB0aGlzLnNlc3Npb24udXNlckFnZW50Ll9tYWtlSW52aXRlcih0YXJnZXRVUkksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmludml0ZXIuX3JlZmVycmVkID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB0aGlzLnNlc3Npb24uX3JlZmVycmFsID0gdGhpcy5pbnZpdGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZpdGVyO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVycmFsO1xufSgpKTtcbmV4cG9ydHMuUmVmZXJyYWwgPSBSZWZlcnJhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiB7QGxpbmsgU2Vzc2lvbn0gc3RhdGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSB7QGxpbmsgU2Vzc2lvbn0gYmVoYXZlcyBpbiBhIGRldGVybWluaXN0aWMgbWFubmVyIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSAoRlNNKS5cbiAqIGBgYHR4dFxuICogICAgICAgICAgICAgICAgICAgX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cbiAqICAgICAgICAgICAgICAgICAgfCAgX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fICAgIHwgICAgICAgICAgICB8XG4gKiBTZXNzaW9uICAgICAgICAgIHwgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ICAgdiAgICAgICAgICAgIHZcbiAqIENvbnN0cnVjdGVkIC0+IEluaXRpYWwgLT4gRXN0YWJsaXNoaW5nIC0+IEVzdGFibGlzaGVkIC0+IFRlcm1pbmF0aW5nIC0+IFRlcm1pbmF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgfF9fX19fX19fX19fX19fX19fX19fX19fX19fX14gICBeXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbnZhciBTZXNzaW9uU3RhdGU7XG4oZnVuY3Rpb24gKFNlc3Npb25TdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIElmIGBJbnZpdGVyYCwgSU5WSVRFIG5vdCBzZW50IHlldC5cbiAgICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSAoYnV0IG5vIGZpbmFsIHJlc3BvbnNlIHNlbnQgeWV0KS5cbiAgICAgKi9cbiAgICBTZXNzaW9uU3RhdGVbXCJJbml0aWFsXCJdID0gXCJJbml0aWFsXCI7XG4gICAgLyoqXG4gICAgICogSWYgYEludml0ZXJgLCBzZW50IElOVklURSBhbmQgd2FpdGluZyBmb3IgYSBmaW5hbCByZXNwb25zZS5cbiAgICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSBhbmQgYXR0ZW1wdGluZyB0byBzZW5kIDIwMCBmaW5hbCByZXNwb25zZSAoYnV0IGhhcyBub3Qgc2VudCBpdCB5ZXQpLlxuICAgICAqL1xuICAgIFNlc3Npb25TdGF0ZVtcIkVzdGFibGlzaGluZ1wiXSA9IFwiRXN0YWJsaXNoaW5nXCI7XG4gICAgLyoqXG4gICAgICogSWYgYEludml0ZXJgLCBzZW50IElOVklURSBhbmQgcmVjZWl2ZWQgMjAwIGZpbmFsIHJlc3BvbnNlIGFuZCBzZW50IEFDSy5cbiAgICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSBhbmQgc2VudCAyMDAgZmluYWwgcmVzcG9uc2UuXG4gICAgICovXG4gICAgU2Vzc2lvblN0YXRlW1wiRXN0YWJsaXNoZWRcIl0gPSBcIkVzdGFibGlzaGVkXCI7XG4gICAgLyoqXG4gICAgICogSWYgYEludml0ZXJgLCBzZW50IElOVklURSwgc2VudCBDQU5DRUwgYW5kIG5vdyB3YWl0aW5nIGZvciA0ODcgZmluYWwgcmVzcG9uc2UgdG8gQUNLIChvciAyMDAgdG8gQUNLICYgQllFKS5cbiAgICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSwgc2VudCAyMDAgZmluYWwgcmVzcG9uc2UgYW5kIG5vdyB3YWl0aW5nIG9uIEFDSyBhbmQgdXBvbiByZWNlaXB0IHdpbGwgYXR0ZW1wdCBCWUVcbiAgICAgKiAoYXMgdGhlIHByb3RvY29sIHNwZWNpZmljYXRpb24gcmVxdWlyZXMsIGJlZm9yZSBzZW5kaW5nIGEgQllFIHdlIG11c3QgcmVjZWl2ZSB0aGUgQUNLIC0gc28gd2UgYXJlIHdhaXRpbmcpLlxuICAgICAqL1xuICAgIFNlc3Npb25TdGF0ZVtcIlRlcm1pbmF0aW5nXCJdID0gXCJUZXJtaW5hdGluZ1wiO1xuICAgIC8qKlxuICAgICAqIElmIGBJbnZpdGVyYCwgc2VudCBJTlZJVEUgYW5kIHJlY2VpdmVkIG5vbi0yMDAgZmluYWwgcmVzcG9uc2UgKG9yIHNlbnQvcmVjZWl2ZWQgQllFIGFmdGVyIHJlY2VpdmluZyAyMDApLlxuICAgICAqIElmIGBJbnZpdGF0aW9uYCwgcmVjZWl2ZWQgSU5WSVRFIGFuZCBzZW50IG5vbi0yMDAgZmluYWwgcmVzcG9uc2UgKG9yIHNlbnQvcmVjZWl2ZWQgQllFIGFmdGVyIHNlbmRpbmcgMjAwKS5cbiAgICAgKi9cbiAgICBTZXNzaW9uU3RhdGVbXCJUZXJtaW5hdGVkXCJdID0gXCJUZXJtaW5hdGVkXCI7XG59KShTZXNzaW9uU3RhdGUgPSBleHBvcnRzLlNlc3Npb25TdGF0ZSB8fCAoZXhwb3J0cy5TZXNzaW9uU3RhdGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuLi9jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9tZXNzYWdlcy91dGlsc1wiKTtcbnZhciBhbGxvd2VkX21ldGhvZHNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3VzZXItYWdlbnQtY29yZS9hbGxvd2VkLW1ldGhvZHNcIik7XG52YXIgYnllXzEgPSByZXF1aXJlKFwiLi9ieWVcIik7XG52YXIgZW1pdHRlcl8xID0gcmVxdWlyZShcIi4vZW1pdHRlclwiKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi9leGNlcHRpb25zXCIpO1xudmFyIGluZm9fMSA9IHJlcXVpcmUoXCIuL2luZm9cIik7XG52YXIgbWVzc2FnZV8xID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcbnZhciBub3RpZmljYXRpb25fMSA9IHJlcXVpcmUoXCIuL25vdGlmaWNhdGlvblwiKTtcbnZhciByZWZlcnJhbF8xID0gcmVxdWlyZShcIi4vcmVmZXJyYWxcIik7XG52YXIgc2Vzc2lvbl9zdGF0ZV8xID0gcmVxdWlyZShcIi4vc2Vzc2lvbi1zdGF0ZVwiKTtcbi8qKlxuICogQSBzZXNzaW9uIHByb3ZpZGVzIHJlYWwgdGltZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gb25lIG9yIG1vcmUgcGFydGljaXBhbnRzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgdHJhbnNwb3J0IGJlaGF2ZXMgaW4gYSBkZXRlcm1pbmlzdGljIG1hbm5lciBhY2NvcmRpbmcgdG8gdGhlXG4gKiB0aGUgc3RhdGUgZGVmaW5lZCBpbiB7QGxpbmsgU2Vzc2lvblN0YXRlfS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFNlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHVzZXJBZ2VudCAtIFVzZXIgYWdlbnQuIFNlZSB7QGxpbmsgVXNlckFnZW50fSBmb3IgZGV0YWlscy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXNzaW9uKHVzZXJBZ2VudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvKiogVHJ1ZSBpZiB0aGVyZSBpcyBhIHJlLUlOVklURSByZXF1ZXN0IG91dHN0YW5kaW5nLiAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAvKiogU2Vzc2lvbiBzdGF0ZS4gKi9cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkluaXRpYWw7XG4gICAgICAgIC8qKiBTZXNzaW9uIHN0YXRlIGVtaXR0ZXIuICovXG4gICAgICAgIHRoaXMuX3N0YXRlRXZlbnRFbWl0dGVyID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gb3B0aW9ucy5kZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5fdXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cnVjdG9yLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24gXCIgKyB0aGlzLmlkICsgXCIgaW4gc3RhdGUgXCIgKyB0aGlzLl9zdGF0ZSArIFwiIGlzIGJlaW5nIGRpc3Bvc2VkXCIpO1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgdXNlciBhZ2VudCdzIHNlc3Npb24gY29sbGVjdGlvblxuICAgICAgICBkZWxldGUgdGhpcy51c2VyQWdlbnQuX3Nlc3Npb25zW3RoaXMuaWRdO1xuICAgICAgICAvLyBEaXNwb3NlIG9mIGRpYWxvZyBtZWRpYVxuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gVE9ETzogVGhlIFNESCBuZWVkcyB0byByZW1haW4gZGVmaW5lZCBhcyBpdCB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBpcyBjbG9zZWQgaW4gY2FzZXNcbiAgICAgICAgICAgIC8vIHdoZXJlIGFuIGFuc3dlci9vZmZlciBhcnJpdmVzIHdoaWxlIHRoZSBzZXNzaW9uIGlzIGJlaW5nIHRvcm4gZG93bi4gVGhlcmUgYXJlIGEgdmFyaWV0eVxuICAgICAgICAgICAgLy8gb2YgY2lyY3Vtc3RhbmNlcyB3aGVyZSB0aGlzIGNhbiBoYXBwZW4gLSBzZW5kaW5nIGEgQllFIGR1cmluZyBhIHJlLUlOVklURSBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgIC8vIFRoZSBjb2RlIGlzIGN1cnJlbnRseSB3cml0dGVuIHN1Y2ggdGhhdCBpdCBsYXppbHkgbWFrZXMgYSBuZXcgU0RIIHdoZW4gaXQgbmVlZHMgb25lXG4gICAgICAgICAgICAvLyBhbmQgb25lIGlzIG5vdCB5ZXQgZGVmaW5lZC4gVGh1cyBpZiB3ZSB1bmRlZmluZWQgaXQgaGVyZSwgaXQgd2lsbCBjdXJyZW50bHkgbWFrZSBhXG4gICAgICAgICAgICAvLyBuZXcgb25lIHdoaWNoIGlzIG91dCBvZiBzeW5jIGFuZCB0aGVuIG5ldmVyIGdldHMgY2xlYW5lZCB1cC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgZG93bnNpZGUgb2YgbGVhdmluZyBpdCBkZWZpbmVkIGFyZSB0aGF0IGNhbGxzIHRoaXMgY2xvc2VkIFNESCB3aWxsIGNvbnRpbnVlIHRvIGJlXG4gICAgICAgICAgICAvLyBtYWRlICh0aGluayBzZXREZXNjcmlwdGlvbikgYW5kIHRob3NlIHNob3VsZC93aWxsIGZhaWwuIFRoZXNlIGZhaWx1cmVzIGFyZSBoYW5kbGVkLCBidXRcbiAgICAgICAgICAgIC8vIGl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBpdCBhbGwgY29kZWQgdXAgaW4gYSB3YXkgd2hlcmUgaGF2aW5nIGFuIHVuZGVmaW5lZCBTREggd2hlcmVcbiAgICAgICAgICAgIC8vIG9uZSBpcyBleHBlY3RlZCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB0aGUgSW52aXRlci9JbnZpdGF0aW9uIHN1YiBjbGFzcyBkaXNwb3NlIG1ldGhvZCBoYW5kbGVzIHRoaXMgY2FzZVxuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZzpcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gdGhlIEludml0ZXIvSW52aXRhdGlvbiBzdWIgY2xhc3MgZGlzcG9zZSBtZXRob2QgaGFuZGxlcyB0aGlzIGNhc2VcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYnllKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWNjZXB0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlamVjdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nOlxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBub3RoaW5nIHRvIGJlIGRvbmVcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBub3RoaW5nIHRvIGJlIGRvbmVcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcImFzc2VydGVkSWRlbnRpdHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFzc2VydGVkIGlkZW50aXR5IG9mIHRoZSByZW1vdGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2VydGVkSWRlbnRpdHk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJkaWFsb2dcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbmZpcm1lZCBzZXNzaW9uIGRpYWxvZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpYWxvZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbi5wcm90b3R5cGUsIFwicmVwbGFjZWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlc3Npb24gYmVpbmcgcmVwbGFjZSBieSB0aGlzIG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbi5wcm90b3R5cGUsIFwic2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIuXG4gICAgICAgICAqIEByZW1hcmtzXG4gICAgICAgICAqIElmIGB0aGlzYCBpcyBhbiBpbnN0YW5jZSBvZiBgSW52aXRhdGlvbmAsXG4gICAgICAgICAqIGBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyYCB3aWxsIGJlIGRlZmluZWQgd2hlbiB0aGUgc2Vzc2lvbiBzdGF0ZSBjaGFuZ2VzIHRvIFwiZXN0YWJsaXNoZWRcIi5cbiAgICAgICAgICogSWYgYHRoaXNgIGlzIGFuIGluc3RhbmNlIG9mIGBJbnZpdGVyYCBhbmQgYW4gb2ZmZXIgd2FzIHNlbnQgaW4gdGhlIElOVklURSxcbiAgICAgICAgICogYHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJgIHdpbGwgYmUgZGVmaW5lZCB3aGVuIHRoZSBzZXNzaW9uIHN0YXRlIGNoYW5nZXMgdG8gXCJlc3RhYmxpc2hpbmdcIi5cbiAgICAgICAgICogSWYgYHRoaXNgIGlzIGFuIGluc3RhbmNlIG9mIGBJbnZpdGVyYCBhbmQgYW4gb2ZmZXIgd2FzIG5vdCBzZW50IGluIHRoZSBJTlZJVEUsXG4gICAgICAgICAqIGBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyYCB3aWxsIGJlIGRlZmluZWQgd2hlbiB0aGUgc2Vzc2lvbiBzdGF0ZSBjaGFuZ2VzIHRvIFwiZXN0YWJsaXNoZWRcIi5cbiAgICAgICAgICogT3RoZXJ3aXNlIGB1bmRlZmluZWRgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcInNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBmYWN0b3J5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VyQWdlbnQuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcInN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlc3Npb24gc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcInN0YXRlQ2hhbmdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlc3Npb24gc3RhdGUgY2hhbmdlIGVtaXR0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyXzEuX21ha2VFbWl0dGVyKHRoaXMuX3N0YXRlRXZlbnRFbWl0dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcInVzZXJBZ2VudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlciBhZ2VudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJBZ2VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRW5kIHRoZSB7QGxpbmsgU2Vzc2lvbn0uIFNlbmRzIGEgQllFLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIFNlZSB7QGxpbmsgU2Vzc2lvbkJ5ZU9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmJ5ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJTZXNzaW9uLmJ5ZSgpIG1heSBvbmx5IGJlIGNhbGxlZCBpZiBlc3RhYmxpc2hlZCBzZXNzaW9uLlwiO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIEhvd2V2ZXIgSW52aXRlci5pbnZpdGUoKSBoYXMgbm90IHlldCBiZWVuIGNhbGxlZC5cIjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBQZXJoYXBzIHlvdSBzaG91bGQgaGF2ZSBjYWxsZWQgSW52aXRlci5jYW5jZWwoKT9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMucmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIEludml0YXRpb24uYWNjZXB0KCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgUGVyaGFwcyB5b3Ugc2hvdWxkIGhhdmUgY2FsbGVkIEludml0YXRpb24ucmVqZWN0KCk/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FuY2VsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIGEgZGlhbG9nIGRvZXMgbm90IHlldCBleGlzdC5cIjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBQZXJoYXBzIHlvdSBzaG91bGQgaGF2ZSBjYWxsZWQgSW52aXRlci5jYW5jZWwoKT9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMucmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIEludml0YXRpb24uYWNjZXB0KCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQgKG9yIG5vdCB5ZXQgcmVzb2x2ZWQpLlwiO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIFBlcmhhcHMgeW91IHNob3VsZCBoYXZlIGNhbGxlZCBJbnZpdGF0aW9uLnJlamVjdCgpP1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZDpcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlbGVnYXRlID0gb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGU7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdGhpcy5jb3B5UmVxdWVzdE9wdGlvbnMob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5ZShyZXF1ZXN0RGVsZWdhdGUsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIEhvd2V2ZXIgdGhpcyBzZXNzaW9uIGlzIGFscmVhZHkgdGVybWluYXRpbmcuXCI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgUGVyaGFwcyB5b3UgaGF2ZSBhbHJlYWR5IGNhbGxlZCBJbnZpdGVyLmNhbmNlbCgpP1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5yZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIFBlcmhhcHMgeW91IGhhdmUgYWxyZWFkeSBjYWxsZWQgU2Vzc2lvbi5ieWUoKT9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIEhvd2V2ZXIgdGhpcyBzZXNzaW9uIGlzIGFscmVhZHkgdGVybWluYXRlZC5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgc2Vzc2lvbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoYXJlIHtAbGluayBJbmZvfSB3aXRoIHBlZXIuIFNlbmRzIGFuIElORk8uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBTZXNzaW9uSW5mb09wdGlvbnN9IGZvciBkZXRhaWxzLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBndWFyZCBzZXNzaW9uIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiU2Vzc2lvbi5pbmZvKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGlmIGVzdGFibGlzaGVkIHNlc3Npb24uXCI7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHNlc3Npb24gc3RhdGUgXCIgKyB0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3REZWxlZ2F0ZSA9IG9wdGlvbnMucmVxdWVzdERlbGVnYXRlO1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB0aGlzLmNvcHlSZXF1ZXN0T3B0aW9ucyhvcHRpb25zLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm8ocmVxdWVzdERlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5lZ290aWF0ZSB0aGUgc2Vzc2lvbi4gU2VuZHMgYSByZS1JTlZJVEUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBTZXNzaW9uSW52aXRlT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5pbnZpdGVcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBzZXNzaW9uIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZWludml0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBleGNlcHRpb25zXzEuUmVxdWVzdFBlbmRpbmdFcnJvcihcIlJlaW52aXRlIGluIHByb2dyZXNzLiBQbGVhc2Ugd2FpdCB1bnRpbCBjb21wbGV0ZSwgdGhlbiB0cnkgYWdhaW4uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdSZWludml0ZSA9IHRydWU7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgIG9uQWNjZXB0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHJlLUlOVklURSB0cmFuc2FjdGlvbiBoYXMgYW4gb2ZmZXIvYW5zd2VyIFtSRkMzMjY0XSBleGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBpdC4gIFRoZSBVQUMgKFVzZXIgQWdlbnQgQ2xpZW50KSBnZW5lcmF0aW5nIGEgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyByZS1JTlZJVEUgY2FuIGFjdCBhcyB0aGUgb2ZmZXJlciBvciBhcyB0aGUgYW5zd2VyZXIuICBBIFVBQyB3aWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gdG8gYWN0IGFzIHRoZSBvZmZlcmVyIGluY2x1ZGVzIGFuIG9mZmVyIGluIHRoZSByZS1JTlZJVEUuICBUaGUgVUFTXG4gICAgICAgICAgICAgICAgLy8gKFVzZXIgQWdlbnQgU2VydmVyKSB0aGVuIHByb3ZpZGVzIGFuIGFuc3dlciBpbiBhIHJlc3BvbnNlIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlLUlOVklURS4gIEEgVUFDIHdpbGxpbmcgdG8gYWN0IGFzIGFuc3dlcmVyIGRvZXMgbm90IGluY2x1ZGUgYW5cbiAgICAgICAgICAgICAgICAvLyBvZmZlciBpbiB0aGUgcmUtSU5WSVRFLiAgVGhlIFVBUyB0aGVuIHByb3ZpZGVzIGFuIG9mZmVyIGluIGEgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgcmUtSU5WSVRFIGJlY29taW5nLCB0aHVzLCB0aGUgb2ZmZXJlci5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjE0MSNzZWN0aW9uLTFcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGNvcmVfMS5nZXRCb2R5KHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJSZWNlaXZlZCAyeHggcmVzcG9uc2UgdG8gcmUtSU5WSVRFIHdpdGhvdXQgYSBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2tBbmRCeWUocmVzcG9uc2UsIDQwMCwgXCJNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aXRob3V0U2RwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElOVklURSB3aXRob3V0IFNEUCAtIHNldCByZW1vdGUgb2ZmZXIgYW5kIHNlbmQgYW4gYW5zd2VyIGluIHRoZSBBQ0tcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFNESCBvcHRpb25zICYgU0RIIG1vZGlmaWVycyBvcHRpb25zIGFyZSBhcHBsaWVkIHNvbWV3aGF0IGFtYmlndW91c2x5XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICBUaGlzIGJlaGF2aW9yIHdhcyBwb3J0ZWQgZnJvbSBsZWdhY3kgY29kZSBhbmQgdGhlIGlzc3VlIHB1bnRlZCBkb3duIHRoZSByb2FkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zd2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyczogb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9mZmVyQW5kR2V0QW5zd2VyKGJvZHksIGFuc3dlck9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYW5zd2VyQm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYWNrKHsgYm9keTogYW5zd2VyQm9keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHdheSB0byByZWNvdmVyLCBzbyB0ZXJtaW5hdGUgc2Vzc2lvbiBhbmQgbWFyayBhcyBmYWlsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gaGFuZGxlIG9mZmVyIGluIDJ4eCByZXNwb25zZSB0byByZS1JTlZJVEVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBub3QgYmUgc2VudCBpZiBhbHJlYWR5IHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFja0FuZEJ5ZShyZXNwb25zZSwgNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uQWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElOVklURSB3aXRoIFNEUCAtIHNldCByZW1vdGUgYW5zd2VyIGFuZCBzZW5kIGFuIEFDS1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogU0RIIG9wdGlvbnMgJiBTREggbW9kaWZpZXJzIG9wdGlvbnMgYXJlIGFwcGxpZWQgc29tZXdoYXQgYW1iaWd1b3VzbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIFRoaXMgYmVoYXZpb3Igd2FzIHBvcnRlZCBmcm9tIGxlZ2FjeSBjb2RlIGFuZCB0aGUgaXNzdWUgcHVudGVkIGRvd24gdGhlIHJvYWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnN3ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IF90aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IF90aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFuc3dlcihib2R5LCBhbnN3ZXJPcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGhhbmRsZSBhbnN3ZXIgaW4gMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgc2Vzc2lvbiBpcyBub3QgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBBQ0sgbmVlZHMgdG8gYmUgc2VudCByZWdhcmRsZXNzIGFzIGl0IHdhcyBub3QgaGFuZGxlZCBieSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFja0FuZEJ5ZShyZXNwb25zZSwgNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vbkFjY2VwdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWRpcmVjdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIlJlY2VpdmVkIGEgbm9uLTJ4eCByZXNwb25zZSB0byByZS1JTlZJVEVcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFNkcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucm9sbGJhY2tPZmZlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHJvbGxiYWNrIG9mZmVyIG9uIG5vbi0yeHggcmVzcG9uc2UgdG8gcmUtSU5WSVRFXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBCWUUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBzZXNzaW9uIGlzIG5vdCBhbHJlYWR5IHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYSBCWUUgbWF5IGJlIHNlbnQvcmVjZWl2ZWQgd2hpbGUgcmUtSU5WSVRFIGlzIG91dHN0YW5kaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBBQ0sgd2FzIGFscmVhZHkgc2VudCBieSB0aGUgdHJhbnNhY3Rpb24sIHNvIGp1c3QgbmVlZCB0byBzZW5kIEJZRS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlYXNvbjogXCIgKyBfdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg1MDAsIFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMgfHwge307XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycyA9IChyZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiQWxsb3c6IFwiICsgYWxsb3dlZF9tZXRob2RzXzEuQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLl9jb250YWN0KTtcbiAgICAgICAgLy8gSnVzdCBzZW5kIGFuIElOVklURSB3aXRoIG5vIHNkcC4uLlxuICAgICAgICBpZiAob3B0aW9ucy53aXRob3V0U2RwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5kaWFsb2cuaW52aXRlKGRlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBhbiBvZmZlciBhbmQgc2VuZCBpdCBpbiBhbiBJTlZJVEVcbiAgICAgICAgLy8gRklYTUU6IFNESCBvcHRpb25zICYgU0RIIG1vZGlmaWVycyBvcHRpb25zIGFyZSBhcHBsaWVkIHNvbWV3aGF0IGFtYmlndW91c2x5XG4gICAgICAgIC8vICAgICAgICBUaGlzIGJlaGF2aW9yIHdhcyBwb3J0ZWQgZnJvbSBsZWdhY3kgY29kZSBhbmQgdGhlIGlzc3VlIHB1bnRlZCBkb3duIHRoZSByb2FkLlxuICAgICAgICB2YXIgb2ZmZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmZXIob2ZmZXJPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9mZmVyQm9keSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBvZmZlckJvZHk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZGlhbG9nLmludml0ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgcmUtSU5WSVRFXCIpO1xuICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxpdmVyIGEge0BsaW5rIE1lc3NhZ2V9LiBTZW5kcyBhIE1FU1NBR0UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBTZXNzaW9uTWVzc2FnZU9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBndWFyZCBzZXNzaW9uIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiU2Vzc2lvbi5tZXNzYWdlKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGlmIGVzdGFibGlzaGVkIHNlc3Npb24uXCI7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHNlc3Npb24gc3RhdGUgXCIgKyB0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3REZWxlZ2F0ZSA9IG9wdGlvbnMucmVxdWVzdERlbGVnYXRlO1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB0aGlzLmNvcHlSZXF1ZXN0T3B0aW9ucyhvcHRpb25zLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2UocmVxdWVzdERlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9mZmVyIGEge0BsaW5rIFJlZmVycmFsfS4gU2VuZCBhIFJFRkVSLlxuICAgICAqIEBwYXJhbSByZWZlclRvIC0gVGhlIHJlZmVycmFsIHRhcmdldC4gSWYgYSBgU2Vzc2lvbmAsIGEgUkVGRVIgdy9SZXBsYWNlcyBpcyBzZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIFNlZSB7QGxpbmsgU2Vzc2lvblJlZmVyT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVmZXIgPSBmdW5jdGlvbiAocmVmZXJUbywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBndWFyZCBzZXNzaW9uIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiU2Vzc2lvbi5yZWZlcigpIG1heSBvbmx5IGJlIGNhbGxlZCBpZiBlc3RhYmxpc2hlZCBzZXNzaW9uLlwiO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBzZXNzaW9uIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0RGVsZWdhdGUgPSBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZTtcbiAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdGhpcy5jb3B5UmVxdWVzdE9wdGlvbnMob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycyA/XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMuY29uY2F0KHRoaXMucmVmZXJFeHRyYUhlYWRlcnModGhpcy5yZWZlclRvU3RyaW5nKHJlZmVyVG8pKSkgOlxuICAgICAgICAgICAgdGhpcy5yZWZlckV4dHJhSGVhZGVycyh0aGlzLnJlZmVyVG9TdHJpbmcocmVmZXJUbykpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmZXIob3B0aW9ucy5vbk5vdGlmeSwgcmVxdWVzdERlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIEJZRS5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fYnllID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFVzaW5nIGNvcmUgc2Vzc2lvbiBkaWFsb2dcbiAgICAgICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlNlc3Npb24gZGlhbG9nIHVuZGVmaW5lZC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLmRpYWxvZztcbiAgICAgICAgLy8gVGhlIGNhbGxlcidzIFVBIE1BWSBzZW5kIGEgQllFIGZvciBlaXRoZXIgY29uZmlybWVkIG9yIGVhcmx5IGRpYWxvZ3MsXG4gICAgICAgIC8vIGFuZCB0aGUgY2FsbGVlJ3MgVUEgTUFZIHNlbmQgYSBCWUUgb24gY29uZmlybWVkIGRpYWxvZ3MsIGJ1dCBNVVNUIE5PVFxuICAgICAgICAvLyBzZW5kIGEgQllFIG9uIGVhcmx5IGRpYWxvZ3MuIEhvd2V2ZXIsIHRoZSBjYWxsZWUncyBVQSBNVVNUIE5PVCBzZW5kIGFcbiAgICAgICAgLy8gQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZyB1bnRpbCBpdCBoYXMgcmVjZWl2ZWQgYW4gQUNLIGZvciBpdHMgMnh4XG4gICAgICAgIC8vIHJlc3BvbnNlIG9yIHVudGlsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1XG4gICAgICAgIHN3aXRjaCAoZGlhbG9nLnNlc3Npb25TdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2Vzc2lvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaWFsb2cgc3RhdGUgXCIgKyBkaWFsb2cuc2Vzc2lvblN0YXRlKTtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5FYXJseTogLy8gSW1wbGVtZW50YXRpb24gY2hvaWNlIC0gbm90IHNlbmRpbmcgQllFIGZvciBlYXJseSBkaWFsb2dzLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlhbG9nIHN0YXRlIFwiICsgZGlhbG9nLnNlc3Npb25TdGF0ZSk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuQWNrV2FpdDogeyAvLyBUaGlzIHN0YXRlIG9ubHkgb2NjdXJzIGlmIHdlIGFyZSB0aGUgY2FsbGVlLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRpbmcpOyAvLyBXZSdyZSB0ZXJtaW5hdGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gQUNLIHNob3dzIHVwLCBzYXkgQllFLlxuICAgICAgICAgICAgICAgICAgICAgICAgb25BY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGRpYWxvZy5ieWUoZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3IgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiB0aW1lcyBvdXQgYmVmb3JlIHRoZSBBQ0sgYXJyaXZlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWNrVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gZGlhbG9nLmJ5ZShkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5Db25maXJtZWQ6IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGRpYWxvZy5ieWUoZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlhbG9nIHN0YXRlIFwiICsgZGlhbG9nLnNlc3Npb25TdGF0ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgSU5GTy5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5faW5mbyA9IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBVc2luZyBjb3JlIHNlc3Npb24gZGlhbG9nXG4gICAgICAgIGlmICghdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIGRpYWxvZyB1bmRlZmluZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGlhbG9nLmluZm8oZGVsZWdhdGUsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgTUVTU0FHRS5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBVc2luZyBjb3JlIHNlc3Npb24gZGlhbG9nXG4gICAgICAgIGlmICghdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIGRpYWxvZyB1bmRlZmluZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGlhbG9nLm1lc3NhZ2UoZGVsZWdhdGUsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgUkVGRVIuXG4gICAgICogQHBhcmFtIG9uTm90aWZ5IC0gTm90aWZpY2F0aW9uIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnMgYnVja2V0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl9yZWZlciA9IGZ1bmN0aW9uIChvbk5vdGlmeSwgZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVXNpbmcgY29yZSBzZXNzaW9uIGRpYWxvZ1xuICAgICAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU2Vzc2lvbiBkaWFsb2cgdW5kZWZpbmVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc2V0LCBkZWxpdmVyIGFueSBpbi1kaWFsb2cgTk9USUZZIHJlcXVlc3RzIGhlcmUuLi5cbiAgICAgICAgdGhpcy5vbk5vdGlmeSA9IG9uTm90aWZ5O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGlhbG9nLnJlZmVyKGRlbGVnYXRlLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIEFDSyBhbmQgdGhlbiBCWUUuIFRoZXJlIGFyZSB1bnJlY292ZXJhYmxlIGVycm9ycyB3aGljaCBjYW4gb2NjdXJcbiAgICAgKiB3aGlsZSBoYW5kbGluZyBkaWFsb2cgZm9ybWluZyBhbmQgaW4tZGlhbG9nIElOVklURSByZXNwb25zZXMgYW5kIHdoZW5cbiAgICAgKiB0aGV5IG9jY3VyIHdlIEFDSyB0aGUgcmVzcG9uc2UgYW5kIHNlbmQgYSBCWUUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBCWUUgaXMgc2VudCBpbiB0aGUgZGlhbG9nIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgICAgKiB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHkgYHRoaXMuZGlhbG9nYC4gQW5kLCBhY2NvcmRpbmdseSwgdGhlXG4gICAgICogc2Vzc2lvbiBzdGF0ZSBpcyBub3QgdHJhbnNpdGlvbmVkIHRvIHRlcm1pbmF0ZWQgYW5kIHNlc3Npb24gaXMgbm90IGNsb3NlZC5cbiAgICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgY2F1c2luZyB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHN0YXR1c0NvZGUgLSBTdGF0dXMgY29kZSBmb3IgaGUgcmVhc29uIHBocmFzZS5cbiAgICAgKiBAcGFyYW0gcmVhc29uUGhyYXNlIC0gUmVhc29uIHBocmFzZSBmb3IgdGhlIEJZRS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5hY2tBbmRCeWUgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSkge1xuICAgICAgICByZXNwb25zZS5hY2soKTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZWFzb246IFwiICsgdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2luZyB0aGUgZGlhbG9nIHNlc3Npb24gYXNzb2NpYXRlIHdpdGggdGhlIHJlc3BvbnNlICh3aGljaCBtaWdodCBub3QgYmUgdGhpcy5kaWFsb2cpXG4gICAgICAgIHJlc3BvbnNlLnNlc3Npb24uYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgQUNLIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25BY2tSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vbkFja1JlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkICYmIHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQUNLIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBkcm9wcGluZyByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLmRpYWxvZztcbiAgICAgICAgaWYgKCFkaWFsb2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZGlhbG9nLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOiB7XG4gICAgICAgICAgICAgICAgLy8gU3RhdGUgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYXMgZmlyc3QgcmVsaWFibGUgcmVzcG9uc2UgbXVzdCBoYXZlIGFuc3dlci9vZmZlci5cbiAgICAgICAgICAgICAgICAvLyBTbyB3ZSBtdXN0IGhhdmUgbmV2ZXIgaGFzIHNlbnQgYW4gb2ZmZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSBcIiArIGRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW1wiUmVhc29uOiBcIiArIHRoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKV07XG4gICAgICAgICAgICAgICAgZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU6IHtcbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSB3ZSBzaG91bGQgYmUgaW4uXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoZSBBQ0sgaGFzIHRoZSBhbnN3ZXIgdGhhdCBnb3QgdXMgaGVyZSwgb3Igd2Ugd2VyZSBpbiB0aGlzIHN0YXRlIHByaW9yIHRvIHRoZSBBQ0suXG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBjb3JlXzEuZ2V0Qm9keShyZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBBQ0sgZG9lc24ndCBoYXZlIGFuIGFuc3dlciwgbm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChib2R5LmNvbnRlbnREaXNwb3NpdGlvbiA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJib2R5ID0gYm9keS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJ0eXBlID0gYm9keS5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm9keS5jb250ZW50RGlzcG9zaXRpb24gIT09IFwic2Vzc2lvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjZWl2ZWQgYW5zd2VyIGluIEFDSy5cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuc3dlcihib2R5LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtcIlJlYXNvbjogXCIgKyBfdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg0ODgsIFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOiB7XG4gICAgICAgICAgICAgICAgLy8gU3RhdGUgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYXMgbG9jYWwgb2ZmZXIgd291bGQgYmUgYW5zd2VyZWQgYnkgdGhpcyBBQ0suXG4gICAgICAgICAgICAgICAgLy8gU28gd2UgbXVzdCBoYXZlIHJlY2VpdmVkIGFuIEFDSyB3aXRob3V0IGFuIGFuc3dlci5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgZGlhbG9nLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXCJSZWFzb246IFwiICsgdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg0ODgsIFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCIpXTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjoge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRlIHNob3VsZCBuZXZlciBiZSByZWFjaGVkIGFzIHJlbW90ZSBvZmZlciB3b3VsZCBiZSBhbnN3ZXJlZCBpbiBmaXJzdCByZWxpYWJsZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyBTbyB3ZSBtdXN0IGhhdmUgbmV2ZXIgaGFzIHNlbnQgYW4gYW5zd2VyLlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyBkaWFsb2cuc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtcIlJlYXNvbjogXCIgKyB0aGlzLmdldFJlYXNvbkhlYWRlclZhbHVlKDQ4OCwgXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIildO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5ieWUodW5kZWZpbmVkLCB7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgZGlhbG9nLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSBcIiArIGRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluIGRpYWxvZyBCWUUgcmVxdWVzdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vbkJ5ZVJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uLm9uQnllUmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQllFIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBkcm9wcGluZyByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25CeWUpIHtcbiAgICAgICAgICAgIHZhciBieWUgPSBuZXcgYnllXzEuQnllKHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkJ5ZShieWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluIGRpYWxvZyBJTkZPIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25JbmZvUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25JbmZvUmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiSU5GTyByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uSW5mbykge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBuZXcgaW5mb18xLkluZm8ocmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW5mbyhpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBXZSBzaG91bGQgcmVqZWN0IHJlcXVlc3QuLi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBhIFVBIHJlY2VpdmVzIGFuIElORk8gcmVxdWVzdCBhc3NvY2lhdGVkIHdpdGggYW4gSW5mbyBQYWNrYWdlIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBVQSBoYXMgbm90IGluZGljYXRlZCB3aWxsaW5nbmVzcyB0byByZWNlaXZlLCB0aGUgVUEgTVVTVCBzZW5kIGFcbiAgICAgICAgICAgIC8vIDQ2OSAoQmFkIEluZm8gUGFja2FnZSkgcmVzcG9uc2UgKHNlZSBTZWN0aW9uIDExLjYpLCB3aGljaCBjb250YWlucyBhXG4gICAgICAgICAgICAvLyBSZWN2LUluZm8gaGVhZGVyIGZpZWxkIHdpdGggSW5mbyBQYWNrYWdlcyBmb3Igd2hpY2ggdGhlIFVBIGlzIHdpbGxpbmdcbiAgICAgICAgICAgIC8vIHRvIHJlY2VpdmUgSU5GTyByZXF1ZXN0cy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDg2I3NlY3Rpb24tNC4yLjJcbiAgICAgICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgSU5WSVRFIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25JbnZpdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vbkludml0ZVJlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIklOVklURSByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgY29yZSB0cmFjayBhbmQgc2V0IHRoZSBDb250YWN0IGhlYWRlcixcbiAgICAgICAgLy8gYnV0IGN1cnJlbnRseSB0aGUgc2Vzc2lvbiB3aGljaCBpcyBzZXR0aW5nIGl0IGlzIGhvbGRpbmcgb250byBpdC5cbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtcIkNvbnRhY3Q6IFwiICsgdGhpcy5fY29udGFjdF07XG4gICAgICAgIC8vIEhhbmRsZSBQLUFzc2VydGVkLUlkZW50aXR5XG4gICAgICAgIGlmIChyZXF1ZXN0Lm1lc3NhZ2UuaGFzSGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHJlcXVlc3QubWVzc2FnZS5nZXRIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpO1xuICAgICAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXIgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydGVkSWRlbnRpdHkgPSBjb3JlXzEuR3JhbW1hci5uYW1lQWRkckhlYWRlclBhcnNlKGhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRklYTUU6IFNESCBvcHRpb25zICYgU0RIIG1vZGlmaWVycyBvcHRpb25zIGFyZSBhcHBsaWVkIHNvbWV3aGF0IGFtYmlndW91c2x5XG4gICAgICAgIC8vICAgICAgICBUaGlzIGJlaGF2aW9yIHdhcyBwb3J0ZWQgZnJvbSBsZWdhY3kgY29kZSBhbmQgdGhlIGlzc3VlIHB1bnRlZCBkb3duIHRoZSByb2FkLlxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXJJbkRpYWxvZyhvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHZhciBvdXRnb2luZ1Jlc3BvbnNlID0gcmVxdWVzdC5hY2NlcHQoeyBzdGF0dXNDb2RlOiAyMDAsIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRlbGVnYXRlICYmIF90aGlzLmRlbGVnYXRlLm9uSW52aXRlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUocmVxdWVzdC5tZXNzYWdlLCBvdXRnb2luZ1Jlc3BvbnNlLm1lc3NhZ2UsIDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gaGFuZGxlIHRvIHJlLUlOVklURSByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihfdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGxvY2FsL3JlbW90ZSBvZmZlci4uLlxuICAgICAgICAgICAgaWYgKF90aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZSA9PT0gY29yZV8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRnb2luZ1Jlc3BvbnNlID0gcmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODggfSk7IC8vIE5vdCBBY2NlcHRhYmxlIEhlcmVcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVsZWdhdGUgJiYgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUocmVxdWVzdC5tZXNzYWdlLCBvdXRnb2luZ1Jlc3BvbnNlLm1lc3NhZ2UsIDQ4OCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByb2xsYmFja1xuICAgICAgICAgICAgX3RoaXMucm9sbGJhY2tPZmZlcigpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRnb2luZ1Jlc3BvbnNlID0gcmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODggfSk7IC8vIE5vdCBBY2NlcHRhYmxlIEhlcmVcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVsZWdhdGUgJiYgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUocmVxdWVzdC5tZXNzYWdlLCBvdXRnb2luZ1Jlc3BvbnNlLm1lc3NhZ2UsIDQ4OCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yUm9sbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvclJvbGxiYWNrLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byByb2xsYmFjayBvZmZlciBvbiByZS1JTlZJVEUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdSZXNwb25zZSA9IHJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg4IH0pOyAvLyBOb3QgQWNjZXB0YWJsZSBIZXJlXG4gICAgICAgICAgICAgICAgLy8gQSBCWUUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBzZXNzaW9uIGlzIG5vdCBhbHJlYWR5IHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIEFDSyB3YXMgYWxyZWFkeSBzZW50IGJ5IHRoZSB0cmFuc2FjdGlvbiwgc28ganVzdCBuZWVkIHRvIHNlbmQgQllFLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXJzQnllID0gW107XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyc0J5ZS5wdXNoKFwiUmVhc29uOiBcIiArIF90aGlzLmdldFJlYXNvbkhlYWRlclZhbHVlKDUwMCwgXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZWxlZ2F0ZSAmJiBfdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxlZ2F0ZS5vbkludml0ZShyZXF1ZXN0Lm1lc3NhZ2UsIG91dGdvaW5nUmVzcG9uc2UubWVzc2FnZSwgNDg4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgaW4gZGlhbG9nIE1FU1NBR0UgcmVxdWVzdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vbk1lc3NhZ2VSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vbk1lc3NhZ2VSZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJNRVNTQUdFIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBkcm9wcGluZyByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25NZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBtZXNzYWdlXzEuTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluIGRpYWxvZyBOT1RJRlkgcmVxdWVzdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vbk5vdGlmeVJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uLm9uTm90aWZ5UmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTk9USUZZIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBkcm9wcGluZyByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgYSBOT1RJRlkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9ncmVzcyBvZiBhIFJFRkVSLFxuICAgICAgICAvLyBsb29rIHRvIGRlbGVnYXRlIGhhbmRsaW5nIHRvIHRoZSBhc3NvY2lhdGVkIGNhbGxiYWNrLlxuICAgICAgICBpZiAodGhpcy5vbk5vdGlmeSkge1xuICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IG5ldyBub3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24ocmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLm9uTm90aWZ5KG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFjY2VwdCB0aGUgTk9USUZZLlxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KSB7XG4gICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9uID0gbmV3IG5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbihyZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgUFJBQ0sgcmVxdWVzdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vblByYWNrUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25QcmFja1JlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlBSQUNLIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBkcm9wcGluZyByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQuXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluIGRpYWxvZyBSRUZFUiByZXF1ZXN0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uUmVmZXJSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vblJlZmVyUmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiUkVGRVIgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlICsgXCIsIGRyb3BwaW5nIHJlcXVlc3RcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUkVGRVIgaXMgYSBTSVAgcmVxdWVzdCBhbmQgaXMgY29uc3RydWN0ZWQgYXMgZGVmaW5lZCBpbiBbMV0uICBBIFJFRkVSXG4gICAgICAgIC8vIHJlcXVlc3QgTVVTVCBjb250YWluIGV4YWN0bHkgb25lIFJlZmVyLVRvIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuMVxuICAgICAgICBpZiAoIXJlcXVlc3QubWVzc2FnZS5oYXNIZWFkZXIoXCJyZWZlci10b1wiKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkludmFsaWQgUkVGRVIgcGFja2V0LiBBIHJlZmVyLXRvIGhlYWRlciBpcyByZXF1aXJlZC4gUmVqZWN0aW5nLlwiKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVqZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZmVycmFsID0gbmV3IHJlZmVycmFsXzEuUmVmZXJyYWwocmVxdWVzdCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWZlcikge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZmVyKHJlZmVycmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIk5vIGRlbGVnYXRlIGF2YWlsYWJsZSB0byBoYW5kbGUgUkVGRVIsIGF1dG9tYXRpY2FsbHkgYWNjZXB0aW5nIGFuZCBmb2xsb3dpbmcuXCIpO1xuICAgICAgICAgICAgcmVmZXJyYWxcbiAgICAgICAgICAgICAgICAuYWNjZXB0KClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZWZlcnJhbFxuICAgICAgICAgICAgICAgIC5tYWtlSW52aXRlcihfdGhpcy5fcmVmZXJyYWxJbnZpdGVyT3B0aW9ucylcbiAgICAgICAgICAgICAgICAuaW52aXRlKCk7IH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBsb2dnaW5nIGFuZCBlYXRpbmcgZXJyb3IuLi5cbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gb2ZmZXIgb3IgYW5zd2VyIGZvciBhIHJlc3BvbnNlIHRvIGFuIElOVklURSByZXF1ZXN0LlxuICAgICAqIElmIGEgcmVtb3RlIG9mZmVyIHdhcyBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdCwgc2V0IHRoZSByZW1vdGVcbiAgICAgKiBkZXNjcmlwdGlvbiBhbmQgZ2V0IGEgbG9jYWwgYW5zd2VyLiBJZiBhIHJlbW90ZSBvZmZlciB3YXMgbm90XG4gICAgICogcHJvdmlkZWQsIGdlbmVyYXRlcyBhIGxvY2FsIG9mZmVyLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlciA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VySW5EaWFsb2cob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBjb3JlXzEuZ2V0Qm9keShyZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICBpZiAoIWJvZHkgfHwgYm9keS5jb250ZW50RGlzcG9zaXRpb24gIT09IFwic2Vzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPZmZlcihvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE9mZmVyQW5kR2V0QW5zd2VyKGJvZHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvZmZlciBvciBhbnN3ZXIgZm9yIGEgcmVzcG9uc2UgdG8gYW4gSU5WSVRFIHJlcXVlc3RcbiAgICAgKiB3aGVuIGEgZGlhbG9nIChlYXJseSBvciBvdGhlcndpc2UpIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWQuXG4gICAgICogVGhpcyBtZXRob2QgbWF5IE5PVCBiZSBjYWxsZWQgaWYgYSBkaWFsb2cgaGFzIHlldCB0byBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXJJbkRpYWxvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgICAgICAgICAvLyBvICBPbmNlIHRoZSBVQVMgaGFzIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAgICAgLy8gb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgaW5pdGlhbCBJTlZJVEUuICBUaGlzIG1lYW5zIHRoYXQgYSBVQVMgYmFzZWQgb24gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYXRpb24gYWxvbmUgY2FuIG5ldmVyIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIHVudGlsXG4gICAgICAgICAgICAgICAgLy8gY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlhbG9nLm9mZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gb2ZmZXIgdW5kZWZpbmVkIGluIHNpZ25hbGluZyBzdGF0ZSBcIiArIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRPZmZlckFuZEdldEFuc3dlcih0aGlzLmRpYWxvZy5vZmZlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgICAgICAgICAgLy8gbyAgT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIGRpYWxvZyBJTlZJVEUgd2l0aG91dCBvZmZlciwgZ2V0IGFuIG9mZmVyIGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGxvY2FsIG9mZmVyLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmdldE9mZmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNkaCA9IHRoaXMuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIHZhciBzZGhPcHRpb25zID0gb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucztcbiAgICAgICAgdmFyIHNkaE1vZGlmaWVycyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycztcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gdmVyeSBkZWZlbnNpdmVseS4gRG9uJ3QgdHJ1c3QgU0RIIHRvIGJlaGF2ZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZGguZ2V0RGVzY3JpcHRpb24oc2RoT3B0aW9ucywgc2RoTW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5QW5kQ29udGVudFR5cGUpIHsgcmV0dXJuIGNvcmVfMS5mcm9tQm9keUxlZ2FjeShib2R5QW5kQ29udGVudFR5cGUpOyB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJTZXNzaW9uLmdldE9mZmVyOiBTREggZ2V0RGVzY3JpcHRpb24gcmVqZWN0ZWQuLi5cIik7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgLy8gZG9uJ3QgdHJ1c3QgU0RIIHRvIHRocm93IGFuIEVycm9yXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uZ2V0T2ZmZXI6IFNESCBnZXREZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJvbGxiYWNrIGxvY2FsL3JlbW90ZSBvZmZlci5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yb2xsYmFja09mZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2RoID0gdGhpcy5zZXR1cFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgaWYgKCFzZGgucm9sbGJhY2tEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIHZlcnkgZGVmZW5zaXZlbHkuIERvbid0IHRydXN0IFNESCB0byBiZWhhdmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc2RoLnJvbGxiYWNrRGVzY3JpcHRpb24oKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJTZXNzaW9uLnJvbGxiYWNrT2ZmZXI6IFNESCByb2xsYmFja0Rlc2NyaXB0aW9uIHJlamVjdGVkLi4uXCIpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IC8vIGRvbid0IHRydXN0IFNESCB0byB0aHJvdyBhbiBFcnJvclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJTZXNzaW9uLnJvbGxiYWNrT2ZmZXI6IFNESCByb2xsYmFja0Rlc2NyaXB0aW9uIHRocmV3Li4uXCIpO1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHJlbW90ZSBhbnN3ZXIuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc2V0QW5zd2VyID0gZnVuY3Rpb24gKGFuc3dlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2RoID0gdGhpcy5zZXR1cFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgdmFyIHNkaE9wdGlvbnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zO1xuICAgICAgICB2YXIgc2RoTW9kaWZpZXJzID0gb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzO1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiB2ZXJ5IGRlZmVuc2l2ZWx5LiBEb24ndCB0cnVzdCBTREggdG8gYmVoYXZlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFzZGguaGFzRGVzY3JpcHRpb24oYW5zd2VyLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXhjZXB0aW9uc18xLkNvbnRlbnRUeXBlVW5zdXBwb3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRBbnN3ZXI6IFNESCBoYXNEZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZGguc2V0RGVzY3JpcHRpb24oYW5zd2VyLmNvbnRlbnQsIHNkaE9wdGlvbnMsIHNkaE1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRBbnN3ZXI6IFNESCBzZXREZXNjcmlwdGlvbiByZWplY3RlZC4uLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRBbnN3ZXI6IFNESCBzZXREZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCByZW1vdGUgb2ZmZXIgYW5kIGdldCBsb2NhbCBhbnN3ZXIuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIgPSBmdW5jdGlvbiAob2ZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNkaCA9IHRoaXMuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIHZhciBzZGhPcHRpb25zID0gb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucztcbiAgICAgICAgdmFyIHNkaE1vZGlmaWVycyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycztcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gdmVyeSBkZWZlbnNpdmVseS4gRG9uJ3QgdHJ1c3QgU0RIIHRvIGJlaGF2ZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghc2RoLmhhc0Rlc2NyaXB0aW9uKG9mZmVyLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXhjZXB0aW9uc18xLkNvbnRlbnRUeXBlVW5zdXBwb3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRPZmZlckFuZEdldEFuc3dlcjogU0RIIGhhc0Rlc2NyaXB0aW9uIHRocmV3Li4uXCIpO1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNkaC5zZXREZXNjcmlwdGlvbihvZmZlci5jb250ZW50LCBzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2RoLmdldERlc2NyaXB0aW9uKHNkaE9wdGlvbnMsIHNkaE1vZGlmaWVycyk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHlBbmRDb250ZW50VHlwZSkgeyByZXR1cm4gY29yZV8xLmZyb21Cb2R5TGVnYWN5KGJvZHlBbmRDb250ZW50VHlwZSk7IH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0T2ZmZXJBbmRHZXRBbnN3ZXI6IFNESCBzZXREZXNjcmlwdGlvbiBvciBnZXREZXNjcmlwdGlvbiByZWplY3RlZC4uLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRPZmZlckFuZEdldEFuc3dlcjogU0RIIHNldERlc2NyaXB0aW9uIG9yIGdldERlc2NyaXB0aW9uIHRocmV3Li4uXCIpO1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU0RIIGZvciBjb25maXJtZWQgZGlhbG9nLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnNldFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoc2RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHNkaDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNESCBmb3IgY29uZmlybWVkIGRpYWxvZy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5zZXR1cFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkodGhpcywgdGhpcy51c2VyQWdlbnQuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gc2Vzc2lvbiBzdGF0ZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5zdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGludmFsaWRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gXCIgKyBfdGhpcy5fc3RhdGUgKyBcIiB0byBcIiArIG5ld1N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVmFsaWRhdGUgdHJhbnNpdGlvblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nOlxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkOlxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nOlxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHN0YXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFuc2l0aW9uXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24gXCIgKyB0aGlzLmlkICsgXCIgdHJhbnNpdGlvbmVkIHRvIHN0YXRlIFwiICsgdGhpcy5fc3RhdGUpO1xuICAgICAgICB0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlci5lbWl0KFwiZXZlbnRcIiwgdGhpcy5fc3RhdGUpO1xuICAgICAgICAvLyBEaXNwb3NlXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuY29weVJlcXVlc3RPcHRpb25zID0gZnVuY3Rpb24gKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucyA9PT0gdm9pZCAwKSB7IHJlcXVlc3RPcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycyA/IHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycy5zbGljZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYm9keSA9IHJlcXVlc3RPcHRpb25zLmJvZHkgP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcmVxdWVzdE9wdGlvbnMuYm9keS5jb250ZW50RGlzcG9zaXRpb24gfHwgXCJyZW5kZXJcIixcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVxdWVzdE9wdGlvbnMuYm9keS5jb250ZW50VHlwZSB8fCBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiByZXF1ZXN0T3B0aW9ucy5ib2R5LmNvbnRlbnQgfHwgXCJcIlxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICB9O1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZ2V0UmVhc29uSGVhZGVyVmFsdWUgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHZhciBjYXVzZSA9IGNvZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gdXRpbHNfMS5nZXRSZWFzb25QaHJhc2UoY29kZSk7XG4gICAgICAgIGlmICghdGV4dCAmJiByZWFzb24pIHtcbiAgICAgICAgICAgIHRleHQgPSByZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiU0lQO2NhdXNlPVwiICsgY2F1c2UgKyAnO3RleHQ9XCInICsgdGV4dCArICdcIic7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWZlckV4dHJhSGVhZGVycyA9IGZ1bmN0aW9uIChyZWZlclRvKSB7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZWZlcnJlZC1CeTogPFwiICsgdGhpcy51c2VyQWdlbnQuY29uZmlndXJhdGlvbi51cmkgKyBcIj5cIik7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLl9jb250YWN0KTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJBbGxvdzogXCIgKyBbXG4gICAgICAgICAgICBcIkFDS1wiLFxuICAgICAgICAgICAgXCJDQU5DRUxcIixcbiAgICAgICAgICAgIFwiSU5WSVRFXCIsXG4gICAgICAgICAgICBcIk1FU1NBR0VcIixcbiAgICAgICAgICAgIFwiQllFXCIsXG4gICAgICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgICAgIFwiSU5GT1wiLFxuICAgICAgICAgICAgXCJOT1RJRllcIixcbiAgICAgICAgICAgIFwiUkVGRVJcIlxuICAgICAgICBdLnRvU3RyaW5nKCkpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlZmVyLVRvOiBcIiArIHJlZmVyVG8pO1xuICAgICAgICByZXR1cm4gZXh0cmFIZWFkZXJzO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVmZXJUb1N0cmluZyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHJlZmVyVG87XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBjb3JlXzEuVVJJKSB7XG4gICAgICAgICAgICAvLyBSRUZFUiB3aXRob3V0IFJlcGxhY2VzIChCbGluZCBUcmFuc2ZlcilcbiAgICAgICAgICAgIHJlZmVyVG8gPSB0YXJnZXQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJFRkVSIHdpdGggUmVwbGFjZXMgKEF0dGVuZGVkIFRyYW5zZmVyKVxuICAgICAgICAgICAgaWYgKCF0YXJnZXQuZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0YXJnZXQucmVtb3RlSWRlbnRpdHkuZnJpZW5kbHlOYW1lO1xuICAgICAgICAgICAgdmFyIHJlbW90ZVRhcmdldCA9IHRhcmdldC5kaWFsb2cucmVtb3RlVGFyZ2V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgY2FsbElkID0gdGFyZ2V0LmRpYWxvZy5jYWxsSWQ7XG4gICAgICAgICAgICB2YXIgcmVtb3RlVGFnID0gdGFyZ2V0LmRpYWxvZy5yZW1vdGVUYWc7XG4gICAgICAgICAgICB2YXIgbG9jYWxUYWcgPSB0YXJnZXQuZGlhbG9nLmxvY2FsVGFnO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VzID0gZW5jb2RlVVJJQ29tcG9uZW50KGNhbGxJZCArIFwiO3RvLXRhZz1cIiArIHJlbW90ZVRhZyArIFwiO2Zyb20tdGFnPVwiICsgbG9jYWxUYWcpO1xuICAgICAgICAgICAgcmVmZXJUbyA9IFwiXFxcIlwiICsgZGlzcGxheU5hbWUgKyBcIlxcXCIgPFwiICsgcmVtb3RlVGFyZ2V0ICsgXCI/UmVwbGFjZXM9XCIgKyByZXBsYWNlcyArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZlclRvO1xuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb247XG59KCkpO1xuZXhwb3J0cy5TZXNzaW9uID0gU2Vzc2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG4vKipcbiAqIERpYWxvZy5cbiAqIEByZW1hcmtzXG4gKiBBIGtleSBjb25jZXB0IGZvciBhIHVzZXIgYWdlbnQgaXMgdGhhdCBvZiBhIGRpYWxvZy4gIEEgZGlhbG9nXG4gKiByZXByZXNlbnRzIGEgcGVlci10by1wZWVyIFNJUCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gdXNlciBhZ2VudHNcbiAqIHRoYXQgcGVyc2lzdHMgZm9yIHNvbWUgdGltZS4gIFRoZSBkaWFsb2cgZmFjaWxpdGF0ZXMgc2VxdWVuY2luZyBvZlxuICogbWVzc2FnZXMgYmV0d2VlbiB0aGUgdXNlciBhZ2VudHMgYW5kIHByb3BlciByb3V0aW5nIG9mIHJlcXVlc3RzXG4gKiBiZXR3ZWVuIGJvdGggb2YgdGhlbS4gIFRoZSBkaWFsb2cgcmVwcmVzZW50cyBhIGNvbnRleHQgaW4gd2hpY2ggdG9cbiAqIGludGVycHJldCBTSVAgbWVzc2FnZXMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyXG4gKiBAcHVibGljXG4gKi9cbnZhciBEaWFsb2cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogRGlhbG9nIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBjb3JlIC0gVXNlciBhZ2VudCBjb3JlLlxuICAgICAqIEBwYXJhbSBkaWFsb2dTdGF0ZSAtIEluaXRpYWwgZGlhbG9nIHN0YXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpYWxvZyhjb3JlLCBkaWFsb2dTdGF0ZSkge1xuICAgICAgICB0aGlzLmNvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLmRpYWxvZ1N0YXRlID0gZGlhbG9nU3RhdGU7XG4gICAgICAgIHRoaXMuY29yZS5kaWFsb2dzLnNldCh0aGlzLmlkLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBhIFVBQyByZWNlaXZlcyBhIHJlc3BvbnNlIHRoYXQgZXN0YWJsaXNoZXMgYSBkaWFsb2csIGl0XG4gICAgICogY29uc3RydWN0cyB0aGUgc3RhdGUgb2YgdGhlIGRpYWxvZy4gIFRoaXMgc3RhdGUgTVVTVCBiZSBtYWludGFpbmVkXG4gICAgICogZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGlhbG9nLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICogQHBhcmFtIG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgLSBPdXRnb2luZyByZXF1ZXN0IG1lc3NhZ2UgZm9yIGRpYWxvZy5cbiAgICAgKiBAcGFyYW0gaW5jb21pbmdSZXNwb25zZU1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGNyZWF0aW5nIGRpYWxvZy5cbiAgICAgKi9cbiAgICBEaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yVXNlckFnZW50Q2xpZW50ID0gZnVuY3Rpb24gKG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsIGluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHdhcyBzZW50IG92ZXIgVExTLCBhbmQgdGhlIFJlcXVlc3QtVVJJIGNvbnRhaW5lZCBhXG4gICAgICAgIC8vIFNJUFMgVVJJLCB0aGUgXCJzZWN1cmVcIiBmbGFnIGlzIHNldCB0byBUUlVFLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAgICB2YXIgc2VjdXJlID0gZmFsc2U7IC8vIEZJWE1FOiBDdXJyZW50bHkgbm8gc3VwcG9ydCBmb3IgVExTLlxuICAgICAgICAvLyBUaGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBsaXN0IG9mIFVSSXMgaW4gdGhlIFJlY29yZC1Sb3V0ZVxuICAgICAgICAvLyBoZWFkZXIgZmllbGQgZnJvbSB0aGUgcmVzcG9uc2UsIHRha2VuIGluIHJldmVyc2Ugb3JkZXIgYW5kIHByZXNlcnZpbmdcbiAgICAgICAgLy8gYWxsIFVSSSBwYXJhbWV0ZXJzLiAgSWYgbm8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBpcyBwcmVzZW50IGluXG4gICAgICAgIC8vIHRoZSByZXNwb25zZSwgdGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgZW1wdHkgc2V0LiAgVGhpcyByb3V0ZVxuICAgICAgICAvLyBzZXQsIGV2ZW4gaWYgZW1wdHksIG92ZXJyaWRlcyBhbnkgcHJlLWV4aXN0aW5nIHJvdXRlIHNldCBmb3IgZnV0dXJlXG4gICAgICAgIC8vIHJlcXVlc3RzIGluIHRoaXMgZGlhbG9nLiAgVGhlIHJlbW90ZSB0YXJnZXQgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSVxuICAgICAgICAvLyBmcm9tIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIHZhciByb3V0ZVNldCA9IGluY29taW5nUmVzcG9uc2VNZXNzYWdlLmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIikucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgY29udGFjdCA9IGluY29taW5nUmVzcG9uc2VNZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiKTtcbiAgICAgICAgaWYgKCFjb250YWN0KSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbnRhY3QgaW5zdGFuY2VvZiBtZXNzYWdlc18xLk5hbWVBZGRySGVhZGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCBub3QgaW5zdGFuY2Ugb2YgTmFtZUFkZHJIZWFkZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1vdGVUYXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICAgICAgLy8gVGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgIC8vIG51bWJlciBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgcmVtb3RlIHNlcXVlbmNlXG4gICAgICAgIC8vIG51bWJlciBNVVNUIGJlIGVtcHR5IChpdCBpcyBlc3RhYmxpc2hlZCB3aGVuIHRoZSByZW1vdGUgVUEgc2VuZHMgYVxuICAgICAgICAvLyByZXF1ZXN0IHdpdGhpbiB0aGUgZGlhbG9nKS4gIFRoZSBjYWxsIGlkZW50aWZpZXIgY29tcG9uZW50IG9mIHRoZVxuICAgICAgICAvLyBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBDYWxsLUlEIGluIHRoZSByZXF1ZXN0LlxuICAgICAgICAvLyBUaGUgbG9jYWwgdGFnIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB0YWcgaW5cbiAgICAgICAgLy8gdGhlIEZyb20gZmllbGQgaW4gdGhlIHJlcXVlc3QsIGFuZCB0aGUgcmVtb3RlIHRhZyBjb21wb25lbnQgb2YgdGhlXG4gICAgICAgIC8vIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGluIHRoZSBUbyBmaWVsZCBvZiB0aGUgcmVzcG9uc2UuICBBXG4gICAgICAgIC8vIFVBQyBNVVNUIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgYSByZXNwb25zZSB3aXRob3V0IGEgdGFnIGluIHRoZSBUb1xuICAgICAgICAvLyBmaWVsZCwgaW4gd2hpY2ggY2FzZSB0aGUgdGFnIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBhIHZhbHVlIG9mIG51bGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIFRoaXMgaXMgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0Mywgd2hpY2hcbiAgICAgICAgLy8gICAgZGlkIG5vdCBtYW5kYXRlIFRvIHRhZ3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIHZhciBsb2NhbFNlcXVlbmNlTnVtYmVyID0gb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5jc2VxO1xuICAgICAgICB2YXIgcmVtb3RlU2VxdWVuY2VOdW1iZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjYWxsSWQgPSBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmNhbGxJZDtcbiAgICAgICAgdmFyIGxvY2FsVGFnID0gb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuICAgICAgICB2YXIgcmVtb3RlVGFnID0gaW5jb21pbmdSZXNwb25zZU1lc3NhZ2UudG9UYWc7XG4gICAgICAgIGlmICghY2FsbElkKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpZCB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG9jYWxUYWcpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHRhZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVtb3RlVGFnKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdGFnIHVuZGVmaW5lZC5cIik7IC8vIEZJWE1FOiBObyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIFJGQyAyNTQzXG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHJlbW90ZSBVUkkgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSSBpbiB0aGUgVG8gZmllbGQsIGFuZCB0aGUgbG9jYWxcbiAgICAgICAgLy8gVVJJIE1VU1QgYmUgc2V0IHRvIHRoZSBVUkkgaW4gdGhlIEZyb20gZmllbGQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIGlmICghb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS50bykgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2FsVVJJID0gb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tLnVyaTtcbiAgICAgICAgdmFyIHJlbW90ZVVSSSA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UudG8udXJpO1xuICAgICAgICAvLyBBIGRpYWxvZyBjYW4gYWxzbyBiZSBpbiB0aGUgXCJlYXJseVwiIHN0YXRlLCB3aGljaCBvY2N1cnMgd2hlbiBpdCBpc1xuICAgICAgICAvLyBjcmVhdGVkIHdpdGggYSBwcm92aXNpb25hbCByZXNwb25zZSwgYW5kIHRoZW4gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAgICAgLy8gXCJjb25maXJtZWRcIiBzdGF0ZSB3aGVuIGEgMnh4IGZpbmFsIHJlc3BvbnNlIGFycml2ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTJcbiAgICAgICAgaWYgKCFpbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZS5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbWluZyByZXNwb25zZSBzdGF0dXMgY29kZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlYXJseSA9IGluY29taW5nUmVzcG9uc2VNZXNzYWdlLnN0YXR1c0NvZGUgPCAyMDAgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHZhciBkaWFsb2dTdGF0ZSA9IHtcbiAgICAgICAgICAgIGlkOiBjYWxsSWQgKyBsb2NhbFRhZyArIHJlbW90ZVRhZyxcbiAgICAgICAgICAgIGVhcmx5OiBlYXJseSxcbiAgICAgICAgICAgIGNhbGxJZDogY2FsbElkLFxuICAgICAgICAgICAgbG9jYWxUYWc6IGxvY2FsVGFnLFxuICAgICAgICAgICAgcmVtb3RlVGFnOiByZW1vdGVUYWcsXG4gICAgICAgICAgICBsb2NhbFNlcXVlbmNlTnVtYmVyOiBsb2NhbFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3RlU2VxdWVuY2VOdW1iZXI6IHJlbW90ZVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgbG9jYWxVUkk6IGxvY2FsVVJJLFxuICAgICAgICAgICAgcmVtb3RlVVJJOiByZW1vdGVVUkksXG4gICAgICAgICAgICByZW1vdGVUYXJnZXQ6IHJlbW90ZVRhcmdldCxcbiAgICAgICAgICAgIHJvdXRlU2V0OiByb3V0ZVNldCxcbiAgICAgICAgICAgIHNlY3VyZTogc2VjdXJlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaWFsb2dTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBVQVMgdGhlbiBjb25zdHJ1Y3RzIHRoZSBzdGF0ZSBvZiB0aGUgZGlhbG9nLiAgVGhpcyBzdGF0ZSBNVVNUIGJlXG4gICAgICogbWFpbnRhaW5lZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkaWFsb2cuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjFcbiAgICAgKiBAcGFyYW0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZSBjcmVhdGluZyBkaWFsb2cuXG4gICAgICogQHBhcmFtIHRvVGFnIC0gVGFnIGluIHRoZSBUbyBmaWVsZCBpbiB0aGUgcmVzcG9uc2UgdG8gdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAgICovXG4gICAgRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudFNlcnZlciA9IGZ1bmN0aW9uIChpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLCB0b1RhZywgZWFybHkpIHtcbiAgICAgICAgaWYgKGVhcmx5ID09PSB2b2lkIDApIHsgZWFybHkgPSBmYWxzZTsgfVxuICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBhcnJpdmVkIG92ZXIgVExTLCBhbmQgdGhlIFJlcXVlc3QtVVJJIGNvbnRhaW5lZCBhIFNJUFNcbiAgICAgICAgLy8gVVJJLCB0aGUgXCJzZWN1cmVcIiBmbGFnIGlzIHNldCB0byBUUlVFLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgICAgICB2YXIgc2VjdXJlID0gZmFsc2U7IC8vIEZJWE1FOiBDdXJyZW50bHkgbm8gc3VwcG9ydCBmb3IgVExTLlxuICAgICAgICAvLyBUaGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBsaXN0IG9mIFVSSXMgaW4gdGhlIFJlY29yZC1Sb3V0ZVxuICAgICAgICAvLyBoZWFkZXIgZmllbGQgZnJvbSB0aGUgcmVxdWVzdCwgdGFrZW4gaW4gb3JkZXIgYW5kIHByZXNlcnZpbmcgYWxsIFVSSVxuICAgICAgICAvLyBwYXJhbWV0ZXJzLiAgSWYgbm8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBpcyBwcmVzZW50IGluIHRoZVxuICAgICAgICAvLyByZXF1ZXN0LCB0aGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBlbXB0eSBzZXQuICBUaGlzIHJvdXRlIHNldCxcbiAgICAgICAgLy8gZXZlbiBpZiBlbXB0eSwgb3ZlcnJpZGVzIGFueSBwcmUtZXhpc3Rpbmcgcm91dGUgc2V0IGZvciBmdXR1cmVcbiAgICAgICAgLy8gcmVxdWVzdHMgaW4gdGhpcyBkaWFsb2cuICBUaGUgcmVtb3RlIHRhcmdldCBNVVNUIGJlIHNldCB0byB0aGUgVVJJXG4gICAgICAgIC8vIGZyb20gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgICAgICB2YXIgcm91dGVTZXQgPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIik7XG4gICAgICAgIHZhciBjb250YWN0ID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRhY3RcIik7XG4gICAgICAgIGlmICghY29udGFjdCkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3QgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb250YWN0IGluc3RhbmNlb2YgbWVzc2FnZXNfMS5OYW1lQWRkckhlYWRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3Qgbm90IGluc3RhbmNlIG9mIE5hbWVBZGRySGVhZGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtb3RlVGFyZ2V0ID0gY29udGFjdC51cmk7XG4gICAgICAgIC8vIFRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2VcbiAgICAgICAgLy8gbnVtYmVyIGluIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC4gIFRoZSBsb2NhbCBzZXF1ZW5jZVxuICAgICAgICAvLyBudW1iZXIgTVVTVCBiZSBlbXB0eS4gIFRoZSBjYWxsIGlkZW50aWZpZXIgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgSURcbiAgICAgICAgLy8gTVVTVCBiZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBDYWxsLUlEIGluIHRoZSByZXF1ZXN0LiAgVGhlIGxvY2FsXG4gICAgICAgIC8vIHRhZyBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGluIHRoZSBUbyBmaWVsZFxuICAgICAgICAvLyBpbiB0aGUgcmVzcG9uc2UgdG8gdGhlIHJlcXVlc3QgKHdoaWNoIGFsd2F5cyBpbmNsdWRlcyBhIHRhZyksIGFuZCB0aGVcbiAgICAgICAgLy8gcmVtb3RlIHRhZyBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGZyb20gdGhlXG4gICAgICAgIC8vIEZyb20gZmllbGQgaW4gdGhlIHJlcXVlc3QuICBBIFVBUyBNVVNUIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgYVxuICAgICAgICAvLyByZXF1ZXN0IHdpdGhvdXQgYSB0YWcgaW4gdGhlIEZyb20gZmllbGQsIGluIHdoaWNoIGNhc2UgdGhlIHRhZyBpc1xuICAgICAgICAvLyBjb25zaWRlcmVkIHRvIGhhdmUgYSB2YWx1ZSBvZiBudWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICBUaGlzIGlzIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggUkZDIDI1NDMsIHdoaWNoXG4gICAgICAgIC8vICAgIGRpZCBub3QgbWFuZGF0ZSBGcm9tIHRhZ3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgICAgIHZhciByZW1vdGVTZXF1ZW5jZU51bWJlciA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuY3NlcTtcbiAgICAgICAgdmFyIGxvY2FsU2VxdWVuY2VOdW1iZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjYWxsSWQgPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLmNhbGxJZDtcbiAgICAgICAgdmFyIGxvY2FsVGFnID0gdG9UYWc7XG4gICAgICAgIHZhciByZW1vdGVUYWcgPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLmZyb21UYWc7XG4gICAgICAgIC8vIFRoZSByZW1vdGUgVVJJIE1VU1QgYmUgc2V0IHRvIHRoZSBVUkkgaW4gdGhlIEZyb20gZmllbGQsIGFuZCB0aGVcbiAgICAgICAgLy8gbG9jYWwgVVJJIE1VU1QgYmUgc2V0IHRvIHRoZSBVUkkgaW4gdGhlIFRvIGZpZWxkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgICAgICB2YXIgcmVtb3RlVVJJID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tLnVyaTtcbiAgICAgICAgdmFyIGxvY2FsVVJJID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS50by51cmk7XG4gICAgICAgIHZhciBkaWFsb2dTdGF0ZSA9IHtcbiAgICAgICAgICAgIGlkOiBjYWxsSWQgKyBsb2NhbFRhZyArIHJlbW90ZVRhZyxcbiAgICAgICAgICAgIGVhcmx5OiBlYXJseSxcbiAgICAgICAgICAgIGNhbGxJZDogY2FsbElkLFxuICAgICAgICAgICAgbG9jYWxUYWc6IGxvY2FsVGFnLFxuICAgICAgICAgICAgcmVtb3RlVGFnOiByZW1vdGVUYWcsXG4gICAgICAgICAgICBsb2NhbFNlcXVlbmNlTnVtYmVyOiBsb2NhbFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3RlU2VxdWVuY2VOdW1iZXI6IHJlbW90ZVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgbG9jYWxVUkk6IGxvY2FsVVJJLFxuICAgICAgICAgICAgcmVtb3RlVVJJOiByZW1vdGVVUkksXG4gICAgICAgICAgICByZW1vdGVUYXJnZXQ6IHJlbW90ZVRhcmdldCxcbiAgICAgICAgICAgIHJvdXRlU2V0OiByb3V0ZVNldCxcbiAgICAgICAgICAgIHNlY3VyZTogc2VjdXJlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaWFsb2dTdGF0ZTtcbiAgICB9O1xuICAgIC8qKiBEZXN0cnVjdG9yLiAqL1xuICAgIERpYWxvZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb3JlLmRpYWxvZ3MuZGVsZXRlKHRoaXMuaWQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBkaWFsb2cgaXMgaWRlbnRpZmllZCBhdCBlYWNoIFVBIHdpdGggYSBkaWFsb2cgSUQsIHdoaWNoIGNvbnNpc3RzIG9mXG4gICAgICAgICAqIGEgQ2FsbC1JRCB2YWx1ZSwgYSBsb2NhbCB0YWcgYW5kIGEgcmVtb3RlIHRhZy4gIFRoZSBkaWFsb2cgSUQgYXQgZWFjaFxuICAgICAgICAgKiBVQSBpbnZvbHZlZCBpbiB0aGUgZGlhbG9nIGlzIG5vdCB0aGUgc2FtZS4gIFNwZWNpZmljYWxseSwgdGhlIGxvY2FsXG4gICAgICAgICAqIHRhZyBhdCBvbmUgVUEgaXMgaWRlbnRpY2FsIHRvIHRoZSByZW1vdGUgdGFnIGF0IHRoZSBwZWVyIFVBLiAgVGhlXG4gICAgICAgICAqIHRhZ3MgYXJlIG9wYXF1ZSB0b2tlbnMgdGhhdCBmYWNpbGl0YXRlIHRoZSBnZW5lcmF0aW9uIG9mIHVuaXF1ZVxuICAgICAgICAgKiBkaWFsb2cgSURzLlxuICAgICAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJlYXJseVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRpYWxvZyBjYW4gYWxzbyBiZSBpbiB0aGUgXCJlYXJseVwiIHN0YXRlLCB3aGljaCBvY2N1cnMgd2hlbiBpdCBpc1xuICAgICAgICAgKiBjcmVhdGVkIHdpdGggYSBwcm92aXNpb25hbCByZXNwb25zZSwgYW5kIHRoZW4gaXQgdHJhbnNpdGlvbiB0byB0aGVcbiAgICAgICAgICogXCJjb25maXJtZWRcIiBzdGF0ZSB3aGVuIGEgMnh4IGZpbmFsIHJlc3BvbnNlIHJlY2VpdmVkIG9yIGlzIHNlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IFJGQyAzMjYxIGlzIGNvbmNpc2Ugb24gd2hlbiBhIGRpYWxvZyBpcyBcImNvbmZpcm1lZFwiLCBidXQgaXRcbiAgICAgICAgICogY2FuIGJlIGEgcG9pbnQgb2YgY29uZnVzaW9uIGlmIGFuIElOVklURSBkaWFsb2cgaXMgXCJjb25maXJtZWRcIiBhZnRlclxuICAgICAgICAgKiBhIDJ4eCBpcyBzZW50IG9yIGFmdGVyIHJlY2VpdmluZyB0aGUgQUNLIGZvciB0aGUgMnh4IHJlc3BvbnNlLlxuICAgICAgICAgKiBXaXRoIGNhcmVmdWwgcmVhZGluZyBpdCBjYW4gYmUgaW5mZXJyZWQgYSBkaWFsb2cgaXMgYWx3YXlzIGlzXG4gICAgICAgICAqIFwiY29uZmlybWVkXCIgd2hlbiB0aGUgMnh4IGlzIHNlbnQgKHJlZ2FyZGxlc3Mgb2YgdHlwZSBvZiBkaWFsb2cpLlxuICAgICAgICAgKiBIb3dldmVyIGEgSU5WSVRFIGRpYWxvZyBkb2VzIGhhdmUgYWRkaXRpb25hbCBjb25zaWRlcmF0aW9uc1xuICAgICAgICAgKiB3aGVuIGl0IGlzIGNvbmZpcm1lZCBidXQgYW4gQUNLIGhhcyBub3QgeWV0IGJlZW4gcmVjZWl2ZWQgKGluXG4gICAgICAgICAqIHBhcnRpY3VsYXIgd2l0aCByZWdhcmQgdG8gYSBjYWxsZWUgc2VuZGluZyBCWUUgcmVxdWVzdHMpLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5lYXJseTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwiY2FsbElkXCIsIHtcbiAgICAgICAgLyoqIENhbGwgaWRlbnRpZmllciBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBpZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5jYWxsSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcImxvY2FsVGFnXCIsIHtcbiAgICAgICAgLyoqIExvY2FsIHRhZyBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBpZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFRhZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwicmVtb3RlVGFnXCIsIHtcbiAgICAgICAgLyoqIFJlbW90ZSB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgaWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlVGFnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJsb2NhbFNlcXVlbmNlTnVtYmVyXCIsIHtcbiAgICAgICAgLyoqIExvY2FsIHNlcXVlbmNlIG51bWJlciAodXNlZCB0byBvcmRlciByZXF1ZXN0cyBmcm9tIHRoZSBVQSB0byBpdHMgcGVlcikuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwicmVtb3RlU2VxdWVuY2VOdW1iZXJcIiwge1xuICAgICAgICAvKiogUmVtb3RlIHNlcXVlbmNlIG51bWJlciAodXNlZCB0byBvcmRlciByZXF1ZXN0cyBmcm9tIGl0cyBwZWVyIHRvIHRoZSBVQSkuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcImxvY2FsVVJJXCIsIHtcbiAgICAgICAgLyoqIExvY2FsIFVSSS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFVSSTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwicmVtb3RlVVJJXCIsIHtcbiAgICAgICAgLyoqIFJlbW90ZSBVUkkuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlVVJJO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJyZW1vdGVUYXJnZXRcIiwge1xuICAgICAgICAvKiogUmVtb3RlIHRhcmdldC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5yZW1vdGVUYXJnZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcInJvdXRlU2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJvdXRlIHNldCwgd2hpY2ggaXMgYW4gb3JkZXJlZCBsaXN0IG9mIFVSSXMuIFRoZSByb3V0ZSBzZXQgaXMgdGhlXG4gICAgICAgICAqIGxpc3Qgb2Ygc2VydmVycyB0aGF0IG5lZWQgdG8gYmUgdHJhdmVyc2VkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBwZWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5yb3V0ZVNldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwic2VjdXJlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSByZXF1ZXN0IHdhcyBzZW50IG92ZXIgVExTLCBhbmQgdGhlIFJlcXVlc3QtVVJJIGNvbnRhaW5lZFxuICAgICAgICAgKiBhIFNJUFMgVVJJLCB0aGUgXCJzZWN1cmVcIiBmbGFnIGlzIHNldCB0byB0cnVlLiAqTk9UIElNUExFTUVOVEVEKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5zZWN1cmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcInVzZXJBZ2VudENvcmVcIiwge1xuICAgICAgICAvKiogVGhlIHVzZXIgYWdlbnQgY29yZSBzZXJ2aWNpbmcgdGhpcyBkaWFsb2cuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIENvbmZpcm0gdGhlIGRpYWxvZy4gT25seSBtYXR0ZXJzIGlmIGRpYWxvZyBpcyBjdXJyZW50bHkgZWFybHkuICovXG4gICAgRGlhbG9nLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpYWxvZ1N0YXRlLmVhcmx5ID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBzZW50IHdpdGhpbiBhIGRpYWxvZywgYXMgYW55IG90aGVyIHJlcXVlc3RzLCBhcmUgYXRvbWljLiAgSWZcbiAgICAgKiBhIHBhcnRpY3VsYXIgcmVxdWVzdCBpcyBhY2NlcHRlZCBieSB0aGUgVUFTLCBhbGwgdGhlIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggaXQgYXJlIHBlcmZvcm1lZC4gIElmIHRoZSByZXF1ZXN0IGlzIHJlamVjdGVkLCBub25lXG4gICAgICogb2YgdGhlIHN0YXRlIGNoYW5nZXMgYXJlIHBlcmZvcm1lZC5cbiAgICAgKlxuICAgICAqICAgIE5vdGUgdGhhdCBzb21lIHJlcXVlc3RzLCBzdWNoIGFzIElOVklURXMsIGFmZmVjdCBzZXZlcmFsIHBpZWNlcyBvZlxuICAgICAqICAgIHN0YXRlLlxuICAgICAqXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZSB3aXRoaW4gdGhpcyBkaWFsb2cuXG4gICAgICovXG4gICAgRGlhbG9nLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIEFDSyBndWFyZC5cbiAgICAgICAgLy8gQnkgY29udmVudGlvbiwgdGhlIGhhbmRsaW5nIG9mIEFDS3MgaXMgdGhlIHJlc3BvbnNpYmlsaXR5XG4gICAgICAgIC8vIHRoZSBwYXJ0aWN1bGFyIGRpYWxvZyBpbXBsZW1lbnRhdGlvbi4gRm9yIGV4YW1wbGUsIHNlZSBTZXNzaW9uRGlhbG9nLlxuICAgICAgICAvLyBGdXJ0aGVybW9yZSwgQUNLcyBoYXZlIHNhbWUgc2VxdWVuY2UgbnVtYmVyIGFzIHRoZSBhc3NvY2lhdGVkIElOVklURS5cbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuQUNLKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgd2FzIG5vdCBlbXB0eSwgYnV0IHRoZSBzZXF1ZW5jZSBudW1iZXJcbiAgICAgICAgLy8gb2YgdGhlIHJlcXVlc3QgaXMgbG93ZXIgdGhhbiB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciwgdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gaXMgb3V0IG9mIG9yZGVyIGFuZCBNVVNUIGJlIHJlamVjdGVkIHdpdGggYSA1MDAgKFNlcnZlciBJbnRlcm5hbFxuICAgICAgICAvLyBFcnJvcikgcmVzcG9uc2UuICBJZiB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciB3YXMgbm90IGVtcHR5LCBhbmRcbiAgICAgICAgLy8gdGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgcmVxdWVzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHJlbW90ZVxuICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIsIHRoZSByZXF1ZXN0IGlzIGluIG9yZGVyLiAgSXQgaXMgcG9zc2libGUgZm9yIHRoZVxuICAgICAgICAvLyBDU2VxIHNlcXVlbmNlIG51bWJlciB0byBiZSBoaWdoZXIgdGhhbiB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciBieVxuICAgICAgICAvLyBtb3JlIHRoYW4gb25lLiAgVGhpcyBpcyBub3QgYW4gZXJyb3IgY29uZGl0aW9uLCBhbmQgYSBVQVMgU0hPVUxEIGJlXG4gICAgICAgIC8vIHByZXBhcmVkIHRvIHJlY2VpdmUgYW5kIHByb2Nlc3MgcmVxdWVzdHMgd2l0aCBDU2VxIHZhbHVlcyBtb3JlIHRoYW5cbiAgICAgICAgLy8gb25lIGhpZ2hlciB0aGFuIHRoZSBwcmV2aW91cyByZWNlaXZlZCByZXF1ZXN0LiAgVGhlIFVBUyBNVVNUIHRoZW4gc2V0XG4gICAgICAgIC8vIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIHRvIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgbnVtYmVyIGluIHRoZVxuICAgICAgICAvLyBDU2VxIGhlYWRlciBmaWVsZCB2YWx1ZSBpbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgSWYgYSBwcm94eSBjaGFsbGVuZ2VzIGEgcmVxdWVzdCBnZW5lcmF0ZWQgYnkgdGhlIFVBQywgdGhlIFVBQyBoYXNcbiAgICAgICAgLy8gICAgdG8gcmVzdWJtaXQgdGhlIHJlcXVlc3Qgd2l0aCBjcmVkZW50aWFscy4gIFRoZSByZXN1Ym1pdHRlZCByZXF1ZXN0XG4gICAgICAgIC8vICAgIHdpbGwgaGF2ZSBhIG5ldyBDU2VxIG51bWJlci4gIFRoZSBVQVMgd2lsbCBuZXZlciBzZWUgdGhlIGZpcnN0XG4gICAgICAgIC8vICAgIHJlcXVlc3QsIGFuZCB0aHVzLCBpdCB3aWxsIG5vdGljZSBhIGdhcCBpbiB0aGUgQ1NlcSBudW1iZXIgc3BhY2UuXG4gICAgICAgIC8vICAgIFN1Y2ggYSBnYXAgZG9lcyBub3QgcmVwcmVzZW50IGFueSBlcnJvciBjb25kaXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgIGlmICh0aGlzLnJlbW90ZVNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jc2VxIDw9IHRoaXMucmVtb3RlU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2Ygc2VxdWVuY2UgaW4gZGlhbG9nIHJlcXVlc3QuIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgc2VxdWVuY2VHdWFyZCgpP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlU2VxdWVuY2VOdW1iZXIgPSBtZXNzYWdlLmNzZXE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgaXMgZW1wdHksIGl0IE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZVxuICAgICAgICAvLyBvZiB0aGUgc2VxdWVuY2UgbnVtYmVyIGluIHRoZSBDU2VxIGhlYWRlciBmaWVsZCB2YWx1ZSBpbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgICAgaWYgKCF0aGlzLnJlbW90ZVNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVNlcXVlbmNlTnVtYmVyID0gbWVzc2FnZS5jc2VxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gYSBVQVMgcmVjZWl2ZXMgYSB0YXJnZXQgcmVmcmVzaCByZXF1ZXN0LCBpdCBNVVNUIHJlcGxhY2UgdGhlXG4gICAgICAgIC8vIGRpYWxvZydzIHJlbW90ZSB0YXJnZXQgVVJJIHdpdGggdGhlIFVSSSBmcm9tIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZFxuICAgICAgICAvLyBpbiB0aGF0IHJlcXVlc3QsIGlmIHByZXNlbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgIC8vIE5vdGU6IFwidGFyZ2V0IHJlZnJlc2ggcmVxdWVzdFwiIHByb2Nlc3NpbmcgZGVsZWdhdGVkIHRvIHN1Yi1jbGFzcy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBkaWFsb2cgaWRlbnRpZmllciBpbiB0aGUgMnh4IHJlc3BvbnNlIG1hdGNoZXMgdGhlIGRpYWxvZ1xuICAgICAqIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgZGlhbG9nIE1VU1QgYmUgdHJhbnNpdGlvbmVkIHRvXG4gICAgICogdGhlIFwiY29uZmlybWVkXCIgc3RhdGUsIGFuZCB0aGUgcm91dGUgc2V0IGZvciB0aGUgZGlhbG9nIE1VU1QgYmVcbiAgICAgKiByZWNvbXB1dGVkIGJhc2VkIG9uIHRoZSAyeHggcmVzcG9uc2UgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvblxuICAgICAqIDEyLjIuMS4yLiAgT3RoZXJ3aXNlLCBhIG5ldyBkaWFsb2cgaW4gdGhlIFwiY29uZmlybWVkXCIgc3RhdGUgTVVTVCBiZVxuICAgICAqIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTIuMS4yLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHBpZWNlIG9mIHN0YXRlIHRoYXQgaXMgcmVjb21wdXRlZCBpcyB0aGUgcm91dGVcbiAgICAgKiBzZXQuICBPdGhlciBwaWVjZXMgb2Ygc3RhdGUgc3VjaCBhcyB0aGUgaGlnaGVzdCBzZXF1ZW5jZSBudW1iZXJzXG4gICAgICogKHJlbW90ZSBhbmQgbG9jYWwpIHNlbnQgd2l0aGluIHRoZSBkaWFsb2cgYXJlIG5vdCByZWNvbXB1dGVkLiAgVGhlXG4gICAgICogcm91dGUgc2V0IG9ubHkgaXMgcmVjb21wdXRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuICBSRkNcbiAgICAgKiAyNTQzIGRpZCBub3QgbWFuZGF0ZSBtaXJyb3Jpbmcgb2YgdGhlIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgaW5cbiAgICAgKiBhIDF4eCwgb25seSAyeHguICBIb3dldmVyLCB3ZSBjYW5ub3QgdXBkYXRlIHRoZSBlbnRpcmUgc3RhdGUgb2ZcbiAgICAgKiB0aGUgZGlhbG9nLCBzaW5jZSBtaWQtZGlhbG9nIHJlcXVlc3RzIG1heSBoYXZlIGJlZW4gc2VudCB3aXRoaW5cbiAgICAgKiB0aGUgZWFybHkgZGlhbG9nLCBtb2RpZnlpbmcgdGhlIHNlcXVlbmNlIG51bWJlcnMsIGZvciBleGFtcGxlLlxuICAgICAqXG4gICAgICogIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICAgKi9cbiAgICBEaWFsb2cucHJvdG90eXBlLnJlY29tcHV0ZVJvdXRlU2V0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5kaWFsb2dTdGF0ZS5yb3V0ZVNldCA9IG1lc3NhZ2UuZ2V0SGVhZGVycyhcInJlY29yZC1yb3V0ZVwiKS5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIGlzIGNvbnN0cnVjdGVkIGJ5IHVzaW5nIG1hbnkgb2YgdGhlXG4gICAgICogY29tcG9uZW50cyBvZiB0aGUgc3RhdGUgc3RvcmVkIGFzIHBhcnQgb2YgdGhlIGRpYWxvZy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMS4xXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIE91dGdvaW5nIHJlcXVlc3QgbWV0aG9kLlxuICAgICAqL1xuICAgIERpYWxvZy5wcm90b3R5cGUuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVGhlIFVSSSBpbiB0aGUgVG8gZmllbGQgb2YgdGhlIHJlcXVlc3QgTVVTVCBiZSBzZXQgdG8gdGhlIHJlbW90ZSBVUklcbiAgICAgICAgLy8gZnJvbSB0aGUgZGlhbG9nIHN0YXRlLiAgVGhlIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0XG4gICAgICAgIC8vIE1VU1QgYmUgc2V0IHRvIHRoZSByZW1vdGUgdGFnIG9mIHRoZSBkaWFsb2cgSUQuICBUaGUgRnJvbSBVUkkgb2YgdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgTVVTVCBiZSBzZXQgdG8gdGhlIGxvY2FsIFVSSSBmcm9tIHRoZSBkaWFsb2cgc3RhdGUuICBUaGUgdGFnXG4gICAgICAgIC8vIGluIHRoZSBGcm9tIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdCBNVVNUIGJlIHNldCB0byB0aGUgbG9jYWwgdGFnXG4gICAgICAgIC8vIG9mIHRoZSBkaWFsb2cgSUQuICBJZiB0aGUgdmFsdWUgb2YgdGhlIHJlbW90ZSBvciBsb2NhbCB0YWdzIGlzIG51bGwsXG4gICAgICAgIC8vIHRoZSB0YWcgcGFyYW1ldGVyIE1VU1QgYmUgb21pdHRlZCBmcm9tIHRoZSBUbyBvciBGcm9tIGhlYWRlciBmaWVsZHMsXG4gICAgICAgIC8vIHJlc3BlY3RpdmVseS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgVXNhZ2Ugb2YgdGhlIFVSSSBmcm9tIHRoZSBUbyBhbmQgRnJvbSBmaWVsZHMgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vICAgIHJlcXVlc3Qgd2l0aGluIHN1YnNlcXVlbnQgcmVxdWVzdHMgaXMgZG9uZSBmb3IgYmFja3dhcmRzXG4gICAgICAgIC8vICAgIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0Mywgd2hpY2ggdXNlZCB0aGUgVVJJIGZvciBkaWFsb2dcbiAgICAgICAgLy8gICAgaWRlbnRpZmljYXRpb24uICBJbiB0aGlzIHNwZWNpZmljYXRpb24sIG9ubHkgdGhlIHRhZ3MgYXJlIHVzZWQgZm9yXG4gICAgICAgIC8vICAgIGRpYWxvZyBpZGVudGlmaWNhdGlvbi4gIEl0IGlzIGV4cGVjdGVkIHRoYXQgbWFuZGF0b3J5IHJlZmxlY3Rpb25cbiAgICAgICAgLy8gICAgb2YgdGhlIG9yaWdpbmFsIFRvIGFuZCBGcm9tIFVSSSBpbiBtaWQtZGlhbG9nIHJlcXVlc3RzIHdpbGwgYmVcbiAgICAgICAgLy8gICAgZGVwcmVjYXRlZCBpbiBhIHN1YnNlcXVlbnQgcmV2aXNpb24gb2YgdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMS4xXG4gICAgICAgIHZhciB0b1VyaSA9IHRoaXMucmVtb3RlVVJJO1xuICAgICAgICB2YXIgdG9UYWcgPSB0aGlzLnJlbW90ZVRhZztcbiAgICAgICAgdmFyIGZyb21VcmkgPSB0aGlzLmxvY2FsVVJJO1xuICAgICAgICB2YXIgZnJvbVRhZyA9IHRoaXMubG9jYWxUYWc7XG4gICAgICAgIC8vIFRoZSBDYWxsLUlEIG9mIHRoZSByZXF1ZXN0IE1VU1QgYmUgc2V0IHRvIHRoZSBDYWxsLUlEIG9mIHRoZSBkaWFsb2cuXG4gICAgICAgIC8vIFJlcXVlc3RzIHdpdGhpbiBhIGRpYWxvZyBNVVNUIGNvbnRhaW4gc3RyaWN0bHkgbW9ub3RvbmljYWxseVxuICAgICAgICAvLyBpbmNyZWFzaW5nIGFuZCBjb250aWd1b3VzIENTZXEgc2VxdWVuY2UgbnVtYmVycyAoaW5jcmVhc2luZy1ieS1vbmUpXG4gICAgICAgIC8vIGluIGVhY2ggZGlyZWN0aW9uIChleGNlcHRpbmcgQUNLIGFuZCBDQU5DRUwgb2YgY291cnNlLCB3aG9zZSBudW1iZXJzXG4gICAgICAgIC8vIGVxdWFsIHRoZSByZXF1ZXN0cyBiZWluZyBhY2tub3dsZWRnZWQgb3IgY2FuY2VsbGVkKS4gIFRoZXJlZm9yZSwgaWZcbiAgICAgICAgLy8gdGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBpcyBub3QgZW1wdHksIHRoZSB2YWx1ZSBvZiB0aGUgbG9jYWxcbiAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgaW5jcmVtZW50ZWQgYnkgb25lLCBhbmQgdGhpcyB2YWx1ZSBNVVNUIGJlXG4gICAgICAgIC8vIHBsYWNlZCBpbnRvIHRoZSBDU2VxIGhlYWRlciBmaWVsZC4gIElmIHRoZSBsb2NhbCBzZXF1ZW5jZSBudW1iZXIgaXNcbiAgICAgICAgLy8gZW1wdHksIGFuIGluaXRpYWwgdmFsdWUgTVVTVCBiZSBjaG9zZW4gdXNpbmcgdGhlIGd1aWRlbGluZXMgb2ZcbiAgICAgICAgLy8gU2VjdGlvbiA4LjEuMS41LiAgVGhlIG1ldGhvZCBmaWVsZCBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgdmFsdWVcbiAgICAgICAgLy8gTVVTVCBtYXRjaCB0aGUgbWV0aG9kIG9mIHRoZSByZXF1ZXN0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMS4xXG4gICAgICAgIHZhciBjYWxsSWQgPSB0aGlzLmNhbGxJZDtcbiAgICAgICAgdmFyIGNzZXE7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY3NlcSkge1xuICAgICAgICAgICAgY3NlcSA9IG9wdGlvbnMuY3NlcTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICBjc2VxID0gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFNlcXVlbmNlTnVtYmVyID0gMTsgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMS41XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjc2VxID0gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFNlcXVlbmNlTnVtYmVyICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIFVBQyB1c2VzIHRoZSByZW1vdGUgdGFyZ2V0IGFuZCByb3V0ZSBzZXQgdG8gYnVpbGQgdGhlIFJlcXVlc3QtVVJJXG4gICAgICAgIC8vIGFuZCBSb3V0ZSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSByb3V0ZSBzZXQgaXMgZW1wdHksIHRoZSBVQUMgTVVTVCBwbGFjZSB0aGUgcmVtb3RlIHRhcmdldCBVUklcbiAgICAgICAgLy8gaW50byB0aGUgUmVxdWVzdC1VUkkuICBUaGUgVUFDIE1VU1QgTk9UIGFkZCBhIFJvdXRlIGhlYWRlciBmaWVsZCB0b1xuICAgICAgICAvLyB0aGUgcmVxdWVzdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlIHNldCBpcyBub3QgZW1wdHksIGFuZCB0aGUgZmlyc3QgVVJJIGluIHRoZSByb3V0ZSBzZXRcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIGxyIHBhcmFtZXRlciAoc2VlIFNlY3Rpb24gMTkuMS4xKSwgdGhlIFVBQyBNVVNUIHBsYWNlXG4gICAgICAgIC8vIHRoZSByZW1vdGUgdGFyZ2V0IFVSSSBpbnRvIHRoZSBSZXF1ZXN0LVVSSSBhbmQgTVVTVCBpbmNsdWRlIGEgUm91dGVcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIGNvbnRhaW5pbmcgdGhlIHJvdXRlIHNldCB2YWx1ZXMgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICAgICAgLy8gcGFyYW1ldGVycy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlIHNldCBpcyBub3QgZW1wdHksIGFuZCBpdHMgZmlyc3QgVVJJIGRvZXMgbm90IGNvbnRhaW4gdGhlXG4gICAgICAgIC8vIGxyIHBhcmFtZXRlciwgdGhlIFVBQyBNVVNUIHBsYWNlIHRoZSBmaXJzdCBVUkkgZnJvbSB0aGUgcm91dGUgc2V0XG4gICAgICAgIC8vIGludG8gdGhlIFJlcXVlc3QtVVJJLCBzdHJpcHBpbmcgYW55IHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IGFsbG93ZWRcbiAgICAgICAgLy8gaW4gYSBSZXF1ZXN0LVVSSS4gIFRoZSBVQUMgTVVTVCBhZGQgYSBSb3V0ZSBoZWFkZXIgZmllbGQgY29udGFpbmluZ1xuICAgICAgICAvLyB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSBzZXQgdmFsdWVzIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgICAgIC8vIHBhcmFtZXRlcnMuICBUaGUgVUFDIE1VU1QgdGhlbiBwbGFjZSB0aGUgcmVtb3RlIHRhcmdldCBVUkkgaW50byB0aGVcbiAgICAgICAgLy8gUm91dGUgaGVhZGVyIGZpZWxkIGFzIHRoZSBsYXN0IHZhbHVlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMS4xXG4gICAgICAgIC8vIFRoZSBsciBwYXJhbWV0ZXIsIHdoZW4gcHJlc2VudCwgaW5kaWNhdGVzIHRoYXQgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gcmVzcG9uc2libGUgZm9yIHRoaXMgcmVzb3VyY2UgaW1wbGVtZW50cyB0aGUgcm91dGluZyBtZWNoYW5pc21zXG4gICAgICAgIC8vIHNwZWNpZmllZCBpbiB0aGlzIGRvY3VtZW50LiAgVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSB1c2VkIGluIHRoZVxuICAgICAgICAvLyBVUklzIHByb3hpZXMgcGxhY2UgaW50byBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkIHZhbHVlcywgYW5kXG4gICAgICAgIC8vIG1heSBhcHBlYXIgaW4gdGhlIFVSSXMgaW4gYSBwcmUtZXhpc3Rpbmcgcm91dGUgc2V0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHRvIGFjaGlldmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aFxuICAgICAgICAvLyBzeXN0ZW1zIGltcGxlbWVudGluZyB0aGUgc3RyaWN0LXJvdXRpbmcgbWVjaGFuaXNtcyBvZiBSRkMgMjU0M1xuICAgICAgICAvLyBhbmQgdGhlIHJmYzI1NDNiaXMgZHJhZnRzIHVwIHRvIGJpcy0wNS4gIEFuIGVsZW1lbnQgcHJlcGFyaW5nXG4gICAgICAgIC8vIHRvIHNlbmQgYSByZXF1ZXN0IGJhc2VkIG9uIGEgVVJJIG5vdCBjb250YWluaW5nIHRoaXMgcGFyYW1ldGVyXG4gICAgICAgIC8vIGNhbiBhc3N1bWUgdGhlIHJlY2VpdmluZyBlbGVtZW50IGltcGxlbWVudHMgc3RyaWN0LXJvdXRpbmcgYW5kXG4gICAgICAgIC8vIHJlZm9ybWF0IHRoZSBtZXNzYWdlIHRvIHByZXNlcnZlIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGVcbiAgICAgICAgLy8gUmVxdWVzdC1VUkkuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTkuMS4xXG4gICAgICAgIC8vIE5PVEU6IE5vdCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIFJGQyAyNTQzIChubyBzdXBwb3J0IGZvciBzdHJpY3Qtcm91dGluZykuXG4gICAgICAgIHZhciBydXJpID0gdGhpcy5yZW1vdGVUYXJnZXQ7XG4gICAgICAgIHZhciByb3V0ZVNldCA9IHRoaXMucm91dGVTZXQ7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFIZWFkZXJzO1xuICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ib2R5O1xuICAgICAgICAvLyBUaGUgcmVsYXRpdmUgb3JkZXIgb2YgaGVhZGVyIGZpZWxkcyB3aXRoIGRpZmZlcmVudCBmaWVsZCBuYW1lcyBpcyBub3RcbiAgICAgICAgLy8gc2lnbmlmaWNhbnQuICBIb3dldmVyLCBpdCBpcyBSRUNPTU1FTkRFRCB0aGF0IGhlYWRlciBmaWVsZHMgd2hpY2ggYXJlXG4gICAgICAgIC8vIG5lZWRlZCBmb3IgcHJveHkgcHJvY2Vzc2luZyAoVmlhLCBSb3V0ZSwgUmVjb3JkLVJvdXRlLCBQcm94eS1SZXF1aXJlLFxuICAgICAgICAvLyBNYXgtRm9yd2FyZHMsIGFuZCBQcm94eS1BdXRob3JpemF0aW9uLCBmb3IgZXhhbXBsZSkgYXBwZWFyIHRvd2FyZHNcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgbWVzc2FnZSB0byBmYWNpbGl0YXRlIHJhcGlkIHBhcnNpbmcuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNy4zLjFcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLnVzZXJBZ2VudENvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWV0aG9kLCBydXJpLCBmcm9tVXJpLCB0b1VyaSwge1xuICAgICAgICAgICAgY2FsbElkOiBjYWxsSWQsXG4gICAgICAgICAgICBjc2VxOiBjc2VxLFxuICAgICAgICAgICAgZnJvbVRhZzogZnJvbVRhZyxcbiAgICAgICAgICAgIHRvVGFnOiB0b1RhZyxcbiAgICAgICAgICAgIHJvdXRlU2V0OiByb3V0ZVNldFxuICAgICAgICB9LCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluY3JlbWVudCB0aGUgbG9jYWwgc2VxdWVuY2UgbnVtYmVyIGJ5IG9uZS5cbiAgICAgKiBJdCBmZWVscyBsaWtlIHRoaXMgc2hvdWxkIGJlIHByb3RlY3RlZCwgYnV0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIGhhbmRsaW5nIGN1cnJlbnRseVxuICAgICAqIG5lZWRzIHRoaXMgdG8ga2VlcCB0aGUgZGlhbG9nIGluIHN5bmMgd2hlbiBcImF1dG8gcmUtc2VuZHNcIiByZXF1ZXN0IG1lc3NhZ2VzLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERpYWxvZy5wcm90b3R5cGUuaW5jcmVtZW50TG9jYWxTZXF1ZW5jZU51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpYWxvZ1N0YXRlLmxvY2FsU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvY2FsIHNlcXVlbmNlIG51bWJlciB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlciArPSAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgd2FzIG5vdCBlbXB0eSwgYnV0IHRoZSBzZXF1ZW5jZSBudW1iZXJcbiAgICAgKiBvZiB0aGUgcmVxdWVzdCBpcyBsb3dlciB0aGFuIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyLCB0aGUgcmVxdWVzdFxuICAgICAqIGlzIG91dCBvZiBvcmRlciBhbmQgTVVTVCBiZSByZWplY3RlZCB3aXRoIGEgNTAwIChTZXJ2ZXIgSW50ZXJuYWxcbiAgICAgKiBFcnJvcikgcmVzcG9uc2UuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIEluY29taW5nIHJlcXVlc3QgdG8gZ3VhcmQuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcHJvZ3JhbSBleGVjdXRpb24gaXMgdG8gY29udGludWUgaW4gdGhlIGJyYW5jaCBpbiBxdWVzdGlvbi5cbiAgICAgKiAgICAgICAgICBPdGhlcndpc2UgYSA1MDAgU2VydmVyIEludGVybmFsIEVycm9yIHdhcyBzdGF0ZWxlc3Mgc2VudCBhbmQgcmVxdWVzdCBwcm9jZXNzaW5nIG11c3Qgc3RvcC5cbiAgICAgKi9cbiAgICBEaWFsb2cucHJvdG90eXBlLnNlcXVlbmNlR3VhcmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyBBQ0sgZ3VhcmQuXG4gICAgICAgIC8vIEJ5IGNvbnZlbnRpb24sIGhhbmRsaW5nIG9mIHVuZXhwZWN0ZWQgQUNLcyBpcyByZXNwb25zaWJpbGl0eVxuICAgICAgICAvLyB0aGUgcGFydGljdWxhciBkaWFsb2cgaW1wbGVtZW50YXRpb24uIEZvciBleGFtcGxlLCBzZWUgU2Vzc2lvbkRpYWxvZy5cbiAgICAgICAgLy8gRnVydGhlcm1vcmUsIHdlIGNhbm5vdCByZXBseSB0byBhbiBcIm91dCBvZiBzZXF1ZW5jZVwiIEFDSy5cbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuQUNLKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBXZSBhcmUgcmVqZWN0aW5nIG9uIFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgdGhlIHJlbW90ZVxuICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIgKGV4Y2VwdGluZyBBQ0sgd2hvc2UgbnVtYmVycyBlcXVhbCB0aGUgcmVxdWVzdHNcbiAgICAgICAgLy8gYmVpbmcgYWNrbm93bGVkZ2VkIG9yIGNhbmNlbGxlZCksIHdoaWNoIGlzIHRoZSBjb3JyZWN0IHRoaW5nIHRvXG4gICAgICAgIC8vIGRvIGluIG91ciBjYXNlLiBUaGUgb25seSB0aW1lIGEgcmVxdWVzdCB3aXRoIHRoZSBzYW1lIHNlcXVlbmNlIG51bWJlclxuICAgICAgICAvLyB3aWxsIHNob3cgdXAgaGVyZSBpZiBpcyBhKSBpdCBpcyBhIHZlcnkgbGF0ZSByZXRyYW5zbWlzc2lvbiBvZiBhXG4gICAgICAgIC8vIHJlcXVlc3Qgd2UgYWxyZWFkeSBoYW5kbGVkIG9yIGIpIGl0IGlzIGEgZGlmZmVyZW50IHJlcXVlc3Qgd2l0aCB0aGVcbiAgICAgICAgLy8gc2FtZSBzZXF1ZW5jZSBudW1iZXIgd2hpY2ggd291bGQgYmUgdmlvbGF0aW9uIG9mIHRoZSBzdGFuZGFyZC5cbiAgICAgICAgLy8gUmVxdWVzdCByZXRyYW5zbWlzc2lvbnMgYXJlIGFic29yYmVkIGJ5IHRoZSB0cmFuc2FjdGlvbiBsYXllcixcbiAgICAgICAgLy8gc28gYW55IHJlcXVlc3Qgd2l0aCBhIGR1cGxpY2F0ZSBzZXF1ZW5jZSBudW1iZXIgZ2V0dGluZyBoZXJlXG4gICAgICAgIC8vIHdvdWxkIGhhdmUgdG8gYmUgYSByZXRyYW5zbWlzc2lvbiBhZnRlciB0aGUgdHJhbnNhY3Rpb24gdGVybWluYXRlZFxuICAgICAgICAvLyBvciBhIGJyb2tlbiByZXF1ZXN0ICh3aXRoIHVuaXF1ZSB2aWEgYnJhbmNoIHZhbHVlKS5cbiAgICAgICAgLy8gUmVxdWVzdHMgd2l0aGluIGEgZGlhbG9nIE1VU1QgY29udGFpbiBzdHJpY3RseSBtb25vdG9uaWNhbGx5XG4gICAgICAgIC8vIGluY3JlYXNpbmcgYW5kIGNvbnRpZ3VvdXMgQ1NlcSBzZXF1ZW5jZSBudW1iZXJzIChpbmNyZWFzaW5nLWJ5LW9uZSlcbiAgICAgICAgLy8gaW4gZWFjaCBkaXJlY3Rpb24gKGV4Y2VwdGluZyBBQ0sgYW5kIENBTkNFTCBvZiBjb3Vyc2UsIHdob3NlIG51bWJlcnNcbiAgICAgICAgLy8gZXF1YWwgdGhlIHJlcXVlc3RzIGJlaW5nIGFja25vd2xlZGdlZCBvciBjYW5jZWxsZWQpLiAgVGhlcmVmb3JlLCBpZlxuICAgICAgICAvLyB0aGUgbG9jYWwgc2VxdWVuY2UgbnVtYmVyIGlzIG5vdCBlbXB0eSwgdGhlIHZhbHVlIG9mIHRoZSBsb2NhbFxuICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIgTVVTVCBiZSBpbmNyZW1lbnRlZCBieSBvbmUsIGFuZCB0aGlzIHZhbHVlIE1VU1QgYmVcbiAgICAgICAgLy8gcGxhY2VkIGludG8gdGhlIENTZXEgaGVhZGVyIGZpZWxkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMS4xXG4gICAgICAgIGlmICh0aGlzLnJlbW90ZVNlcXVlbmNlTnVtYmVyICYmIG1lc3NhZ2UuY3NlcSA8PSB0aGlzLnJlbW90ZVNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvcmUucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA1MDAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbG9nO1xufSgpKTtcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RpYWxvZ1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXNzaW9uLWRpYWxvZ1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdWJzY3JpcHRpb24tZGlhbG9nXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciBzZXNzaW9uXzEgPSByZXF1aXJlKFwiLi4vc2Vzc2lvblwiKTtcbnZhciB0aW1lcnNfMSA9IHJlcXVpcmUoXCIuLi90aW1lcnNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIGJ5ZV91c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL2J5ZS11c2VyLWFnZW50LWNsaWVudFwiKTtcbnZhciBieWVfdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9ieWUtdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgaW5mb191c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL2luZm8tdXNlci1hZ2VudC1jbGllbnRcIik7XG52YXIgaW5mb191c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL2luZm8tdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgbWVzc2FnZV91c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL21lc3NhZ2UtdXNlci1hZ2VudC1jbGllbnRcIik7XG52YXIgbWVzc2FnZV91c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL21lc3NhZ2UtdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgbm90aWZ5X3VzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHMvbm90aWZ5LXVzZXItYWdlbnQtY2xpZW50XCIpO1xudmFyIG5vdGlmeV91c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL25vdGlmeS11c2VyLWFnZW50LXNlcnZlclwiKTtcbnZhciBwcmFja191c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3ByYWNrLXVzZXItYWdlbnQtY2xpZW50XCIpO1xudmFyIHByYWNrX3VzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHMvcHJhY2stdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgcmVfaW52aXRlX3VzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHMvcmUtaW52aXRlLXVzZXItYWdlbnQtY2xpZW50XCIpO1xudmFyIHJlX2ludml0ZV91c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3JlLWludml0ZS11c2VyLWFnZW50LXNlcnZlclwiKTtcbnZhciByZWZlcl91c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3JlZmVyLXVzZXItYWdlbnQtY2xpZW50XCIpO1xudmFyIHJlZmVyX3VzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHMvcmVmZXItdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgZGlhbG9nXzEgPSByZXF1aXJlKFwiLi9kaWFsb2dcIik7XG4vKipcbiAqIFNlc3Npb24gRGlhbG9nLlxuICogQHB1YmxpY1xuICovXG52YXIgU2Vzc2lvbkRpYWxvZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTZXNzaW9uRGlhbG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlc3Npb25EaWFsb2coaW5pdGlhbFRyYW5zYWN0aW9uLCBjb3JlLCBzdGF0ZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29yZSwgc3RhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluaXRpYWxUcmFuc2FjdGlvbiA9IGluaXRpYWxUcmFuc2FjdGlvbjtcbiAgICAgICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGUgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLiAqL1xuICAgICAgICBfdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDtcbiAgICAgICAgLyoqIFRydWUgaWYgd2FpdGluZyBmb3IgYW4gQUNLIHRvIHRoZSBpbml0aWFsIHRyYW5zYWN0aW9uIDJ4eCAoVUFTIG9ubHkpLiAqL1xuICAgICAgICBfdGhpcy5hY2tXYWl0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIGlmIChpbml0aWFsVHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgY3JlYXRlZCBieSBhbiBpbnZpdGUgc2VydmVyIHRyYW5zYWN0aW9uLCB3ZSdyZVxuICAgICAgICAgICAgLy8gZ29pbmcgdG8gYmUgd2FpdGluZyBmb3IgYW4gQUNLIGlmIGFyZSB0byBiZSBjb25maXJtZWQuXG4gICAgICAgICAgICBfdGhpcy5hY2tXYWl0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBjb25maXJtZWQgdXBvbiBjcmVhdGlvbiBzdGFydCB0aGUgcmV0cmFuc21pdHRpbmcgd2hhdGV2ZXJcbiAgICAgICAgLy8gdGhlIDJ4eCBmaW5hbCByZXNwb25zZSB3YXMgdGhhdCBjb25maXJtZWQgdXMgaW50byBleGlzdGVuY2UuXG4gICAgICAgIGlmICghX3RoaXMuZWFybHkpIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0Mnh4UmV0cmFuc21pc3Npb25UaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihpbml0aWFsVHJhbnNhY3Rpb24ucmVxdWVzdCk7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IGNvcmUubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAuaW52aXRlLWRpYWxvZ1wiKTtcbiAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyBfdGhpcy5pZCArIFwiIGNvbnN0cnVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ7XG4gICAgICAgIHRoaXMuX29mZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmludml0ZTJ4eFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBVQVMgTVVTVCBzdGlsbCByZXNwb25kIHRvIGFueSBwZW5kaW5nIHJlcXVlc3RzIHJlY2VpdmVkIGZvciB0aGF0XG4gICAgICAgIC8vIGRpYWxvZy4gIEl0IGlzIFJFQ09NTUVOREVEIHRoYXQgYSA0ODcgKFJlcXVlc3QgVGVybWluYXRlZCkgcmVzcG9uc2VcbiAgICAgICAgLy8gYmUgZ2VuZXJhdGVkIHRvIHRob3NlIHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTUuMS4yXG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIC8vIHRoaXMudXNlckFnZW50U2VydmVycy5mb3JFYWNoKCh1YXMpID0+IHVhcy5yZXBseSg0ODcpKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBkZXN0cm95ZWRcIik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUsIFwic2Vzc2lvblN0YXRlXCIsIHtcbiAgICAgICAgLy8gRklYTUU6IE5lZWQgcmVhbCBzdGF0ZSBtYWNoaW5lXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbl8xLlNlc3Npb25TdGF0ZS5FYXJseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWNrV2FpdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uXzEuU2Vzc2lvblN0YXRlLkFja1dhaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zaWduYWxpbmdTdGF0ZSA9PT0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbl8xLlNlc3Npb25TdGF0ZS5Db25maXJtZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uRGlhbG9nLnByb3RvdHlwZSwgXCJzaWduYWxpbmdTdGF0ZVwiLCB7XG4gICAgICAgIC8qKiBUaGUgc3RhdGUgb2YgdGhlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsaW5nU3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uRGlhbG9nLnByb3RvdHlwZSwgXCJvZmZlclwiLCB7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBvZmZlci4gVW5kZWZpbmVkIHVubGVzcyBzaWduYWxpbmcgc3RhdGUgSGF2ZUxvY2FsT2ZmZXIsIEhhdmVSZW1vdGVPZmZlciwgb2YgU3RhYmxlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb25EaWFsb2cucHJvdG90eXBlLCBcImFuc3dlclwiLCB7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBhbnN3ZXIuIFVuZGVmaW5lZCB1bmxlc3Mgc2lnbmFsaW5nIHN0YXRlIFN0YWJsZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5zd2VyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQ29uZmlybSB0aGUgZGlhbG9nLiBPbmx5IG1hdHRlcnMgaWYgZGlhbG9nIGlzIGN1cnJlbnRseSBlYXJseS4gKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXaGVuIHdlJ3JlIGNvbmZpcm1lZCBzdGFydCB0aGUgcmV0cmFuc21pdHRpbmcgd2hhdGV2ZXJcbiAgICAgICAgLy8gdGhlIDJ4eCBmaW5hbCByZXNwb25zZSB0aGF0IG1heSBoYXZlIGNvbmZpcm1lZCB1cy5cbiAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQyeHhSZXRyYW5zbWlzc2lvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jb25maXJtLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKiogUmUtY29uZmlybSB0aGUgZGlhbG9nLiBPbmx5IG1hdHRlcnMgaWYgaGFuZGxpbmcgcmUtSU5WSVRFIHJlcXVlc3QuICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUucmVDb25maXJtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXaGVuIHdlJ3JlIGNvbmZpcm1lZCBzdGFydCB0aGUgcmV0cmFuc21pdHRpbmcgd2hhdGV2ZXJcbiAgICAgICAgLy8gdGhlIDJ4eCBmaW5hbCByZXNwb25zZSB0aGF0IG1heSBoYXZlIGNvbmZpcm1lZCB1cy5cbiAgICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZUludml0ZTJ4eFJldHJhbnNtaXNzaW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFVBQyBjb3JlIE1VU1QgZ2VuZXJhdGUgYW4gQUNLIHJlcXVlc3QgZm9yIGVhY2ggMnh4IHJlY2VpdmVkIGZyb21cbiAgICAgKiB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBUaGUgaGVhZGVyIGZpZWxkcyBvZiB0aGUgQUNLIGFyZSBjb25zdHJ1Y3RlZFxuICAgICAqIGluIHRoZSBzYW1lIHdheSBhcyBmb3IgYW55IHJlcXVlc3Qgc2VudCB3aXRoaW4gYSBkaWFsb2cgKHNlZSBTZWN0aW9uXG4gICAgICogMTIpIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgQ1NlcSBhbmQgdGhlIGhlYWRlciBmaWVsZHMgcmVsYXRlZCB0b1xuICAgICAqIGF1dGhlbnRpY2F0aW9uLiAgVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgTVVTVCBiZVxuICAgICAqIHRoZSBzYW1lIGFzIHRoZSBJTlZJVEUgYmVpbmcgYWNrbm93bGVkZ2VkLCBidXQgdGhlIENTZXEgbWV0aG9kIE1VU1RcbiAgICAgKiBiZSBBQ0suICBUaGUgQUNLIE1VU1QgY29udGFpbiB0aGUgc2FtZSBjcmVkZW50aWFscyBhcyB0aGUgSU5WSVRFLiAgSWZcbiAgICAgKiB0aGUgMnh4IGNvbnRhaW5zIGFuIG9mZmVyIChiYXNlZCBvbiB0aGUgcnVsZXMgYWJvdmUpLCB0aGUgQUNLIE1VU1RcbiAgICAgKiBjYXJyeSBhbiBhbnN3ZXIgaW4gaXRzIGJvZHkuICBJZiB0aGUgb2ZmZXIgaW4gdGhlIDJ4eCByZXNwb25zZSBpcyBub3RcbiAgICAgKiBhY2NlcHRhYmxlLCB0aGUgVUFDIGNvcmUgTVVTVCBnZW5lcmF0ZSBhIHZhbGlkIGFuc3dlciBpbiB0aGUgQUNLIGFuZFxuICAgICAqIHRoZW4gc2VuZCBhIEJZRSBpbW1lZGlhdGVseS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBQ0sgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIEFDSyByZXF1ZXN0XCIpO1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb247XG4gICAgICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50Q2xpZW50KSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBzZW5kaW5nIEFDSyBmb3IgYSByZS1JTlZJVEVcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBub3QgaW5zdGFuY2Ugb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLnJlaW52aXRlVXNlckFnZW50Q2xpZW50LnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5yZWludml0ZVVzZXJBZ2VudENsaWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIHNlbmRpbmcgQUNLIGZvciB0aGUgaW5pdGlhbCBJTlZJVEVcbiAgICAgICAgICAgIGlmICghKHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5pdGlhbCB0cmFuc2FjdGlvbiBub3QgaW5zdGFuY2Ugb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLmluaXRpYWxUcmFuc2FjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmNzZXEgPSB0cmFuc2FjdGlvbi5yZXF1ZXN0LmNzZXE7IC8vIEFDSyBjc2VxIGlzIElOVklURSBjc2VxXG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5BQ0ssIG9wdGlvbnMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5hY2tSZXNwb25zZShtZXNzYWdlKTsgLy8gU2VlIEludml0ZUNsaWVudFRyYW5zYWN0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVybWluYXRpbmcgYSBTZXNzaW9uXG4gICAgICpcbiAgICAgKiBUaGlzIHNlY3Rpb24gZGVzY3JpYmVzIHRoZSBwcm9jZWR1cmVzIGZvciB0ZXJtaW5hdGluZyBhIHNlc3Npb25cbiAgICAgKiBlc3RhYmxpc2hlZCBieSBTSVAuICBUaGUgc3RhdGUgb2YgdGhlIHNlc3Npb24gYW5kIHRoZSBzdGF0ZSBvZiB0aGVcbiAgICAgKiBkaWFsb2cgYXJlIHZlcnkgY2xvc2VseSByZWxhdGVkLiAgV2hlbiBhIHNlc3Npb24gaXMgaW5pdGlhdGVkIHdpdGggYW5cbiAgICAgKiBJTlZJVEUsIGVhY2ggMXh4IG9yIDJ4eCByZXNwb25zZSBmcm9tIGEgZGlzdGluY3QgVUFTIGNyZWF0ZXMgYVxuICAgICAqIGRpYWxvZywgYW5kIGlmIHRoYXQgcmVzcG9uc2UgY29tcGxldGVzIHRoZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UsIGl0XG4gICAgICogYWxzbyBjcmVhdGVzIGEgc2Vzc2lvbi4gIEFzIGEgcmVzdWx0LCBlYWNoIHNlc3Npb24gaXMgXCJhc3NvY2lhdGVkXCJcbiAgICAgKiB3aXRoIGEgc2luZ2xlIGRpYWxvZyAtIHRoZSBvbmUgd2hpY2ggcmVzdWx0ZWQgaW4gaXRzIGNyZWF0aW9uLiAgSWYgYW5cbiAgICAgKiBpbml0aWFsIElOVklURSBnZW5lcmF0ZXMgYSBub24tMnh4IGZpbmFsIHJlc3BvbnNlLCB0aGF0IHRlcm1pbmF0ZXNcbiAgICAgKiBhbGwgc2Vzc2lvbnMgKGlmIGFueSkgYW5kIGFsbCBkaWFsb2dzIChpZiBhbnkpIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAgICogdGhyb3VnaCByZXNwb25zZXMgdG8gdGhlIHJlcXVlc3QuICBCeSB2aXJ0dWUgb2YgY29tcGxldGluZyB0aGVcbiAgICAgKiB0cmFuc2FjdGlvbiwgYSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIGFsc28gcHJldmVudHMgZnVydGhlciBzZXNzaW9uc1xuICAgICAqIGZyb20gYmVpbmcgY3JlYXRlZCBhcyBhIHJlc3VsdCBvZiB0aGUgSU5WSVRFLiAgVGhlIEJZRSByZXF1ZXN0IGlzXG4gICAgICogdXNlZCB0byB0ZXJtaW5hdGUgYSBzcGVjaWZpYyBzZXNzaW9uIG9yIGF0dGVtcHRlZCBzZXNzaW9uLiAgSW4gdGhpc1xuICAgICAqIGNhc2UsIHRoZSBzcGVjaWZpYyBzZXNzaW9uIGlzIHRoZSBvbmUgd2l0aCB0aGUgcGVlciBVQSBvbiB0aGUgb3RoZXJcbiAgICAgKiBzaWRlIG9mIHRoZSBkaWFsb2cuICBXaGVuIGEgQllFIGlzIHJlY2VpdmVkIG9uIGEgZGlhbG9nLCBhbnkgc2Vzc2lvblxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGRpYWxvZyBTSE9VTEQgdGVybWluYXRlLiAgQSBVQSBNVVNUIE5PVCBzZW5kIGFcbiAgICAgKiBCWUUgb3V0c2lkZSBvZiBhIGRpYWxvZy4gIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyXG4gICAgICogY29uZmlybWVkIG9yIGVhcmx5IGRpYWxvZ3MsIGFuZCB0aGUgY2FsbGVlJ3MgVUEgTUFZIHNlbmQgYSBCWUUgb25cbiAgICAgKiBjb25maXJtZWQgZGlhbG9ncywgYnV0IE1VU1QgTk9UIHNlbmQgYSBCWUUgb24gZWFybHkgZGlhbG9ncy5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHRoZSBjYWxsZWUncyBVQSBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZ1xuICAgICAqIHVudGlsIGl0IGhhcyByZWNlaXZlZCBhbiBBQ0sgZm9yIGl0cyAyeHggcmVzcG9uc2Ugb3IgdW50aWwgdGhlIHNlcnZlclxuICAgICAqIHRyYW5zYWN0aW9uIHRpbWVzIG91dC4gIElmIG5vIFNJUCBleHRlbnNpb25zIGhhdmUgZGVmaW5lZCBvdGhlclxuICAgICAqIGFwcGxpY2F0aW9uIGxheWVyIHN0YXRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGRpYWxvZywgdGhlIEJZRSBhbHNvXG4gICAgICogdGVybWluYXRlcyB0aGUgZGlhbG9nLlxuICAgICAqXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgICAqIEZJWE1FOiBNYWtlIHRoZXNlIHByb3BlciBFeGNlcHRpb25zLi4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBCWUUgb3B0aW9ucyBidWNrZXQuXG4gICAgICogQHJldHVybnNcbiAgICAgKiBUaHJvd3MgYEVycm9yYCBpZiBjYWxsZWUncyBVQSBhdHRlbXB0cyBhIEJZRSBvbiBhbiBlYXJseSBkaWFsb2cuXG4gICAgICogVGhyb3dzIGBFcnJvcmAgaWYgY2FsbGVlJ3MgVUEgYXR0ZW1wdHMgYSBCWUUgb24gYSBjb25maXJtZWQgZGlhbG9nXG4gICAgICogICAgICAgICAgICAgICAgd2hpbGUgaXQncyB3YWl0aW5nIG9uIHRoZSBBQ0sgZm9yIGl0cyAyeHggcmVzcG9uc2UuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUuYnllID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBCWUUgcmVxdWVzdFwiKTtcbiAgICAgICAgLy8gVGhlIGNhbGxlcidzIFVBIE1BWSBzZW5kIGEgQllFIGZvciBlaXRoZXJcbiAgICAgICAgLy8gY29uZmlybWVkIG9yIGVhcmx5IGRpYWxvZ3MsIGFuZCB0aGUgY2FsbGVlJ3MgVUEgTUFZIHNlbmQgYSBCWUUgb25cbiAgICAgICAgLy8gY29uZmlybWVkIGRpYWxvZ3MsIGJ1dCBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGVhcmx5IGRpYWxvZ3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBjYWxsZWUncyBVQSBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZ1xuICAgICAgICAvLyB1bnRpbCBpdCBoYXMgcmVjZWl2ZWQgYW4gQUNLIGZvciBpdHMgMnh4IHJlc3BvbnNlIG9yIHVudGlsIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gdGltZXMgb3V0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxUcmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVUFTIE1VU1QgTk9UIHNlbmQgYSBCWUUgb24gZWFybHkgZGlhbG9ncy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hY2tXYWl0ICYmIHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uLnN0YXRlICE9PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhpcyBzaG91bGQgdGhyb3cgYSBwcm9wZXIgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVBUyBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidW50aWwgaXQgaGFzIHJlY2VpdmVkIGFuIEFDSyBmb3IgaXRzIDJ4eCByZXNwb25zZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwib3IgdW50aWwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiB0aW1lcyBvdXQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEEgQllFIHJlcXVlc3QgaXMgY29uc3RydWN0ZWQgYXMgd291bGQgYW55IG90aGVyIHJlcXVlc3Qgd2l0aGluIGFcbiAgICAgICAgLy8gZGlhbG9nLCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiAxMi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gT25jZSB0aGUgQllFIGlzIGNvbnN0cnVjdGVkLCB0aGUgVUFDIGNvcmUgY3JlYXRlcyBhIG5ldyBub24tSU5WSVRFXG4gICAgICAgIC8vIGNsaWVudCB0cmFuc2FjdGlvbiwgYW5kIHBhc3NlcyBpdCB0aGUgQllFIHJlcXVlc3QuICBUaGUgVUFDIE1VU1RcbiAgICAgICAgLy8gY29uc2lkZXIgdGhlIHNlc3Npb24gdGVybWluYXRlZCAoYW5kIHRoZXJlZm9yZSBzdG9wIHNlbmRpbmcgb3JcbiAgICAgICAgLy8gbGlzdGVuaW5nIGZvciBtZWRpYSkgYXMgc29vbiBhcyB0aGUgQllFIHJlcXVlc3QgaXMgcGFzc2VkIHRvIHRoZVxuICAgICAgICAvLyBjbGllbnQgdHJhbnNhY3Rpb24uICBJZiB0aGUgcmVzcG9uc2UgZm9yIHRoZSBCWUUgaXMgYSA0ODFcbiAgICAgICAgLy8gKENhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpIG9yIGEgNDA4IChSZXF1ZXN0IFRpbWVvdXQpIG9yIG5vXG4gICAgICAgIC8vIHJlc3BvbnNlIGF0IGFsbCBpcyByZWNlaXZlZCBmb3IgdGhlIEJZRSAodGhhdCBpcywgYSB0aW1lb3V0IGlzXG4gICAgICAgIC8vIHJldHVybmVkIGJ5IHRoZSBjbGllbnQgdHJhbnNhY3Rpb24pLCB0aGUgVUFDIE1VU1QgY29uc2lkZXIgdGhlXG4gICAgICAgIC8vIHNlc3Npb24gYW5kIHRoZSBkaWFsb2cgdGVybWluYXRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNS4xLjFcbiAgICAgICAgcmV0dXJuIG5ldyBieWVfdXNlcl9hZ2VudF9jbGllbnRfMS5CeWVVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gSU5GTyByZXF1ZXN0IGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggYW4gSW5mbyBQYWNrYWdlIChzZWVcbiAgICAgKiBTZWN0aW9uIDUpLCBvciBhc3NvY2lhdGVkIHdpdGggYSBsZWdhY3kgSU5GTyB1c2FnZSAoc2VlIFNlY3Rpb24gMikuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc3RydWN0aW9uIG9mIHRoZSBJTkZPIHJlcXVlc3QgaXMgdGhlIHNhbWUgYXMgYW55IG90aGVyXG4gICAgICogbm9uLXRhcmdldCByZWZyZXNoIHJlcXVlc3Qgd2l0aGluIGFuIGV4aXN0aW5nIGludml0ZSBkaWFsb2cgdXNhZ2UgYXNcbiAgICAgKiBkZXNjcmliZWQgaW4gU2VjdGlvbiAxMi4yIG9mIFJGQyAzMjYxLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDg2I3NlY3Rpb24tNC4yLjFcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIElORk8gcmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgbm90IGNvbmZpcm1lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBpbmZvX3VzZXJfYWdlbnRfY2xpZW50XzEuSW5mb1VzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvblxuICAgICAqXG4gICAgICogQSBzdWNjZXNzZnVsIElOVklURSByZXF1ZXN0IChzZWUgU2VjdGlvbiAxMykgZXN0YWJsaXNoZXMgYm90aCBhXG4gICAgICogZGlhbG9nIGJldHdlZW4gdHdvIHVzZXIgYWdlbnRzIGFuZCBhIHNlc3Npb24gdXNpbmcgdGhlIG9mZmVyLWFuc3dlclxuICAgICAqIG1vZGVsLiAgU2VjdGlvbiAxMiBleHBsYWlucyBob3cgdG8gbW9kaWZ5IGFuIGV4aXN0aW5nIGRpYWxvZyB1c2luZyBhXG4gICAgICogdGFyZ2V0IHJlZnJlc2ggcmVxdWVzdCAoZm9yIGV4YW1wbGUsIGNoYW5naW5nIHRoZSByZW1vdGUgdGFyZ2V0IFVSSVxuICAgICAqIG9mIHRoZSBkaWFsb2cpLiAgVGhpcyBzZWN0aW9uIGRlc2NyaWJlcyBob3cgdG8gbW9kaWZ5IHRoZSBhY3R1YWxcbiAgICAgKiBzZXNzaW9uLiAgVGhpcyBtb2RpZmljYXRpb24gY2FuIGludm9sdmUgY2hhbmdpbmcgYWRkcmVzc2VzIG9yIHBvcnRzLFxuICAgICAqIGFkZGluZyBhIG1lZGlhIHN0cmVhbSwgZGVsZXRpbmcgYSBtZWRpYSBzdHJlYW0sIGFuZCBzbyBvbi4gIFRoaXMgaXNcbiAgICAgKiBhY2NvbXBsaXNoZWQgYnkgc2VuZGluZyBhIG5ldyBJTlZJVEUgcmVxdWVzdCB3aXRoaW4gdGhlIHNhbWUgZGlhbG9nXG4gICAgICogdGhhdCBlc3RhYmxpc2hlZCB0aGUgc2Vzc2lvbi4gIEFuIElOVklURSByZXF1ZXN0IHNlbnQgd2l0aGluIGFuXG4gICAgICogZXhpc3RpbmcgZGlhbG9nIGlzIGtub3duIGFzIGEgcmUtSU5WSVRFLlxuICAgICAqXG4gICAgICogICAgTm90ZSB0aGF0IGEgc2luZ2xlIHJlLUlOVklURSBjYW4gbW9kaWZ5IHRoZSBkaWFsb2cgYW5kIHRoZVxuICAgICAqICAgIHBhcmFtZXRlcnMgb2YgdGhlIHNlc3Npb24gYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKlxuICAgICAqIEVpdGhlciB0aGUgY2FsbGVyIG9yIGNhbGxlZSBjYW4gbW9kaWZ5IGFuIGV4aXN0aW5nIHNlc3Npb24uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXRcbiAgICAgKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5pbnZpdGUgPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIElOVklURSByZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBub3QgY29uZmlybWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoYXQgYSBVQUMgTVVTVCBOT1QgaW5pdGlhdGUgYSBuZXcgSU5WSVRFIHRyYW5zYWN0aW9uIHdpdGhpbiBhXG4gICAgICAgIC8vIGRpYWxvZyB3aGlsZSBhbm90aGVyIElOVklURSB0cmFuc2FjdGlvbiBpcyBpbiBwcm9ncmVzcyBpbiBlaXRoZXJcbiAgICAgICAgLy8gZGlyZWN0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAxLiBJZiB0aGVyZSBpcyBhbiBvbmdvaW5nIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24sIHRoZSBUVSBNVVNUXG4gICAgICAgIC8vICAgICAgIHdhaXQgdW50aWwgdGhlIHRyYW5zYWN0aW9uIHJlYWNoZXMgdGhlIGNvbXBsZXRlZCBvciB0ZXJtaW5hdGVkXG4gICAgICAgIC8vICAgICAgIHN0YXRlIGJlZm9yZSBpbml0aWF0aW5nIHRoZSBuZXcgSU5WSVRFLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAyLiBJZiB0aGVyZSBpcyBhbiBvbmdvaW5nIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24sIHRoZSBUVSBNVVNUXG4gICAgICAgIC8vICAgICAgIHdhaXQgdW50aWwgdGhlIHRyYW5zYWN0aW9uIHJlYWNoZXMgdGhlIGNvbmZpcm1lZCBvciB0ZXJtaW5hdGVkXG4gICAgICAgIC8vICAgICAgIHN0YXRlIGJlZm9yZSBpbml0aWF0aW5nIHRoZSBuZXcgSU5WSVRFLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCBhIFVBIE1BWSBpbml0aWF0ZSBhIHJlZ3VsYXIgdHJhbnNhY3Rpb24gd2hpbGUgYW4gSU5WSVRFXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGlzIGluIHByb2dyZXNzLiAgQSBVQSBNQVkgYWxzbyBpbml0aWF0ZSBhbiBJTlZJVEVcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gd2hpbGUgYSByZWd1bGFyIHRyYW5zYWN0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0LjFcbiAgICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhbiBvbmdvaW5nIHJlLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhpcyBzaG91bGQgdGhyb3cgYSBwcm9wZXIgZXhjZXB0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYW4gb25nb2luZyByZS1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHJlX2ludml0ZV91c2VyX2FnZW50X2NsaWVudF8xLlJlSW52aXRlVXNlckFnZW50Q2xpZW50KHRoaXMsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVUFDIE1BWSBhc3NvY2lhdGUgYSBNRVNTQUdFIHJlcXVlc3Qgd2l0aCBhbiBleGlzdGluZyBkaWFsb2cuICBJZiBhXG4gICAgICogTUVTU0FHRSByZXF1ZXN0IGlzIHNlbnQgd2l0aGluIGEgZGlhbG9nLCBpdCBpcyBcImFzc29jaWF0ZWRcIiB3aXRoIGFueVxuICAgICAqIG1lZGlhIHNlc3Npb24gb3Igc2Vzc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgZGlhbG9nLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDI4I3NlY3Rpb24tNFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHNlbmRpbmcgTUVTU0FHRSByZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBub3QgY29uZmlybWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXNzYWdlc18xLkMuTUVTU0FHRSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZV91c2VyX2FnZW50X2NsaWVudF8xLk1lc3NhZ2VVc2VyQWdlbnRDbGllbnQodGhpcy5jb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgTk9USUZZIG1lY2hhbmlzbSBkZWZpbmVkIGluIFsyXSBNVVNUIGJlIHVzZWQgdG8gaW5mb3JtIHRoZSBhZ2VudFxuICAgICAqIHNlbmRpbmcgdGhlIFJFRkVSIG9mIHRoZSBzdGF0dXMgb2YgdGhlIHJlZmVyZW5jZS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUxNSNzZWN0aW9uLTIuNC40XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIE5PVElGWSByZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBub3QgY29uZmlybWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG5vdGlmeV91c2VyX2FnZW50X2NsaWVudF8xLk5vdGlmeVVzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBc3N1bWluZyB0aGUgcmVzcG9uc2UgaXMgdG8gYmUgdHJhbnNtaXR0ZWQgcmVsaWFibHksIHRoZSBVQUMgTVVTVFxuICAgICAqIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHdpdGggbWV0aG9kIFBSQUNLLiAgVGhpcyByZXF1ZXN0IGlzIHNlbnQgd2l0aGluXG4gICAgICogdGhlIGRpYWxvZyBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIChpbmRlZWQsIHRoZVxuICAgICAqIHByb3Zpc2lvbmFsIHJlc3BvbnNlIG1heSBoYXZlIGNyZWF0ZWQgdGhlIGRpYWxvZykuICBQUkFDSyByZXF1ZXN0c1xuICAgICAqIE1BWSBjb250YWluIGJvZGllcywgd2hpY2ggYXJlIGludGVycHJldGVkIGFjY29yZGluZyB0byB0aGVpciB0eXBlIGFuZFxuICAgICAqIGRpc3Bvc2l0aW9uLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUucHJhY2sgPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIFBSQUNLIHJlcXVlc3RcIik7XG4gICAgICAgIHJldHVybiBuZXcgcHJhY2tfdXNlcl9hZ2VudF9jbGllbnRfMS5QcmFja1VzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSRUZFUiBpcyBhIFNJUCByZXF1ZXN0IGFuZCBpcyBjb25zdHJ1Y3RlZCBhcyBkZWZpbmVkIGluIFsxXS4gIEEgUkVGRVJcbiAgICAgKiByZXF1ZXN0IE1VU1QgY29udGFpbiBleGFjdGx5IG9uZSBSZWZlci1UbyBoZWFkZXIgZmllbGQgdmFsdWUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuMVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUucmVmZXIgPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIFJFRkVSIHJlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLmVhcmx5KSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhpcyBzaG91bGQgdGhyb3cgYSBwcm9wZXIgZXhjZXB0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIG5vdCBjb25maXJtZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBWYWxpZGF0ZSBSZWZlci1UbyBoZWFkZXIgZmllbGQgdmFsdWUuXG4gICAgICAgIHJldHVybiBuZXcgcmVmZXJfdXNlcl9hZ2VudF9jbGllbnRfMS5SZWZlclVzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBzZW50IHdpdGhpbiBhIGRpYWxvZywgYXMgYW55IG90aGVyIHJlcXVlc3RzLCBhcmUgYXRvbWljLiAgSWZcbiAgICAgKiBhIHBhcnRpY3VsYXIgcmVxdWVzdCBpcyBhY2NlcHRlZCBieSB0aGUgVUFTLCBhbGwgdGhlIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggaXQgYXJlIHBlcmZvcm1lZC4gIElmIHRoZSByZXF1ZXN0IGlzIHJlamVjdGVkLCBub25lXG4gICAgICogb2YgdGhlIHN0YXRlIGNoYW5nZXMgYXJlIHBlcmZvcm1lZC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIHdpdGhpbiB0aGlzIGRpYWxvZy5cbiAgICAgKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVjZWl2ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3RcIik7XG4gICAgICAgIC8vIFJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucyBjZWFzZSB3aGVuIGFuIEFDSyByZXF1ZXN0IGZvciB0aGVcbiAgICAgICAgLy8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuICBUaGlzIGlzIGluZGVwZW5kZW50IG9mIHdoYXRldmVyIHRyYW5zcG9ydFxuICAgICAgICAvLyBwcm90b2NvbHMgYXJlIHVzZWQgdG8gc2VuZCB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgLy8gSWYgYWNrV2FpdCBpcyB0cnVlLCB0aGVuIHRoaXMgaXMgdGhlIEFDSyB0byB0aGUgaW5pdGlhbCBJTlZJVEUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhpcyBpcyBhbiBBQ0sgdG8gYW4gaW4gZGlhbG9nIElOVklURS4gSW4gZWl0aGVyIGNhc2UsXG4gICAgICAgICAgICAvLyBndWFyZCB0byBtYWtlIHN1cmUgdGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgQUNLIG1hdGNoZXMgdGhlIElOVklURS5cbiAgICAgICAgICAgIGlmICh0aGlzLmFja1dhaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsVHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWNlaXZlZCB1bmV4cGVjdGVkIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0LCBkcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uLnJlcXVlc3QuY3NlcSAhPT0gbWVzc2FnZS5jc2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3QsIGRyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYmVmb3JlIHRoZSBkZWxlZ2F0ZSBoYXMgYSBjaGFuY2UgdG8gaGFuZGxlIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgYXMgZGVsZWdhdGUgbWF5IGNhbGxiYWNrIGludG8gdGhpcyBkaWFsb2cuXG4gICAgICAgICAgICAgICAgdGhpcy5hY2tXYWl0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIgcmVxdWVzdCwgZHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyLnRyYW5zYWN0aW9uLnJlcXVlc3QuY3NlcSAhPT0gbWVzc2FnZS5jc2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3QsIGRyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkFjayh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cgb3V0IG9mIHNlcXVlbmNlIGd1YXJkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICBpZiAoIXRoaXMuc2VxdWVuY2VHdWFyZChtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWplY3RlZCBvdXQgb2Ygb3JkZXIgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3QuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLklOVklURSkge1xuICAgICAgICAgICAgLy8gQSBVQVMgdGhhdCByZWNlaXZlcyBhIHNlY29uZCBJTlZJVEUgYmVmb3JlIGl0IHNlbmRzIHRoZSBmaW5hbFxuICAgICAgICAgICAgLy8gcmVzcG9uc2UgdG8gYSBmaXJzdCBJTlZJVEUgd2l0aCBhIGxvd2VyIENTZXEgc2VxdWVuY2UgbnVtYmVyIG9uIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBkaWFsb2cgTVVTVCByZXR1cm4gYSA1MDAgKFNlcnZlciBJbnRlcm5hbCBFcnJvcikgcmVzcG9uc2UgdG8gdGhlXG4gICAgICAgICAgICAvLyBzZWNvbmQgSU5WSVRFIGFuZCBNVVNUIGluY2x1ZGUgYSBSZXRyeS1BZnRlciBoZWFkZXIgZmllbGQgd2l0aCBhXG4gICAgICAgICAgICAvLyByYW5kb21seSBjaG9zZW4gdmFsdWUgb2YgYmV0d2VlbiAwIGFuZCAxMCBzZWNvbmRzLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4yXG4gICAgICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjAuMzNcbiAgICAgICAgICAgICAgICB2YXIgcmV0cnlBZnRlciA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAxMCkpICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW1wiUmV0cnktQWZ0ZXI6IFwiICsgcmV0cnlBZnRlcl07XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAwLCBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBIFVBUyB0aGF0IHJlY2VpdmVzIGFuIElOVklURSBvbiBhIGRpYWxvZyB3aGlsZSBhbiBJTlZJVEUgaXQgaGFkIHNlbnRcbiAgICAgICAgICAgIC8vIG9uIHRoYXQgZGlhbG9nIGlzIGluIHByb2dyZXNzIE1VU1QgcmV0dXJuIGEgNDkxIChSZXF1ZXN0IFBlbmRpbmcpXG4gICAgICAgICAgICAvLyByZXNwb25zZSB0byB0aGUgcmVjZWl2ZWQgSU5WSVRFLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4yXG4gICAgICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ5MSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cgY29tbW9uIHByb2Nlc3NpbmcuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gUmVxdWVzdHMgd2l0aGluIGEgZGlhbG9nIE1BWSBjb250YWluIFJlY29yZC1Sb3V0ZSBhbmQgQ29udGFjdCBoZWFkZXJcbiAgICAgICAgLy8gZmllbGRzLiAgSG93ZXZlciwgdGhlc2UgcmVxdWVzdHMgZG8gbm90IGNhdXNlIHRoZSBkaWFsb2cncyByb3V0ZSBzZXRcbiAgICAgICAgLy8gdG8gYmUgbW9kaWZpZWQsIGFsdGhvdWdoIHRoZXkgbWF5IG1vZGlmeSB0aGUgcmVtb3RlIHRhcmdldCBVUkkuXG4gICAgICAgIC8vIFNwZWNpZmljYWxseSwgcmVxdWVzdHMgdGhhdCBhcmUgbm90IHRhcmdldCByZWZyZXNoIHJlcXVlc3RzIGRvIG5vdFxuICAgICAgICAvLyBtb2RpZnkgdGhlIGRpYWxvZydzIHJlbW90ZSB0YXJnZXQgVVJJLCBhbmQgcmVxdWVzdHMgdGhhdCBhcmUgdGFyZ2V0XG4gICAgICAgIC8vIHJlZnJlc2ggcmVxdWVzdHMgZG8uICBGb3IgZGlhbG9ncyB0aGF0IGhhdmUgYmVlbiBlc3RhYmxpc2hlZCB3aXRoIGFuXG4gICAgICAgIC8vIElOVklURSwgdGhlIG9ubHkgdGFyZ2V0IHJlZnJlc2ggcmVxdWVzdCBkZWZpbmVkIGlzIHJlLUlOVklURSAoc2VlXG4gICAgICAgIC8vIFNlY3Rpb24gMTQpLiAgT3RoZXIgZXh0ZW5zaW9ucyBtYXkgZGVmaW5lIGRpZmZlcmVudCB0YXJnZXQgcmVmcmVzaFxuICAgICAgICAvLyByZXF1ZXN0cyBmb3IgZGlhbG9ncyBlc3RhYmxpc2hlZCBpbiBvdGhlciB3YXlzLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICBOb3RlIHRoYXQgYW4gQUNLIGlzIE5PVCBhIHRhcmdldCByZWZyZXNoIHJlcXVlc3QuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRhcmdldCByZWZyZXNoIHJlcXVlc3RzIG9ubHkgdXBkYXRlIHRoZSBkaWFsb2cncyByZW1vdGUgdGFyZ2V0IFVSSSxcbiAgICAgICAgLy8gYW5kIG5vdCB0aGUgcm91dGUgc2V0IGZvcm1lZCBmcm9tIHRoZSBSZWNvcmQtUm91dGUuICBVcGRhdGluZyB0aGVcbiAgICAgICAgLy8gbGF0dGVyIHdvdWxkIGludHJvZHVjZSBzZXZlcmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHJvYmxlbXMgd2l0aFxuICAgICAgICAvLyBSRkMgMjU0My1jb21wbGlhbnQgc3lzdGVtcy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBwYXJzZXIgbmVlZHMgdG8gYmUgdHlwZWQuLi5cbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRhY3RcIik7XG4gICAgICAgICAgICBpZiAoIWNvbnRhY3QpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY29udGFjdCBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuTmFtZUFkZHJIZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCBub3QgaW5zdGFuY2Ugb2YgTmFtZUFkZHJIZWFkZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaWFsb2dTdGF0ZS5yZW1vdGVUYXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTd2l0Y2ggb24gbWV0aG9kIGFuZCB0aGVuIGRlbGVnYXRlLlxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5CWUU6XG4gICAgICAgICAgICAgICAgLy8gQSBVQVMgY29yZSByZWNlaXZpbmcgYSBCWUUgcmVxdWVzdCBmb3IgYW4gZXhpc3RpbmcgZGlhbG9nIE1VU1QgZm9sbG93XG4gICAgICAgICAgICAgICAgLy8gdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvbiAxMi4yLjIgdG8gcHJvY2VzcyB0aGUgcmVxdWVzdC4gIE9uY2UgZG9uZSxcbiAgICAgICAgICAgICAgICAvLyB0aGUgVUFTIFNIT1VMRCB0ZXJtaW5hdGUgdGhlIHNlc3Npb24gKGFuZCB0aGVyZWZvcmUgc3RvcCBzZW5kaW5nIGFuZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBmb3IgbWVkaWEpLiAgVGhlIG9ubHkgY2FzZSB3aGVyZSBpdCBjYW4gZWxlY3Qgbm90IHRvIGFyZVxuICAgICAgICAgICAgICAgIC8vIG11bHRpY2FzdCBzZXNzaW9ucywgd2hlcmUgcGFydGljaXBhdGlvbiBpcyBwb3NzaWJsZSBldmVuIGlmIHRoZSBvdGhlclxuICAgICAgICAgICAgICAgIC8vIHBhcnRpY2lwYW50IGluIHRoZSBkaWFsb2cgaGFzIHRlcm1pbmF0ZWQgaXRzIGludm9sdmVtZW50IGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlc3Npb24uICBXaGV0aGVyIG9yIG5vdCBpdCBlbmRzIGl0cyBwYXJ0aWNpcGF0aW9uIG9uIHRoZSBzZXNzaW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBVQVMgY29yZSBNVVNUIGdlbmVyYXRlIGEgMnh4IHJlc3BvbnNlIHRvIHRoZSBCWUUsIGFuZCBNVVNUIHBhc3NcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gZm9yIHRyYW5zbWlzc2lvbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRoZSBVQVMgTVVTVCBzdGlsbCByZXNwb25kIHRvIGFueSBwZW5kaW5nIHJlcXVlc3RzIHJlY2VpdmVkIGZvciB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZGlhbG9nLiAgSXQgaXMgUkVDT01NRU5ERUQgdGhhdCBhIDQ4NyAoUmVxdWVzdCBUZXJtaW5hdGVkKSByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIGJlIGdlbmVyYXRlZCB0byB0aG9zZSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTUuMS4yXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IGJ5ZV91c2VyX2FnZW50X3NlcnZlcl8xLkJ5ZVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQnllID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25CeWUodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLklORk86XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBVQSByZWNlaXZlcyBhbiBJTkZPIHJlcXVlc3QgYXNzb2NpYXRlZCB3aXRoIGFuIEluZm8gUGFja2FnZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIFVBIGhhcyBub3QgaW5kaWNhdGVkIHdpbGxpbmduZXNzIHRvIHJlY2VpdmUsIHRoZSBVQSBNVVNUIHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIDQ2OSAoQmFkIEluZm8gUGFja2FnZSkgcmVzcG9uc2UgKHNlZSBTZWN0aW9uIDExLjYpLCB3aGljaCBjb250YWlucyBhXG4gICAgICAgICAgICAgICAgLy8gUmVjdi1JbmZvIGhlYWRlciBmaWVsZCB3aXRoIEluZm8gUGFja2FnZXMgZm9yIHdoaWNoIHRoZSBVQSBpcyB3aWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gdG8gcmVjZWl2ZSBJTkZPIHJlcXVlc3RzLlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyBpbmZvX3VzZXJfYWdlbnRfc2VydmVyXzEuSW5mb1VzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uSW5mbyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW5mbyh1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQ2OSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IFtcIlJlY3YtSW5mbyA6XCJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5JTlZJVEU6XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldyBzZXNzaW9uIGRlc2NyaXB0aW9uIGlzIG5vdCBhY2NlcHRhYmxlLCB0aGUgVUFTIGNhbiByZWplY3RcbiAgICAgICAgICAgICAgICAvLyBpdCBieSByZXR1cm5pbmcgYSA0ODggKE5vdCBBY2NlcHRhYmxlIEhlcmUpIHJlc3BvbnNlIGZvciB0aGUgcmUtXG4gICAgICAgICAgICAgICAgLy8gSU5WSVRFLiAgVGhpcyByZXNwb25zZSBTSE9VTEQgaW5jbHVkZSBhIFdhcm5pbmcgaGVhZGVyIGZpZWxkLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyByZV9pbnZpdGVfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5SZUludml0ZVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OCB9KTsgLy8gVE9ETzogV2FybmluZyBoZWFkZXIgZmllbGQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuTUVTU0FHRTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgbWVzc2FnZV91c2VyX2FnZW50X3NlcnZlcl8xLk1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIodGhpcy5jb3JlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZSh1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5OT1RJRlk6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuNFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyBub3RpZnlfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5Ob3RpZnlVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLlBSQUNLOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyBwcmFja191c2VyX2FnZW50X3NlcnZlcl8xLlByYWNrVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25QcmFjayA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUHJhY2sodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuUkVGRVI6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuMlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyByZWZlcl91c2VyX2FnZW50X3NlcnZlcl8xLlJlZmVyVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWZlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVmZXIodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVjZWl2ZWQgdW5pbXBsZW1lbnRlZCBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUucmVsaWFibGVTZXF1ZW5jZUd1YXJkID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBtZXNzYWdlLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmICghc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdHVzIGNvZGUgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXNDb2RlID4gMTAwICYmIHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgICAgICAgIC8vIElmIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgZm9yIGFuIGluaXRpYWwgcmVxdWVzdCwgYW5kXG4gICAgICAgICAgICAvLyB0aGF0IHJlc3BvbnNlIGNvbnRhaW5zIGEgUmVxdWlyZSBoZWFkZXIgZmllbGQgY29udGFpbmluZyB0aGUgb3B0aW9uXG4gICAgICAgICAgICAvLyB0YWcgMTAwcmVsLCB0aGUgcmVzcG9uc2UgaXMgdG8gYmUgc2VudCByZWxpYWJseS4gIElmIHRoZSByZXNwb25zZSBpc1xuICAgICAgICAgICAgLy8gYSAxMDAgKFRyeWluZykgKGFzIG9wcG9zZWQgdG8gMTAxIHRvIDE5OSksIHRoaXMgb3B0aW9uIHRhZyBNVVNUIGJlXG4gICAgICAgICAgICAvLyBpZ25vcmVkLCBhbmQgdGhlIHByb2NlZHVyZXMgYmVsb3cgTVVTVCBOT1QgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgICAgICAgICAgdmFyIHJlcXVpcmVIZWFkZXIgPSBtZXNzYWdlLmdldEhlYWRlcihcInJlcXVpcmVcIik7XG4gICAgICAgICAgICB2YXIgcnNlcUhlYWRlciA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwicnNlcVwiKTtcbiAgICAgICAgICAgIHZhciByc2VxID0gcmVxdWlyZUhlYWRlciAmJiByZXF1aXJlSGVhZGVyLmluY2x1ZGVzKFwiMTAwcmVsXCIpICYmIHJzZXFIZWFkZXIgPyBOdW1iZXIocnNlcUhlYWRlcikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocnNlcSkge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsaW5nIG9mIHN1YnNlcXVlbnQgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIGZvciB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgcmVxdWVzdCBmb2xsb3dzIHRoZSBzYW1lIHJ1bGVzIGFzIGFib3ZlLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlOiByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgaW5cbiAgICAgICAgICAgICAgICAvLyBvcmRlci4gIEFzIGEgcmVzdWx0LCBpZiB0aGUgVUFDIHJlY2VpdmVzIGFub3RoZXIgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZSB0byB0aGUgc2FtZSByZXF1ZXN0LCBhbmQgaXRzIFJTZXEgdmFsdWUgaXMgbm90IG9uZSBoaWdoZXJcbiAgICAgICAgICAgICAgICAvLyB0aGFuIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgbnVtYmVyLCB0aGF0IHJlc3BvbnNlIE1VU1QgTk9UIGJlXG4gICAgICAgICAgICAgICAgLy8gYWNrbm93bGVkZ2VkIHdpdGggYSBQUkFDSywgYW5kIE1VU1QgTk9UIGJlIHByb2Nlc3NlZCBmdXJ0aGVyIGJ5IHRoZVxuICAgICAgICAgICAgICAgIC8vIFVBQy4gIEFuIGltcGxlbWVudGF0aW9uIE1BWSBkaXNjYXJkIHRoZSByZXNwb25zZSwgb3IgTUFZIGNhY2hlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlIGluIHRoZSBob3BlcyBvZiByZWNlaXZpbmcgdGhlIG1pc3NpbmcgcmVzcG9uc2VzLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJzZXEgJiYgdGhpcy5yc2VxICsgMSAhPT0gcnNlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9uY2UgYSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBpcyByZWNlaXZlZCwgcmV0cmFuc21pc3Npb25zIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhhdCByZXNwb25zZSBNVVNUIGJlIGRpc2NhcmRlZC4gIEEgcmVzcG9uc2UgaXMgYSByZXRyYW5zbWlzc2lvbiB3aGVuXG4gICAgICAgICAgICAgICAgLy8gaXRzIGRpYWxvZyBJRCwgQ1NlcSwgYW5kIFJTZXEgbWF0Y2ggdGhlIG9yaWdpbmFsIHJlc3BvbnNlLiAgVGhlIFVBQ1xuICAgICAgICAgICAgICAgIC8vIE1VU1QgbWFpbnRhaW4gYSBzZXF1ZW5jZSBudW1iZXIgdGhhdCBpbmRpY2F0ZXMgdGhlIG1vc3QgcmVjZW50bHlcbiAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCBpbi1vcmRlciByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBmb3IgdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0LiAgVGhpcyBzZXF1ZW5jZSBudW1iZXIgTVVTVCBiZSBtYWludGFpbmVkIHVudGlsIGEgZmluYWxcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZSBpcyByZWNlaXZlZCBmb3IgdGhlIGluaXRpYWwgcmVxdWVzdC4gIEl0cyB2YWx1ZSBNVVNUIGJlXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdG8gdGhlIFJTZXEgaGVhZGVyIGZpZWxkIGluIHRoZSBmaXJzdCByZWxpYWJsZVxuICAgICAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHJlY2VpdmVkIGZvciB0aGUgaW5pdGlhbCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yc2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnNlcSA9IHJzZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgbm90IGluIGEgc3RhYmxlIHNpZ25hbGluZyBzdGF0ZSwgcm9sbGJhY2sgdG8gcHJpb3Igc3RhYmxlIHNpZ25hbGluZyBzdGF0ZS5cbiAgICAgKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5zaWduYWxpbmdTdGF0ZVJvbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlciB8fFxuICAgICAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JvbGxiYWNrT2ZmZXIgJiYgdGhpcy5fcm9sbGJhY2tBbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2ZmZXIgPSB0aGlzLl9yb2xsYmFja09mZmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IHRoaXMuX3JvbGxiYWNrQW5zd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNpZ25hbGluZyBzdGF0ZSBvZiB0aGUgZGlhbG9nLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gYmFzZSB0aGUgdXBkYXRlIG9mZiBvZi5cbiAgICAgKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgYm9keSA9IG1lc3NhZ2VzXzEuZ2V0Qm9keShtZXNzYWdlKTtcbiAgICAgICAgLy8gTm8gYm9keSwgbm8gc2Vzc2lvbi4gTm8sIHdvbWFuLCBubyBjcnkuXG4gICAgICAgIGlmICghYm9keSB8fCBib2R5LmNvbnRlbnREaXNwb3NpdGlvbiAhPT0gXCJzZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSBnb3QgYW4gZXhpc3Rpbmcgb2ZmZXIgYW5kIGFuc3dlciB3aGljaCB3ZSBtYXkgd2lzaCB0byByb2xsYmFjayB0b1xuICAgICAgICBpZiAodGhpcy5fc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvbGxiYWNrT2ZmZXIgPSB0aGlzLl9vZmZlcjtcbiAgICAgICAgICAgIHRoaXMuX3JvbGxiYWNrQW5zd2VyID0gdGhpcy5fYW5zd2VyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGluIFVBUyByb2xlLCByZWNlaXZpbmcgaW5jb21pbmcgcmVxdWVzdCB3aXRoIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBtZXNzYWdlc18xLkluY29taW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZlciA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5zd2VyID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgICAgICAgICAgICAvLyBZb3UgY2Fubm90IG1ha2UgYSBuZXcgb2ZmZXIgd2hpbGUgb25lIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCB0byBkbyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc2lnbmFsaW5nIHN0YXRlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBpbiBVQUMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlc3BvbnNlIHdpdGggc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZlciA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5zd2VyID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgICAgICAgICAgICAvLyBZb3UgY2Fubm90IG1ha2UgYSBuZXcgb2ZmZXIgd2hpbGUgb25lIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCB0byBkbyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc2lnbmFsaW5nIHN0YXRlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBpbiBVQUMgcm9sZSwgc2VuZGluZyBvdXRnb2luZyByZXF1ZXN0IHdpdGggc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmZXIgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgICAgICAgICAgICAvLyBZb3UgY2Fubm90IG1ha2UgYSBuZXcgb2ZmZXIgd2hpbGUgb25lIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCB0byBkbyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5zd2VyID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgaW4gVUFTIHJvbGUsIHNlbmRpbmcgb3V0Z29pbmcgcmVzcG9uc2Ugd2l0aCBzZXNzaW9uIGRlc2NyaXB0aW9uXG4gICAgICAgIGlmIChtZXNzYWdlc18xLmlzQm9keShtZXNzYWdlKSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmZXIgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgICAgICAgICAgICAvLyBZb3UgY2Fubm90IG1ha2UgYSBuZXcgb2ZmZXIgd2hpbGUgb25lIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCB0byBkbyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5zd2VyID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLnN0YXJ0Mnh4UmV0cmFuc21pc3Npb25UaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbl8xID0gdGhpcy5pbml0aWFsVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSByZXNwb25zZSBoYXMgYmVlbiBjb25zdHJ1Y3RlZCwgaXQgaXMgcGFzc2VkIHRvIHRoZSBJTlZJVEVcbiAgICAgICAgICAgIC8vIHNlcnZlciB0cmFuc2FjdGlvbi4gIEluIG9yZGVyIHRvIGVuc3VyZSByZWxpYWJsZSBlbmQtdG8tZW5kXG4gICAgICAgICAgICAvLyB0cmFuc3BvcnQgb2YgdGhlIHJlc3BvbnNlLCBpdCBpcyBuZWNlc3NhcnkgdG8gcGVyaW9kaWNhbGx5IHBhc3NcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBkaXJlY3RseSB0byB0aGUgdHJhbnNwb3J0IHVudGlsIHRoZSBBQ0sgYXJyaXZlcy4gIFRoZVxuICAgICAgICAgICAgLy8gMnh4IHJlc3BvbnNlIGlzIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IHdpdGggYW4gaW50ZXJ2YWwgdGhhdFxuICAgICAgICAgICAgLy8gc3RhcnRzIGF0IFQxIHNlY29uZHMgYW5kIGRvdWJsZXMgZm9yIGVhY2ggcmV0cmFuc21pc3Npb24gdW50aWwgaXRcbiAgICAgICAgICAgIC8vIHJlYWNoZXMgVDIgc2Vjb25kcyAoVDEgYW5kIFQyIGFyZSBkZWZpbmVkIGluIFNlY3Rpb24gMTcpLlxuICAgICAgICAgICAgLy8gUmVzcG9uc2UgcmV0cmFuc21pc3Npb25zIGNlYXNlIHdoZW4gYW4gQUNLIHJlcXVlc3QgZm9yIHRoZVxuICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuICBUaGlzIGlzIGluZGVwZW5kZW50IG9mIHdoYXRldmVyIHRyYW5zcG9ydFxuICAgICAgICAgICAgLy8gcHJvdG9jb2xzIGFyZSB1c2VkIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjFcbiAgICAgICAgICAgIHZhciB0aW1lb3V0XzEgPSB0aW1lcnNfMS5UaW1lcnMuVDE7XG4gICAgICAgICAgICB2YXIgcmV0cmFuc21pc3Npb25fMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmFja1dhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52aXRlMnh4VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIk5vIEFDSyBmb3IgMnh4IHJlc3BvbnNlIHJlY2VpdmVkLCBhdHRlbXB0aW5nIHJldHJhbnNtaXNzaW9uXCIpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXzEucmV0cmFuc21pdEFjY2VwdGVkUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0XzEgPSBNYXRoLm1pbih0aW1lb3V0XzEgKiAyLCB0aW1lcnNfMS5UaW1lcnMuVDIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmludml0ZTJ4eFRpbWVyID0gc2V0VGltZW91dChyZXRyYW5zbWlzc2lvbl8xLCB0aW1lb3V0XzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW52aXRlMnh4VGltZXIgPSBzZXRUaW1lb3V0KHJldHJhbnNtaXNzaW9uXzEsIHRpbWVvdXRfMSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHJhbnNtaXRzIHRoZSAyeHggcmVzcG9uc2UgZm9yIDY0KlQxIHNlY29uZHMgd2l0aG91dFxuICAgICAgICAgICAgLy8gcmVjZWl2aW5nIGFuIEFDSywgdGhlIGRpYWxvZyBpcyBjb25maXJtZWQsIGJ1dCB0aGUgc2Vzc2lvbiBTSE9VTEQgYmVcbiAgICAgICAgICAgIC8vIHRlcm1pbmF0ZWQuICBUaGlzIGlzIGFjY29tcGxpc2hlZCB3aXRoIGEgQllFLCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiAxNS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgICAgICAgIHZhciBzdGF0ZUNoYW5nZWRfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25fMS5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXzEucmVtb3ZlTGlzdGVuZXIoXCJzdGF0ZUNoYW5nZWRcIiwgc3RhdGVDaGFuZ2VkXzEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW52aXRlMnh4VGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnZpdGUyeHhUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNrV2FpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGVnYXRlICYmIF90aGlzLmRlbGVnYXRlLm9uQWNrVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uQWNrVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnllKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25fMS5hZGRMaXN0ZW5lcihcInN0YXRlQ2hhbmdlZFwiLCBzdGF0ZUNoYW5nZWRfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEZJWE1FOiBSZWZhY3RvclxuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLnN0YXJ0UmVJbnZpdGUyeHhSZXRyYW5zbWlzc2lvblRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlciAmJiB0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbl8yID0gdGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlci50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIC8vIE9uY2UgdGhlIHJlc3BvbnNlIGhhcyBiZWVuIGNvbnN0cnVjdGVkLCBpdCBpcyBwYXNzZWQgdG8gdGhlIElOVklURVxuICAgICAgICAgICAgLy8gc2VydmVyIHRyYW5zYWN0aW9uLiAgSW4gb3JkZXIgdG8gZW5zdXJlIHJlbGlhYmxlIGVuZC10by1lbmRcbiAgICAgICAgICAgIC8vIHRyYW5zcG9ydCBvZiB0aGUgcmVzcG9uc2UsIGl0IGlzIG5lY2Vzc2FyeSB0byBwZXJpb2RpY2FsbHkgcGFzc1xuICAgICAgICAgICAgLy8gdGhlIHJlc3BvbnNlIGRpcmVjdGx5IHRvIHRoZSB0cmFuc3BvcnQgdW50aWwgdGhlIEFDSyBhcnJpdmVzLiAgVGhlXG4gICAgICAgICAgICAvLyAyeHggcmVzcG9uc2UgaXMgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgd2l0aCBhbiBpbnRlcnZhbCB0aGF0XG4gICAgICAgICAgICAvLyBzdGFydHMgYXQgVDEgc2Vjb25kcyBhbmQgZG91YmxlcyBmb3IgZWFjaCByZXRyYW5zbWlzc2lvbiB1bnRpbCBpdFxuICAgICAgICAgICAgLy8gcmVhY2hlcyBUMiBzZWNvbmRzIChUMSBhbmQgVDIgYXJlIGRlZmluZWQgaW4gU2VjdGlvbiAxNykuXG4gICAgICAgICAgICAvLyBSZXNwb25zZSByZXRyYW5zbWlzc2lvbnMgY2Vhc2Ugd2hlbiBhbiBBQ0sgcmVxdWVzdCBmb3IgdGhlXG4gICAgICAgICAgICAvLyByZXNwb25zZSBpcyByZWNlaXZlZC4gIFRoaXMgaXMgaW5kZXBlbmRlbnQgb2Ygd2hhdGV2ZXIgdHJhbnNwb3J0XG4gICAgICAgICAgICAvLyBwcm90b2NvbHMgYXJlIHVzZWQgdG8gc2VuZCB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMVxuICAgICAgICAgICAgdmFyIHRpbWVvdXRfMiA9IHRpbWVyc18xLlRpbWVycy5UMTtcbiAgICAgICAgICAgIHZhciByZXRyYW5zbWlzc2lvbl8yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52aXRlMnh4VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIk5vIEFDSyBmb3IgMnh4IHJlc3BvbnNlIHJlY2VpdmVkLCBhdHRlbXB0aW5nIHJldHJhbnNtaXNzaW9uXCIpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXzIucmV0cmFuc21pdEFjY2VwdGVkUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0XzIgPSBNYXRoLm1pbih0aW1lb3V0XzIgKiAyLCB0aW1lcnNfMS5UaW1lcnMuVDIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmludml0ZTJ4eFRpbWVyID0gc2V0VGltZW91dChyZXRyYW5zbWlzc2lvbl8yLCB0aW1lb3V0XzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW52aXRlMnh4VGltZXIgPSBzZXRUaW1lb3V0KHJldHJhbnNtaXNzaW9uXzIsIHRpbWVvdXRfMik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHJhbnNtaXRzIHRoZSAyeHggcmVzcG9uc2UgZm9yIDY0KlQxIHNlY29uZHMgd2l0aG91dFxuICAgICAgICAgICAgLy8gcmVjZWl2aW5nIGFuIEFDSywgdGhlIGRpYWxvZyBpcyBjb25maXJtZWQsIGJ1dCB0aGUgc2Vzc2lvbiBTSE9VTEQgYmVcbiAgICAgICAgICAgIC8vIHRlcm1pbmF0ZWQuICBUaGlzIGlzIGFjY29tcGxpc2hlZCB3aXRoIGEgQllFLCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiAxNS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgICAgICAgIHZhciBzdGF0ZUNoYW5nZWRfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25fMi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXzIucmVtb3ZlTGlzdGVuZXIoXCJzdGF0ZUNoYW5nZWRcIiwgc3RhdGVDaGFuZ2VkXzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW52aXRlMnh4VGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnZpdGUyeHhUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBXaGF0IHRvIGRvIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFuc2FjdGlvbl8yLmFkZExpc3RlbmVyKFwic3RhdGVDaGFuZ2VkXCIsIHN0YXRlQ2hhbmdlZF8yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb25EaWFsb2c7XG59KGRpYWxvZ18xLkRpYWxvZykpO1xuZXhwb3J0cy5TZXNzaW9uRGlhbG9nID0gU2Vzc2lvbkRpYWxvZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciBzdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9zdWJzY3JpcHRpb25cIik7XG52YXIgdGltZXJzXzEgPSByZXF1aXJlKFwiLi4vdGltZXJzXCIpO1xudmFyIGFsbG93ZWRfbWV0aG9kc18xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnQtY29yZS9hbGxvd2VkLW1ldGhvZHNcIik7XG52YXIgbm90aWZ5X3VzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHMvbm90aWZ5LXVzZXItYWdlbnQtc2VydmVyXCIpO1xudmFyIHJlX3N1YnNjcmliZV91c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3JlLXN1YnNjcmliZS11c2VyLWFnZW50LWNsaWVudFwiKTtcbnZhciBkaWFsb2dfMSA9IHJlcXVpcmUoXCIuL2RpYWxvZ1wiKTtcbi8qKlxuICogU3Vic2NyaXB0aW9uIERpYWxvZy5cbiAqIEByZW1hcmtzXG4gKiBTSVAtU3BlY2lmaWMgRXZlbnQgTm90aWZpY2F0aW9uXG4gKlxuICogQWJzdHJhY3RcbiAqXG4gKiAgICBUaGlzIGRvY3VtZW50IGRlc2NyaWJlcyBhbiBleHRlbnNpb24gdG8gdGhlIFNlc3Npb24gSW5pdGlhdGlvblxuICogICAgUHJvdG9jb2wgKFNJUCkgZGVmaW5lZCBieSBSRkMgMzI2MS4gIFRoZSBwdXJwb3NlIG9mIHRoaXMgZXh0ZW5zaW9uIGlzXG4gKiAgICB0byBwcm92aWRlIGFuIGV4dGVuc2libGUgZnJhbWV3b3JrIGJ5IHdoaWNoIFNJUCBub2RlcyBjYW4gcmVxdWVzdFxuICogICAgbm90aWZpY2F0aW9uIGZyb20gcmVtb3RlIG5vZGVzIGluZGljYXRpbmcgdGhhdCBjZXJ0YWluIGV2ZW50cyBoYXZlXG4gKiAgICBvY2N1cnJlZC5cbiAqXG4gKiAgICBOb3RlIHRoYXQgdGhlIGV2ZW50IG5vdGlmaWNhdGlvbiBtZWNoYW5pc21zIGRlZmluZWQgaGVyZWluIGFyZSBOT1RcbiAqICAgIGludGVuZGVkIHRvIGJlIGEgZ2VuZXJhbC1wdXJwb3NlIGluZnJhc3RydWN0dXJlIGZvciBhbGwgY2xhc3NlcyBvZlxuICogICAgZXZlbnQgc3Vic2NyaXB0aW9uIGFuZCBub3RpZmljYXRpb24uXG4gKlxuICogICAgVGhpcyBkb2N1bWVudCByZXByZXNlbnRzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgaW1wcm92ZW1lbnQgb24gdGhlXG4gKiAgICBvcmlnaW5hbCBtZWNoYW5pc20gZGVzY3JpYmVkIGJ5IFJGQyAzMjY1LCB0YWtpbmcgaW50byBhY2NvdW50IHNldmVyYWxcbiAqICAgIHllYXJzIG9mIGltcGxlbWVudGF0aW9uIGV4cGVyaWVuY2UuICBBY2NvcmRpbmdseSwgdGhpcyBkb2N1bWVudFxuICogICAgb2Jzb2xldGVzIFJGQyAzMjY1LiAgVGhpcyBkb2N1bWVudCBhbHNvIHVwZGF0ZXMgUkZDIDQ2NjAgc2xpZ2h0bHkgdG9cbiAqICAgIGFjY29tbW9kYXRlIHNvbWUgc21hbGwgY2hhbmdlcyB0byB0aGUgbWVjaGFuaXNtIHRoYXQgd2VyZSBkaXNjdXNzZWRcbiAqICAgIGluIHRoYXQgZG9jdW1lbnQuXG4gKlxuICogIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1XG4gKiBAcHVibGljXG4gKi9cbnZhciBTdWJzY3JpcHRpb25EaWFsb2cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3Vic2NyaXB0aW9uRGlhbG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbkRpYWxvZyhzdWJzY3JpcHRpb25FdmVudCwgc3Vic2NyaXB0aW9uRXhwaXJlcywgc3Vic2NyaXB0aW9uU3RhdGUsIGNvcmUsIHN0YXRlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb3JlLCBzdGF0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgX3RoaXMuX2F1dG9SZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25FdmVudCA9IHN1YnNjcmlwdGlvbkV2ZW50O1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlcyA9IHN1YnNjcmlwdGlvbkV4cGlyZXM7XG4gICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbCA9IHN1YnNjcmlwdGlvbkV4cGlyZXM7XG4gICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzTGFzdFNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGUgPSBzdWJzY3JpcHRpb25TdGF0ZTtcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gY29yZS5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihcInNpcC5zdWJzY3JpYmUtZGlhbG9nXCIpO1xuICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiU1VCU0NSSUJFIGRpYWxvZyBcIiArIF90aGlzLmlkICsgXCIgY29uc3RydWN0ZWRcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBhIFVBQyByZWNlaXZlcyBhIHJlc3BvbnNlIHRoYXQgZXN0YWJsaXNoZXMgYSBkaWFsb2csIGl0XG4gICAgICogY29uc3RydWN0cyB0aGUgc3RhdGUgb2YgdGhlIGRpYWxvZy4gIFRoaXMgc3RhdGUgTVVTVCBiZSBtYWludGFpbmVkXG4gICAgICogZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGlhbG9nLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICogQHBhcmFtIG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgLSBPdXRnb2luZyByZXF1ZXN0IG1lc3NhZ2UgZm9yIGRpYWxvZy5cbiAgICAgKiBAcGFyYW0gaW5jb21pbmdSZXNwb25zZU1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGNyZWF0aW5nIGRpYWxvZy5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb25EaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdE1lc3NhZ2UsIGluY29taW5nTm90aWZ5UmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIHNlbnQgb3ZlciBUTFMsIGFuZCB0aGUgUmVxdWVzdC1VUkkgY29udGFpbmVkIGFcbiAgICAgICAgLy8gU0lQUyBVUkksIHRoZSBcInNlY3VyZVwiIGZsYWcgaXMgc2V0IHRvIFRSVUUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIHZhciBzZWN1cmUgPSBmYWxzZTsgLy8gRklYTUU6IEN1cnJlbnRseSBubyBzdXBwb3J0IGZvciBUTFMuXG4gICAgICAgIC8vIFRoZSByb3V0ZSBzZXQgTVVTVCBiZSBzZXQgdG8gdGhlIGxpc3Qgb2YgVVJJcyBpbiB0aGUgUmVjb3JkLVJvdXRlXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCBmcm9tIHRoZSByZXNwb25zZSwgdGFrZW4gaW4gcmV2ZXJzZSBvcmRlciBhbmQgcHJlc2VydmluZ1xuICAgICAgICAvLyBhbGwgVVJJIHBhcmFtZXRlcnMuICBJZiBubyBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkIGlzIHByZXNlbnQgaW5cbiAgICAgICAgLy8gdGhlIHJlc3BvbnNlLCB0aGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBlbXB0eSBzZXQuICBUaGlzIHJvdXRlXG4gICAgICAgIC8vIHNldCwgZXZlbiBpZiBlbXB0eSwgb3ZlcnJpZGVzIGFueSBwcmUtZXhpc3Rpbmcgcm91dGUgc2V0IGZvciBmdXR1cmVcbiAgICAgICAgLy8gcmVxdWVzdHMgaW4gdGhpcyBkaWFsb2cuICBUaGUgcmVtb3RlIHRhcmdldCBNVVNUIGJlIHNldCB0byB0aGUgVVJJXG4gICAgICAgIC8vIGZyb20gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXNwb25zZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICAgICAgdmFyIHJvdXRlU2V0ID0gaW5jb21pbmdOb3RpZnlSZXF1ZXN0TWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpO1xuICAgICAgICB2YXIgY29udGFjdCA9IGluY29taW5nTm90aWZ5UmVxdWVzdE1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjb250YWN0XCIpO1xuICAgICAgICBpZiAoIWNvbnRhY3QpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY29udGFjdCBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuTmFtZUFkZHJIZWFkZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IG5vdCBpbnN0YW5jZSBvZiBOYW1lQWRkckhlYWRlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW90ZVRhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgICAgICAvLyBUaGUgbG9jYWwgc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2VcbiAgICAgICAgLy8gbnVtYmVyIGluIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC4gIFRoZSByZW1vdGUgc2VxdWVuY2VcbiAgICAgICAgLy8gbnVtYmVyIE1VU1QgYmUgZW1wdHkgKGl0IGlzIGVzdGFibGlzaGVkIHdoZW4gdGhlIHJlbW90ZSBVQSBzZW5kcyBhXG4gICAgICAgIC8vIHJlcXVlc3Qgd2l0aGluIHRoZSBkaWFsb2cpLiAgVGhlIGNhbGwgaWRlbnRpZmllciBjb21wb25lbnQgb2YgdGhlXG4gICAgICAgIC8vIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIENhbGwtSUQgaW4gdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vIFRoZSBsb2NhbCB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHRhZyBpblxuICAgICAgICAvLyB0aGUgRnJvbSBmaWVsZCBpbiB0aGUgcmVxdWVzdCwgYW5kIHRoZSByZW1vdGUgdGFnIGNvbXBvbmVudCBvZiB0aGVcbiAgICAgICAgLy8gZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB0YWcgaW4gdGhlIFRvIGZpZWxkIG9mIHRoZSByZXNwb25zZS4gIEFcbiAgICAgICAgLy8gVUFDIE1VU1QgYmUgcHJlcGFyZWQgdG8gcmVjZWl2ZSBhIHJlc3BvbnNlIHdpdGhvdXQgYSB0YWcgaW4gdGhlIFRvXG4gICAgICAgIC8vIGZpZWxkLCBpbiB3aGljaCBjYXNlIHRoZSB0YWcgaXMgY29uc2lkZXJlZCB0byBoYXZlIGEgdmFsdWUgb2YgbnVsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgVGhpcyBpcyB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIFJGQyAyNTQzLCB3aGljaFxuICAgICAgICAvLyAgICBkaWQgbm90IG1hbmRhdGUgVG8gdGFncy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICAgICAgdmFyIGxvY2FsU2VxdWVuY2VOdW1iZXIgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLmNzZXE7XG4gICAgICAgIHZhciByZW1vdGVTZXF1ZW5jZU51bWJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNhbGxJZCA9IG91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdE1lc3NhZ2UuY2FsbElkO1xuICAgICAgICB2YXIgbG9jYWxUYWcgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLmZyb21UYWc7XG4gICAgICAgIHZhciByZW1vdGVUYWcgPSBpbmNvbWluZ05vdGlmeVJlcXVlc3RNZXNzYWdlLmZyb21UYWc7XG4gICAgICAgIGlmICghY2FsbElkKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpZCB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG9jYWxUYWcpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHRhZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVtb3RlVGFnKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdGFnIHVuZGVmaW5lZC5cIik7IC8vIEZJWE1FOiBObyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIFJGQyAyNTQzXG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHJlbW90ZSBVUkkgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSSBpbiB0aGUgVG8gZmllbGQsIGFuZCB0aGUgbG9jYWxcbiAgICAgICAgLy8gVVJJIE1VU1QgYmUgc2V0IHRvIHRoZSBVUkkgaW4gdGhlIEZyb20gZmllbGQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIGlmICghb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS5mcm9tKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS50bykgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2FsVVJJID0gb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS5mcm9tLnVyaTtcbiAgICAgICAgdmFyIHJlbW90ZVVSSSA9IG91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdE1lc3NhZ2UudG8udXJpO1xuICAgICAgICAvLyBBIGRpYWxvZyBjYW4gYWxzbyBiZSBpbiB0aGUgXCJlYXJseVwiIHN0YXRlLCB3aGljaCBvY2N1cnMgd2hlbiBpdCBpc1xuICAgICAgICAvLyBjcmVhdGVkIHdpdGggYSBwcm92aXNpb25hbCByZXNwb25zZSwgYW5kIHRoZW4gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAgICAgLy8gXCJjb25maXJtZWRcIiBzdGF0ZSB3aGVuIGEgMnh4IGZpbmFsIHJlc3BvbnNlIGFycml2ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTJcbiAgICAgICAgdmFyIGVhcmx5ID0gZmFsc2U7XG4gICAgICAgIHZhciBkaWFsb2dTdGF0ZSA9IHtcbiAgICAgICAgICAgIGlkOiBjYWxsSWQgKyBsb2NhbFRhZyArIHJlbW90ZVRhZyxcbiAgICAgICAgICAgIGVhcmx5OiBlYXJseSxcbiAgICAgICAgICAgIGNhbGxJZDogY2FsbElkLFxuICAgICAgICAgICAgbG9jYWxUYWc6IGxvY2FsVGFnLFxuICAgICAgICAgICAgcmVtb3RlVGFnOiByZW1vdGVUYWcsXG4gICAgICAgICAgICBsb2NhbFNlcXVlbmNlTnVtYmVyOiBsb2NhbFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3RlU2VxdWVuY2VOdW1iZXI6IHJlbW90ZVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgbG9jYWxVUkk6IGxvY2FsVVJJLFxuICAgICAgICAgICAgcmVtb3RlVVJJOiByZW1vdGVVUkksXG4gICAgICAgICAgICByZW1vdGVUYXJnZXQ6IHJlbW90ZVRhcmdldCxcbiAgICAgICAgICAgIHJvdXRlU2V0OiByb3V0ZVNldCxcbiAgICAgICAgICAgIHNlY3VyZTogc2VjdXJlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaWFsb2dTdGF0ZTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLk4pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLk4pO1xuICAgICAgICAgICAgdGhpcy5OID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaFRpbWVyQ2xlYXIoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU1VCU0NSSUJFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBkZXN0cm95ZWRcIik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZSwgXCJhdXRvUmVmcmVzaFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9SZWZyZXNoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhdXRvUmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0b1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXJTZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUsIFwic3Vic2NyaXB0aW9uRXZlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25FdmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUsIFwic3Vic2NyaXB0aW9uRXhwaXJlc1wiLCB7XG4gICAgICAgIC8qKiBOdW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCBzdWJzY3JpcHRpb24gZXhwaXJlcy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kc1NpbmNlTGFzdFNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlc0xhc3RTZXQ7XG4gICAgICAgICAgICB2YXIgc2Vjb25kc1VudGlsRXhwaXJlcyA9IHRoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXMgLSBzZWNvbmRzU2luY2VMYXN0U2V0O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNlY29uZHNVbnRpbEV4cGlyZXMsIDApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHBpcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXhwaXJlcyA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBpcmVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlcyA9IGV4cGlyZXM7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzTGFzdFNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmcmVzaCA9IHRoaXMuc3Vic2NyaXB0aW9uUmVmcmVzaDtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCA9PT0gdW5kZWZpbmVkIHx8IHJlZnJlc2ggPj0gZXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lclNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUsIFwic3Vic2NyaXB0aW9uRXhwaXJlc0luaXRpYWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUsIFwic3Vic2NyaXB0aW9uUmVmcmVzaFwiLCB7XG4gICAgICAgIC8qKiBOdW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCBzdWJzY3JpcHRpb24gYXV0byByZWZyZXNoLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoID09PSB1bmRlZmluZWQgfHwgdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaExhc3RTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2Vjb25kc1NpbmNlTGFzdFNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaExhc3RTZXQ7XG4gICAgICAgICAgICB2YXIgc2Vjb25kc1VudGlsRXhwaXJlcyA9IHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2ggLSBzZWNvbmRzU2luY2VMYXN0U2V0O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNlY29uZHNVbnRpbEV4cGlyZXMsIDApO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZSwgXCJzdWJzY3JpcHRpb25TdGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIGluIGRpYWxvZyByZXF1ZXN0IG1lc3NhZ2UgZnJvbSB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSAgVGhlIGluY29taW5nIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU1VCU0NSSUJFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWNlaXZlZCBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIgcmVxdWVzdFwiKTtcbiAgICAgICAgLy8gUmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cgb3V0IG9mIHNlcXVlbmNlIGd1YXJkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICBpZiAoIXRoaXMuc2VxdWVuY2VHdWFyZChtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU1VCU0NSSUJFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWplY3RlZCBvdXQgb2Ygb3JkZXIgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3QuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIGNvbW1vbiBwcm9jZXNzaW5nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIFN3aXRjaCBvbiBtZXRob2QgYW5kIHRoZW4gZGVsZWdhdGUuXG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLk5PVElGWTpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTVUJTQ1JJQkUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHJlY2VpdmVkIHVuaW1wbGVtZW50ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAxIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA0LjEuMi4yLiAgUmVmcmVzaGluZyBvZiBTdWJzY3JpcHRpb25zXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGFsbG93SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV2ZW50OiBcIiArIHRoaXMuc3Vic2NyaXB0aW9uRXZlbnQpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiRXhwaXJlczogXCIgKyB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXNJbml0aWFsKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uY29udGFjdC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA0LjEuMi4yLiAgUmVmcmVzaGluZyBvZiBTdWJzY3JpcHRpb25zXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gRGVsZWdhdGUgdG8gaGFuZGxlIHJlc3BvbnNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5QZW5kaW5nICYmIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgbmVlZHMgdG8gYmUgYSBwcm9wZXIgZXhjZXB0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIFwiICsgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSArIFwiLiBNYXkgb25seSByZS1zdWJzY3JpYmUgd2hpbGUgaW4gc3RhdGUgXFxcInBlbmRpbmdcXFwiIG9yIFxcXCJhY3RpdmVcXFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTVUJTQ1JJQkUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHNlbmRpbmcgU1VCU0NSSUJFIHJlcXVlc3RcIik7XG4gICAgICAgIHZhciB1YWMgPSBuZXcgcmVfc3Vic2NyaWJlX3VzZXJfYWdlbnRfY2xpZW50XzEuUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgICAgICAvLyBXaGVuIHJlZnJlc2hpbmcgYSBzdWJzY3JpcHRpb24sIGEgc3Vic2NyaWJlciBzdGFydHMgVGltZXIgTiwgc2V0IHRvXG4gICAgICAgIC8vIDY0KlQxLCB3aGVuIGl0IHNlbmRzIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAgICAgIHRoaXMuTiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfTigpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfTik7XG4gICAgICAgIHJldHVybiB1YWM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA0LjQuMS4gIERpYWxvZyBDcmVhdGlvbiBhbmQgVGVybWluYXRpb25cbiAgICAgKiBBIHN1YnNjcmlwdGlvbiBpcyBkZXN0cm95ZWQgYWZ0ZXIgYSBub3RpZmllciBzZW5kcyBhIE5PVElGWSByZXF1ZXN0XG4gICAgICogd2l0aCBhIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgb2YgXCJ0ZXJtaW5hdGVkXCIsIG9yIGluIGNlcnRhaW4gZXJyb3JcbiAgICAgKiBzaXR1YXRpb25zIGRlc2NyaWJlZCBlbHNld2hlcmUgaW4gdGhpcyBkb2N1bWVudC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogNC4xLjIuMy4gIFVuc3Vic2NyaWJpbmdcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjNcbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGFsbG93SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV2ZW50OiBcIiArIHRoaXMuc3Vic2NyaXB0aW9uRXZlbnQpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiRXhwaXJlczogMFwiKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uY29udGFjdC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgaW4gZGlhbG9nIE5PVElGWSByZXF1ZXN0cy5cbiAgICAgKiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGZpcnN0IE5PVElGWSB3aGljaCBjcmVhdGVkIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgaW5jb21pbmcgTk9USUZZIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLm9uTm90aWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gSWYsIGZvciBzb21lIHJlYXNvbiwgdGhlIGV2ZW50IHBhY2thZ2UgZGVzaWduYXRlZCBpbiB0aGUgXCJFdmVudFwiXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCBvZiB0aGUgTk9USUZZIHJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCwgdGhlIHN1YnNjcmliZXJcbiAgICAgICAgLy8gd2lsbCByZXNwb25kIHdpdGggYSA0ODkgKEJhZCBFdmVudCkgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICAgICAgdmFyIGV2ZW50ID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkV2ZW50XCIpLmV2ZW50O1xuICAgICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50ICE9PSB0aGlzLnN1YnNjcmlwdGlvbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvcmUucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIHN0YXRlIGRpYWdyYW0sIFwiUmUtc3Vic2NyaXB0aW9uIHRpbWVzIG91dFwiIG1lYW5zIHRoYXQgYW5cbiAgICAgICAgLy8gYXR0ZW1wdCB0byByZWZyZXNoIG9yIHVwZGF0ZSB0aGUgc3Vic2NyaXB0aW9uIHVzaW5nIGEgbmV3IFNVQlNDUklCRVxuICAgICAgICAvLyByZXF1ZXN0IGRvZXMgbm90IHJlc3VsdCBpbiBhIE5PVElGWSByZXF1ZXN0IGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAvLyBUaW1lciBOIGV4cGlyZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjJcbiAgICAgICAgaWYgKHRoaXMuTikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuTik7XG4gICAgICAgICAgICB0aGlzLk4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3RzIE1VU1QgY29udGFpbiBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIGhlYWRlciBmaWVsZHMgdGhhdFxuICAgICAgICAvLyBpbmRpY2F0ZSB0aGUgc3RhdHVzIG9mIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvblN0YXRlID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiKTtcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25TdGF0ZSB8fCAhc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSBzdWJzY3JpcHRpb25TdGF0ZS5zdGF0ZTtcbiAgICAgICAgdmFyIGV4cGlyZXMgPSBzdWJzY3JpcHRpb25TdGF0ZS5leHBpcmVzID8gTWF0aC5tYXgoc3Vic2NyaXB0aW9uU3RhdGUuZXhwaXJlcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc3RhdGUgYW5kIGV4cGlyYXRpb24uXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZywgZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYWN0aXZlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlLCBleHBpcmVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZCwgZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVbnJlY29nbml6ZWQgc3Vic2NyaXB0aW9uIHN0YXRlLlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxlZ2F0ZSByZW1haW5kZXIgb2YgTk9USUZZIGhhbmRsaW5nLlxuICAgICAgICB2YXIgdWFzID0gbmV3IG5vdGlmeV91c2VyX2FnZW50X3NlcnZlcl8xLk5vdGlmeVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSh1YXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLm9uUmVmcmVzaCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWZyZXNoKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVmcmVzaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5vblRlcm1pbmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uVGVybWluYXRlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLnJlZnJlc2hUaW1lckNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZnJlc2hUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoVGltZXJTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVmcmVzaFRpbWVyQ2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2ggJiYgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzID4gMCkge1xuICAgICAgICAgICAgdmFyIHJlZnJlc2ggPSB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgKiA5MDA7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoID0gTWF0aC5mbG9vcihyZWZyZXNoIC8gMTAwMCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoTGFzdFNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uUmVmcmVzaChfdGhpcy5yZWZyZXNoKCkpO1xuICAgICAgICAgICAgfSwgcmVmcmVzaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUuc3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBuZXdFeHBpcmVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICAgICAgdmFyIGludmFsaWRTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIkludmFsaWQgc3Vic2NyaXB0aW9uIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBcIiArIF90aGlzLnN1YnNjcmlwdGlvblN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0OlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5QZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIHZhbHVlIGlzIFwicGVuZGluZ1wiLCB0aGUgc3Vic2NyaXB0aW9uIGhhc1xuICAgICAgICAvLyBiZWVuIHJlY2VpdmVkIGJ5IHRoZSBub3RpZmllciwgYnV0IHRoZXJlIGlzIGluc3VmZmljaWVudCBwb2xpY3lcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gdG8gZ3JhbnQgb3IgZGVueSB0aGUgc3Vic2NyaXB0aW9uIHlldC4gIElmIHRoZSBoZWFkZXJcbiAgICAgICAgLy8gZmllbGQgYWxzbyBjb250YWlucyBhbiBcImV4cGlyZXNcIiBwYXJhbWV0ZXIsIHRoZSBzdWJzY3JpYmVyIFNIT1VMRFxuICAgICAgICAvLyB0YWtlIGl0IGFzIHRoZSBhdXRob3JpdGF0aXZlIHN1YnNjcmlwdGlvbiBkdXJhdGlvbiBhbmQgYWRqdXN0XG4gICAgICAgIC8vIGFjY29yZGluZ2x5LiAgTm8gZnVydGhlciBhY3Rpb24gaXMgbmVjZXNzYXJ5IG9uIHRoZSBwYXJ0IG9mIHRoZVxuICAgICAgICAvLyBzdWJzY3JpYmVyLiAgVGhlIFwicmV0cnktYWZ0ZXJcIiBhbmQgXCJyZWFzb25cIiBwYXJhbWV0ZXJzIGhhdmUgbm9cbiAgICAgICAgLy8gc2VtYW50aWNzIGZvciBcInBlbmRpbmdcIi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuM1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdFeHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzID0gbmV3RXhwaXJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGQgdmFsdWUgaXMgXCJhY3RpdmVcIiwgaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGUgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGFjY2VwdGVkIGFuZCAoaW4gZ2VuZXJhbCkgaGFzIGJlZW5cbiAgICAgICAgLy8gYXV0aG9yaXplZC4gIElmIHRoZSBoZWFkZXIgZmllbGQgYWxzbyBjb250YWlucyBhbiBcImV4cGlyZXNcIlxuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRoZSBzdWJzY3JpYmVyIFNIT1VMRCB0YWtlIGl0IGFzIHRoZSBhdXRob3JpdGF0aXZlXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBkdXJhdGlvbiBhbmQgYWRqdXN0IGFjY29yZGluZ2x5LiAgVGhlIFwicmV0cnktYWZ0ZXJcIiBhbmRcbiAgICAgICAgLy8gXCJyZWFzb25cIiBwYXJhbWV0ZXJzIGhhdmUgbm8gc2VtYW50aWNzIGZvciBcImFjdGl2ZVwiLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4zXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAobmV3RXhwaXJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyA9IG5ld0V4cGlyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgdmFsdWUgaXMgXCJ0ZXJtaW5hdGVkXCIsIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vIE1VU1QgY29uc2lkZXIgdGhlIHN1YnNjcmlwdGlvbiB0ZXJtaW5hdGVkLiAgVGhlIFwiZXhwaXJlc1wiIHBhcmFtZXRlclxuICAgICAgICAvLyBoYXMgbm8gc2VtYW50aWNzIGZvciBcInRlcm1pbmF0ZWRcIiAtLSBub3RpZmllcnMgU0hPVUxEIE5PVCBpbmNsdWRlIGFuXG4gICAgICAgIC8vIFwiZXhwaXJlc1wiIHBhcmFtZXRlciBvbiBhIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgaGVhZGVyIGZpZWxkIHdpdGggYVxuICAgICAgICAvLyB2YWx1ZSBvZiBcInRlcm1pbmF0ZWRcIiwgYW5kIHN1YnNjcmliZXJzIE1VU1QgaWdub3JlIGFueSBzdWNoXG4gICAgICAgIC8vIHBhcmFtZXRlciwgaWYgcHJlc2VudC5cbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiByZWZyZXNoaW5nIGEgc3Vic2NyaXB0aW9uLCBhIHN1YnNjcmliZXIgc3RhcnRzIFRpbWVyIE4sIHNldCB0b1xuICAgICAqIDY0KlQxLCB3aGVuIGl0IHNlbmRzIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdC4gIElmIHRoaXMgVGltZXIgTiBleHBpcmVzXG4gICAgICogcHJpb3IgdG8gdGhlIHJlY2VpcHQgb2YgYSBOT1RJRlkgcmVxdWVzdCwgdGhlIHN1YnNjcmliZXIgY29uc2lkZXJzXG4gICAgICogdGhlIHN1YnNjcmlwdGlvbiB0ZXJtaW5hdGVkLiAgSWYgdGhlIHN1YnNjcmliZXIgcmVjZWl2ZXMgYSBzdWNjZXNzXG4gICAgICogcmVzcG9uc2UgdG8gdGhlIFNVQlNDUklCRSByZXF1ZXN0IHRoYXQgaW5kaWNhdGVzIHRoYXQgbm8gTk9USUZZXG4gICAgICogcmVxdWVzdCB3aWxsIGJlIGdlbmVyYXRlZCAtLSBzdWNoIGFzIHRoZSAyMDQgcmVzcG9uc2UgZGVmaW5lZCBmb3IgdXNlXG4gICAgICogd2l0aCB0aGUgb3B0aW9uYWwgZXh0ZW5zaW9uIGRlc2NyaWJlZCBpbiBbUkZDNTgzOV0gLS0gdGhlbiBpdCBNVVNUXG4gICAgICogY2FuY2VsIFRpbWVyIE4uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS50aW1lcl9OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRGlhbG9nO1xufShkaWFsb2dfMS5EaWFsb2cpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uRGlhbG9nID0gU3Vic2NyaXB0aW9uRGlhbG9nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKlxuICogQW4gRXhjZXB0aW9uIGlzIGNvbnNpZGVyZWQgYSBjb25kaXRpb24gdGhhdCBhIHJlYXNvbmFibGUgYXBwbGljYXRpb24gbWF5IHdpc2ggdG8gY2F0Y2guXG4gKiBBbiBFcnJvciBpbmRpY2F0ZXMgc2VyaW91cyBwcm9ibGVtcyB0aGF0IGEgcmVhc29uYWJsZSBhcHBsaWNhdGlvbiBzaG91bGQgbm90IHRyeSB0byBjYXRjaC5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRXhjZXB0aW9uO1xufShFcnJvcikpO1xuZXhwb3J0cy5FeGNlcHRpb24gPSBFeGNlcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhjZXB0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXN0YXRlLWVycm9yXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zcG9ydC1lcnJvclwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vZXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBjb21wbGV0ZWQgZ2l2ZW4gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gc3RhdGUuXG4gKiBAcHVibGljXG4gKi9cbnZhciBUcmFuc2FjdGlvblN0YXRlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNhY3Rpb25TdGF0ZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uU3RhdGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlID8gbWVzc2FnZSA6IFwiVHJhbnNhY3Rpb24gc3RhdGUgZXJyb3IuXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvblN0YXRlRXJyb3I7XG59KGV4Y2VwdGlvbl8xLkV4Y2VwdGlvbikpO1xuZXhwb3J0cy5UcmFuc2FjdGlvblN0YXRlRXJyb3IgPSBUcmFuc2FjdGlvblN0YXRlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vZXhjZXB0aW9uXCIpO1xuLyoqXG4gKiBUcmFuc3BvcnQgZXJyb3IuXG4gKiBAcHVibGljXG4gKi9cbnZhciBUcmFuc3BvcnRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUcmFuc3BvcnRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlID8gbWVzc2FnZSA6IFwiVW5zcGVjaWZpZWQgdHJhbnNwb3J0IGVycm9yLlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3J0RXJyb3I7XG59KGV4Y2VwdGlvbl8xLkV4Y2VwdGlvbikpO1xuZXhwb3J0cy5UcmFuc3BvcnRFcnJvciA9IFRyYW5zcG9ydEVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEEgY29yZSBsaWJyYXJ5IGltcGxlbWVudGluZyBsb3cgbGV2ZWwgU0lQIHByb3RvY29sIGVsZW1lbnRzLlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLy8gRGlyZWN0b3JpZXNcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RpYWxvZ3NcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhjZXB0aW9uc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVzc2FnZXNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2Vzc2lvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNhY3Rpb25zXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY29yZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyLWFnZW50c1wiKSwgZXhwb3J0cyk7XG4vLyBGaWxlc1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZXJzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sZXZlbHNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2VyLWZhY3RvcnlcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2VyXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBMb2cgbGV2ZWxzLlxuICogQHB1YmxpY1xuICovXG52YXIgTGV2ZWxzO1xuKGZ1bmN0aW9uIChMZXZlbHMpIHtcbiAgICBMZXZlbHNbTGV2ZWxzW1wiZXJyb3JcIl0gPSAwXSA9IFwiZXJyb3JcIjtcbiAgICBMZXZlbHNbTGV2ZWxzW1wid2FyblwiXSA9IDFdID0gXCJ3YXJuXCI7XG4gICAgTGV2ZWxzW0xldmVsc1tcImxvZ1wiXSA9IDJdID0gXCJsb2dcIjtcbiAgICBMZXZlbHNbTGV2ZWxzW1wiZGVidWdcIl0gPSAzXSA9IFwiZGVidWdcIjtcbn0pKExldmVscyA9IGV4cG9ydHMuTGV2ZWxzIHx8IChleHBvcnRzLkxldmVscyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsZXZlbHNfMSA9IHJlcXVpcmUoXCIuL2xldmVsc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbi8qKlxuICogTG9nZ2VyLlxuICogQHB1YmxpY1xuICovXG52YXIgTG9nZ2VyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXJGYWN0b3J5KCkge1xuICAgICAgICB0aGlzLmJ1aWx0aW5FbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbHNfMS5MZXZlbHMubG9nO1xuICAgICAgICB0aGlzLmxvZ2dlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSB0aGlzLmdldExvZ2dlcihcInNpcDpsb2dnZXJmYWN0b3J5XCIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xldmVsOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPD0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdMZXZlbCA+IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZXZlbHNfMS5MZXZlbHMuaGFzT3duUHJvcGVydHkobmV3TGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiaW52YWxpZCAnbGV2ZWwnIHBhcmFtZXRlciB2YWx1ZTogXCIgKyBKU09OLnN0cmluZ2lmeShuZXdMZXZlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUsIFwiY29ubmVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcImludmFsaWQgJ2Nvbm5lY3RvcicgcGFyYW1ldGVyIHZhbHVlOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExvZ2dlckZhY3RvcnkucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uIChjYXRlZ29yeSwgbGFiZWwpIHtcbiAgICAgICAgaWYgKGxhYmVsICYmIHRoaXMubGV2ZWwgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbG9nZ2VyXzEuTG9nZ2VyKHRoaXMsIGNhdGVnb3J5LCBsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sb2dnZXJzW2NhdGVnb3J5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcih0aGlzLCBjYXRlZ29yeSk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldID0gbG9nZ2VyO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUuZ2VuZXJpY0xvZyA9IGZ1bmN0aW9uIChsZXZlbFRvTG9nLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubGV2ZWwgPj0gbGV2ZWxUb0xvZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbHRpbkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50KGxldmVsVG9Mb2csIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcihsZXZlbHNfMS5MZXZlbHNbbGV2ZWxUb0xvZ10sIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnkucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKGxldmVsVG9Mb2csIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBbbmV3IERhdGUoKSwgY2F0ZWdvcnldO1xuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4LnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudCA9IHByZWZpeC5jb25jYXQoY29udGVudCkuam9pbihcIiB8IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGxldmVsVG9Mb2cpIHtcbiAgICAgICAgICAgIGNhc2UgbGV2ZWxzXzEuTGV2ZWxzLmVycm9yOlxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihjb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbGV2ZWxzXzEuTGV2ZWxzLndhcm46XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGxldmVsc18xLkxldmVscy5sb2c6XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbGV2ZWxzXzEuTGV2ZWxzLmRlYnVnOlxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1Zyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMb2dnZXJGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeSA9IExvZ2dlckZhY3Rvcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsZXZlbHNfMSA9IHJlcXVpcmUoXCIuL2xldmVsc1wiKTtcbi8qKlxuICogTG9nZ2VyLlxuICogQHB1YmxpY1xuICovXG52YXIgTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcihsb2dnZXIsIGNhdGVnb3J5LCBsYWJlbCkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgfVxuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoY29udGVudCkgeyB0aGlzLmdlbmVyaWNMb2cobGV2ZWxzXzEuTGV2ZWxzLmVycm9yLCBjb250ZW50KTsgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoY29udGVudCkgeyB0aGlzLmdlbmVyaWNMb2cobGV2ZWxzXzEuTGV2ZWxzLndhcm4sIGNvbnRlbnQpOyB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgdGhpcy5nZW5lcmljTG9nKGxldmVsc18xLkxldmVscy5sb2csIGNvbnRlbnQpOyB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoY29udGVudCkgeyB0aGlzLmdlbmVyaWNMb2cobGV2ZWxzXzEuTGV2ZWxzLmRlYnVnLCBjb250ZW50KTsgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmdlbmVyaWNMb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZ2VuZXJpY0xvZyhsZXZlbCwgdGhpcy5jYXRlZ29yeSwgdGhpcy5sYWJlbCwgY29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5jb21pbmdfcmVxdWVzdF9tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2VcIik7XG52YXIgaW5jb21pbmdfcmVzcG9uc2VfbWVzc2FnZV8xID0gcmVxdWlyZShcIi4vaW5jb21pbmctcmVzcG9uc2UtbWVzc2FnZVwiKTtcbnZhciBvdXRnb2luZ19yZXF1ZXN0X21lc3NhZ2VfMSA9IHJlcXVpcmUoXCIuL291dGdvaW5nLXJlcXVlc3QtbWVzc2FnZVwiKTtcbi8qKlxuICogQ3JlYXRlIGEgQm9keSBnaXZlbiBhIGxlZ2FjeSBib2R5IHR5cGUuXG4gKiBAcGFyYW0gYm9keUxlZ2FjeSAtIEJvZHkgT2JqZWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZnJvbUJvZHlMZWdhY3koYm9keUxlZ2FjeSkge1xuICAgIHZhciBjb250ZW50ID0gKHR5cGVvZiBib2R5TGVnYWN5ID09PSBcInN0cmluZ1wiKSA/IGJvZHlMZWdhY3kgOiBib2R5TGVnYWN5LmJvZHk7XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gKHR5cGVvZiBib2R5TGVnYWN5ID09PSBcInN0cmluZ1wiKSA/IFwiYXBwbGljYXRpb24vc2RwXCIgOiBib2R5TGVnYWN5LmNvbnRlbnRUeXBlO1xuICAgIHZhciBjb250ZW50RGlzcG9zaXRpb24gPSBjb250ZW50VHlwZVRvQ29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnRUeXBlKTtcbiAgICB2YXIgYm9keSA9IHsgY29udGVudERpc3Bvc2l0aW9uOiBjb250ZW50RGlzcG9zaXRpb24sIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSwgY29udGVudDogY29udGVudCB9O1xuICAgIHJldHVybiBib2R5O1xufVxuZXhwb3J0cy5mcm9tQm9keUxlZ2FjeSA9IGZyb21Cb2R5TGVnYWN5O1xuLyoqXG4gKiBHaXZlbiBhIG1lc3NhZ2UsIGdldCBhIG5vcm1hbGl6ZWQgYm9keS5cbiAqIFRoZSBjb250ZW50IGRpc3Bvc2l0aW9uIGlzIGluZmVycmVkIGlmIG5vdCBzZXQuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEJvZHkobWVzc2FnZSkge1xuICAgIHZhciBjb250ZW50RGlzcG9zaXRpb247XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHZhciBjb250ZW50O1xuICAgIC8vIFdlJ3JlIGluIFVBUyByb2xlLCByZWNlaXZpbmcgaW5jb21pbmcgcmVxdWVzdFxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgaW5jb21pbmdfcmVxdWVzdF9tZXNzYWdlXzEuSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ib2R5KSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogUGFyc2luZyBuZWVkcyB0eXBpbmdcbiAgICAgICAgICAgIHZhciBwYXJzZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gcGFyc2UgPyBwYXJzZS50eXBlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICAgICAgY29udGVudCA9IG1lc3NhZ2UuYm9keTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSdyZSBpbiBVQUMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlc3BvbnNlXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBpbmNvbWluZ19yZXNwb25zZV9tZXNzYWdlXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFBhcnNpbmcgbmVlZHMgdHlwaW5nXG4gICAgICAgICAgICB2YXIgcGFyc2UgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9IHBhcnNlID8gcGFyc2UudHlwZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBtZXNzYWdlLmJvZHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UncmUgaW4gVUFDIHJvbGUsIHNlbmRpbmcgb3V0Z29pbmcgcmVxdWVzdFxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2Ygb3V0Z29pbmdfcmVxdWVzdF9tZXNzYWdlXzEuT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ib2R5KSB7XG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb24gPSBtZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogT3V0Z29pbmdSZXF1ZXN0IHNob3VsZCBub3QgYWxsb3cgYSBcInN0cmluZ1wiIGJvZHkgd2l0aG91dCBhIFwiQ29udGVudC1UeXBlXCIgaGVhZGVyLlxuICAgICAgICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVyIGNvbnRlbnQgdHlwZSBoZWFkZXIgZG9lcyBub3QgZXF1YWwgYm9keSBjb250ZW50IHR5cGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ID0gbWVzc2FnZS5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IE91dGdvaW5nUmVxdWVzdCBzaG91bGQgbm90IGFsbG93IHRoZSBcIkNvbnRlbnQtVHlwZVwiIGhlYWRlciBub3QgdG8gbWF0Y2ggdGggYm9keSBjb250ZW50IHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUgIT09IG1lc3NhZ2UuYm9keS5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXIgY29udGVudCB0eXBlIGhlYWRlciBkb2VzIG5vdCBlcXVhbCBib2R5IGNvbnRlbnQgdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gbWVzc2FnZS5ib2R5LmNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBtZXNzYWdlLmJvZHkuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSdyZSBpbiBVQVMgcm9sZSwgc2VuZGluZyBvdXRnb2luZyByZXNwb25zZVxuICAgIGlmIChpc0JvZHkobWVzc2FnZSkpIHtcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gbWVzc2FnZS5jb250ZW50RGlzcG9zaXRpb247XG4gICAgICAgIGNvbnRlbnRUeXBlID0gbWVzc2FnZS5jb250ZW50VHlwZTtcbiAgICAgICAgY29udGVudCA9IG1lc3NhZ2UuY29udGVudDtcbiAgICB9XG4gICAgLy8gTm8gY29udGVudCwgbm8gYm9keS5cbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmICFjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gY29udGVudFR5cGVUb0NvbnRlbnREaXNwb3NpdGlvbihjb250ZW50VHlwZSk7XG4gICAgfVxuICAgIGlmICghY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgZGlzcG9zaXRpb24gdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IHR5cGUgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBjb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSxcbiAgICAgICAgY29udGVudDogY29udGVudFxuICAgIH07XG59XG5leHBvcnRzLmdldEJvZHkgPSBnZXRCb2R5O1xuLyoqXG4gKiBVc2VyLURlZmluZWQgVHlwZSBHdWFyZCBmb3IgQm9keS5cbiAqIEBwYXJhbSBib2R5IC0gQm9keSB0byBjaGVjay5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0JvZHkoYm9keSkge1xuICAgIHJldHVybiBib2R5ICYmXG4gICAgICAgIHR5cGVvZiBib2R5LmNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdHlwZW9mIGJvZHkuY29udGVudFR5cGUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgYm9keS5jb250ZW50RGlzcG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IHRydWUgOiB0eXBlb2YgYm9keS5jb250ZW50RGlzcG9zaXRpb24gPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnRzLmlzQm9keSA9IGlzQm9keTtcbi8vIElmIHRoZSBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciBmaWVsZCBpcyBtaXNzaW5nLCBib2RpZXMgb2Zcbi8vIENvbnRlbnQtVHlwZSBhcHBsaWNhdGlvbi9zZHAgaW1wbHkgdGhlIGRpc3Bvc2l0aW9uIFwic2Vzc2lvblwiLCB3aGlsZVxuLy8gb3RoZXIgY29udGVudCB0eXBlcyBpbXBseSBcInJlbmRlclwiLlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbmZ1bmN0aW9uIGNvbnRlbnRUeXBlVG9Db250ZW50RGlzcG9zaXRpb24oY29udGVudFR5cGUpIHtcbiAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vc2RwXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic2Vzc2lvblwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwicmVuZGVyXCI7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZDVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG8tanMvbWQ1XCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIERpZ2VzdCBBdXRoZW50aWNhdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgRGlnZXN0QXV0aGVudGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIGxvZ2dlckZhY3RvcnkgLSBMb2dnZXJGYWN0b3J5LlxuICAgICAqIEBwYXJhbSB1c2VybmFtZSAtIFVzZXJuYW1lLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpZ2VzdEF1dGhlbnRpY2F0aW9uKGxvZ2dlckZhY3RvcnksIHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwanMuZGlnZXN0YXV0aGVudGljYXRpb25cIik7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgICAgICB0aGlzLm5jID0gMDtcbiAgICAgICAgdGhpcy5uY0hleCA9IFwiMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgRGlnZXN0IGF1dGhlbnRpY2F0aW9uIGdpdmVuIGEgU0lQIHJlcXVlc3QgYW5kIHRoZSBjaGFsbGVuZ2VcbiAgICAgKiByZWNlaXZlZCBpbiBhIHJlc3BvbnNlIHRvIHRoYXQgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtXG4gICAgICogQHBhcmFtIGNoYWxsZW5nZSAtXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBjcmVkZW50aWFscyB3ZXJlIHN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBEaWdlc3RBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNoYWxsZW5nZSwgYm9keSkge1xuICAgICAgICAvLyBJbnNwZWN0IGFuZCB2YWxpZGF0ZSB0aGUgY2hhbGxlbmdlLlxuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGNoYWxsZW5nZS5hbGdvcml0aG07XG4gICAgICAgIHRoaXMucmVhbG0gPSBjaGFsbGVuZ2UucmVhbG07XG4gICAgICAgIHRoaXMubm9uY2UgPSBjaGFsbGVuZ2Uubm9uY2U7XG4gICAgICAgIHRoaXMub3BhcXVlID0gY2hhbGxlbmdlLm9wYXF1ZTtcbiAgICAgICAgdGhpcy5zdGFsZSA9IGNoYWxsZW5nZS5zdGFsZTtcbiAgICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGdvcml0aG0gIT09IFwiTUQ1XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiY2hhbGxlbmdlIHdpdGggRGlnZXN0IGFsZ29yaXRobSBkaWZmZXJlbnQgdGhhbiAnTUQ1JywgYXV0aGVudGljYXRpb24gYWJvcnRlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFsZ29yaXRobSA9IFwiTUQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlYWxtKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHJlYWxtLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImNoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCBub25jZSwgYXV0aGVudGljYXRpb24gYWJvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAncW9wJyBjYW4gY29udGFpbiBhIGxpc3Qgb2YgdmFsdWVzIChBcnJheSkuIExldCdzIGNob29zZSBqdXN0IG9uZS5cbiAgICAgICAgaWYgKGNoYWxsZW5nZS5xb3ApIHtcbiAgICAgICAgICAgIGlmIChjaGFsbGVuZ2UucW9wLmluZGV4T2YoXCJhdXRoXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnFvcCA9IFwiYXV0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbGxlbmdlLnFvcC5pbmRleE9mKFwiYXV0aC1pbnRcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucW9wID0gXCJhdXRoLWludFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlICdxb3AnIGlzIHByZXNlbnQgYnV0IGRvZXMgbm90IGNvbnRhaW4gJ2F1dGgnIG9yICdhdXRoLWludCcsIHNvIGFib3J0IGhlcmUuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImNoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCBxb3AgZGlmZmVyZW50IHRoYW4gJ2F1dGgnIG9yICdhdXRoLWludCcsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsbCBvdGhlciBhdHRyaWJ1dGVzLlxuICAgICAgICB0aGlzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICB0aGlzLnVyaSA9IHJlcXVlc3QucnVyaTtcbiAgICAgICAgdGhpcy5jbm9uY2UgPSB1dGlsc18xLmNyZWF0ZVJhbmRvbVRva2VuKDEyKTtcbiAgICAgICAgdGhpcy5uYyArPSAxO1xuICAgICAgICB0aGlzLnVwZGF0ZU5jSGV4KCk7XG4gICAgICAgIC8vIG5jLXZhbHVlID0gOExIRVguIE1heCB2YWx1ZSA9ICdGRkZGRkZGRicuXG4gICAgICAgIGlmICh0aGlzLm5jID09PSA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgICB0aGlzLm5jID0gMTtcbiAgICAgICAgICAgIHRoaXMubmNIZXggPSBcIjAwMDAwMDAxXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBEaWdlc3QgXCJyZXNwb25zZVwiIHZhbHVlLlxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVJlc3BvbnNlKGJvZHkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBvciBXV1ctQXV0aG9yaXphdGlvbiBoZWFkZXIgdmFsdWUuXG4gICAgICovXG4gICAgRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXV0aFBhcmFtcyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc3BvbnNlIGZpZWxkIGRvZXMgbm90IGV4aXN0LCBjYW5ub3QgZ2VuZXJhdGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXV0aFBhcmFtcy5wdXNoKFwiYWxnb3JpdGhtPVwiICsgdGhpcy5hbGdvcml0aG0pO1xuICAgICAgICBhdXRoUGFyYW1zLnB1c2goJ3VzZXJuYW1lPVwiJyArIHRoaXMudXNlcm5hbWUgKyAnXCInKTtcbiAgICAgICAgYXV0aFBhcmFtcy5wdXNoKCdyZWFsbT1cIicgKyB0aGlzLnJlYWxtICsgJ1wiJyk7XG4gICAgICAgIGF1dGhQYXJhbXMucHVzaCgnbm9uY2U9XCInICsgdGhpcy5ub25jZSArICdcIicpO1xuICAgICAgICBhdXRoUGFyYW1zLnB1c2goJ3VyaT1cIicgKyB0aGlzLnVyaSArICdcIicpO1xuICAgICAgICBhdXRoUGFyYW1zLnB1c2goJ3Jlc3BvbnNlPVwiJyArIHRoaXMucmVzcG9uc2UgKyAnXCInKTtcbiAgICAgICAgaWYgKHRoaXMub3BhcXVlKSB7XG4gICAgICAgICAgICBhdXRoUGFyYW1zLnB1c2goJ29wYXF1ZT1cIicgKyB0aGlzLm9wYXF1ZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnFvcCkge1xuICAgICAgICAgICAgYXV0aFBhcmFtcy5wdXNoKFwicW9wPVwiICsgdGhpcy5xb3ApO1xuICAgICAgICAgICAgYXV0aFBhcmFtcy5wdXNoKCdjbm9uY2U9XCInICsgdGhpcy5jbm9uY2UgKyAnXCInKTtcbiAgICAgICAgICAgIGF1dGhQYXJhbXMucHVzaChcIm5jPVwiICsgdGhpcy5uY0hleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiRGlnZXN0IFwiICsgYXV0aFBhcmFtcy5qb2luKFwiLCBcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgJ25jJyB2YWx1ZSBhcyByZXF1aXJlZCBieSBEaWdlc3QgaW4gdGhpcy5uY0hleCBieSByZWFkaW5nIHRoaXMubmMuXG4gICAgICovXG4gICAgRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLnVwZGF0ZU5jSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGV4ID0gTnVtYmVyKHRoaXMubmMpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdGhpcy5uY0hleCA9IFwiMDAwMDAwMDBcIi5zdWJzdHIoMCwgOCAtIGhleC5sZW5ndGgpICsgaGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgRGlnZXN0ICdyZXNwb25zZScgdmFsdWUuXG4gICAgICovXG4gICAgRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLmNhbGN1bGF0ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgdmFyIGhhMjtcbiAgICAgICAgLy8gSEExID0gTUQ1KEExKSA9IE1ENSh1c2VybmFtZTpyZWFsbTpwYXNzd29yZClcbiAgICAgICAgdmFyIGhhMSA9IG1kNV8xLmRlZmF1bHQodGhpcy51c2VybmFtZSArIFwiOlwiICsgdGhpcy5yZWFsbSArIFwiOlwiICsgdGhpcy5wYXNzd29yZCk7XG4gICAgICAgIGlmICh0aGlzLnFvcCA9PT0gXCJhdXRoXCIpIHtcbiAgICAgICAgICAgIC8vIEhBMiA9IE1ENShBMikgPSBNRDUobWV0aG9kOmRpZ2VzdFVSSSlcbiAgICAgICAgICAgIGhhMiA9IG1kNV8xLmRlZmF1bHQodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpub25jZUNvdW50OmNyZWRlbnRpYWxzTm9uY2U6cW9wOkhBMilcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBtZDVfMS5kZWZhdWx0KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgdGhpcy5uY0hleCArIFwiOlwiICsgdGhpcy5jbm9uY2UgKyBcIjphdXRoOlwiICsgaGEyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnFvcCA9PT0gXCJhdXRoLWludFwiKSB7XG4gICAgICAgICAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkk6TUQ1KGVudGl0eUJvZHkpKVxuICAgICAgICAgICAgaGEyID0gbWQ1XzEuZGVmYXVsdCh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkgKyBcIjpcIiArIG1kNV8xLmRlZmF1bHQoYm9keSA/IGJvZHkgOiBcIlwiKSk7XG4gICAgICAgICAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6bm9uY2VDb3VudDpjcmVkZW50aWFsc05vbmNlOnFvcDpIQTIpXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbWQ1XzEuZGVmYXVsdChoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIHRoaXMubmNIZXggKyBcIjpcIiArIHRoaXMuY25vbmNlICsgXCI6YXV0aC1pbnQ6XCIgKyBoYTIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucW9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEhBMiA9IE1ENShBMikgPSBNRDUobWV0aG9kOmRpZ2VzdFVSSSlcbiAgICAgICAgICAgIGhhMiA9IG1kNV8xLmRlZmF1bHQodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpIQTIpXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbWQ1XzEuZGVmYXVsdChoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIGhhMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEaWdlc3RBdXRoZW50aWNhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkRpZ2VzdEF1dGhlbnRpY2F0aW9uID0gRGlnZXN0QXV0aGVudGljYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHBlZ0dyYW1tYXIgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vZ3JhbW1hci9kaXN0L2dyYW1tYXJcIikpO1xuLyoqXG4gKiBHcmFtbWFyLlxuICogQGludGVybmFsXG4gKi9cbnZhciBHcmFtbWFyO1xuKGZ1bmN0aW9uIChHcmFtbWFyKSB7XG4gICAgLyoqXG4gICAgICogUGFyc2UuXG4gICAgICogQHBhcmFtIGlucHV0IC1cbiAgICAgKiBAcGFyYW0gc3RhcnRSdWxlIC1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShpbnB1dCwgc3RhcnRSdWxlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0geyBzdGFydFJ1bGU6IHN0YXJ0UnVsZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGVnR3JhbW1hci5wYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIEdyYW1tYXIucGFyc2UgPSBwYXJzZTtcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIGEgU0lQLk5hbWVBZGRySGVhZGVyIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAgICAqIGl0IGlzIGFuIGludmFsaWQgTmFtZUFkZHJIZWFkZXIuXG4gICAgICogQHBhcmFtIG5hbWVfYWRkcl9oZWFkZXIgLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hbWVBZGRySGVhZGVyUGFyc2UobmFtZUFkZHJIZWFkZXIpIHtcbiAgICAgICAgdmFyIHBhcnNlZE5hbWVBZGRySGVhZGVyID0gR3JhbW1hci5wYXJzZShuYW1lQWRkckhlYWRlciwgXCJOYW1lX0FkZHJfSGVhZGVyXCIpO1xuICAgICAgICByZXR1cm4gcGFyc2VkTmFtZUFkZHJIZWFkZXIgIT09IC0xID8gcGFyc2VkTmFtZUFkZHJIZWFkZXIgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZSA9IG5hbWVBZGRySGVhZGVyUGFyc2U7XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyBhIFNJUC5VUkkgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmXG4gICAgICogaXQgaXMgYW4gaW52YWxpZCBVUkkuXG4gICAgICogQHBhcmFtIHVyaSAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gVVJJUGFyc2UodXJpKSB7XG4gICAgICAgIHZhciBwYXJzZWRVcmkgPSBHcmFtbWFyLnBhcnNlKHVyaSwgXCJTSVBfVVJJXCIpO1xuICAgICAgICByZXR1cm4gcGFyc2VkVXJpICE9PSAtMSA/IHBhcnNlZFVyaSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgR3JhbW1hci5VUklQYXJzZSA9IFVSSVBhcnNlO1xufSkoR3JhbW1hciA9IGV4cG9ydHMuR3JhbW1hciB8fCAoZXhwb3J0cy5HcmFtbWFyID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYW1tYXJfMSA9IHJlcXVpcmUoXCIuL2dyYW1tYXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBJbmNvbWluZyBtZXNzYWdlLlxuICogQHB1YmxpY1xuICovXG52YXIgSW5jb21pbmdNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluY29taW5nTWVzc2FnZSgpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGhlYWRlciBvZiB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUgaW50byB0aGUgbGFzdCBwb3NpdGlvbiBvZiB0aGVcbiAgICAgKiBoZWFkZXIgYXJyYXkuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIGhlYWRlciB2YWx1ZVxuICAgICAqL1xuICAgIEluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuYWRkSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB7IHJhdzogdmFsdWUgfTtcbiAgICAgICAgbmFtZSA9IHV0aWxzXzEuaGVhZGVyaXplKG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbbmFtZV0ucHVzaChoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW25hbWVdID0gW2hlYWRlcl07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBuYW1lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgdW5kZWZpbmVkIGlmIGhlYWRlciBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIEluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyc1t1dGlsc18xLmhlYWRlcml6ZShuYW1lKV07XG4gICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyWzBdLnJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHJldHVybnMgQXJyYXkgLSB3aXRoIGFsbCB0aGUgaGVhZGVycyBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAgICovXG4gICAgSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyc1t1dGlsc18xLmhlYWRlcml6ZShuYW1lKV07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGhlYWRlcl8xID0gaGVhZGVyOyBfaSA8IGhlYWRlcl8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGhlYWRlclBhcnQgPSBoZWFkZXJfMVtfaV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChoZWFkZXJQYXJ0LnJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBoZWFkZXIuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIEluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuaGFzSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5oZWFkZXJzW3V0aWxzXzEuaGVhZGVyaXplKG5hbWUpXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgb24gdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gaWR4IC0gaGVhZGVyIGluZGV4XG4gICAgICogQHJldHVybnMgUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGVcbiAgICAgKiAgIGhlYWRlciBpcyBub3QgcHJlc2VudCBvciBpbiBjYXNlIG9mIGEgcGFyc2luZyBlcnJvci5cbiAgICAgKi9cbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLnBhcnNlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIGlkeCkge1xuICAgICAgICBpZiAoaWR4ID09PSB2b2lkIDApIHsgaWR4ID0gMDsgfVxuICAgICAgICBuYW1lID0gdXRpbHNfMS5oZWFkZXJpemUobmFtZSk7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmxvZ2dlci5sb2coXCJoZWFkZXIgJ1wiICsgbmFtZSArIFwiJyBub3QgcHJlc2VudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZHggPj0gdGhpcy5oZWFkZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGhpcy5sb2dnZXIubG9nKFwibm90IHNvIG1hbnkgJ1wiICsgbmFtZSArIFwiJyBoZWFkZXJzIHByZXNlbnRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tuYW1lXVtpZHhdO1xuICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIucmF3O1xuICAgICAgICBpZiAoaGVhZGVyLnBhcnNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlci5wYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3Vic3RpdHV0ZSAnLScgYnkgJ18nIGZvciBncmFtbWFyIHJ1bGUgbWF0Y2hpbmcuXG4gICAgICAgIHZhciBwYXJzZWQgPSBncmFtbWFyXzEuR3JhbW1hci5wYXJzZSh2YWx1ZSwgbmFtZS5yZXBsYWNlKC8tL2csIFwiX1wiKSk7XG4gICAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbbmFtZV0uc3BsaWNlKGlkeCwgMSk7IC8vIGRlbGV0ZSBmcm9tIGhlYWRlcnNcbiAgICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgXCInICsgbmFtZSArICdcIiBoZWFkZXIgZmllbGQgd2l0aCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgSGVhZGVyIGF0dHJpYnV0ZSBzZWxlY3Rvci4gQWxpYXMgb2YgcGFyc2VIZWFkZXIuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEBwYXJhbSBpZHggLSBoZWFkZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBQYXJzZWQgaGVhZGVyIG9iamVjdCwgdW5kZWZpbmVkIGlmIHRoZVxuICAgICAqICAgaGVhZGVyIGlzIG5vdCBwcmVzZW50IG9yIGluIGNhc2Ugb2YgYSBwYXJzaW5nIGVycm9yLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtZXNzYWdlLnMoJ3ZpYScsMykucG9ydFxuICAgICAqL1xuICAgIEluY29taW5nTWVzc2FnZS5wcm90b3R5cGUucyA9IGZ1bmN0aW9uIChuYW1lLCBpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gdm9pZCAwKSB7IGlkeCA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIZWFkZXIobmFtZSwgaWR4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgYnkgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBoZWFkZXIgdmFsdWVcbiAgICAgKi9cbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldID0gW3sgcmF3OiB2YWx1ZSB9XTtcbiAgICB9O1xuICAgIEluY29taW5nTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gSW5jb21pbmdNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuSW5jb21pbmdNZXNzYWdlID0gSW5jb21pbmdNZXNzYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBpbmNvbWluZ19tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9pbmNvbWluZy1tZXNzYWdlXCIpO1xuLyoqXG4gKiBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UuXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEluY29taW5nUmVxdWVzdE1lc3NhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlO1xufShpbmNvbWluZ19tZXNzYWdlXzEuSW5jb21pbmdNZXNzYWdlKSk7XG5leHBvcnRzLkluY29taW5nUmVxdWVzdE1lc3NhZ2UgPSBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBpbmNvbWluZ19tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9pbmNvbWluZy1tZXNzYWdlXCIpO1xuLyoqXG4gKiBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlLlxuICogQHB1YmxpY1xuICovXG52YXIgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW5jb21pbmdSZXNwb25zZU1lc3NhZ2U7XG59KGluY29taW5nX21lc3NhZ2VfMS5JbmNvbWluZ01lc3NhZ2UpKTtcbmV4cG9ydHMuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UgPSBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vLyBEaXJlY3Rvcmllc1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWV0aG9kc1wiKSwgZXhwb3J0cyk7XG4vLyBGaWxlc1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYm9keVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kaWdlc3QtYXV0aGVudGljYXRpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZ3JhbW1hclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmNvbWluZy1tZXNzYWdlXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2luY29taW5nLXJlcXVlc3QtbWVzc2FnZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmNvbWluZy1yZXNwb25zZS1tZXNzYWdlXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25hbWUtYWRkci1oZWFkZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3V0Z29pbmctcmVxdWVzdC1tZXNzYWdlXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL291dGdvaW5nLXJlc3BvbnNlXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhcmFtZXRlcnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3VyaVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogU0lQIE1ldGhvZHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgQztcbihmdW5jdGlvbiAoQykge1xuICAgIEMuQUNLID0gXCJBQ0tcIjtcbiAgICBDLkJZRSA9IFwiQllFXCI7XG4gICAgQy5DQU5DRUwgPSBcIkNBTkNFTFwiO1xuICAgIEMuSU5GTyA9IFwiSU5GT1wiO1xuICAgIEMuSU5WSVRFID0gXCJJTlZJVEVcIjtcbiAgICBDLk1FU1NBR0UgPSBcIk1FU1NBR0VcIjtcbiAgICBDLk5PVElGWSA9IFwiTk9USUZZXCI7XG4gICAgQy5PUFRJT05TID0gXCJPUFRJT05TXCI7XG4gICAgQy5SRUdJU1RFUiA9IFwiUkVHSVNURVJcIjtcbiAgICBDLlVQREFURSA9IFwiVVBEQVRFXCI7XG4gICAgQy5TVUJTQ1JJQkUgPSBcIlNVQlNDUklCRVwiO1xuICAgIEMuUFVCTElTSCA9IFwiUFVCTElTSFwiO1xuICAgIEMuUkVGRVIgPSBcIlJFRkVSXCI7XG4gICAgQy5QUkFDSyA9IFwiUFJBQ0tcIjtcbn0pKEMgPSBleHBvcnRzLkMgfHwgKGV4cG9ydHMuQyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgcGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vcGFyYW1ldGVyc1wiKTtcbi8qKlxuICogTmFtZSBBZGRyZXNzIFNJUCBoZWFkZXIuXG4gKiBAcHVibGljXG4gKi9cbnZhciBOYW1lQWRkckhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOYW1lQWRkckhlYWRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB1cmkgLVxuICAgICAqIEBwYXJhbSBkaXNwbGF5TmFtZSAtXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5hbWVBZGRySGVhZGVyKHVyaSwgZGlzcGxheU5hbWUsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyYW1ldGVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXJpID0gdXJpO1xuICAgICAgICBfdGhpcy5fZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmFtZUFkZHJIZWFkZXIucHJvdG90eXBlLCBcImZyaWVuZGx5TmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWUgfHwgdGhpcy51cmkuYW9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmFtZUFkZHJIZWFkZXIucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNwbGF5TmFtZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlOYW1lID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5hbWVBZGRySGVhZGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lQWRkckhlYWRlcih0aGlzLnVyaS5jbG9uZSgpLCB0aGlzLl9kaXNwbGF5TmFtZSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpKSk7XG4gICAgfTtcbiAgICBOYW1lQWRkckhlYWRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib2R5ID0gKHRoaXMuZGlzcGxheU5hbWUgfHwgdGhpcy5kaXNwbGF5TmFtZSA9PT0gXCIwXCIpID8gJ1wiJyArIHRoaXMuZGlzcGxheU5hbWUgKyAnXCIgJyA6IFwiXCI7XG4gICAgICAgIGJvZHkgKz0gXCI8XCIgKyB0aGlzLnVyaS50b1N0cmluZygpICsgXCI+XCI7XG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gXCI7XCIgKyBwYXJhbWV0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gXCI9XCIgKyB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcbiAgICByZXR1cm4gTmFtZUFkZHJIZWFkZXI7XG59KHBhcmFtZXRlcnNfMS5QYXJhbWV0ZXJzKSk7XG5leHBvcnRzLk5hbWVBZGRySGVhZGVyID0gTmFtZUFkZHJIZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG5hbWVfYWRkcl9oZWFkZXJfMSA9IHJlcXVpcmUoXCIuL25hbWUtYWRkci1oZWFkZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBPdXRnb2luZyBTSVAgcmVxdWVzdCBtZXNzYWdlLlxuICogQHB1YmxpY1xuICovXG52YXIgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1ldGhvZCwgcnVyaSwgZnJvbVVSSSwgdG9VUkksIG9wdGlvbnMsIGV4dHJhSGVhZGVycywgYm9keSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5nZXREZWZhdWx0T3B0aW9ucygpO1xuICAgICAgICAvLyBPcHRpb25zIC0gbWVyZ2UgYSBkZWVwIGNvcHlcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wdGlvblRhZ3MgJiYgdGhpcy5vcHRpb25zLm9wdGlvblRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9wdGlvblRhZ3MgPSB0aGlzLm9wdGlvbnMub3B0aW9uVGFncy5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb3V0ZVNldCAmJiB0aGlzLm9wdGlvbnMucm91dGVTZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJvdXRlU2V0ID0gdGhpcy5vcHRpb25zLnJvdXRlU2V0LnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmEgaGVhZGVycyAtIGRlZXAgY29weVxuICAgICAgICBpZiAoZXh0cmFIZWFkZXJzICYmIGV4dHJhSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm9keSAtIGRlZXAgY29weVxuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gc2hvdWxkIGJlIEJvZHlcbiAgICAgICAgICAgIC8vIHRoaXMuYm9keSA9IHsgLi4uYm9keSB9O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHkuY29udGVudCxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogYm9keS5jb250ZW50VHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZXRob2RcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIC8vIFJVUklcbiAgICAgICAgdGhpcy5ydXJpID0gcnVyaS5jbG9uZSgpO1xuICAgICAgICAvLyBGcm9tXG4gICAgICAgIHRoaXMuZnJvbVVSSSA9IGZyb21VUkkuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5mcm9tVGFnID0gdGhpcy5vcHRpb25zLmZyb21UYWcgPyB0aGlzLm9wdGlvbnMuZnJvbVRhZyA6IHV0aWxzXzEubmV3VGFnKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UubWFrZU5hbWVBZGRySGVhZGVyKHRoaXMuZnJvbVVSSSwgdGhpcy5vcHRpb25zLmZyb21EaXNwbGF5TmFtZSwgdGhpcy5mcm9tVGFnKTtcbiAgICAgICAgLy8gVG9cbiAgICAgICAgdGhpcy50b1VSSSA9IHRvVVJJLmNsb25lKCk7XG4gICAgICAgIHRoaXMudG9UYWcgPSB0aGlzLm9wdGlvbnMudG9UYWc7XG4gICAgICAgIHRoaXMudG8gPSBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLm1ha2VOYW1lQWRkckhlYWRlcih0aGlzLnRvVVJJLCB0aGlzLm9wdGlvbnMudG9EaXNwbGF5TmFtZSwgdGhpcy50b1RhZyk7XG4gICAgICAgIC8vIENhbGwtSURcbiAgICAgICAgdGhpcy5jYWxsSWQgPSB0aGlzLm9wdGlvbnMuY2FsbElkID8gdGhpcy5vcHRpb25zLmNhbGxJZCA6IHRoaXMub3B0aW9ucy5jYWxsSWRQcmVmaXggKyB1dGlsc18xLmNyZWF0ZVJhbmRvbVRva2VuKDE1KTtcbiAgICAgICAgLy8gQ1NlcVxuICAgICAgICB0aGlzLmNzZXEgPSB0aGlzLm9wdGlvbnMuY3NlcTtcbiAgICAgICAgLy8gVGhlIHJlbGF0aXZlIG9yZGVyIG9mIGhlYWRlciBmaWVsZHMgd2l0aCBkaWZmZXJlbnQgZmllbGQgbmFtZXMgaXMgbm90XG4gICAgICAgIC8vIHNpZ25pZmljYW50LiAgSG93ZXZlciwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdCBoZWFkZXIgZmllbGRzIHdoaWNoIGFyZVxuICAgICAgICAvLyBuZWVkZWQgZm9yIHByb3h5IHByb2Nlc3NpbmcgKFZpYSwgUm91dGUsIFJlY29yZC1Sb3V0ZSwgUHJveHktUmVxdWlyZSxcbiAgICAgICAgLy8gTWF4LUZvcndhcmRzLCBhbmQgUHJveHktQXV0aG9yaXphdGlvbiwgZm9yIGV4YW1wbGUpIGFwcGVhciB0b3dhcmRzXG4gICAgICAgIC8vIHRoZSB0b3Agb2YgdGhlIG1lc3NhZ2UgdG8gZmFjaWxpdGF0ZSByYXBpZCBwYXJzaW5nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTcuMy4xXG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKFwicm91dGVcIiwgdGhpcy5vcHRpb25zLnJvdXRlU2V0KTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoXCJ2aWFcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKFwidG9cIiwgdGhpcy50by50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoXCJmcm9tXCIsIHRoaXMuZnJvbS50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoXCJjc2VxXCIsIHRoaXMuY3NlcSArIFwiIFwiICsgdGhpcy5tZXRob2QpO1xuICAgICAgICB0aGlzLnNldEhlYWRlcihcImNhbGwtaWRcIiwgdGhpcy5jYWxsSWQpO1xuICAgICAgICB0aGlzLnNldEhlYWRlcihcIm1heC1mb3J3YXJkc1wiLCBcIjcwXCIpO1xuICAgIH1cbiAgICAvKiogR2V0IGEgY29weSBvZiB0aGUgZGVmYXVsdCBvcHRpb25zLiAqL1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZ2V0RGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxsSWQ6IFwiXCIsXG4gICAgICAgICAgICBjYWxsSWRQcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICBjc2VxOiAxLFxuICAgICAgICAgICAgdG9EaXNwbGF5TmFtZTogXCJcIixcbiAgICAgICAgICAgIHRvVGFnOiBcIlwiLFxuICAgICAgICAgICAgZnJvbURpc3BsYXlOYW1lOiBcIlwiLFxuICAgICAgICAgICAgZnJvbVRhZzogXCJcIixcbiAgICAgICAgICAgIGZvcmNlUnBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgaGFja1ZpYVRjcDogZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25UYWdzOiBbXCJvdXRib3VuZFwiXSxcbiAgICAgICAgICAgIHJvdXRlU2V0OiBbXSxcbiAgICAgICAgICAgIHVzZXJBZ2VudFN0cmluZzogXCJzaXAuanNcIixcbiAgICAgICAgICAgIHZpYUhvc3Q6IFwiXCJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UubWFrZU5hbWVBZGRySGVhZGVyID0gZnVuY3Rpb24gKHVyaSwgZGlzcGxheU5hbWUsIHRhZykge1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnRhZyA9IHRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG5hbWVfYWRkcl9oZWFkZXJfMS5OYW1lQWRkckhlYWRlcih1cmksIGRpc3BsYXlOYW1lLCBwYXJhbWV0ZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBuYW1lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgdW5kZWZpbmVkIGlmIGhlYWRlciBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldO1xuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqOlwiLCBcImlcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5leHRyYUhlYWRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4SGVhZGVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChleEhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4SGVhZGVyLnN1YnN0cmluZyhleEhlYWRlci5pbmRleE9mKFwiOlwiKSArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHJldHVybnMgQXJyYXkgd2l0aCBhbGwgdGhlIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAqL1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLmdldEhlYWRlcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBoZWFkZXJBcnJheSA9IHRoaXMuaGVhZGVyc1t1dGlsc18xLmhlYWRlcml6ZShuYW1lKV07XG4gICAgICAgIGlmIChoZWFkZXJBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBoZWFkZXJBcnJheV8xID0gaGVhZGVyQXJyYXk7IF9pIDwgaGVhZGVyQXJyYXlfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyUGFydCA9IGhlYWRlckFycmF5XzFbX2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGhlYWRlclBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccyo6XCIsIFwiaVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSB0aGlzLmV4dHJhSGVhZGVyczsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhIZWFkZXIgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGV4SGVhZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChleEhlYWRlci5zdWJzdHJpbmcoZXhIZWFkZXIuaW5kZXhPZihcIjpcIikgKyAxKS50cmltKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoZSBleGlzdGVuY2Ugb2YgdGhlIGdpdmVuIGhlYWRlci5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBoZWFkZXIgd2l0aCBnaXZlbiBuYW1lIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5wcm90b3R5cGUuaGFzSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1t1dGlsc18xLmhlYWRlcml6ZShuYW1lKV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccyo6XCIsIFwiaVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmV4dHJhSGVhZGVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGV4dHJhSGVhZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgdGhlIGdpdmVuIGhlYWRlciBieSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIGhlYWRlciB2YWx1ZVxuICAgICAqL1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldID0gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFZpYSBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB0cmFuc3BvcnQgdXNlZCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogYW5kIGlkZW50aWZpZXMgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSByZXNwb25zZSBpcyB0byBiZSBzZW50LiAgQSBWaWFcbiAgICAgKiBoZWFkZXIgZmllbGQgdmFsdWUgaXMgYWRkZWQgb25seSBhZnRlciB0aGUgdHJhbnNwb3J0IHRoYXQgd2lsbCBiZVxuICAgICAqIHVzZWQgdG8gcmVhY2ggdGhlIG5leHQgaG9wIGhhcyBiZWVuIHNlbGVjdGVkICh3aGljaCBtYXkgaW52b2x2ZSB0aGVcbiAgICAgKiB1c2FnZSBvZiB0aGUgcHJvY2VkdXJlcyBpbiBbNF0pLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgVUFDIGNyZWF0ZXMgYSByZXF1ZXN0LCBpdCBNVVNUIGluc2VydCBhIFZpYSBpbnRvIHRoYXRcbiAgICAgKiByZXF1ZXN0LiAgVGhlIHByb3RvY29sIG5hbWUgYW5kIHByb3RvY29sIHZlcnNpb24gaW4gdGhlIGhlYWRlciBmaWVsZFxuICAgICAqIE1VU1QgYmUgU0lQIGFuZCAyLjAsIHJlc3BlY3RpdmVseS4gIFRoZSBWaWEgaGVhZGVyIGZpZWxkIHZhbHVlIE1VU1RcbiAgICAgKiBjb250YWluIGEgYnJhbmNoIHBhcmFtZXRlci4gIFRoaXMgcGFyYW1ldGVyIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlXG4gICAgICogdHJhbnNhY3Rpb24gY3JlYXRlZCBieSB0aGF0IHJlcXVlc3QuICBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIGJ5IGJvdGhcbiAgICAgKiB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjEuN1xuICAgICAqIEBwYXJhbSBicmFuY2hQYXJhbWV0ZXIgLSBUaGUgYnJhbmNoIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHNlbnQgcHJvdG9jb2wgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLnNldFZpYUhlYWRlciA9IGZ1bmN0aW9uIChicmFuY2gsIHRyYW5zcG9ydCkge1xuICAgICAgICAvLyBGSVhNRTogSGFja1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhY2tWaWFUY3ApIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IFwiVENQXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpYSA9IFwiU0lQLzIuMC9cIiArIHRyYW5zcG9ydDtcbiAgICAgICAgdmlhICs9IFwiIFwiICsgdGhpcy5vcHRpb25zLnZpYUhvc3QgKyBcIjticmFuY2g9XCIgKyBicmFuY2g7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VScG9ydCkge1xuICAgICAgICAgICAgdmlhICs9IFwiO3Jwb3J0XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoXCJ2aWFcIiwgdmlhKTtcbiAgICAgICAgdGhpcy5icmFuY2ggPSBicmFuY2g7XG4gICAgfTtcbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiXCI7XG4gICAgICAgIG1zZyArPSB0aGlzLm1ldGhvZCArIFwiIFwiICsgdGhpcy5ydXJpLnRvUmF3KCkgKyBcIiBTSVAvMi4wXFxyXFxuXCI7XG4gICAgICAgIGZvciAodmFyIGhlYWRlciBpbiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlcnNbaGVhZGVyXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmhlYWRlcnNbaGVhZGVyXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlclBhcnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBoZWFkZXIgKyBcIjogXCIgKyBoZWFkZXJQYXJ0ICsgXCJcXHJcXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuZXh0cmFIZWFkZXJzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IF9jW19iXTtcbiAgICAgICAgICAgIG1zZyArPSBoZWFkZXIudHJpbSgpICsgXCJcXHJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBtc2cgKz0gXCJTdXBwb3J0ZWQ6IFwiICsgdGhpcy5vcHRpb25zLm9wdGlvblRhZ3Muam9pbihcIiwgXCIpICsgXCJcXHJcXG5cIjtcbiAgICAgICAgbXNnICs9IFwiVXNlci1BZ2VudDogXCIgKyB0aGlzLm9wdGlvbnMudXNlckFnZW50U3RyaW5nICsgXCJcXHJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCJDb250ZW50LUxlbmd0aDogXCIgKyB1dGlsc18xLnN0cl91dGY4X2xlbmd0aCh0aGlzLmJvZHkpICsgXCJcXHJcXG5cXHJcXG5cIjtcbiAgICAgICAgICAgICAgICBtc2cgKz0gdGhpcy5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ib2R5ICYmIHRoaXMuYm9keS5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gXCJDb250ZW50LVR5cGU6IFwiICsgdGhpcy5ib2R5LmNvbnRlbnRUeXBlICsgXCJcXHJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgdXRpbHNfMS5zdHJfdXRmOF9sZW5ndGgodGhpcy5ib2R5LmJvZHkpICsgXCJcXHJcXG5cXHJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IHRoaXMuYm9keS5ib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgMCArIFwiXFxyXFxuXFxyXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXNnICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgMCArIFwiXFxyXFxuXFxyXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuICAgIHJldHVybiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSA9IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIFdoZW4gYSBVQVMgd2lzaGVzIHRvIGNvbnN0cnVjdCBhIHJlc3BvbnNlIHRvIGEgcmVxdWVzdCwgaXQgZm9sbG93c1xuICogdGhlIGdlbmVyYWwgcHJvY2VkdXJlcyBkZXRhaWxlZCBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLlxuICogQWRkaXRpb25hbCBiZWhhdmlvcnMgc3BlY2lmaWMgdG8gdGhlIHJlc3BvbnNlIGNvZGUgaW4gcXVlc3Rpb24sIHdoaWNoXG4gKiBhcmUgbm90IGRldGFpbGVkIGluIHRoaXMgc2VjdGlvbiwgbWF5IGFsc28gYmUgcmVxdWlyZWQuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi42XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0T3V0Z29pbmdSZXNwb25zZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgdmFyIENSTEYgPSBcIlxcclxcblwiO1xuICAgIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgPCAxMDAgfHwgb3B0aW9ucy5zdGF0dXNDb2RlID4gNjk5KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN0YXR1c0NvZGU6IFwiICsgb3B0aW9ucy5zdGF0dXNDb2RlKTtcbiAgICB9XG4gICAgdmFyIHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlID8gb3B0aW9ucy5yZWFzb25QaHJhc2UgOiB1dGlsc18xLmdldFJlYXNvblBocmFzZShvcHRpb25zLnN0YXR1c0NvZGUpO1xuICAgIC8vIFNJUCByZXNwb25zZXMgYXJlIGRpc3Rpbmd1aXNoZWQgZnJvbSByZXF1ZXN0cyBieSBoYXZpbmcgYSBTdGF0dXMtTGluZVxuICAgIC8vIGFzIHRoZWlyIHN0YXJ0LWxpbmUuICBBIFN0YXR1cy1MaW5lIGNvbnNpc3RzIG9mIHRoZSBwcm90b2NvbCB2ZXJzaW9uXG4gICAgLy8gZm9sbG93ZWQgYnkgYSBudW1lcmljIFN0YXR1cy1Db2RlIGFuZCBpdHMgYXNzb2NpYXRlZCB0ZXh0dWFsIHBocmFzZSxcbiAgICAvLyB3aXRoIGVhY2ggZWxlbWVudCBzZXBhcmF0ZWQgYnkgYSBzaW5nbGUgU1AgY2hhcmFjdGVyLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNy4yXG4gICAgdmFyIHJlc3BvbnNlID0gXCJTSVAvMi4wIFwiICsgb3B0aW9ucy5zdGF0dXNDb2RlICsgXCIgXCIgKyByZWFzb25QaHJhc2UgKyBDUkxGO1xuICAgIC8vIE9uZSBsYXJnZWx5IG5vbi1tZXRob2Qtc3BlY2lmaWMgZ3VpZGVsaW5lIGZvciB0aGUgZ2VuZXJhdGlvbiBvZlxuICAgIC8vIHJlc3BvbnNlcyBpcyB0aGF0IFVBU3MgU0hPVUxEIE5PVCBpc3N1ZSBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGZvciBhXG4gICAgLy8gbm9uLUlOVklURSByZXF1ZXN0LiAgUmF0aGVyLCBVQVNzIFNIT1VMRCBnZW5lcmF0ZSBhIGZpbmFsIHJlc3BvbnNlIHRvXG4gICAgLy8gYSBub24tSU5WSVRFIHJlcXVlc3QgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi42LjFcbiAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlID49IDEwMCAmJiBvcHRpb25zLnN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICAvLyBXaGVuIGEgMTAwIChUcnlpbmcpIHJlc3BvbnNlIGlzIGdlbmVyYXRlZCwgYW55IFRpbWVzdGFtcCBoZWFkZXIgZmllbGRcbiAgICAvLyBwcmVzZW50IGluIHRoZSByZXF1ZXN0IE1VU1QgYmUgY29waWVkIGludG8gdGhpcyAxMDAgKFRyeWluZylcbiAgICAvLyByZXNwb25zZS4gIElmIHRoZXJlIGlzIGEgZGVsYXkgaW4gZ2VuZXJhdGluZyB0aGUgcmVzcG9uc2UsIHRoZSBVQVNcbiAgICAvLyBTSE9VTEQgYWRkIGEgZGVsYXkgdmFsdWUgaW50byB0aGUgVGltZXN0YW1wIHZhbHVlIGluIHRoZSByZXNwb25zZS5cbiAgICAvLyBUaGlzIHZhbHVlIE1VU1QgY29udGFpbiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0aW1lIG9mIHNlbmRpbmcgb2ZcbiAgICAvLyB0aGUgcmVzcG9uc2UgYW5kIHJlY2VpcHQgb2YgdGhlIHJlcXVlc3QsIG1lYXN1cmVkIGluIHNlY29uZHMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNi4xXG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgLy8gVGhlIEZyb20gZmllbGQgb2YgdGhlIHJlc3BvbnNlIE1VU1QgZXF1YWwgdGhlIEZyb20gaGVhZGVyIGZpZWxkIG9mXG4gICAgLy8gdGhlIHJlcXVlc3QuICBUaGUgQ2FsbC1JRCBoZWFkZXIgZmllbGQgb2YgdGhlIHJlc3BvbnNlIE1VU1QgZXF1YWwgdGhlXG4gICAgLy8gQ2FsbC1JRCBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgQ1NlcSBoZWFkZXIgZmllbGQgb2YgdGhlXG4gICAgLy8gcmVzcG9uc2UgTVVTVCBlcXVhbCB0aGUgQ1NlcSBmaWVsZCBvZiB0aGUgcmVxdWVzdC4gIFRoZSBWaWEgaGVhZGVyXG4gICAgLy8gZmllbGQgdmFsdWVzIGluIHRoZSByZXNwb25zZSBNVVNUIGVxdWFsIHRoZSBWaWEgaGVhZGVyIGZpZWxkIHZhbHVlc1xuICAgIC8vIGluIHRoZSByZXF1ZXN0IGFuZCBNVVNUIG1haW50YWluIHRoZSBzYW1lIG9yZGVyaW5nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjYuMlxuICAgIHZhciBmcm9tSGVhZGVyID0gXCJGcm9tOiBcIiArIG1lc3NhZ2UuZ2V0SGVhZGVyKFwiRnJvbVwiKSArIENSTEY7XG4gICAgdmFyIGNhbGxJZEhlYWRlciA9IFwiQ2FsbC1JRDogXCIgKyBtZXNzYWdlLmNhbGxJZCArIENSTEY7XG4gICAgdmFyIGNTZXFIZWFkZXIgPSBcIkNTZXE6IFwiICsgbWVzc2FnZS5jc2VxICsgXCIgXCIgKyBtZXNzYWdlLm1ldGhvZCArIENSTEY7XG4gICAgdmFyIHZpYUhlYWRlcnMgPSBtZXNzYWdlLmdldEhlYWRlcnMoXCJ2aWFcIikucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBcIlZpYTogXCIgKyBjdXJyZW50ICsgQ1JMRjtcbiAgICB9LCBcIlwiKTtcbiAgICAvLyBJZiBhIHJlcXVlc3QgY29udGFpbmVkIGEgVG8gdGFnIGluIHRoZSByZXF1ZXN0LCB0aGUgVG8gaGVhZGVyIGZpZWxkXG4gICAgLy8gaW4gdGhlIHJlc3BvbnNlIE1VU1QgZXF1YWwgdGhhdCBvZiB0aGUgcmVxdWVzdC4gIEhvd2V2ZXIsIGlmIHRoZSBUb1xuICAgIC8vIGhlYWRlciBmaWVsZCBpbiB0aGUgcmVxdWVzdCBkaWQgbm90IGNvbnRhaW4gYSB0YWcsIHRoZSBVUkkgaW4gdGhlIFRvXG4gICAgLy8gaGVhZGVyIGZpZWxkIGluIHRoZSByZXNwb25zZSBNVVNUIGVxdWFsIHRoZSBVUkkgaW4gdGhlIFRvIGhlYWRlclxuICAgIC8vIGZpZWxkOyBhZGRpdGlvbmFsbHksIHRoZSBVQVMgTVVTVCBhZGQgYSB0YWcgdG8gdGhlIFRvIGhlYWRlciBmaWVsZCBpblxuICAgIC8vIHRoZSByZXNwb25zZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSAxMDAgKFRyeWluZykgcmVzcG9uc2UsIGluXG4gICAgLy8gd2hpY2ggYSB0YWcgTUFZIGJlIHByZXNlbnQpLiAgVGhpcyBzZXJ2ZXMgdG8gaWRlbnRpZnkgdGhlIFVBUyB0aGF0IGlzXG4gICAgLy8gcmVzcG9uZGluZywgcG9zc2libHkgcmVzdWx0aW5nIGluIGEgY29tcG9uZW50IG9mIGEgZGlhbG9nIElELiAgVGhlXG4gICAgLy8gc2FtZSB0YWcgTVVTVCBiZSB1c2VkIGZvciBhbGwgcmVzcG9uc2VzIHRvIHRoYXQgcmVxdWVzdCwgYm90aCBmaW5hbFxuICAgIC8vIGFuZCBwcm92aXNpb25hbCAoYWdhaW4gZXhjZXB0aW5nIHRoZSAxMDAgKFRyeWluZykpLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjYuMlxuICAgIHZhciB0b0hlYWRlciA9IFwiVG86IFwiICsgbWVzc2FnZS5nZXRIZWFkZXIoXCJ0b1wiKTtcbiAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlID4gMTAwICYmICFtZXNzYWdlLnBhcnNlSGVhZGVyKFwidG9cIikuaGFzUGFyYW0oXCJ0YWdcIikpIHtcbiAgICAgICAgdmFyIHRvVGFnID0gb3B0aW9ucy50b1RhZztcbiAgICAgICAgaWYgKCF0b1RhZykge1xuICAgICAgICAgICAgLy8gU3RhdGVsZXNzIFVBUyBCZWhhdmlvci4uLlxuICAgICAgICAgICAgLy8gbyAgVG8gaGVhZGVyIHRhZ3MgTVVTVCBiZSBnZW5lcmF0ZWQgZm9yIHJlc3BvbnNlcyBpbiBhIHN0YXRlbGVzc1xuICAgICAgICAgICAgLy8gICAgbWFubmVyIC0gaW4gYSBtYW5uZXIgdGhhdCB3aWxsIGdlbmVyYXRlIHRoZSBzYW1lIHRhZyBmb3IgdGhlXG4gICAgICAgICAgICAvLyAgICBzYW1lIHJlcXVlc3QgY29uc2lzdGVudGx5LiAgRm9yIGluZm9ybWF0aW9uIG9uIHRhZyBjb25zdHJ1Y3Rpb25cbiAgICAgICAgICAgIC8vICAgIHNlZSBTZWN0aW9uIDE5LjMuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi43XG4gICAgICAgICAgICB0b1RhZyA9IHV0aWxzXzEubmV3VGFnKCk7IC8vIEZJWE1FOiBuZXdUYWcoKSBjdXJyZW50bHkgZ2VuZXJhdGVzIHJhbmRvbSB0YWdzXG4gICAgICAgIH1cbiAgICAgICAgdG9IZWFkZXIgKz0gXCI7dGFnPVwiICsgdG9UYWc7XG4gICAgfVxuICAgIHRvSGVhZGVyICs9IENSTEY7XG4gICAgLy8gRklYTUU6IFRPRE86IG5lZWRzIHJldmlldy4uLiBtb3ZlZCB0byBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgKGFzIGl0IGlzIHNwZWNpZmljIHRvIHRoYXQpXG4gICAgLy8gbGV0IHJlY29yZFJvdXRlSGVhZGVycyA9IFwiXCI7XG4gICAgLy8gaWYgKHJlcXVlc3QubWV0aG9kID09PSBDLklOVklURSAmJiBzdGF0dXNDb2RlID4gMTAwICYmIHN0YXR1c0NvZGUgPD0gMjAwKSB7XG4gICAgLy8gICByZWNvcmRSb3V0ZUhlYWRlcnMgPSByZXF1ZXN0LmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIikucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIC8vICAgICByZXR1cm4gcHJldmlvdXMgKyBcIlJlY29yZC1Sb3V0ZTogXCIgKyBjdXJyZW50ICsgQ1JMRjtcbiAgICAvLyAgIH0sIFwiXCIpO1xuICAgIC8vIH1cbiAgICAvLyBGSVhNRTogVE9ETzogbmVlZHMgcmV2aWV3Li4uXG4gICAgdmFyIHN1cHBvcnRlZEhlYWRlciA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMuc3VwcG9ydGVkKSB7XG4gICAgICAgIHN1cHBvcnRlZEhlYWRlciA9IFwiU3VwcG9ydGVkOiBcIiArIG9wdGlvbnMuc3VwcG9ydGVkLmpvaW4oXCIsIFwiKSArIENSTEY7XG4gICAgfVxuICAgIC8vIEZJWE1FOiBUT0RPOiBuZWVkcyByZXZpZXcuLi5cbiAgICB2YXIgdXNlckFnZW50SGVhZGVyID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy51c2VyQWdlbnQpIHtcbiAgICAgICAgdXNlckFnZW50SGVhZGVyID0gXCJVc2VyLUFnZW50OiBcIiArIG9wdGlvbnMudXNlckFnZW50ICsgQ1JMRjtcbiAgICB9XG4gICAgdmFyIGV4dGVuc2lvbkhlYWRlcnMgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmV4dHJhSGVhZGVycykge1xuICAgICAgICBleHRlbnNpb25IZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgY3VycmVudC50cmltKCkgKyBDUkxGO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICB9XG4gICAgLy8gVGhlIHJlbGF0aXZlIG9yZGVyIG9mIGhlYWRlciBmaWVsZHMgd2l0aCBkaWZmZXJlbnQgZmllbGQgbmFtZXMgaXMgbm90XG4gICAgLy8gc2lnbmlmaWNhbnQuICBIb3dldmVyLCBpdCBpcyBSRUNPTU1FTkRFRCB0aGF0IGhlYWRlciBmaWVsZHMgd2hpY2ggYXJlXG4gICAgLy8gbmVlZGVkIGZvciBwcm94eSBwcm9jZXNzaW5nIChWaWEsIFJvdXRlLCBSZWNvcmQtUm91dGUsIFByb3h5LVJlcXVpcmUsXG4gICAgLy8gTWF4LUZvcndhcmRzLCBhbmQgUHJveHktQXV0aG9yaXphdGlvbiwgZm9yIGV4YW1wbGUpIGFwcGVhciB0b3dhcmRzXG4gICAgLy8gdGhlIHRvcCBvZiB0aGUgbWVzc2FnZSB0byBmYWNpbGl0YXRlIHJhcGlkIHBhcnNpbmcuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi03LjMuMVxuICAgIC8vIHJlc3BvbnNlICs9IHJlY29yZFJvdXRlSGVhZGVycztcbiAgICByZXNwb25zZSArPSB2aWFIZWFkZXJzO1xuICAgIHJlc3BvbnNlICs9IGZyb21IZWFkZXI7XG4gICAgcmVzcG9uc2UgKz0gdG9IZWFkZXI7XG4gICAgcmVzcG9uc2UgKz0gY1NlcUhlYWRlcjtcbiAgICByZXNwb25zZSArPSBjYWxsSWRIZWFkZXI7XG4gICAgcmVzcG9uc2UgKz0gc3VwcG9ydGVkSGVhZGVyO1xuICAgIHJlc3BvbnNlICs9IHVzZXJBZ2VudEhlYWRlcjtcbiAgICByZXNwb25zZSArPSBleHRlbnNpb25IZWFkZXJzO1xuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgcmVzcG9uc2UgKz0gXCJDb250ZW50LVR5cGU6IFwiICsgb3B0aW9ucy5ib2R5LmNvbnRlbnRUeXBlICsgQ1JMRjtcbiAgICAgICAgcmVzcG9uc2UgKz0gXCJDb250ZW50LUxlbmd0aDogXCIgKyB1dGlsc18xLnN0cl91dGY4X2xlbmd0aChvcHRpb25zLmJvZHkuY29udGVudCkgKyBDUkxGICsgQ1JMRjtcbiAgICAgICAgcmVzcG9uc2UgKz0gb3B0aW9ucy5ib2R5LmNvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXNwb25zZSArPSBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArIDAgKyBDUkxGICsgQ1JMRjtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZTogcmVzcG9uc2UgfTtcbn1cbmV4cG9ydHMuY29uc3RydWN0T3V0Z29pbmdSZXNwb25zZSA9IGNvbnN0cnVjdE91dGdvaW5nUmVzcG9uc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBQYXJhbWV0ZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcmFtZXRlcnMocGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gcGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbShwYXJhbSwgcGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFBhcmFtZXRlcnMucHJvdG90eXBlLnNldFBhcmFtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9ICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IG51bGwpID8gbnVsbCA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcmFtZXRlcnMucHJvdG90eXBlLmdldFBhcmFtID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyYW1ldGVycy5wcm90b3R5cGUuaGFzUGFyYW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShrZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUGFyYW1ldGVycy5wcm90b3R5cGUuZGVsZXRlUGFyYW0gPSBmdW5jdGlvbiAocGFyYW1ldGVyKSB7XG4gICAgICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJhbWV0ZXJzLnByb3RvdHlwZS5jbGVhclBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gICAgfTtcbiAgICByZXR1cm4gUGFyYW1ldGVycztcbn0oKSk7XG5leHBvcnRzLlBhcmFtZXRlcnMgPSBQYXJhbWV0ZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhbW1hcl8xID0gcmVxdWlyZShcIi4vZ3JhbW1hclwiKTtcbnZhciBpbmNvbWluZ19yZXF1ZXN0X21lc3NhZ2VfMSA9IHJlcXVpcmUoXCIuL2luY29taW5nLXJlcXVlc3QtbWVzc2FnZVwiKTtcbnZhciBpbmNvbWluZ19yZXNwb25zZV9tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9pbmNvbWluZy1yZXNwb25zZS1tZXNzYWdlXCIpO1xuLyoqXG4gKiBFeHRyYWN0IGFuZCBwYXJzZSBldmVyeSBoZWFkZXIgb2YgYSBTSVAgbWVzc2FnZS5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUGFyc2VyO1xuKGZ1bmN0aW9uIChQYXJzZXIpIHtcbiAgICBmdW5jdGlvbiBnZXRIZWFkZXIoZGF0YSwgaGVhZGVyU3RhcnQpIHtcbiAgICAgICAgLy8gJ3N0YXJ0JyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgICAgICB2YXIgc3RhcnQgPSBoZWFkZXJTdGFydDtcbiAgICAgICAgLy8gJ2VuZCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICAgICAgdmFyIGVuZCA9IDA7XG4gICAgICAgIC8vICdwYXJ0aWFsIGVuZCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICAgICAgdmFyIHBhcnRpYWxFbmQgPSAwO1xuICAgICAgICAvLyBFbmQgb2YgbWVzc2FnZS5cbiAgICAgICAgaWYgKGRhdGEuc3Vic3RyaW5nKHN0YXJ0LCBzdGFydCArIDIpLm1hdGNoKC8oXlxcclxcbikvKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFBhcnRpYWwgRW5kIG9mIEhlYWRlci5cbiAgICAgICAgICAgIHBhcnRpYWxFbmQgPSBkYXRhLmluZGV4T2YoXCJcXHJcXG5cIiwgc3RhcnQpO1xuICAgICAgICAgICAgLy8gJ2luZGV4T2YnIHJldHVybnMgLTEgaWYgdGhlIHZhbHVlIHRvIGJlIGZvdW5kIG5ldmVyIG9jY3Vycy5cbiAgICAgICAgICAgIGlmIChwYXJ0aWFsRW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhLnN1YnN0cmluZyhwYXJ0aWFsRW5kICsgMiwgcGFydGlhbEVuZCArIDQpLm1hdGNoKC8oXlxcclxcbikvKSAmJlxuICAgICAgICAgICAgICAgIGRhdGEuY2hhckF0KHBhcnRpYWxFbmQgKyAyKS5tYXRjaCgvKF5cXHMrKS8pKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2UuIENvbnRpbnVlIGZyb20gdGhlIG5leHQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwYXJ0aWFsRW5kICsgMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IHBhcnRpYWxFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgUGFyc2VyLmdldEhlYWRlciA9IGdldEhlYWRlcjtcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihtZXNzYWdlLCBkYXRhLCBoZWFkZXJTdGFydCwgaGVhZGVyRW5kKSB7XG4gICAgICAgIHZhciBoY29sb25JbmRleCA9IGRhdGEuaW5kZXhPZihcIjpcIiwgaGVhZGVyU3RhcnQpO1xuICAgICAgICB2YXIgaGVhZGVyTmFtZSA9IGRhdGEuc3Vic3RyaW5nKGhlYWRlclN0YXJ0LCBoY29sb25JbmRleCkudHJpbSgpO1xuICAgICAgICB2YXIgaGVhZGVyVmFsdWUgPSBkYXRhLnN1YnN0cmluZyhoY29sb25JbmRleCArIDEsIGhlYWRlckVuZCkudHJpbSgpO1xuICAgICAgICB2YXIgcGFyc2VkO1xuICAgICAgICAvLyBJZiBoZWFkZXItZmllbGQgaXMgd2VsbC1rbm93biwgcGFyc2UgaXQuXG4gICAgICAgIHN3aXRjaCAoaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidmlhXCI6XG4gICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKFwidmlhXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5nZXRIZWFkZXJzKFwidmlhXCIpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiVmlhXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZpYSA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmlhQnJhbmNoID0gcGFyc2VkLmJyYW5jaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZnJvbVwiOlxuICAgICAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImZyb21cIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJmcm9tXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZyb21UYWcgPSBwYXJzZWQuZ2V0UGFyYW0oXCJ0YWdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwidG9cIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJ0b1wiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG8gPSBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9UYWcgPSBwYXJzZWQuZ2V0UGFyYW0oXCJ0YWdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlY29yZC1yb3V0ZVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlZCA9IGdyYW1tYXJfMS5HcmFtbWFyLnBhcnNlKGhlYWRlclZhbHVlLCBcIlJlY29yZF9Sb3V0ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShwYXJzZWQgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcihcInJlY29yZC1yb3V0ZVwiLCBoZWFkZXJWYWx1ZS5zdWJzdHJpbmcoaGVhZGVyLnBvc2l0aW9uLCBoZWFkZXIub2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyc1tcIlJlY29yZC1Sb3V0ZVwiXVttZXNzYWdlLmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIikubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsLWlkXCI6XG4gICAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiY2FsbC1pZFwiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcImNhbGwtaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbGxJZCA9IGhlYWRlclZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb250YWN0XCI6XG4gICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlZCA9IGdyYW1tYXJfMS5HcmFtbWFyLnBhcnNlKGhlYWRlclZhbHVlLCBcIkNvbnRhY3RcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEocGFyc2VkIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRIZWFkZXIoXCJjb250YWN0XCIsIGhlYWRlclZhbHVlLnN1YnN0cmluZyhoZWFkZXIucG9zaXRpb24sIGhlYWRlci5vZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJzLkNvbnRhY3RbbWVzc2FnZS5nZXRIZWFkZXJzKFwiY29udGFjdFwiKS5sZW5ndGggLSAxXS5wYXJzZWQgPSBoZWFkZXIucGFyc2VkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnQtbGVuZ3RoXCI6XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiY29udGVudC1sZW5ndGhcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50LXR5cGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY3NlcVwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiY3NlcVwiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcImNzZXFcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNzZXEgPSBwYXJzZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgaW5jb21pbmdfcmVzcG9uc2VfbWVzc2FnZV8xLkluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0aG9kID0gcGFyc2VkLm1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF4LWZvcndhcmRzXCI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJtYXgtZm9yd2FyZHNcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJtYXgtZm9yd2FyZHNcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwid3d3LWF1dGhlbnRpY2F0ZVwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwid3d3LWF1dGhlbnRpY2F0ZVwiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcInd3dy1hdXRoZW50aWNhdGVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHJveHktYXV0aGVudGljYXRlXCI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJwcm94eS1hdXRoZW50aWNhdGVcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJwcm94eS1hdXRoZW50aWNhdGVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVmZXItdG9cIjpcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJyZWZlci10b1wiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcInJlZmVyLXRvXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWZlclRvID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHBhcnNlIHRoaXMgaGVhZGVyLlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBcImVycm9yIHBhcnNpbmcgaGVhZGVyICdcIiArIGhlYWRlck5hbWUgKyBcIidcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhcnNlci5wYXJzZUhlYWRlciA9IHBhcnNlSGVhZGVyO1xuICAgIGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShkYXRhLCBsb2dnZXIpIHtcbiAgICAgICAgdmFyIGhlYWRlclN0YXJ0ID0gMDtcbiAgICAgICAgdmFyIGhlYWRlckVuZCA9IGRhdGEuaW5kZXhPZihcIlxcclxcblwiKTtcbiAgICAgICAgaWYgKGhlYWRlckVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibm8gQ1JMRiBmb3VuZCwgbm90IGEgU0lQIG1lc3NhZ2UsIGRpc2NhcmRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBmaXJzdCBsaW5lLiBDaGVjayBpZiBpdCBpcyBhIFJlcXVlc3Qgb3IgYSBSZXBseS5cbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGRhdGEuc3Vic3RyaW5nKDAsIGhlYWRlckVuZCk7XG4gICAgICAgIHZhciBwYXJzZWQgPSBncmFtbWFyXzEuR3JhbW1hci5wYXJzZShmaXJzdExpbmUsIFwiUmVxdWVzdF9SZXNwb25zZVwiKTtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZXJyb3IgcGFyc2luZyBmaXJzdCBsaW5lIG9mIFNJUCBtZXNzYWdlOiBcIicgKyBmaXJzdExpbmUgKyAnXCInKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcGFyc2VkLnN0YXR1c19jb2RlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IGluY29taW5nX3JlcXVlc3RfbWVzc2FnZV8xLkluY29taW5nUmVxdWVzdE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIG1lc3NhZ2UubWV0aG9kID0gcGFyc2VkLm1ldGhvZDtcbiAgICAgICAgICAgIG1lc3NhZ2UucnVyaSA9IHBhcnNlZC51cmk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IGluY29taW5nX3Jlc3BvbnNlX21lc3NhZ2VfMS5JbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSgpO1xuICAgICAgICAgICAgbWVzc2FnZS5zdGF0dXNDb2RlID0gcGFyc2VkLnN0YXR1c19jb2RlO1xuICAgICAgICAgICAgbWVzc2FnZS5yZWFzb25QaHJhc2UgPSBwYXJzZWQucmVhc29uX3BocmFzZTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmRhdGEgPSBkYXRhO1xuICAgICAgICBoZWFkZXJTdGFydCA9IGhlYWRlckVuZCArIDI7XG4gICAgICAgIC8vIExvb3Agb3ZlciBldmVyeSBsaW5lIGluIGRhdGEuIERldGVjdCB0aGUgZW5kIG9mIGVhY2ggaGVhZGVyIGFuZCBwYXJzZVxuICAgICAgICAvLyBpdCBvciBzaW1wbHkgYWRkIHRvIHRoZSBoZWFkZXJzIGNvbGxlY3Rpb24uXG4gICAgICAgIHZhciBib2R5U3RhcnQ7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBoZWFkZXJFbmQgPSBnZXRIZWFkZXIoZGF0YSwgaGVhZGVyU3RhcnQpO1xuICAgICAgICAgICAgLy8gVGhlIFNJUCBtZXNzYWdlIGhhcyBub3JtYWxseSBmaW5pc2hlZC5cbiAgICAgICAgICAgIGlmIChoZWFkZXJFbmQgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgYm9keVN0YXJ0ID0gaGVhZGVyU3RhcnQgKyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyRW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGRhdGEuaW5kZXhPZiByZXR1cm5lZCAtMSBkdWUgdG8gYSBtYWxmb3JtZWQgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJtYWxmb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyc2VkSGVhZGVyID0gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSGVhZGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHBhcnNlZC5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVyU3RhcnQgPSBoZWFkZXJFbmQgKyAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJGQzMyNjEgMTguMy5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgYnl0ZXMgaW4gdGhlIHRyYW5zcG9ydCBwYWNrZXRcbiAgICAgICAgLy8gYmV5b25kIHRoZSBlbmQgb2YgdGhlIGJvZHksIHRoZXkgTVVTVCBiZSBkaXNjYXJkZWQuXG4gICAgICAgIGlmIChtZXNzYWdlLmhhc0hlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cihib2R5U3RhcnQsIE51bWJlcihtZXNzYWdlLmdldEhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cmluZyhib2R5U3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBQYXJzZXIucGFyc2VNZXNzYWdlID0gcGFyc2VNZXNzYWdlO1xufSkoUGFyc2VyID0gZXhwb3J0cy5QYXJzZXIgfHwgKGV4cG9ydHMuUGFyc2VyID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgcGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vcGFyYW1ldGVyc1wiKTtcbi8qKlxuICogVVJJLlxuICogQHB1YmxpY1xuICovXG52YXIgVVJJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFVSSSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBzY2hlbWUgLVxuICAgICAqIEBwYXJhbSB1c2VyIC1cbiAgICAgKiBAcGFyYW0gaG9zdCAtXG4gICAgICogQHBhcmFtIHBvcnQgLVxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC1cbiAgICAgKiBAcGFyYW0gaGVhZGVycyAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gVVJJKHNjaGVtZSwgdXNlciwgaG9zdCwgcG9ydCwgcGFyYW1ldGVycywgaGVhZGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIC8vIENoZWNrc1xuICAgICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBcImhvc3RcIiBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIHBhcmFtZXRlcnNcbiAgICAgICAgc2NoZW1lID0gc2NoZW1lIHx8IFwic2lwXCI7XG4gICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSYXcgVVJJXG4gICAgICAgIF90aGlzLnJhdyA9IHtcbiAgICAgICAgICAgIHNjaGVtZTogc2NoZW1lLFxuICAgICAgICAgICAgdXNlcjogdXNlcixcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICBwb3J0OiBwb3J0XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vcm1hbGl6ZWQgVVJJXG4gICAgICAgIF90aGlzLm5vcm1hbCA9IHtcbiAgICAgICAgICAgIHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICAgICAgaG9zdDogaG9zdC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgcG9ydDogcG9ydFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkkucHJvdG90eXBlLCBcInNjaGVtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub3JtYWwuc2NoZW1lOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yYXcuc2NoZW1lID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbC5zY2hlbWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVVJJLnByb3RvdHlwZSwgXCJ1c2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vcm1hbC51c2VyOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwudXNlciA9IHRoaXMucmF3LnVzZXIgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSSS5wcm90b3R5cGUsIFwiaG9zdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub3JtYWwuaG9zdDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmF3Lmhvc3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLmhvc3QgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVVJJLnByb3RvdHlwZSwgXCJhb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsLnVzZXIgKyBcIkBcIiArIHRoaXMubm9ybWFsLmhvc3Q7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkkucHJvdG90eXBlLCBcInBvcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsLnBvcnQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbC5wb3J0ID0gdGhpcy5yYXcucG9ydCA9IHZhbHVlID09PSAwID8gdmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVVJJLnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzW3RoaXMuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9O1xuICAgIFVSSS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNbdGhpcy5oZWFkZXJpemUobmFtZSldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLmhhc0hlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIW5hbWUgJiYgISF0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkodGhpcy5oZWFkZXJpemUobmFtZSkpO1xuICAgIH07XG4gICAgVVJJLnByb3RvdHlwZS5kZWxldGVIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyaXplKGhlYWRlcik7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5oZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5oZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVSSS5wcm90b3R5cGUuY2xlYXJIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICB9O1xuICAgIFVSSS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJJKHRoaXMuX3Jhdy5zY2hlbWUsIHRoaXMuX3Jhdy51c2VyIHx8IFwiXCIsIHRoaXMuX3Jhdy5ob3N0LCB0aGlzLl9yYXcucG9ydCwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpKSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcnMpKSk7XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLnRvUmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fcmF3KTtcbiAgICB9O1xuICAgIFVSSS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLl9ub3JtYWwpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSSS5wcm90b3R5cGUsIFwiX25vcm1hbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub3JtYWw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkkucHJvdG90eXBlLCBcIl9yYXdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmF3OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBVUkkucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgdmFyIHVyaVN0cmluZyA9IHVyaS5zY2hlbWUgKyBcIjpcIjtcbiAgICAgICAgLy8gYWRkIHNsYXNoZXMgaWYgaXQncyBub3QgYSBzaXAocykgVVJJXG4gICAgICAgIGlmICghdXJpLnNjaGVtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKFwiXnNpcHM/JFwiKSkge1xuICAgICAgICAgICAgdXJpU3RyaW5nICs9IFwiLy9cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJpLnVzZXIpIHtcbiAgICAgICAgICAgIHVyaVN0cmluZyArPSB0aGlzLmVzY2FwZVVzZXIodXJpLnVzZXIpICsgXCJAXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXJpU3RyaW5nICs9IHVyaS5ob3N0O1xuICAgICAgICBpZiAodXJpLnBvcnQgfHwgdXJpLnBvcnQgPT09IDApIHtcbiAgICAgICAgICAgIHVyaVN0cmluZyArPSBcIjpcIiArIHVyaS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHVyaVN0cmluZyArPSBcIjtcIiArIHBhcmFtZXRlcjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJpU3RyaW5nICs9IFwiPVwiICsgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGhlYWRlciBpbiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCBpbiB0aGlzLmhlYWRlcnNbaGVhZGVyXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJzW2hlYWRlcl0uaGFzT3duUHJvcGVydHkoaWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKGhlYWRlciArIFwiPVwiICsgdGhpcy5oZWFkZXJzW2hlYWRlcl1baWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXJpU3RyaW5nICs9IFwiP1wiICsgaGVhZGVycy5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpU3RyaW5nO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBIZXgtZXNjYXBlIGEgU0lQIFVSSSB1c2VyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAgICAgKi9cbiAgICBVUkkucHJvdG90eXBlLmVzY2FwZVVzZXIgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB2YXIgZGVjb2RlZFVzZXI7XG4gICAgICAgIC8vIEZJWE1FOiBUaGlzIGlzIGNhbGxlZCBieSB0b1N0cmluZyBhYm92ZSB3aGljaCBzaG91bGQgbmV2ZXIgdGhyb3csIGJ1dFxuICAgICAgICAvLyBkZWNvZGVVUklDb21wb25lbnQgY2FuIHRocm93IGFuZCBJJ3ZlIHNlZW4gb25lIGNhc2UgaW4gcHJvZHVjdGlvbiB3aGVyZVxuICAgICAgICAvLyBpdCBkaWQgdGhyb3cgcmVzdWx0aW5nIGluIGEgY2FzY2FkaW5nIGZhaWx1cmUuIFRoaXMgY2xhc3Mgc2hvdWxkIGJlXG4gICAgICAgIC8vIGZpeGVkIHNvIHRoYXQgZGVjb2RlVVJJQ29tcG9uZW50IGlzIG5vdCBjYWxsZWQgYXQgdGhpcyBwb2ludCAoaW4gdG9TdHJpbmcpLlxuICAgICAgICAvLyBUaGUgdXNlciBzaG91bGQgYmUgZGVjb2RlZCB3aGVuIHRoZSBVUkkgaXMgY29uc3RydWN0b3Igb3Igc29tZSBvdGhlclxuICAgICAgICAvLyBwbGFjZSB3aGVyZSB3ZSBjYW4gY2F0Y2ggdGhlIGVycm9yIGJlZm9yZSB0aGUgVVJJIGlzIGNyZWF0ZWQgb3Igc29tZXN1Y2guXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVkVXNlciA9IGRlY29kZVVSSUNvbXBvbmVudCh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGhleC1lc2NhcGUgJzonICglM0EpLCAnKycgKCUyQiksICc/JyAoJTNGXCIpLCAnLycgKCUyRikuXG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlZFVzZXIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNBL2lnLCBcIjpcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lMkIvaWcsIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUzRi9pZywgXCI/XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTJGL2lnLCBcIi9cIik7XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLmhlYWRlcml6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIGV4Y2VwdGlvbnMgPSB7XG4gICAgICAgICAgICBcIkNhbGwtSWRcIjogXCJDYWxsLUlEXCIsXG4gICAgICAgICAgICBcIkNzZXFcIjogXCJDU2VxXCIsXG4gICAgICAgICAgICBcIk1pbi1TZVwiOiBcIk1pbi1TRVwiLFxuICAgICAgICAgICAgXCJSYWNrXCI6IFwiUkFja1wiLFxuICAgICAgICAgICAgXCJSc2VxXCI6IFwiUlNlcVwiLFxuICAgICAgICAgICAgXCJXd3ctQXV0aGVudGljYXRlXCI6IFwiV1dXLUF1dGhlbnRpY2F0ZVwiLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmFtZSA9IHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18vZywgXCItXCIpLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgdmFyIHBhcnRzID0gbmFtZS5sZW5ndGg7XG4gICAgICAgIHZhciBobmFtZSA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIHBhcnQgPSAwOyBwYXJ0IDwgcGFydHM7IHBhcnQrKykge1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBobmFtZSArPSBcIi1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhuYW1lICs9IG5hbWVbcGFydF0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lW3BhcnRdLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZXB0aW9uc1tobmFtZV0pIHtcbiAgICAgICAgICAgIGhuYW1lID0gZXhjZXB0aW9uc1tobmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhuYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFVSSTtcbn0ocGFyYW1ldGVyc18xLlBhcmFtZXRlcnMpKTtcbmV4cG9ydHMuVVJJID0gVVJJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBwYXJhbSBzaXplIC1cbiAqIEBwYXJhbSBiYXNlIC1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVSYW5kb21Ub2tlbihzaXplLCBiYXNlKSB7XG4gICAgaWYgKGJhc2UgPT09IHZvaWQgMCkgeyBiYXNlID0gMzI7IH1cbiAgICB2YXIgdG9rZW4gPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciByID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmFzZSk7XG4gICAgICAgIHRva2VuICs9IHIudG9TdHJpbmcoYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbn1cbmV4cG9ydHMuY3JlYXRlUmFuZG9tVG9rZW4gPSBjcmVhdGVSYW5kb21Ub2tlbjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYXNvblBocmFzZShjb2RlKSB7XG4gICAgcmV0dXJuIFJFQVNPTl9QSFJBU0VbY29kZV0gfHwgXCJcIjtcbn1cbmV4cG9ydHMuZ2V0UmVhc29uUGhyYXNlID0gZ2V0UmVhc29uUGhyYXNlO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbmV3VGFnKCkge1xuICAgIHJldHVybiBjcmVhdGVSYW5kb21Ub2tlbigxMCk7XG59XG5leHBvcnRzLm5ld1RhZyA9IG5ld1RhZztcbi8qKlxuICogQHBhcmFtIHN0ciAtXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGVhZGVyaXplKHN0cikge1xuICAgIHZhciBleGNlcHRpb25zID0ge1xuICAgICAgICBcIkNhbGwtSWRcIjogXCJDYWxsLUlEXCIsXG4gICAgICAgIFwiQ3NlcVwiOiBcIkNTZXFcIixcbiAgICAgICAgXCJNaW4tU2VcIjogXCJNaW4tU0VcIixcbiAgICAgICAgXCJSYWNrXCI6IFwiUkFja1wiLFxuICAgICAgICBcIlJzZXFcIjogXCJSU2VxXCIsXG4gICAgICAgIFwiV3d3LUF1dGhlbnRpY2F0ZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICB9O1xuICAgIHZhciBuYW1lID0gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCBcIi1cIikuc3BsaXQoXCItXCIpO1xuICAgIHZhciBwYXJ0cyA9IG5hbWUubGVuZ3RoO1xuICAgIHZhciBobmFtZSA9IFwiXCI7XG4gICAgZm9yICh2YXIgcGFydCA9IDA7IHBhcnQgPCBwYXJ0czsgcGFydCsrKSB7XG4gICAgICAgIGlmIChwYXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICBobmFtZSArPSBcIi1cIjtcbiAgICAgICAgfVxuICAgICAgICBobmFtZSArPSBuYW1lW3BhcnRdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZVtwYXJ0XS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChleGNlcHRpb25zW2huYW1lXSkge1xuICAgICAgICBobmFtZSA9IGV4Y2VwdGlvbnNbaG5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaG5hbWU7XG59XG5leHBvcnRzLmhlYWRlcml6ZSA9IGhlYWRlcml6ZTtcbi8qKlxuICogQHBhcmFtIHN0ciAtXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc3RyX3V0ZjhfbGVuZ3RoKHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8lW0EtRlxcZF17Mn0vZywgXCJVXCIpLmxlbmd0aDtcbn1cbmV4cG9ydHMuc3RyX3V0ZjhfbGVuZ3RoID0gc3RyX3V0ZjhfbGVuZ3RoO1xuLyoqXG4gKiBTSVAgUmVzcG9uc2UgUmVhc29uc1xuICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJFQVNPTl9QSFJBU0UgPSB7XG4gICAgMTAwOiBcIlRyeWluZ1wiLFxuICAgIDE4MDogXCJSaW5naW5nXCIsXG4gICAgMTgxOiBcIkNhbGwgSXMgQmVpbmcgRm9yd2FyZGVkXCIsXG4gICAgMTgyOiBcIlF1ZXVlZFwiLFxuICAgIDE4MzogXCJTZXNzaW9uIFByb2dyZXNzXCIsXG4gICAgMTk5OiBcIkVhcmx5IERpYWxvZyBUZXJtaW5hdGVkXCIsXG4gICAgMjAwOiBcIk9LXCIsXG4gICAgMjAyOiBcIkFjY2VwdGVkXCIsXG4gICAgMjA0OiBcIk5vIE5vdGlmaWNhdGlvblwiLFxuICAgIDMwMDogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gICAgMzAxOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gICAgMzAyOiBcIk1vdmVkIFRlbXBvcmFyaWx5XCIsXG4gICAgMzA1OiBcIlVzZSBQcm94eVwiLFxuICAgIDM4MDogXCJBbHRlcm5hdGl2ZSBTZXJ2aWNlXCIsXG4gICAgNDAwOiBcIkJhZCBSZXF1ZXN0XCIsXG4gICAgNDAxOiBcIlVuYXV0aG9yaXplZFwiLFxuICAgIDQwMjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gICAgNDAzOiBcIkZvcmJpZGRlblwiLFxuICAgIDQwNDogXCJOb3QgRm91bmRcIixcbiAgICA0MDU6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gICAgNDA2OiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gICAgNDA3OiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gICAgNDA4OiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICAgIDQxMDogXCJHb25lXCIsXG4gICAgNDEyOiBcIkNvbmRpdGlvbmFsIFJlcXVlc3QgRmFpbGVkXCIsXG4gICAgNDEzOiBcIlJlcXVlc3QgRW50aXR5IFRvbyBMYXJnZVwiLFxuICAgIDQxNDogXCJSZXF1ZXN0LVVSSSBUb28gTG9uZ1wiLFxuICAgIDQxNTogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gICAgNDE2OiBcIlVuc3VwcG9ydGVkIFVSSSBTY2hlbWVcIixcbiAgICA0MTc6IFwiVW5rbm93biBSZXNvdXJjZS1Qcmlvcml0eVwiLFxuICAgIDQyMDogXCJCYWQgRXh0ZW5zaW9uXCIsXG4gICAgNDIxOiBcIkV4dGVuc2lvbiBSZXF1aXJlZFwiLFxuICAgIDQyMjogXCJTZXNzaW9uIEludGVydmFsIFRvbyBTbWFsbFwiLFxuICAgIDQyMzogXCJJbnRlcnZhbCBUb28gQnJpZWZcIixcbiAgICA0Mjg6IFwiVXNlIElkZW50aXR5IEhlYWRlclwiLFxuICAgIDQyOTogXCJQcm92aWRlIFJlZmVycmVyIElkZW50aXR5XCIsXG4gICAgNDMwOiBcIkZsb3cgRmFpbGVkXCIsXG4gICAgNDMzOiBcIkFub255bWl0eSBEaXNhbGxvd2VkXCIsXG4gICAgNDM2OiBcIkJhZCBJZGVudGl0eS1JbmZvXCIsXG4gICAgNDM3OiBcIlVuc3VwcG9ydGVkIENlcnRpZmljYXRlXCIsXG4gICAgNDM4OiBcIkludmFsaWQgSWRlbnRpdHkgSGVhZGVyXCIsXG4gICAgNDM5OiBcIkZpcnN0IEhvcCBMYWNrcyBPdXRib3VuZCBTdXBwb3J0XCIsXG4gICAgNDQwOiBcIk1heC1CcmVhZHRoIEV4Y2VlZGVkXCIsXG4gICAgNDY5OiBcIkJhZCBJbmZvIFBhY2thZ2VcIixcbiAgICA0NzA6IFwiQ29uc2VudCBOZWVkZWRcIixcbiAgICA0Nzg6IFwiVW5yZXNvbHZhYmxlIERlc3RpbmF0aW9uXCIsXG4gICAgNDgwOiBcIlRlbXBvcmFyaWx5IFVuYXZhaWxhYmxlXCIsXG4gICAgNDgxOiBcIkNhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3RcIixcbiAgICA0ODI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICAgIDQ4MzogXCJUb28gTWFueSBIb3BzXCIsXG4gICAgNDg0OiBcIkFkZHJlc3MgSW5jb21wbGV0ZVwiLFxuICAgIDQ4NTogXCJBbWJpZ3VvdXNcIixcbiAgICA0ODY6IFwiQnVzeSBIZXJlXCIsXG4gICAgNDg3OiBcIlJlcXVlc3QgVGVybWluYXRlZFwiLFxuICAgIDQ4ODogXCJOb3QgQWNjZXB0YWJsZSBIZXJlXCIsXG4gICAgNDg5OiBcIkJhZCBFdmVudFwiLFxuICAgIDQ5MTogXCJSZXF1ZXN0IFBlbmRpbmdcIixcbiAgICA0OTM6IFwiVW5kZWNpcGhlcmFibGVcIixcbiAgICA0OTQ6IFwiU2VjdXJpdHkgQWdyZWVtZW50IFJlcXVpcmVkXCIsXG4gICAgNTAwOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgIDUwMTogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgICA1MDI6IFwiQmFkIEdhdGV3YXlcIixcbiAgICA1MDM6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICAgIDUwNDogXCJTZXJ2ZXIgVGltZS1vdXRcIixcbiAgICA1MDU6IFwiVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gICAgNTEzOiBcIk1lc3NhZ2UgVG9vIExhcmdlXCIsXG4gICAgNTgwOiBcIlByZWNvbmRpdGlvbiBGYWlsdXJlXCIsXG4gICAgNjAwOiBcIkJ1c3kgRXZlcnl3aGVyZVwiLFxuICAgIDYwMzogXCJEZWNsaW5lXCIsXG4gICAgNjA0OiBcIkRvZXMgTm90IEV4aXN0IEFueXdoZXJlXCIsXG4gICAgNjA2OiBcIk5vdCBBY2NlcHRhYmxlXCJcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2Vzc2lvblwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogU2Vzc2lvbiBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzXG4gKiBAcHVibGljXG4gKi9cbnZhciBTZXNzaW9uU3RhdGU7XG4oZnVuY3Rpb24gKFNlc3Npb25TdGF0ZSkge1xuICAgIFNlc3Npb25TdGF0ZVtcIkluaXRpYWxcIl0gPSBcIkluaXRpYWxcIjtcbiAgICBTZXNzaW9uU3RhdGVbXCJFYXJseVwiXSA9IFwiRWFybHlcIjtcbiAgICBTZXNzaW9uU3RhdGVbXCJBY2tXYWl0XCJdID0gXCJBY2tXYWl0XCI7XG4gICAgU2Vzc2lvblN0YXRlW1wiQ29uZmlybWVkXCJdID0gXCJDb25maXJtZWRcIjtcbiAgICBTZXNzaW9uU3RhdGVbXCJUZXJtaW5hdGVkXCJdID0gXCJUZXJtaW5hdGVkXCI7XG59KShTZXNzaW9uU3RhdGUgPSBleHBvcnRzLlNlc3Npb25TdGF0ZSB8fCAoZXhwb3J0cy5TZXNzaW9uU3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBPZmZlci9BbnN3ZXIgc3RhdGUuXG4gKiBAcmVtYXJrc1xuICogYGBgdHh0XG4gKiAgICAgICAgIE9mZmVyICAgICAgICAgICAgICAgIEFuc3dlciAgICAgICAgICAgICBSRkMgICAgSW5pIEVzdCBFYXJseVxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICAxLiBJTlZJVEUgUmVxLiAgICAgICAgICAyeHggSU5WSVRFIFJlc3AuICAgICBSRkMgMzI2MSAgWSAgIFkgICAgTlxuICogIDIuIDJ4eCBJTlZJVEUgUmVzcC4gICAgIEFDSyBSZXEuICAgICAgICAgICAgIFJGQyAzMjYxICBZICAgWSAgICBOXG4gKiAgMy4gSU5WSVRFIFJlcS4gICAgICAgICAgMXh4LXJlbCBJTlZJVEUgUmVzcC4gUkZDIDMyNjIgIFkgICBZICAgIE5cbiAqICA0LiAxeHgtcmVsIElOVklURSBSZXNwLiBQUkFDSyBSZXEuICAgICAgICAgICBSRkMgMzI2MiAgWSAgIFkgICAgTlxuICogIDUuIFBSQUNLIFJlcS4gICAgICAgICAgIDIwMCBQUkFDSyBSZXNwLiAgICAgIFJGQyAzMjYyICBOICAgWSAgICBZXG4gKiAgNi4gVVBEQVRFIFJlcS4gICAgICAgICAgMnh4IFVQREFURSBSZXNwLiAgICAgUkZDIDMzMTEgIE4gICBZICAgIFlcbiAqXG4gKiAgICAgICBUYWJsZSAxOiBTdW1tYXJ5IG9mIFNJUCBVc2FnZSBvZiB0aGUgT2ZmZXIvQW5zd2VyIE1vZGVsXG4gKiBgYGBcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MzM3I3NlY3Rpb24tMi4yXG4gKiBAcHVibGljXG4gKi9cbnZhciBTaWduYWxpbmdTdGF0ZTtcbihmdW5jdGlvbiAoU2lnbmFsaW5nU3RhdGUpIHtcbiAgICBTaWduYWxpbmdTdGF0ZVtcIkluaXRpYWxcIl0gPSBcIkluaXRpYWxcIjtcbiAgICBTaWduYWxpbmdTdGF0ZVtcIkhhdmVMb2NhbE9mZmVyXCJdID0gXCJIYXZlTG9jYWxPZmZlclwiO1xuICAgIFNpZ25hbGluZ1N0YXRlW1wiSGF2ZVJlbW90ZU9mZmVyXCJdID0gXCJIYXZlUmVtb3RlT2ZmZXJcIjtcbiAgICBTaWduYWxpbmdTdGF0ZVtcIlN0YWJsZVwiXSA9IFwiU3RhYmxlXCI7XG4gICAgU2lnbmFsaW5nU3RhdGVbXCJDbG9zZWRcIl0gPSBcIkNsb3NlZFwiO1xufSkoU2lnbmFsaW5nU3RhdGUgPSBleHBvcnRzLlNpZ25hbGluZ1N0YXRlIHx8IChleHBvcnRzLlNpZ25hbGluZ1N0YXRlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25cIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yXG4gKiBAcHVibGljXG4gKi9cbnZhciBTdWJzY3JpcHRpb25TdGF0ZTtcbihmdW5jdGlvbiAoU3Vic2NyaXB0aW9uU3RhdGUpIHtcbiAgICBTdWJzY3JpcHRpb25TdGF0ZVtcIkluaXRpYWxcIl0gPSBcIkluaXRpYWxcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0ZVtcIk5vdGlmeVdhaXRcIl0gPSBcIk5vdGlmeVdhaXRcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0ZVtcIlBlbmRpbmdcIl0gPSBcIlBlbmRpbmdcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0ZVtcIkFjdGl2ZVwiXSA9IFwiQWN0aXZlXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdGVbXCJUZXJtaW5hdGVkXCJdID0gXCJUZXJtaW5hdGVkXCI7XG59KShTdWJzY3JpcHRpb25TdGF0ZSA9IGV4cG9ydHMuU3Vic2NyaXB0aW9uU3RhdGUgfHwgKGV4cG9ydHMuU3Vic2NyaXB0aW9uU3RhdGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVDEgPSA1MDA7XG52YXIgVDIgPSA0MDAwO1xudmFyIFQ0ID0gNTAwMDtcbi8qKlxuICogVGltZXJzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLlRpbWVycyA9IHtcbiAgICBUMTogVDEsXG4gICAgVDI6IFQyLFxuICAgIFQ0OiBUNCxcbiAgICBUSU1FUl9COiA2NCAqIFQxLFxuICAgIFRJTUVSX0Q6IDAgKiBUMSxcbiAgICBUSU1FUl9GOiA2NCAqIFQxLFxuICAgIFRJTUVSX0g6IDY0ICogVDEsXG4gICAgVElNRVJfSTogMCAqIFQ0LFxuICAgIFRJTUVSX0o6IDAgKiBUMSxcbiAgICBUSU1FUl9LOiAwICogVDQsXG4gICAgVElNRVJfTDogNjQgKiBUMSxcbiAgICBUSU1FUl9NOiA2NCAqIFQxLFxuICAgIFRJTUVSX046IDY0ICogVDEsXG4gICAgUFJPVklTSU9OQUxfUkVTUE9OU0VfSU5URVJWQUw6IDYwMDAwIC8vIFNlZSBSRkMgMzI2MSBTZWN0aW9uIDEzLjMuMS4xXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG4vKipcbiAqIENsaWVudCBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIHByb3ZpZGVzIGl0cyBmdW5jdGlvbmFsaXR5IHRocm91Z2ggdGhlXG4gKiBtYWludGVuYW5jZSBvZiBhIHN0YXRlIG1hY2hpbmUuXG4gKlxuICogVGhlIFRVIGNvbW11bmljYXRlcyB3aXRoIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gdGhyb3VnaCBhIHNpbXBsZVxuICogaW50ZXJmYWNlLiAgV2hlbiB0aGUgVFUgd2lzaGVzIHRvIGluaXRpYXRlIGEgbmV3IHRyYW5zYWN0aW9uLCBpdFxuICogY3JlYXRlcyBhIGNsaWVudCB0cmFuc2FjdGlvbiBhbmQgcGFzc2VzIGl0IHRoZSBTSVAgcmVxdWVzdCB0byBzZW5kXG4gKiBhbmQgYW4gSVAgYWRkcmVzcywgcG9ydCwgYW5kIHRyYW5zcG9ydCB0byB3aGljaCB0byBzZW5kIGl0LiAgVGhlXG4gKiBjbGllbnQgdHJhbnNhY3Rpb24gYmVnaW5zIGV4ZWN1dGlvbiBvZiBpdHMgc3RhdGUgbWFjaGluZS4gIFZhbGlkXG4gKiByZXNwb25zZXMgYXJlIHBhc3NlZCB1cCB0byB0aGUgVFUgZnJvbSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xXG4gKiBAcHVibGljXG4gKi9cbnZhciBDbGllbnRUcmFuc2FjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDbGllbnRUcmFuc2FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbGllbnRUcmFuc2FjdGlvbihfcmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyLCBzdGF0ZSwgbG9nZ2VyQ2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNwb3J0LCB1c2VyLCBDbGllbnRUcmFuc2FjdGlvbi5tYWtlSWQoX3JlcXVlc3QpLCBzdGF0ZSwgbG9nZ2VyQ2F0ZWdvcnkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9yZXF1ZXN0ID0gX3JlcXVlc3Q7XG4gICAgICAgIF90aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICAvLyBUaGUgVmlhIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHRyYW5zcG9ydCB1c2VkIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gYW5kIGlkZW50aWZpZXMgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSByZXNwb25zZSBpcyB0byBiZSBzZW50LiAgQSBWaWFcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIHZhbHVlIGlzIGFkZGVkIG9ubHkgYWZ0ZXIgdGhlIHRyYW5zcG9ydCB0aGF0IHdpbGwgYmVcbiAgICAgICAgLy8gdXNlZCB0byByZWFjaCB0aGUgbmV4dCBob3AgaGFzIGJlZW4gc2VsZWN0ZWQgKHdoaWNoIG1heSBpbnZvbHZlIHRoZVxuICAgICAgICAvLyB1c2FnZSBvZiB0aGUgcHJvY2VkdXJlcyBpbiBbNF0pLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4xLjdcbiAgICAgICAgX3JlcXVlc3Quc2V0VmlhSGVhZGVyKF90aGlzLmlkLCB0cmFuc3BvcnQucHJvdG9jb2wpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENsaWVudFRyYW5zYWN0aW9uLm1ha2VJZCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJDQU5DRUxcIikge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LmJyYW5jaCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dGdvaW5nIENBTkNFTCByZXF1ZXN0IHdpdGhvdXQgYSBicmFuY2guXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuYnJhbmNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiejloRzRiS1wiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAvKiogVGhlIG91dGdvaW5nIHJlcXVlc3QgdGhlIHRyYW5zYWN0aW9uIGhhbmRsaW5nLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBIDQwOCB0byBub24tSU5WSVRFIHdpbGwgYWx3YXlzIGFycml2ZSB0b28gbGF0ZSB0byBiZSB1c2VmdWwgKFszXSksXG4gICAgICogVGhlIGNsaWVudCBhbHJlYWR5IGhhcyBmdWxsIGtub3dsZWRnZSBvZiB0aGUgdGltZW91dC4gVGhlIG9ubHlcbiAgICAgKiBpbmZvcm1hdGlvbiB0aGlzIG1lc3NhZ2Ugd291bGQgY29udmV5IGlzIHdoZXRoZXIgb3Igbm90IHRoZSBzZXJ2ZXJcbiAgICAgKiBiZWxpZXZlZCB0aGUgdHJhbnNhY3Rpb24gdGltZWQgb3V0LiBIb3dldmVyLCB3aXRoIHRoZSBjdXJyZW50IGRlc2lnblxuICAgICAqIG9mIHRoZSBOSVQsIGEgY2xpZW50IGNhbm5vdCBkbyBhbnl0aGluZyB3aXRoIHRoaXMga25vd2xlZGdlLiBUaHVzLFxuICAgICAqIHRoZSA0MDggaXMgc2ltcGx5IHdhc3RpbmcgbmV0d29yayByZXNvdXJjZXMgYW5kIGNvbnRyaWJ1dGVzIHRvIHRoZVxuICAgICAqIHJlc3BvbnNlIGJvbWJhcmRtZW50IGlsbHVzdHJhdGVkIGluIFszXS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDMyMCNzZWN0aW9uLTQuMVxuICAgICAqL1xuICAgIENsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51c2VyLm9uUmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudXNlci5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDbGllbnRUcmFuc2FjdGlvbjtcbn0odHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpO1xuZXhwb3J0cy5DbGllbnRUcmFuc2FjdGlvbiA9IENsaWVudFRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NsaWVudC10cmFuc2FjdGlvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludml0ZS1zZXJ2ZXItdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm9uLWludml0ZS1jbGllbnQtdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm9uLWludml0ZS1zZXJ2ZXItdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW52aXRlLWNsaWVudC10cmFuc2FjdGlvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJ2ZXItdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24tc3RhdGVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0aW1lcnNfMSA9IHJlcXVpcmUoXCIuLi90aW1lcnNcIik7XG52YXIgY2xpZW50X3RyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtdHJhbnNhY3Rpb25cIik7XG52YXIgdHJhbnNhY3Rpb25fc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCIpO1xuLyoqXG4gKiBJTlZJVEUgQ2xpZW50IFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIFRoZSBJTlZJVEUgdHJhbnNhY3Rpb24gY29uc2lzdHMgb2YgYSB0aHJlZS13YXkgaGFuZHNoYWtlLiAgVGhlIGNsaWVudFxuICogdHJhbnNhY3Rpb24gc2VuZHMgYW4gSU5WSVRFLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIHNlbmRzIHJlc3BvbnNlcyxcbiAqIGFuZCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHNlbmRzIGFuIEFDSy5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBVcG9uIGNvbnN0cnVjdGlvbiwgdGhlIG91dGdvaW5nIHJlcXVlc3QncyBWaWEgaGVhZGVyIGlzIHVwZGF0ZWQgYnkgY2FsbGluZyBgc2V0VmlhSGVhZGVyYC5cbiAgICAgKiBUaGVuIGB0b1N0cmluZ2AgaXMgY2FsbGVkIG9uIHRoZSBvdXRnb2luZyByZXF1ZXN0IGFuZCB0aGUgbWVzc2FnZSBpcyBzZW50IHZpYSB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEFmdGVyIGNvbnN0cnVjdGlvbiB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBpbiB0aGUgXCJjYWxsaW5nXCIgc3RhdGUgYW5kIHRoZSB0cmFuc2FjdGlvbiBpZFxuICAgICAqIHdpbGwgZXF1YWwgdGhlIGJyYW5jaCBwYXJhbWV0ZXIgc2V0IGluIHRoZSBWaWEgaGVhZGVyIG9mIHRoZSBvdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgb3V0Z29pbmcgSU5WSVRFIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydCAtIFRoZSB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIHVzZXIgLSBUaGUgdHJhbnNhY3Rpb24gdXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbihyZXF1ZXN0LCB0cmFuc3BvcnQsIHVzZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyLCB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ2FsbGluZywgXCJzaXAudHJhbnNhY3Rpb24uaWN0XCIpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgMnh4IHRvLXRhZyB0byBBQ0suXG4gICAgICAgICAqIElmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQsIHZhbHVlIGlzIHRoZSBBQ0sgd2hpY2ggd2FzIHNlbnQuXG4gICAgICAgICAqIElmIGtleSBleGlzdHMgYnV0IHZhbHVlIGlzIHVuZGVmaW5lZCwgYSAyeHggd2FzIHJlY2VpdmVkIGJ1dCB0aGUgQUNLIG5vdCB5ZXQgc2VudC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCBhIDJ4eCB3YXMgbm90ICh5ZXQpIHJlY2VpdmVkIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYWNrUmV0cmFuc21pc3Npb25DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gRklYTUU6IFRpbWVyIEEgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0IG5vdCBpbXBsZW1lbnRlZFxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBhbiB1bnJlbGlhYmxlIHRyYW5zcG9ydCBpcyBiZWluZyB1c2VkLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIE1VU1Qgc3RhcnQgdGltZXIgQSB3aXRoIGEgdmFsdWUgb2YgVDEuIElmIGEgcmVsaWFibGUgdHJhbnNwb3J0IGlzIGJlaW5nIHVzZWQsXG4gICAgICAgIC8vIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIE5PVCBzdGFydCB0aW1lciBBIChUaW1lciBBIGNvbnRyb2xzIHJlcXVlc3QgcmV0cmFuc21pc3Npb25zKS5cbiAgICAgICAgLy8gRm9yIGFueSB0cmFuc3BvcnQsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBzdGFydCB0aW1lciBCIHdpdGggYSB2YWx1ZVxuICAgICAgICAvLyBvZiA2NCpUMSBzZWNvbmRzIChUaW1lciBCIGNvbnRyb2xzIHRyYW5zYWN0aW9uIHRpbWVvdXRzKS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAgICAvL1xuICAgICAgICAvLyBXaGlsZSBub3Qgc3BlbGxlZCBvdXQgaW4gdGhlIFJGQywgVGltZXIgQiBpcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0aGF0IGEgc2VuZGVyXG4gICAgICAgIC8vIHdpbGwgd2FpdCBmb3IgYW4gSU5WSVRFIG1lc3NhZ2UgdG8gYmUgYWNrbm93bGVkZ2VkIChhIFNJUCByZXNwb25zZSBtZXNzYWdlIGlzIHJlY2VpdmVkKS5cbiAgICAgICAgLy8gU28gVGltZXIgQiBzaG91bGQgYmUgY2xlYXJlZCB3aGVuIHRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBwcm9jZWVkcyBmcm9tIFwiQ2FsbGluZ1wiLlxuICAgICAgICBfdGhpcy5CID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aW1lcl9CKCk7IH0sIHRpbWVyc18xLlRpbWVycy5USU1FUl9CKTtcbiAgICAgICAgX3RoaXMuc2VuZChyZXF1ZXN0LnRvU3RyaW5nKCkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgaW5pdGlhbCBvdXRnb2luZyByZXF1ZXN0LlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuQikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gICAgICAgICAgICB0aGlzLkIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuRCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuRCk7XG4gICAgICAgICAgICB0aGlzLkQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuTSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuTSk7XG4gICAgICAgICAgICB0aGlzLk0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAvKiogVHJhbnNhY3Rpb24ga2luZC4gRGVwcmVjYXRlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpY3RcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQUNLIGEgMnh4IGZpbmFsIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIGluY2x1ZGVzIHRoZSBBQ0sgb25seSBpZiB0aGUgZmluYWwgcmVzcG9uc2Ugd2FzIG5vdCBhIDJ4eCByZXNwb25zZSAodGhlXG4gICAgICogdHJhbnNhY3Rpb24gd2lsbCBnZW5lcmF0ZSBhbmQgc2VuZCB0aGUgQUNLIHRvIHRoZSB0cmFuc3BvcnQgYXV0b21hZ2ljYWxseSkuIElmIHRoZVxuICAgICAqIGZpbmFsIHJlc3BvbnNlIHdhcyBhIDJ4eCwgdGhlIEFDSyBpcyBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbiAodGhlXG4gICAgICogdHJhbnNhY3Rpb24gdXNlciBuZWVkcyB0byBnZW5lcmF0ZSBhbmQgc2VuZCB0aGUgQUNLKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbGlicmFyeSBpcyBub3Qgc3RyaWN0bHkgUkZDIGNvbXBsaWFudCB3aXRoIHJlZ2FyZCB0byBBQ0sgaGFuZGxpbmcgZm9yIDJ4eCBmaW5hbFxuICAgICAqIHJlc3BvbnNlcy4gU3BlY2lmaWNhbGx5LCByZXRyYW5zbWlzc2lvbnMgb2YgQUNLcyB0byBhIDJ4eCBmaW5hbCByZXNwb25zZXMgaXMgaGFuZGxlZFxuICAgICAqIGJ5IHRoZSB0cmFuc2FjdGlvbiBsYXllciAoaW5zdGVhZCBvZiB0aGUgVUFDIGNvcmUpLiBUaGUgXCJzdGFuZGFyZFwiIGFwcHJvYWNoIGlzIGZvclxuICAgICAqIHRoZSBVQUMgY29yZSB0byByZWNlaXZlIGFsbCAyeHggcmVzcG9uc2VzIGFuZCBtYW5hZ2Ugc2VuZGluZyBBQ0sgcmV0cmFuc21pc3Npb25zIHRvXG4gICAgICogdGhlIHRyYW5zcG9ydCBkaXJlY3RseS4gSGVyZWluIHRoZSB0cmFuc2FjdGlvbiBsYXllciBtYW5hZ2VzIHNlbmRpbmcgQUNLcyB0byAyeHggcmVzcG9uc2VzXG4gICAgICogYW5kIGFueSByZXRyYW5zbWlzc2lvbnMgb2YgdGhvc2UgQUNLcyBhcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNrIC0gVGhlIG91dGdvaW5nIEFDSyByZXF1ZXN0LlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hY2tSZXNwb25zZSA9IGZ1bmN0aW9uIChhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRvVGFnID0gYWNrLnRvVGFnO1xuICAgICAgICBpZiAoIXRvVGFnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB0YWcgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBcIno5aEc0YktcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgICAgICAgYWNrLnNldFZpYUhlYWRlcihpZCwgdGhpcy50cmFuc3BvcnQucHJvdG9jb2wpO1xuICAgICAgICB0aGlzLmFja1JldHJhbnNtaXNzaW9uQ2FjaGUuc2V0KHRvVGFnLCBhY2spOyAvLyBBZGQgdG8gQUNLIHJldHJhbnNtaXNzaW9uIGNhY2hlXG4gICAgICAgIHRoaXMuc2VuZChhY2sudG9TdHJpbmcoKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBBQ0sgdG8gMnh4IHJlc3BvbnNlLlwiKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBpbmNvbWluZyByZXNwb25zZXMgZnJvbSB0aGUgdHJhbnNwb3J0IHdoaWNoIG1hdGNoIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIGluY29taW5nIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUgfHwgc3RhdHVzQ29kZSA8IDEwMCB8fCBzdGF0dXNDb2RlID4gNjk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXR1cyBjb2RlIFwiICsgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nOlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gcmVjZWl2ZXMgYSBwcm92aXNpb25hbCByZXNwb25zZSB3aGlsZSBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBcIkNhbGxpbmdcIiBzdGF0ZSwgaXQgdHJhbnNpdGlvbnMgdG8gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLiBJbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgTk9UIHJldHJhbnNtaXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBhbnkgbG9uZ2VyLiBGdXJ0aGVybW9yZSwgdGhlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIE1VU1QgYmVcbiAgICAgICAgICAgICAgICAvLyBwYXNzZWQgdG8gdGhlIFRVLiAgQW55IGZ1cnRoZXIgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIE1VU1QgYmUgcGFzc2VkXG4gICAgICAgICAgICAgICAgLy8gdXAgdG8gdGhlIFRVIHdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMS4yXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMTAwICYmIHN0YXR1c0NvZGUgPD0gMTk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIDJ4eCByZXNwb25zZSBpcyByZWNlaXZlZCB3aGlsZSBpbiBlaXRoZXIgdGhlIFwiQ2FsbGluZ1wiIG9yXG4gICAgICAgICAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGVzLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0b1xuICAgICAgICAgICAgICAgIC8vIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUuLi4gVGhlIDJ4eCByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB1cCB0byB0aGUgVFUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIE5PVCBnZW5lcmF0ZSBhbiBBQ0sgdG8gdGhlIDJ4eCByZXNwb25zZSAtLSBpdHNcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGluZyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIFRVLiBBIFVBQyBjb3JlIHdpbGwgc2VuZCBhbiBBQ0sgdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgMnh4IHJlc3BvbnNlIHVzaW5nIGEgbmV3IHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gMjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrUmV0cmFuc21pc3Npb25DYWNoZS5zZXQocmVzcG9uc2UudG9UYWcsIHVuZGVmaW5lZCk7IC8vIFByaW1lIHRoZSBBQ0sgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpbiBlaXRoZXIgdGhlIFwiQ2FsbGluZ1wiIG9yIFwiUHJvY2VlZGluZ1wiIHN0YXRlcywgcmVjZXB0aW9uIG9mXG4gICAgICAgICAgICAgICAgLy8gYSByZXNwb25zZSB3aXRoIHN0YXR1cyBjb2RlIGZyb20gMzAwLTY5OSBNVVNUIGNhdXNlIHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiB0byB0cmFuc2l0aW9uIHRvIFwiQ29tcGxldGVkXCIuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBNVVNUIHBhc3MgdGhlIHJlY2VpdmVkIHJlc3BvbnNlIHVwIHRvIHRoZSBUVSwgYW5kIHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBNVVNUIGdlbmVyYXRlIGFuIEFDSyByZXF1ZXN0LCBldmVuIGlmIHRoZSB0cmFuc3BvcnQgaXNcbiAgICAgICAgICAgICAgICAvLyByZWxpYWJsZSAoZ3VpZGVsaW5lcyBmb3IgY29uc3RydWN0aW5nIHRoZSBBQ0sgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBhcmUgZ2l2ZW4gaW4gU2VjdGlvbiAxNy4xLjEuMyksIGFuZCB0aGVuIHBhc3MgdGhlIEFDSyB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi4gVGhlIEFDSyBNVVNUIGJlIHNlbnQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBhZGRyZXNzLCBwb3J0LCBhbmQgdHJhbnNwb3J0IHRvIHdoaWNoIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdhcyBzZW50LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwICYmIHN0YXR1c0NvZGUgPD0gNjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIE5PVCByZXRyYW5zbWl0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgYW55IGxvbmdlci4gRnVydGhlcm1vcmUsIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSBNVVNUIGJlXG4gICAgICAgICAgICAgICAgLy8gcGFzc2VkIHRvIHRoZSBUVS4gIEFueSBmdXJ0aGVyIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBNVVNUIGJlIHBhc3NlZFxuICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoZSBUVSB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgMnh4IHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdoaWxlIGluIGVpdGhlciB0aGUgXCJDYWxsaW5nXCIgb3IgXCJQcm9jZWVkaW5nXCIgc3RhdGVzLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUuLi5cbiAgICAgICAgICAgICAgICAvLyBUaGUgMnh4IHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHVwIHRvIHRoZSBUVS4gVGhlIGNsaWVudFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIE1VU1QgTk9UIGdlbmVyYXRlIGFuIEFDSyB0byB0aGUgMnh4IHJlc3BvbnNlIC0tIGl0c1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsaW5nIGlzIGRlbGVnYXRlZCB0byB0aGUgVFUuIEEgVUFDIGNvcmUgd2lsbCBzZW5kIGFuIEFDSyB0b1xuICAgICAgICAgICAgICAgIC8vIHRoZSAyeHggcmVzcG9uc2UgdXNpbmcgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLnNldChyZXNwb25zZS50b1RhZywgdW5kZWZpbmVkKTsgLy8gUHJpbWUgdGhlIEFDSyBjYWNoZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGluIGVpdGhlciB0aGUgXCJDYWxsaW5nXCIgb3IgXCJQcm9jZWVkaW5nXCIgc3RhdGVzLCByZWNlcHRpb24gb2ZcbiAgICAgICAgICAgICAgICAvLyBhIHJlc3BvbnNlIHdpdGggc3RhdHVzIGNvZGUgZnJvbSAzMDAtNjk5IE1VU1QgY2F1c2UgdGhlIGNsaWVudFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIHRvIHRyYW5zaXRpb24gdG8gXCJDb21wbGV0ZWRcIi4gVGhlIGNsaWVudCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIC8vIE1VU1QgcGFzcyB0aGUgcmVjZWl2ZWQgcmVzcG9uc2UgdXAgdG8gdGhlIFRVLCBhbmQgdGhlIGNsaWVudFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIE1VU1QgZ2VuZXJhdGUgYW4gQUNLIHJlcXVlc3QsIGV2ZW4gaWYgdGhlIHRyYW5zcG9ydCBpc1xuICAgICAgICAgICAgICAgIC8vIHJlbGlhYmxlIChndWlkZWxpbmVzIGZvciBjb25zdHJ1Y3RpbmcgdGhlIEFDSyBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIGFyZSBnaXZlbiBpbiBTZWN0aW9uIDE3LjEuMS4zKSwgYW5kIHRoZW4gcGFzcyB0aGUgQUNLIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLiBUaGUgQUNLIE1VU1QgYmUgc2VudCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFkZHJlc3MsIHBvcnQsIGFuZCB0cmFuc3BvcnQgdG8gd2hpY2ggdGhlIG9yaWdpbmFsIHJlcXVlc3Qgd2FzIHNlbnQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZDpcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlIGlzIHRvIGFsbG93IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiB0byBjb250aW51ZSB0byBleGlzdCB0byByZWNlaXZlLCBhbmQgcGFzcyB0byB0aGUgVFUsXG4gICAgICAgICAgICAgICAgLy8gYW55IHJldHJhbnNtaXNzaW9ucyBvZiB0aGUgMnh4IHJlc3BvbnNlIGFuZCBhbnkgYWRkaXRpb25hbCAyeHhcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZXMgZnJvbSBvdGhlciBicmFuY2hlcyBvZiB0aGUgSU5WSVRFIGlmIGl0IGZvcmtlZFxuICAgICAgICAgICAgICAgIC8vIGRvd25zdHJlYW0uIFRpbWVyIE0gcmVmbGVjdHMgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gdXNlciB3aWxsIHdhaXQgZm9yIHN1Y2ggbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBbnkgMnh4IHJlc3BvbnNlcyB0aGF0IG1hdGNoIHRoaXMgY2xpZW50IHRyYW5zYWN0aW9uIGFuZCB0aGF0IGFyZVxuICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVkIHdoaWxlIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUgTVVTVCBiZSBwYXNzZWQgdXAgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gVFUuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBOT1QgZ2VuZXJhdGUgYW4gQUNLIHRvIHRoZSAyeHhcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZS4gVGhlIGNsaWVudCB0cmFuc2FjdGlvbiB0YWtlcyBubyBmdXJ0aGVyIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDI5OSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIGhlcmVpbiBpcyBpbnRlbnRpb25hbGx5IG5vdCBSRkMgY29tcGxpYW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSB0aGUgZmlyc3QgMnh4IHJlc3BvbnNlIGZvciBhIGdpdmVuIGJyYW5jaCBpcyBwYXNzZWQgdXAgdG8gdGhlIFRVLFxuICAgICAgICAgICAgICAgICAgICAvLyByZXRyYW5zbWlzc2lvbnMgb2YgMnh4IHJlc3BvbnNlcyBhcmUgYWJzb3JiZWQgYW5kIHRoZSBBQ0sgYXNzb2NpYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBvcmlnaW5hbCByZXNwb25zZSBpcyByZXNlbnQuIFRoaXMgYXBwcm9hY2ggaXMgdGFrZW4gYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdXIgY3VycmVudCB0cmFuc2FjdGlvbiB1c2VycyBhcmUgbm90IGN1cnJlbnRseSBpbiBhIGdvb2QgcG9zaXRpb24gdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIDJ4eCByZXRyYW5zbWlzc2lvbi4gVGhpcyBTSE9VTEQgTk9UIGNhdXNlIGFueSBjb21wbGlhbmNlIGlzc3VlcyAtIDspXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjYWNoZSBoaXQsIHBhc3MgdGhlIHJlc3BvbnNlIHRvIHRoZSBUVS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFja1JldHJhbnNtaXNzaW9uQ2FjaGUuaGFzKHJlc3BvbnNlLnRvVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLnNldChyZXNwb25zZS50b1RhZywgdW5kZWZpbmVkKTsgLy8gUHJpbWUgdGhlIEFDSyBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY2FjaGUgaGl0LCB0cnkgcHVsbGluZyB0aGUgQUNLIGZyb20gY2FjaGUgYW5kIHJldHJhbnNtaXR0aW5nIGl0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgYWNrID0gdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLmdldChyZXNwb25zZS50b1RhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChhY2sudG9TdHJpbmcoKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgQUNLIHRvIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbiBBQ0sgd2FzIG5vdCBmb3VuZCBpbiBjYWNoZSB0aGVuIHdlIGhhdmUgcmVjZWl2ZWQgYSByZXRyYW5zbWl0dGVkIDJ4eFxuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZSBiZWZvcmUgdGhlIFRVIHJlc3BvbmRlZCB0byB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgKHdlIGRvbid0IGhhdmUgYW4gQUNLIHlldCkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvIGRpc2NhcmQgdGhpcyByZXNwb25zZSB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSBUVSB3aWxsIGV2ZW50dWFsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHVzIGEgQUNLIGZvciB0aGUgb3JpZ2luYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gQW55IHJldHJhbnNtaXNzaW9ucyBvZiBhIHJlc3BvbnNlIHdpdGggc3RhdHVzIGNvZGUgMzAwLTY5OSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gYXJlIHJlY2VpdmVkIHdoaWxlIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlIE1VU1QgY2F1c2UgdGhlIEFDSyB0b1xuICAgICAgICAgICAgICAgIC8vIGJlIHJlLXBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciByZXRyYW5zbWlzc2lvbiwgYnV0IHRoZVxuICAgICAgICAgICAgICAgIC8vIG5ld2x5IHJlY2VpdmVkIHJlc3BvbnNlIE1VU1QgTk9UIGJlIHBhc3NlZCB1cCB0byB0aGUgVFUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSBcIiArIHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFueSByZXNwb25zZSByZWNlaXZlZCB0aGF0IGRvZXMgbm90IG1hdGNoIGFuIGV4aXN0aW5nIGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSBtYWNoaW5lIGlzIHNpbXBseSBkcm9wcGVkLiAoSW1wbGVtZW50YXRpb25zIGFyZSxcbiAgICAgICAgLy8gb2YgY291cnNlLCBmcmVlIHRvIGxvZyBvciBkbyBvdGhlciBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyB0aGluZ3NcbiAgICAgICAgLy8gd2l0aCBzdWNoIHJlc3BvbnNlcywgYnV0IHRoZSBpbXBsZW1lbnRlciBzaG91bGQgYmUgc3VyZSB0byBjb25zaWRlclxuICAgICAgICAvLyB0aGUgaW1wYWN0IG9mIGxhcmdlIG51bWJlcnMgb2YgbWFsaWNpb3VzIHN0cmF5IHJlc3BvbnNlcy4pXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNy4yXG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJSZWNlaXZlZCB1bmV4cGVjdGVkIFwiICsgc3RhdHVzQ29kZSArIFwiIHJlc3BvbnNlIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLlwiO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCBpbmZvcm0gdGhlIFRVIHRoYXQgYSB0cmFuc3BvcnQgZmFpbHVyZVxuICAgICAqIGhhcyBvY2N1cnJlZCwgYW5kIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIHRyYW5zaXRpb24gZGlyZWN0bHlcbiAgICAgKiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuICBUaGUgVFUgd2lsbCBoYW5kbGUgdGhlIGZhaWxvdmVyXG4gICAgICogbWVjaGFuaXNtcyBkZXNjcmliZWQgaW4gWzRdLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS40XG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yLlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgdGhpcy51c2VyLm9uVHJhbnNwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKiBGb3IgbG9nZ2luZy4gKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uXCI7XG4gICAgfTtcbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBBQ0sgcmVxdWVzdCBjb25zdHJ1Y3RlZCBieSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgY29udGFpblxuICAgICAgICAvLyB2YWx1ZXMgZm9yIHRoZSBDYWxsLUlELCBGcm9tLCBhbmQgUmVxdWVzdC1VUkkgdGhhdCBhcmUgZXF1YWwgdG8gdGhlXG4gICAgICAgIC8vIHZhbHVlcyBvZiB0aG9zZSBoZWFkZXIgZmllbGRzIGluIHRoZSByZXF1ZXN0IHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0XG4gICAgICAgIC8vIGJ5IHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gKGNhbGwgdGhpcyB0aGUgXCJvcmlnaW5hbCByZXF1ZXN0XCIpLiBUaGUgVG9cbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIGluIHRoZSBBQ0sgTVVTVCBlcXVhbCB0aGUgVG8gaGVhZGVyIGZpZWxkIGluIHRoZVxuICAgICAgICAvLyByZXNwb25zZSBiZWluZyBhY2tub3dsZWRnZWQsIGFuZCB0aGVyZWZvcmUgd2lsbCB1c3VhbGx5IGRpZmZlciBmcm9tXG4gICAgICAgIC8vIHRoZSBUbyBoZWFkZXIgZmllbGQgaW4gdGhlIG9yaWdpbmFsIHJlcXVlc3QgYnkgdGhlIGFkZGl0aW9uIG9mIHRoZVxuICAgICAgICAvLyB0YWcgcGFyYW1ldGVyLiBUaGUgQUNLIE1VU1QgY29udGFpbiBhIHNpbmdsZSBWaWEgaGVhZGVyIGZpZWxkLCBhbmRcbiAgICAgICAgLy8gdGhpcyBNVVNUIGJlIGVxdWFsIHRvIHRoZSB0b3AgVmlhIGhlYWRlciBmaWVsZCBvZiB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gcmVxdWVzdC4gVGhlIENTZXEgaGVhZGVyIGZpZWxkIGluIHRoZSBBQ0sgTVVTVCBjb250YWluIHRoZSBzYW1lXG4gICAgICAgIC8vIHZhbHVlIGZvciB0aGUgc2VxdWVuY2UgbnVtYmVyIGFzIHdhcyBwcmVzZW50IGluIHRoZSBvcmlnaW5hbCByZXF1ZXN0LFxuICAgICAgICAvLyBidXQgdGhlIG1ldGhvZCBwYXJhbWV0ZXIgTVVTVCBiZSBlcXVhbCB0byBcIkFDS1wiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgSU5WSVRFIHJlcXVlc3Qgd2hvc2UgcmVzcG9uc2UgaXMgYmVpbmcgYWNrbm93bGVkZ2VkIGhhZCBSb3V0ZVxuICAgICAgICAvLyBoZWFkZXIgZmllbGRzLCB0aG9zZSBoZWFkZXIgZmllbGRzIE1VU1QgYXBwZWFyIGluIHRoZSBBQ0suIFRoaXMgaXNcbiAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgdGhlIEFDSyBjYW4gYmUgcm91dGVkIHByb3Blcmx5IHRocm91Z2ggYW55IGRvd25zdHJlYW1cbiAgICAgICAgLy8gc3RhdGVsZXNzIHByb3hpZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjNcbiAgICAgICAgdmFyIHJ1cmkgPSB0aGlzLnJlcXVlc3QucnVyaTtcbiAgICAgICAgdmFyIGNhbGxJZCA9IHRoaXMucmVxdWVzdC5jYWxsSWQ7XG4gICAgICAgIHZhciBjc2VxID0gdGhpcy5yZXF1ZXN0LmNzZXE7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5yZXF1ZXN0LmdldEhlYWRlcihcImZyb21cIik7XG4gICAgICAgIHZhciB0byA9IHJlc3BvbnNlLmdldEhlYWRlcihcInRvXCIpO1xuICAgICAgICB2YXIgdmlhID0gdGhpcy5yZXF1ZXN0LmdldEhlYWRlcihcInZpYVwiKTtcbiAgICAgICAgdmFyIHJvdXRlID0gdGhpcy5yZXF1ZXN0LmdldEhlYWRlcihcInJvdXRlXCIpO1xuICAgICAgICBpZiAoIWZyb20pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyb20gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmlhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWEgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWNrID0gXCJBQ0sgXCIgKyBydXJpICsgXCIgU0lQLzIuMFxcclxcblwiO1xuICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgIGFjayArPSBcIlJvdXRlOiBcIiArIHJvdXRlICsgXCJcXHJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBhY2sgKz0gXCJWaWE6IFwiICsgdmlhICsgXCJcXHJcXG5cIjtcbiAgICAgICAgYWNrICs9IFwiVG86IFwiICsgdG8gKyBcIlxcclxcblwiO1xuICAgICAgICBhY2sgKz0gXCJGcm9tOiBcIiArIGZyb20gKyBcIlxcclxcblwiO1xuICAgICAgICBhY2sgKz0gXCJDYWxsLUlEOiBcIiArIGNhbGxJZCArIFwiXFxyXFxuXCI7XG4gICAgICAgIGFjayArPSBcIkNTZXE6IFwiICsgY3NlcSArIFwiIEFDS1xcclxcblwiO1xuICAgICAgICBhY2sgKz0gXCJNYXgtRm9yd2FyZHM6IDcwXFxyXFxuXCI7XG4gICAgICAgIGFjayArPSBcIkNvbnRlbnQtTGVuZ3RoOiAwXFxyXFxuXFxyXFxuXCI7XG4gICAgICAgIC8vIFRPT086IFwiVXNlci1BZ2VudFwiIGhlYWRlclxuICAgICAgICB0aGlzLnNlbmQoYWNrKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIEFDSyB0byBub24tMnh4IHJlc3BvbnNlLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBuZXdTdGF0ZSAtIE5ldyBzdGF0ZS5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkdWVUb1RyYW5zcG9ydEVycm9yID09PSB2b2lkIDApIHsgZHVlVG9UcmFuc3BvcnRFcnJvciA9IGZhbHNlOyB9XG4gICAgICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICAgICAgdmFyIGludmFsaWRTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBcIiArIF90aGlzLnN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNhbGxpbmc6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkOlxuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ2FsbGluZyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGlsZSBub3Qgc3BlbGxlZCBvdXQgaW4gdGhlIFJGQywgVGltZXIgQiBpcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0aGF0IGEgc2VuZGVyXG4gICAgICAgIC8vIHdpbGwgd2FpdCBmb3IgYW4gSU5WSVRFIG1lc3NhZ2UgdG8gYmUgYWNrbm93bGVkZ2VkIChhIFNJUCByZXNwb25zZSBtZXNzYWdlIGlzIHJlY2VpdmVkKS5cbiAgICAgICAgLy8gU28gVGltZXIgQiBzaG91bGQgYmUgY2xlYXJlZCB3aGVuIHRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBwcm9jZWVkcyBmcm9tIFwiQ2FsbGluZ1wiLlxuICAgICAgICBpZiAodGhpcy5CKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgICAgICAgICAgIHRoaXMuQiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICAvLyBUaW1lcnMgaGF2ZSBubyBlZmZlY3Qgb24gXCJQcm9jZWVkaW5nXCIgc3RhdGUuXG4gICAgICAgICAgICAvLyBJbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFNIT1VMRCBOT1QgcmV0cmFuc21pdCB0aGUgcmVxdWVzdCBhbnkgbG9uZ2VyLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBzdGFydCBUaW1lciBEIHdoZW4gaXQgZW50ZXJzIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlXG4gICAgICAgIC8vIGZvciBhbnkgcmVhc29uLCB3aXRoIGEgdmFsdWUgb2YgYXQgbGVhc3QgMzIgc2Vjb25kcyBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLFxuICAgICAgICAvLyBhbmQgYSB2YWx1ZSBvZiB6ZXJvIHNlY29uZHMgZm9yIHJlbGlhYmxlIHRyYW5zcG9ydHMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5EID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aW1lcl9EKCk7IH0sIHRpbWVyc18xLlRpbWVycy5USU1FUl9EKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLFxuICAgICAgICAvLyBhbmQgVGltZXIgTSBNVVNUIGJlIHN0YXJ0ZWQgd2l0aCBhIHZhbHVlIG9mIDY0KlQxLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCkge1xuICAgICAgICAgICAgdGhpcy5NID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aW1lcl9NKCk7IH0sIHRpbWVyc18xLlRpbWVycy5USU1FUl9NKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUsIGl0IE1VU1QgYmUgZGVzdHJveWVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguN1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3RhdGUuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aW1lciBBIGZpcmVzLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgcmV0cmFuc21pdCB0aGVcbiAgICAgKiByZXF1ZXN0IGJ5IHBhc3NpbmcgaXQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciwgYW5kIE1VU1QgcmVzZXQgdGhlXG4gICAgICogdGltZXIgd2l0aCBhIHZhbHVlIG9mIDIqVDEuXG4gICAgICogV2hlbiB0aW1lciBBIGZpcmVzIDIqVDEgc2Vjb25kcyBsYXRlciwgdGhlIHJlcXVlc3QgTVVTVCBiZVxuICAgICAqIHJldHJhbnNtaXR0ZWQgYWdhaW4gKGFzc3VtaW5nIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gdGhpc1xuICAgICAqIHN0YXRlKS4gVGhpcyBwcm9jZXNzIE1VU1QgY29udGludWUgc28gdGhhdCB0aGUgcmVxdWVzdCBpc1xuICAgICAqIHJldHJhbnNtaXR0ZWQgd2l0aCBpbnRlcnZhbHMgdGhhdCBkb3VibGUgYWZ0ZXIgZWFjaCB0cmFuc21pc3Npb24uXG4gICAgICogVGhlc2UgcmV0cmFuc21pc3Npb25zIFNIT1VMRCBvbmx5IGJlIGRvbmUgd2hpbGUgdGhlIGNsaWVudFxuICAgICAqIHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcIkNhbGxpbmdcIiBzdGF0ZS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMS4yXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0EgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gdGhlIFwiQ2FsbGluZ1wiIHN0YXRlIHdoZW4gdGltZXJcbiAgICAgKiBCIGZpcmVzLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCBpbmZvcm0gdGhlIFRVIHRoYXQgYSB0aW1lb3V0XG4gICAgICogaGFzIG9jY3VycmVkLiAgVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIE5PVCBnZW5lcmF0ZSBhbiBBQ0suXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9CID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlRpbWVyIEIgZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ2FsbGluZykge1xuICAgICAgICAgICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIFRpbWVyIEQgZmlyZXMgd2hpbGUgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSxcbiAgICAgKiB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgbW92ZSB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBEIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBUaW1lciBNIGZpcmVzIHdoaWxlIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiQWNjZXB0ZWRcIlxuICAgICAqIHN0YXRlLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgbW92ZSB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBNIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbjtcbn0oY2xpZW50X3RyYW5zYWN0aW9uXzEuQ2xpZW50VHJhbnNhY3Rpb24pKTtcbmV4cG9ydHMuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gPSBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciB0aW1lcnNfMSA9IHJlcXVpcmUoXCIuLi90aW1lcnNcIik7XG52YXIgc2VydmVyX3RyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItdHJhbnNhY3Rpb25cIik7XG52YXIgdHJhbnNhY3Rpb25fc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCIpO1xuLyoqXG4gKiBJTlZJVEUgU2VydmVyIFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBVcG9uIGNvbnN0cnVjdGlvbiwgYSBcIjEwMCBUcnlpbmdcIiByZXBseSB3aWxsIGJlIGltbWVkaWF0ZWx5IHNlbnQuXG4gICAgICogQWZ0ZXIgY29uc3RydWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIGluIHRoZSBcInByb2NlZWRpbmdcIiBzdGF0ZSBhbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogYGlkYCB3aWxsIGVxdWFsIHRoZSBicmFuY2ggcGFyYW1ldGVyIHNldCBpbiB0aGUgVmlhIGhlYWRlciBvZiB0aGUgaW5jb21pbmcgcmVxdWVzdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gSW5jb21pbmcgSU5WSVRFIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnQgLSBUaGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSB1c2VyIC0gVGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByZXF1ZXN0LCB0cmFuc3BvcnQsIHVzZXIsIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nLCBcInNpcC50cmFuc2FjdGlvbi5pc3RcIikgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wUHJvZ3Jlc3NFeHRlbnNpb25UaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5IKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5IKTtcbiAgICAgICAgICAgIHRoaXMuSCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5JKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5JKTtcbiAgICAgICAgICAgIHRoaXMuSSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5MKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5MKTtcbiAgICAgICAgICAgIHRoaXMuTCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgIC8qKiBUcmFuc2FjdGlvbiBraW5kLiBEZXByZWNhdGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcImlzdFwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIHJlcXVlc3RzIGZyb20gdHJhbnNwb3J0IG1hdGNoaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBSZXF1ZXN0IG1hdGNoaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIC8vIElmIGEgcmVxdWVzdCByZXRyYW5zbWlzc2lvbiBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBtb3N0XG4gICAgICAgICAgICAgICAgLy8gcmVjZW50IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHRoYXQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIFRVIE1VU1QgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zcG9ydCBsYXllciBmb3IgcmV0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdFByb3Zpc2lvbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZCh0aGlzLmxhc3RQcm92aXNpb25hbFJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCByZXRyYW5zbWlzc2lvbiBvZiBwcm92aXNpb25hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgaW4gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSwgYW55IHJldHJhbnNtaXNzaW9ucyBvZiB0aGUgSU5WSVRFXG4gICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgd2lsbCBtYXRjaCB0aGlzIHRyYW5zYWN0aW9uIHN0YXRlIG1hY2hpbmUgYW5kIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAvLyBhYnNvcmJlZCBieSB0aGUgbWFjaGluZSB3aXRob3V0IGNoYW5naW5nIGl0cyBzdGF0ZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAvLyByZXRyYW5zbWlzc2lvbnMgYXJlIG5vdCBwYXNzZWQgb250byB0aGUgVFUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi03LjFcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICAvLyBGdXJ0aGVybW9yZSwgd2hpbGUgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGlmIGEgcmVxdWVzdCByZXRyYW5zbWlzc2lvbiBpc1xuICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVkLCB0aGUgc2VydmVyIFNIT1VMRCBwYXNzIHRoZSByZXNwb25zZSB0byB0aGUgdHJhbnNwb3J0IGZvciByZXRyYW5zbWlzc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLklOVklURSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGFzdEZpbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhc3QgZmluYWwgcmVzcG9uc2UgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5sYXN0RmluYWxSZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCByZXRyYW5zbWlzc2lvbiBvZiBmaW5hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGFuIEFDSyBpcyByZWNlaXZlZCB3aGlsZSB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIkNvbmZpcm1lZFwiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBtZXNzYWdlc18xLkMuQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29uZmlybWVkOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBwdXJwb3NlIG9mIHRoZSBcIkNvbmZpcm1lZFwiIHN0YXRlIGlzIHRvIGFic29yYiBhbnkgYWRkaXRpb25hbCBBQ0sgbWVzc2FnZXMgdGhhdCBhcnJpdmUsXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIGZyb20gcmV0cmFuc21pc3Npb25zIG9mIHRoZSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLklOVklURSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICAvLyBGb3IgZ29vZCBtZWFzdXJlIGFic29yYiBhbnkgYWRkaXRpb25hbCBtZXNzYWdlcyB0aGF0IGFycml2ZSAoc2hvdWxkIG5vdCBoYXBwZW4pLlxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLklOVklURSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIklOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIHJlcXVlc3QubWV0aG9kICsgXCIgcmVxdWVzdCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIi5cIjtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSByZXNwb25zZXMgZnJvbSBUVSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFN0YXR1cyBjb2RlIG9mIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSByZXNwb25zZSAtIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZSBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICAvLyBUaGUgVFUgcGFzc2VzIGFueSBudW1iZXIgb2YgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi4gU28gbG9uZyBhcyB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIGlzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCBlYWNoIG9mIHRoZXNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAvLyBsYXllciBmb3IgdHJhbnNtaXNzaW9uLiBUaGV5IGFyZSBub3Qgc2VudCByZWxpYWJseSBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBsYXllciAodGhleSBhcmUgbm90IHJldHJhbnNtaXR0ZWQgYnkgaXQpIGFuZCBkbyBub3QgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGNoYW5nZSBpbiB0aGUgc3RhdGUgb2YgdGhlIHNlcnZlciB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RQcm92aXNpb25hbFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBwcm9ncmVzcyBleHRlbnNpb24gdGltZXIgb25seSBmb3IgYSBub24tMTAwIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFByb2dyZXNzRXh0ZW5zaW9uVGltZXIoKTsgLy8gRklYTUU6IHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCAxeHggcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiwgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgVFUgcGFzc2VzIGEgMnh4IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHBhc3MgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi4gSXQgaXMgbm90XG4gICAgICAgICAgICAgICAgLy8gcmV0cmFuc21pdHRlZCBieSB0aGUgc2VydmVyIHRyYW5zYWN0aW9uOyByZXRyYW5zbWlzc2lvbnMgb2YgMnh4XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VzIGFyZSBoYW5kbGVkIGJ5IHRoZSBUVS4gVGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHRoZW5cbiAgICAgICAgICAgICAgICAvLyB0cmFuc2l0aW9uIHRvIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjVcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RmluYWxSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQocmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgMnh4IHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCBpZiB0aGUgVFUgcGFzc2VzIGEgcmVzcG9uc2Ugd2l0aFxuICAgICAgICAgICAgICAgIC8vIHN0YXR1cyBjb2RlIGZyb20gMzAwIHRvIDY5OSB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLCB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBNVVNUIGJlIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24sIGFuZCB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyBtYWNoaW5lIE1VU1QgZW50ZXIgdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RmluYWxSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIG5vbi0yeHggZmluYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkOlxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUsIGlmIHRoZSBUVSBwYXNzZXMgYSAyeHggcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHBhc3MgdGhlIHJlc3BvbnNlIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguN1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDI5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQocmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgMnh4IHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIklOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIHN0YXR1c0NvZGUgKyBcIiByZXNwb25zZSBmcm9tIFRVIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLlwiO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmFuc21pdCB0aGUgbGFzdCAyeHggcmVzcG9uc2UuIFRoaXMgaXMgYSBub29wIGlmIG5vdCBpbiB0aGUgXCJhY2NlcHRlZFwiIHN0YXRlLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZXRyYW5zbWl0QWNjZXB0ZWRSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCAmJiB0aGlzLmxhc3RGaW5hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5sYXN0RmluYWxSZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgMnh4IHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXJzdCwgdGhlIHByb2NlZHVyZXMgaW4gWzRdIGFyZSBmb2xsb3dlZCwgd2hpY2ggYXR0ZW1wdCB0byBkZWxpdmVyIHRoZSByZXNwb25zZSB0byBhIGJhY2t1cC5cbiAgICAgKiBJZiB0aG9zZSBzaG91bGQgYWxsIGZhaWwsIGJhc2VkIG9uIHRoZSBkZWZpbml0aW9uIG9mIGZhaWx1cmUgaW4gWzRdLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIFNIT1VMRFxuICAgICAqIGluZm9ybSB0aGUgVFUgdGhhdCBhIGZhaWx1cmUgaGFzIG9jY3VycmVkLCBhbmQgTVVTVCByZW1haW4gaW4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjhcbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy51c2VyLm9uVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEZvciBsb2dnaW5nLiAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50eXBlVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIklOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb25cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBuZXdTdGF0ZSAtIE5ldyBzdGF0ZS5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICAgICAgdmFyIGludmFsaWRTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBcIiArIF90aGlzLnN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQ6XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uIGFueSBzdGF0ZSB0cmFuc2l0aW9uLCBzdG9wIHJlc2VuZGluZyBwcm92aXNpb25hbCByZXNwb25zZXNcbiAgICAgICAgdGhpcy5zdG9wUHJvZ3Jlc3NFeHRlbnNpb25UaW1lcigpO1xuICAgICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlIGlzIHRvIGFic29yYiByZXRyYW5zbWlzc2lvbnMgb2YgYW4gYWNjZXB0ZWQgSU5WSVRFIHJlcXVlc3QuXG4gICAgICAgIC8vIEFueSBzdWNoIHJldHJhbnNtaXNzaW9ucyBhcmUgYWJzb3JiZWQgZW50aXJlbHkgd2l0aGluIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vIFRoZXkgYXJlIG5vdCBwYXNzZWQgdXAgdG8gdGhlIFRVIHNpbmNlIGFueSBkb3duc3RyZWFtIFVBUyBjb3JlcyB0aGF0IGFjY2VwdGVkIHRoZSByZXF1ZXN0IGhhdmVcbiAgICAgICAgLy8gdGFrZW4gcmVzcG9uc2liaWxpdHkgZm9yIHJlbGlhYmlsaXR5IGFuZCB3aWxsIGFscmVhZHkgcmV0cmFuc21pdCB0aGVpciAyeHggcmVzcG9uc2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjdcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuTCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfTCgpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfTCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSBpcyBlbnRlcmVkLCB0aW1lciBIIE1VU1QgYmUgc2V0IHRvIGZpcmUgaW4gNjQqVDEgc2Vjb25kcyBmb3IgYWxsIHRyYW5zcG9ydHMuXG4gICAgICAgIC8vIFRpbWVyIEggZGV0ZXJtaW5lcyB3aGVuIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gYWJhbmRvbnMgcmV0cmFuc21pdHRpbmcgdGhlIHJlc3BvbnNlLlxuICAgICAgICAvLyBJZiBhbiBBQ0sgaXMgcmVjZWl2ZWQgd2hpbGUgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSxcbiAgICAgICAgLy8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiQ29uZmlybWVkXCIgc3RhdGUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgLy8gRklYTUU6IE1pc3NpbmcgdGltZXIgRyBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLlxuICAgICAgICAgICAgdGhpcy5IID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aW1lcl9IKCk7IH0sIHRpbWVyc18xLlRpbWVycy5USU1FUl9IKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGUgXCJDb25maXJtZWRcIiBzdGF0ZSBpcyB0byBhYnNvcmIgYW55IGFkZGl0aW9uYWwgQUNLIG1lc3NhZ2VzIHRoYXQgYXJyaXZlLFxuICAgICAgICAvLyB0cmlnZ2VyZWQgZnJvbSByZXRyYW5zbWlzc2lvbnMgb2YgdGhlIGZpbmFsIHJlc3BvbnNlLiBXaGVuIHRoaXMgc3RhdGUgaXMgZW50ZXJlZCwgdGltZXIgSVxuICAgICAgICAvLyBpcyBzZXQgdG8gZmlyZSBpbiBUNCBzZWNvbmRzIGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMsIGFuZCB6ZXJvIHNlY29uZHMgZm9yIHJlbGlhYmxlXG4gICAgICAgIC8vIHRyYW5zcG9ydHMuIE9uY2UgdGltZXIgSSBmaXJlcywgdGhlIHNlcnZlciBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHRpbWVyIGlzIG5vdCBnZXR0aW5nIHNldCBjb3JyZWN0bHkgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cy5cbiAgICAgICAgICAgIHRoaXMuSSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfSSgpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfSSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25jZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLCBpdCBNVVNUIGJlIGRlc3Ryb3llZCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjdcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlLlxuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZJWE1FOiBVQVMgUHJvdmlzaW9uYWwgUmV0cmFuc21pc3Npb24gVGltZXIuIFNlZSBSRkMgMzI2MSBTZWN0aW9uIDEzLjMuMS4xXG4gICAgICogVGhpcyBpcyBpbiB0aGUgd3JvbmcgcGxhY2UuIFRoaXMgaXMgbm90IGEgdHJhbnNhY3Rpb24gbGV2ZWwgdGhpbmcuIEl0J3MgYSBVQVMgbGV2ZWwgdGhpbmcuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXJ0UHJvZ3Jlc3NFeHRlbnNpb25UaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gU3RhcnQgdGhlIHByb2dyZXNzIGV4dGVuc2lvbiB0aW1lciBvbmx5IGZvciB0aGUgZmlyc3Qgbm9uLTEwMCBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzRXh0ZW5zaW9uVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiUHJvZ3Jlc3MgZXh0ZW5zaW9uIHRpbWVyIGV4cGlyZWQgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gXCIgKyBfdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmxhc3RQcm92aXNpb25hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhc3QgcHJvdmlzaW9uYWwgcmVzcG9uc2UgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZChfdGhpcy5sYXN0UHJvdmlzaW9uYWxSZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIHJldHJhbnNtaXNzaW9uIG9mIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRpbWVyc18xLlRpbWVycy5QUk9WSVNJT05BTF9SRVNQT05TRV9JTlRFUlZBTCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZJWE1FOiBVQVMgUHJvdmlzaW9uYWwgUmV0cmFuc21pc3Npb24gVGltZXIgaWQuIFNlZSBSRkMgMzI2MSBTZWN0aW9uIDEzLjMuMS4xXG4gICAgICogVGhpcyBpcyBpbiB0aGUgd3JvbmcgcGxhY2UuIFRoaXMgaXMgbm90IGEgdHJhbnNhY3Rpb24gbGV2ZWwgdGhpbmcuIEl0J3MgYSBVQVMgbGV2ZWwgdGhpbmcuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0b3BQcm9ncmVzc0V4dGVuc2lvblRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmVzc0V4dGVuc2lvblRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wcm9ncmVzc0V4dGVuc2lvblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCBpZiB0aGUgVFUgcGFzc2VzIGEgcmVzcG9uc2Ugd2l0aCBzdGF0dXMgY29kZVxuICAgICAqIGZyb20gMzAwIHRvIDY5OSB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLCB0aGUgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24sIGFuZCB0aGUgc3RhdGUgbWFjaGluZSBNVVNUIGVudGVyIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAqIEZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMsIHRpbWVyIEcgaXMgc2V0IHRvIGZpcmUgaW4gVDEgc2Vjb25kcywgYW5kIGlzIG5vdCBzZXQgdG8gZmlyZSBmb3JcbiAgICAgKiByZWxpYWJsZSB0cmFuc3BvcnRzLiBJZiB0aW1lciBHIGZpcmVzLCB0aGUgcmVzcG9uc2UgaXMgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgb25jZVxuICAgICAqIG1vcmUgZm9yIHJldHJhbnNtaXNzaW9uLCBhbmQgdGltZXIgRyBpcyBzZXQgdG8gZmlyZSBpbiBNSU4oMipUMSwgVDIpIHNlY29uZHMuIEZyb20gdGhlbiBvbixcbiAgICAgKiB3aGVuIHRpbWVyIEcgZmlyZXMsIHRoZSByZXNwb25zZSBpcyBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBhZ2FpbiBmb3IgdHJhbnNtaXNzaW9uLCBhbmRcbiAgICAgKiB0aW1lciBHIGlzIHJlc2V0IHdpdGggYSB2YWx1ZSB0aGF0IGRvdWJsZXMsIHVubGVzcyB0aGF0IHZhbHVlIGV4Y2VlZHMgVDIsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBpdCBpcyByZXNldCB3aXRoIHRoZSB2YWx1ZSBvZiBUMi5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9HID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aW1lciBIIGZpcmVzIHdoaWxlIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLCBpdCBpbXBsaWVzIHRoYXQgdGhlIEFDSyB3YXMgbmV2ZXIgcmVjZWl2ZWQuXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUsIGFuZCBNVVNUXG4gICAgICogaW5kaWNhdGUgdG8gdGhlIFRVIHRoYXQgYSB0cmFuc2FjdGlvbiBmYWlsdXJlIGhhcyBvY2N1cnJlZC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9IID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlRpbWVyIEggZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQUNLIHRvIG5lZ2F0aXZlIGZpbmFsIHJlc3BvbnNlIHdhcyBuZXZlciByZWNlaXZlZCwgdGVybWluYXRpbmcgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmNlIHRpbWVyIEkgZmlyZXMsIHRoZSBzZXJ2ZXIgTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9JID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlRpbWVyIEkgZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gVGltZXIgTCBmaXJlcyBhbmQgdGhlIHN0YXRlIG1hY2hpbmUgaXMgaW4gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSwgdGhlIG1hY2hpbmUgTVVTVFxuICAgICAqIHRyYW5zaXRpb24gdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLiBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUsXG4gICAgICogaXQgTVVTVCBiZSBkZXN0cm95ZWQgaW1tZWRpYXRlbHkuIFRpbWVyIEwgcmVmbGVjdHMgdGhlIGFtb3VudCBvZiB0aW1lIHRoZSBzZXJ2ZXJcbiAgICAgKiB0cmFuc2FjdGlvbiBjb3VsZCByZWNlaXZlIDJ4eCByZXNwb25zZXMgZm9yIHJldHJhbnNtaXNzaW9uIGZyb20gdGhlXG4gICAgICogVFUgd2hpbGUgaXQgaXMgd2FpdGluZyB0byByZWNlaXZlIGFuIEFDSy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTcuMVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVGltZXIgTCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW52aXRlU2VydmVyVHJhbnNhY3Rpb247XG59KHNlcnZlcl90cmFuc2FjdGlvbl8xLlNlcnZlclRyYW5zYWN0aW9uKSk7XG5leHBvcnRzLkludml0ZVNlcnZlclRyYW5zYWN0aW9uID0gSW52aXRlU2VydmVyVHJhbnNhY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRpbWVyc18xID0gcmVxdWlyZShcIi4uL3RpbWVyc1wiKTtcbnZhciBjbGllbnRfdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2NsaWVudC10cmFuc2FjdGlvblwiKTtcbnZhciB0cmFuc2FjdGlvbl9zdGF0ZV8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb24tc3RhdGVcIik7XG4vKipcbiAqIE5vbi1JTlZJVEUgQ2xpZW50IFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIE5vbi1JTlZJVEUgdHJhbnNhY3Rpb25zIGRvIG5vdCBtYWtlIHVzZSBvZiBBQ0suXG4gKiBUaGV5IGFyZSBzaW1wbGUgcmVxdWVzdC1yZXNwb25zZSBpbnRlcmFjdGlvbnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMlxuICogQHB1YmxpY1xuICovXG52YXIgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBVcG9uIGNvbnN0cnVjdGlvbiwgdGhlIG91dGdvaW5nIHJlcXVlc3QncyBWaWEgaGVhZGVyIGlzIHVwZGF0ZWQgYnkgY2FsbGluZyBgc2V0VmlhSGVhZGVyYC5cbiAgICAgKiBUaGVuIGB0b1N0cmluZ2AgaXMgY2FsbGVkIG9uIHRoZSBvdXRnb2luZyByZXF1ZXN0IGFuZCB0aGUgbWVzc2FnZSBpcyBzZW50IHZpYSB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEFmdGVyIGNvbnN0cnVjdGlvbiB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBpbiB0aGUgXCJjYWxsaW5nXCIgc3RhdGUgYW5kIHRoZSB0cmFuc2FjdGlvbiBpZFxuICAgICAqIHdpbGwgZXF1YWwgdGhlIGJyYW5jaCBwYXJhbWV0ZXIgc2V0IGluIHRoZSBWaWEgaGVhZGVyIG9mIHRoZSBvdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgb3V0Z29pbmcgTm9uLUlOVklURSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnQgLSBUaGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSB1c2VyIC0gVGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ocmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlcXVlc3QsIHRyYW5zcG9ydCwgdXNlciwgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZywgXCJzaXAudHJhbnNhY3Rpb24ubmljdFwiKSB8fCB0aGlzO1xuICAgICAgICAvLyBGSVhNRTogVGltZXIgRSBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzIG5vdCBpbXBsZW1lbnRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIFwiVHJ5aW5nXCIgc3RhdGUgaXMgZW50ZXJlZCB3aGVuIHRoZSBUVSBpbml0aWF0ZXMgYSBuZXcgY2xpZW50XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHdpdGggYSByZXF1ZXN0LiAgV2hlbiBlbnRlcmluZyB0aGlzIHN0YXRlLCB0aGUgY2xpZW50XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIFNIT1VMRCBzZXQgdGltZXIgRiB0byBmaXJlIGluIDY0KlQxIHNlY29uZHMuIFRoZSByZXF1ZXN0XG4gICAgICAgIC8vIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICBfdGhpcy5GID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aW1lcl9GKCk7IH0sIHRpbWVyc18xLlRpbWVycy5USU1FUl9GKTtcbiAgICAgICAgX3RoaXMuc2VuZChyZXF1ZXN0LnRvU3RyaW5nKCkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgaW5pdGlhbCBvdXRnb2luZyByZXF1ZXN0LlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuRikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuRik7XG4gICAgICAgICAgICB0aGlzLkYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuSykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuSyk7XG4gICAgICAgICAgICB0aGlzLksgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAvKiogVHJhbnNhY3Rpb24ga2luZC4gRGVwcmVjYXRlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJuaWN0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIGluY29taW5nIHJlc3BvbnNlcyBmcm9tIHRoZSB0cmFuc3BvcnQgd2hpY2ggbWF0Y2ggdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgaW5jb21pbmcgcmVzcG9uc2UuXG4gICAgICovXG4gICAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmICghc3RhdHVzQ29kZSB8fCBzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiA2OTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZzpcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdoaWxlIGluIHRoZSBcIlRyeWluZ1wiIHN0YXRlLCB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgVFUsIGFuZCB0aGVuIHRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBTSE9VTEQgbW92ZSB0byB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGEgZmluYWwgcmVzcG9uc2UgKHN0YXR1cyBjb2RlcyAyMDAtNjk5KSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBcIlRyeWluZ1wiIHN0YXRlLCB0aGUgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIFRVLCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gNjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBwcm92aXNpb25hbCByZXNwb25zZSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSBUVS4gKEZyb20gRmlndXJlIDYpXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGEgZmluYWwgcmVzcG9uc2UgKHN0YXR1cyBjb2RlcyAyMDAtNjk5KSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSBUVSwgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDY5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDQwOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiQ29tcGxldGVkXCIgc3RhdGUgZXhpc3RzIHRvIGJ1ZmZlciBhbnkgYWRkaXRpb25hbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIHJldHJhbnNtaXNzaW9ucyB0aGF0IG1heSBiZSByZWNlaXZlZCAod2hpY2ggaXMgd2h5IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiByZW1haW5zIHRoZXJlIG9ubHkgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cykuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gRm9yIGdvb2QgbWVhc3VyZSBqdXN0IGFic29yYiBhZGRpdGlvbmFsIHJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgXCIgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiTm9uLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIHN0YXR1c0NvZGUgKyBcIiByZXNwb25zZSB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIi5cIjtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgaW5mb3JtIHRoZSBUVSB0aGF0IGEgdHJhbnNwb3J0IGZhaWx1cmUgaGFzIG9jY3VycmVkLFxuICAgICAqIGFuZCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCB0cmFuc2l0aW9uIGRpcmVjdGx5IHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICAgKiBUaGUgVFUgd2lsbCBoYW5kbGUgdGhlIGZhaWwgb3ZlciBtZWNoYW5pc21zIGRlc2NyaWJlZCBpbiBbNF0uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjRcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUcmFuc3BvcnQgZXJyb3JcbiAgICAgKi9cbiAgICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy51c2VyLm9uVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKiogRm9yIGxvZ2dpbmcuICovXG4gICAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnR5cGVUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwibm9uLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb25cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBuZXdTdGF0ZSAtIE5ldyBzdGF0ZS5cbiAgICAgKi9cbiAgICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkdWVUb1RyYW5zcG9ydEVycm9yID09PSB2b2lkIDApIHsgZHVlVG9UcmFuc3BvcnRFcnJvciA9IGZhbHNlOyB9XG4gICAgICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICAgICAgdmFyIGludmFsaWRTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBcIiArIF90aGlzLnN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZzpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWR1ZVRvVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uY2UgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBlbnRlcnMgdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGl0IE1VU1Qgc2V0XG4gICAgICAgIC8vIFRpbWVyIEsgdG8gZmlyZSBpbiBUNCBzZWNvbmRzIGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMsIGFuZCB6ZXJvXG4gICAgICAgIC8vIHNlY29uZHMgZm9yIHJlbGlhYmxlIHRyYW5zcG9ydHMgIFRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlIGV4aXN0cyB0b1xuICAgICAgICAvLyBidWZmZXIgYW55IGFkZGl0aW9uYWwgcmVzcG9uc2UgcmV0cmFuc21pc3Npb25zIHRoYXQgbWF5IGJlIHJlY2VpdmVkXG4gICAgICAgIC8vICh3aGljaCBpcyB3aHkgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiByZW1haW5zIHRoZXJlIG9ubHkgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cykuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5GKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuRik7XG4gICAgICAgICAgICAgICAgdGhpcy5GID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5LID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aW1lcl9LKCk7IH0sIHRpbWVyc18xLlRpbWVycy5USU1FUl9LKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgdGVybWluYXRlZCBzdGF0ZSwgaXQgTVVTVCBiZSBkZXN0cm95ZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlLlxuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIFRpbWVyIEYgZmlyZXMgd2hpbGUgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBpcyBzdGlsbCBpbiB0aGVcbiAgICAgKiBcIlRyeWluZ1wiIHN0YXRlLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCBpbmZvcm0gdGhlIFRVIGFib3V0IHRoZVxuICAgICAqIHRpbWVvdXQsIGFuZCB0aGVuIGl0IFNIT1VMRCBlbnRlciB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogSWYgdGltZXIgRiBmaXJlcyB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBUVSBNVVNUIGJlIGluZm9ybWVkIG9mXG4gICAgICogYSB0aW1lb3V0LCBhbmQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIHRlcm1pbmF0ZWQgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAqL1xuICAgIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9GID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlRpbWVyIEYgZXhwaXJlZCBmb3Igbm9uLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZyB8fCB0aGlzLnN0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIFRpbWVyIEsgZmlyZXMgd2hpbGUgaW4gdGhpcyAoQ09NUExFVEVEKSBzdGF0ZSwgdGhlIGNsaWVudCB0cmFuc2FjdGlvblxuICAgICAqIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAqL1xuICAgIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9LID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb247XG59KGNsaWVudF90cmFuc2FjdGlvbl8xLkNsaWVudFRyYW5zYWN0aW9uKSk7XG5leHBvcnRzLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRpbWVyc18xID0gcmVxdWlyZShcIi4uL3RpbWVyc1wiKTtcbnZhciBzZXJ2ZXJfdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3NlcnZlci10cmFuc2FjdGlvblwiKTtcbnZhciB0cmFuc2FjdGlvbl9zdGF0ZV8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb24tc3RhdGVcIik7XG4vKipcbiAqIE5vbi1JTlZJVEUgU2VydmVyIFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gKiBAcHVibGljXG4gKi9cbnZhciBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBBZnRlciBjb25zdHJ1Y3Rpb24gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgaW4gdGhlIFwidHJ5aW5nXCI6IHN0YXRlIGFuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBgaWRgIHdpbGwgZXF1YWwgdGhlIGJyYW5jaCBwYXJhbWV0ZXIgc2V0IGluIHRoZSBWaWEgaGVhZGVyIG9mIHRoZSBpbmNvbWluZyByZXF1ZXN0LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBJbmNvbWluZyBOb24tSU5WSVRFIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnQgLSBUaGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSB1c2VyIC0gVGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByZXF1ZXN0LCB0cmFuc3BvcnQsIHVzZXIsIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcsIFwic2lwLnRyYW5zYWN0aW9uLm5pc3RcIikgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuSikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuSik7XG4gICAgICAgICAgICB0aGlzLkogPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAvKiogVHJhbnNhY3Rpb24ga2luZC4gRGVwcmVjYXRlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJuaXN0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgcmVxdWVzdHMgZnJvbSB0cmFuc3BvcnQgbWF0Y2hpbmcgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFJlcXVlc3QgbWF0Y2hpbmcgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZzpcbiAgICAgICAgICAgICAgICAvLyBPbmNlIGluIHRoZSBcIlRyeWluZ1wiIHN0YXRlLCBhbnkgZnVydGhlciByZXF1ZXN0IHJldHJhbnNtaXNzaW9ucyBhcmUgZGlzY2FyZGVkLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIC8vIElmIGEgcmV0cmFuc21pc3Npb24gb2YgdGhlIHJlcXVlc3QgaXMgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBtb3N0IHJlY2VudGx5IHNlbnQgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgcmV0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGFzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhc3QgcmVzcG9uc2UgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kKHRoaXMubGFzdFJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgcGFzcyB0aGUgZmluYWwgcmVzcG9uc2UgdG8gdGhlIHRyYW5zcG9ydFxuICAgICAgICAgICAgICAgIC8vIGxheWVyIGZvciByZXRyYW5zbWlzc2lvbiB3aGVuZXZlciBhIHJldHJhbnNtaXNzaW9uIG9mIHRoZSByZXF1ZXN0IGlzIHJlY2VpdmVkLiBBbnkgb3RoZXIgZmluYWwgcmVzcG9uc2VzXG4gICAgICAgICAgICAgICAgLy8gcGFzc2VkIGJ5IHRoZSBUVSB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgYmUgZGlzY2FyZGVkIHdoaWxlIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxhc3RSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHJlc3BvbnNlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZCh0aGlzLmxhc3RSZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIHJldHJhbnNtaXNzaW9uIG9mIGZpbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgXCIgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSByZXNwb25zZXMgZnJvbSBUVSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFN0YXR1cyBjb2RlIG9mIHJlc3BvbnNlLiAxMDEtMTk5IG5vdCBhbGxvd2VkIHBlciBSRkMgNDMyMC5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBSZXNwb25zZSB0byBzZW5kLlxuICAgICAqL1xuICAgIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZSBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuIFNJUCBlbGVtZW50IE1VU1QgTk9UIHNlbmQgYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggYVxuICAgICAgICAvLyBTdGF0dXMtQ29kZSBvdGhlciB0aGFuIDEwMCB0byBhIG5vbi1JTlZJVEUgcmVxdWVzdC5cbiAgICAgICAgLy8gQW4gU0lQIGVsZW1lbnQgTVVTVCBOT1QgcmVzcG9uZCB0byBhIG5vbi1JTlZJVEUgcmVxdWVzdCB3aXRoIGFcbiAgICAgICAgLy8gU3RhdHVzLUNvZGUgb2YgMTAwIG92ZXIgYW55IHVucmVsaWFibGUgdHJhbnNwb3J0LCBzdWNoIGFzIFVEUCxcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyBhIGNsaWVudCB0cmFuc2FjdGlvbidzIFRpbWVyIEUgdG8gYmUgcmVzZXQgdG8gVDIuXG4gICAgICAgIC8vIEFuIFNJUCBlbGVtZW50IE1BWSByZXNwb25kIHRvIGEgbm9uLUlOVklURSByZXF1ZXN0IHdpdGggYVxuICAgICAgICAvLyBTdGF0dXMtQ29kZSBvZiAxMDAgb3ZlciBhIHJlbGlhYmxlIHRyYW5zcG9ydCBhdCBhbnkgdGltZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzMjAjc2VjdGlvbi00LjFcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPiAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3Zpc2lvbmFsIHJlc3BvbnNlIG90aGVyIHRoYW4gMTAwIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZzpcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSBpbiB0aGUgXCJUcnlpbmdcIiBzdGF0ZSwgaWYgdGhlIFRVIHBhc3NlcyBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIGVudGVyIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBwcm92aXNpb25hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDY5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIGZpbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIC8vIEFueSBmdXJ0aGVyIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyB0aGF0IGFyZSByZWNlaXZlZCBmcm9tIHRoZSBUVSB3aGlsZVxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIFRVIHBhc3NlcyBhIGZpbmFsIHJlc3BvbnNlIChzdGF0dXMgY29kZXMgMjAwLTY5OSkgdG8gdGhlIHNlcnZlciB3aGlsZSBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIHRyYW5zYWN0aW9uIE1VU1QgZW50ZXIgdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDY5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIGZpbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gQW55IG90aGVyIGZpbmFsIHJlc3BvbnNlcyBwYXNzZWQgYnkgdGhlIFRVIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBNVVNUIGJlIGRpc2NhcmRlZCB3aGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgXCIgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiTm9uLUlOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIHN0YXR1c0NvZGUgKyBcIiByZXNwb25zZSBmcm9tIFRVIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLlwiO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlyc3QsIHRoZSBwcm9jZWR1cmVzIGluIFs0XSBhcmUgZm9sbG93ZWQsIHdoaWNoIGF0dGVtcHQgdG8gZGVsaXZlciB0aGUgcmVzcG9uc2UgdG8gYSBiYWNrdXAuXG4gICAgICogSWYgdGhvc2Ugc2hvdWxkIGFsbCBmYWlsLCBiYXNlZCBvbiB0aGUgZGVmaW5pdGlvbiBvZiBmYWlsdXJlIGluIFs0XSwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBTSE9VTERcbiAgICAgKiBpbmZvcm0gdGhlIFRVIHRoYXQgYSBmYWlsdXJlIGhhcyBvY2N1cnJlZCwgYW5kIFNIT1VMRCB0cmFuc2l0aW9uIHRvIHRoZSB0ZXJtaW5hdGVkIHN0YXRlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi40XG4gICAgICovXG4gICAgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQsIHRydWUpO1xuICAgIH07XG4gICAgLyoqIEZvciBsb2dnaW5nLiAqL1xuICAgIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50eXBlVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIm5vbi1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uXCI7XG4gICAgfTtcbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUuc3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkdWVUb1RyYW5zcG9ydEVycm9yID09PSB2b2lkIDApIHsgZHVlVG9UcmFuc3BvcnRFcnJvciA9IGZhbHNlOyB9XG4gICAgICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICAgICAgdmFyIGludmFsaWRTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBcIiArIF90aGlzLnN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZzpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcgJiYgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nICYmIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gZW50ZXJzIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLCBpdCBNVVNUIHNldCBUaW1lciBKIHRvIGZpcmVcbiAgICAgICAgLy8gaW4gNjQqVDEgc2Vjb25kcyBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLCBhbmQgemVybyBzZWNvbmRzIGZvciByZWxpYWJsZSB0cmFuc3BvcnRzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuSiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfSigpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfSik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIGJlIGRlc3Ryb3llZCB0aGUgaW5zdGFudCBpdCBlbnRlcnMgdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gcmVtYWlucyBpbiB0aGlzIHN0YXRlIHVudGlsIFRpbWVyIEogZmlyZXMsXG4gICAgICogYXQgd2hpY2ggcG9pbnQgaXQgTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAqL1xuICAgIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9KID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlRpbWVyIEogZXhwaXJlZCBmb3IgTk9OLUlOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb247XG59KHNlcnZlcl90cmFuc2FjdGlvbl8xLlNlcnZlclRyYW5zYWN0aW9uKSk7XG5leHBvcnRzLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uID0gTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbi8qKlxuICogU2VydmVyIFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIFRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHRoZSBkZWxpdmVyeSBvZiByZXF1ZXN0cyB0b1xuICogdGhlIFRVIGFuZCB0aGUgcmVsaWFibGUgdHJhbnNtaXNzaW9uIG9mIHJlc3BvbnNlcy4gIEl0IGFjY29tcGxpc2hlc1xuICogdGhpcyB0aHJvdWdoIGEgc3RhdGUgbWFjaGluZS4gIFNlcnZlciB0cmFuc2FjdGlvbnMgYXJlIGNyZWF0ZWQgYnkgdGhlXG4gKiBjb3JlIHdoZW4gYSByZXF1ZXN0IGlzIHJlY2VpdmVkLCBhbmQgdHJhbnNhY3Rpb24gaGFuZGxpbmcgaXMgZGVzaXJlZFxuICogZm9yIHRoYXQgcmVxdWVzdCAodGhpcyBpcyBub3QgYWx3YXlzIHRoZSBjYXNlKS5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMlxuICogQHB1YmxpY1xuICovXG52YXIgU2VydmVyVHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2VydmVyVHJhbnNhY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmVyVHJhbnNhY3Rpb24oX3JlcXVlc3QsIHRyYW5zcG9ydCwgdXNlciwgc3RhdGUsIGxvZ2dlckNhdGVnb3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zcG9ydCwgdXNlciwgX3JlcXVlc3QudmlhQnJhbmNoLCBzdGF0ZSwgbG9nZ2VyQ2F0ZWdvcnkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9yZXF1ZXN0ID0gX3JlcXVlc3Q7XG4gICAgICAgIF90aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwicmVxdWVzdFwiLCB7XG4gICAgICAgIC8qKiBUaGUgaW5jb21pbmcgcmVxdWVzdCB0aGUgdHJhbnNhY3Rpb24gaGFuZGxpbmcuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBTZXJ2ZXJUcmFuc2FjdGlvbjtcbn0odHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpO1xuZXhwb3J0cy5TZXJ2ZXJUcmFuc2FjdGlvbiA9IFNlcnZlclRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRyYW5zYWN0aW9uIHN0YXRlLlxuICogQHB1YmxpY1xuICovXG52YXIgVHJhbnNhY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0ZSkge1xuICAgIFRyYW5zYWN0aW9uU3RhdGVbXCJBY2NlcHRlZFwiXSA9IFwiQWNjZXB0ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXRlW1wiQ2FsbGluZ1wiXSA9IFwiQ2FsbGluZ1wiO1xuICAgIFRyYW5zYWN0aW9uU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSBcIkNvbXBsZXRlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdGVbXCJDb25maXJtZWRcIl0gPSBcIkNvbmZpcm1lZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdGVbXCJQcm9jZWVkaW5nXCJdID0gXCJQcm9jZWVkaW5nXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0ZVtcIlRlcm1pbmF0ZWRcIl0gPSBcIlRlcm1pbmF0ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXRlW1wiVHJ5aW5nXCJdID0gXCJUcnlpbmdcIjtcbn0pKFRyYW5zYWN0aW9uU3RhdGUgPSBleHBvcnRzLlRyYW5zYWN0aW9uU3RhdGUgfHwgKGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0ZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vZXhjZXB0aW9uc1wiKTtcbi8qKlxuICogVHJhbnNhY3Rpb24uXG4gKiBAcmVtYXJrc1xuICogU0lQIGlzIGEgdHJhbnNhY3Rpb25hbCBwcm90b2NvbDogaW50ZXJhY3Rpb25zIGJldHdlZW4gY29tcG9uZW50cyB0YWtlXG4gKiBwbGFjZSBpbiBhIHNlcmllcyBvZiBpbmRlcGVuZGVudCBtZXNzYWdlIGV4Y2hhbmdlcy4gIFNwZWNpZmljYWxseSwgYVxuICogU0lQIHRyYW5zYWN0aW9uIGNvbnNpc3RzIG9mIGEgc2luZ2xlIHJlcXVlc3QgYW5kIGFueSByZXNwb25zZXMgdG9cbiAqIHRoYXQgcmVxdWVzdCwgd2hpY2ggaW5jbHVkZSB6ZXJvIG9yIG1vcmUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIGFuZFxuICogb25lIG9yIG1vcmUgZmluYWwgcmVzcG9uc2VzLiAgSW4gdGhlIGNhc2Ugb2YgYSB0cmFuc2FjdGlvbiB3aGVyZSB0aGVcbiAqIHJlcXVlc3Qgd2FzIGFuIElOVklURSAoa25vd24gYXMgYW4gSU5WSVRFIHRyYW5zYWN0aW9uKSwgdGhlXG4gKiB0cmFuc2FjdGlvbiBhbHNvIGluY2x1ZGVzIHRoZSBBQ0sgb25seSBpZiB0aGUgZmluYWwgcmVzcG9uc2Ugd2FzIG5vdFxuICogYSAyeHggcmVzcG9uc2UuICBJZiB0aGUgcmVzcG9uc2Ugd2FzIGEgMnh4LCB0aGUgQUNLIGlzIG5vdCBjb25zaWRlcmVkXG4gKiBwYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTdcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFRyYW5zYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRyYW5zYWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKF90cmFuc3BvcnQsIF91c2VyLCBfaWQsIF9zdGF0ZSwgbG9nZ2VyQ2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RyYW5zcG9ydCA9IF90cmFuc3BvcnQ7XG4gICAgICAgIF90aGlzLl91c2VyID0gX3VzZXI7XG4gICAgICAgIF90aGlzLl9pZCA9IF9pZDtcbiAgICAgICAgX3RoaXMuX3N0YXRlID0gX3N0YXRlO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSBfdXNlci5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihsb2dnZXJDYXRlZ29yeSwgX2lkKTtcbiAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiQ29uc3RydWN0aW5nIFwiICsgX3RoaXMudHlwZVRvU3RyaW5nKCkgKyBcIiB3aXRoIGlkIFwiICsgX3RoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKiBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJ0ZXJtaW5hdGVkXCIgc3RhdGUsIGl0IGlzIGRlc3Ryb3llZFxuICAgICAqIGltbWVkaWF0ZWx5IGFuZCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYGRpc3Bvc2VgLiBIb3dldmVyLCBpZiBhXG4gICAgICogdHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgZW5kZWQgcHJlbWF0dXJlbHksIHRoZSB0cmFuc2FjdGlvbiB1c2VyIG1heVxuICAgICAqIGRvIHNvIGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QgKGZvciBleGFtcGxlLCBwZXJoYXBzIHRoZSBVQSBpcyBzaHV0dGluZyBkb3duKS5cbiAgICAgKiBObyBzdGF0ZSB0cmFuc2l0aW9uIHdpbGwgb2NjdXIgdXBvbiBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgb3V0c3RhbmRpbmdcbiAgICAgKiB0cmFuc21pc3Npb24gdGltZXJzIHdpbGwgYmUgY2FuY2VsbGVkLCBhbmQgdXNlIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlclxuICAgICAqIGNhbGxpbmcgYGRpc3Bvc2VgIGlzIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJEZXN0cm95ZWQgXCIgKyB0aGlzLnR5cGVUb1N0cmluZygpICsgXCIgd2l0aCBpZCBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqIFRyYW5zYWN0aW9uIGlkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBraW5kLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgIC8qKiBUcmFuc2FjdGlvbiBzdGF0ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgLyoqIFRyYW5zYWN0aW9uIHRyYW5zcG9ydC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjayk7IH07XG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmxvZ1RyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlRyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCBpbiBcIiArIHRoaXMudHlwZVRvU3RyaW5nKCkgKyBcIiB3aXRoIGlkIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXNzIG1lc3NhZ2UgdG8gdHJhbnNwb3J0IGZvciB0cmFuc21pc3Npb24uIElmIHRyYW5zcG9ydCBmYWlscyxcbiAgICAgKiB0aGUgdHJhbnNhY3Rpb24gdXNlciBpcyBub3RpZmllZCBieSBjYWxsYmFjayB0byBvblRyYW5zcG9ydEVycm9yKCkuXG4gICAgICogQHJldHVybnNcbiAgICAgKiBSZWplY3RzIHdpdGggYFRyYW5zcG9ydEVycm9yYCBpZiB0cmFuc3BvcnQgZmFpbHMuXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZChtZXNzYWdlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgcmVqZWN0cywgaXQgU0hPVUxEIHJlamVjdCB3aXRoIGEgVHJhbnNwb3J0RXJyb3IuXG4gICAgICAgICAgICAvLyBCdXQgdGhlIHRyYW5zcG9ydCBtYXkgYmUgZXh0ZXJuYWwgY29kZSwgc28gd2UgYXJlIGNhcmVmdWxcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjb252ZXJ0IGl0IHRvIGEgVHJhbnNwb3J0RXJyb3IgaWYgbmVlZCBiZS5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uVHJhbnNwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydEVycm9yO1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0RXJyb3IgPSBuZXcgZXhjZXB0aW9uc18xLlRyYW5zcG9ydEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0RXJyb3IgPSBuZXcgZXhjZXB0aW9uc18xLlRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5vblRyYW5zcG9ydEVycm9yKHRyYW5zcG9ydEVycm9yKTtcbiAgICAgICAgICAgIHRocm93IHRyYW5zcG9ydEVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN0YXRlIGNoYW5nZSB0byBcXFwiXCIgKyBzdGF0ZSArIFwiXFxcIiBvbiBcIiArIHRoaXMudHlwZVRvU3RyaW5nKCkgKyBcIiB3aXRoIGlkIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuX3VzZXIub25TdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fdXNlci5vblN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0ZUNoYW5nZWRcIik7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUudHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJVbmtub3duVHlwZVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG4vKipcbiAqIEZJWE1FOiBUT0RPOiBTaG91bGQgYmUgY29uZmlndXJhYmxlL3ZhcmlhYmxlLlxuICovXG5leHBvcnRzLkFsbG93ZWRNZXRob2RzID0gW1xuICAgIG1lc3NhZ2VzXzEuQy5BQ0ssXG4gICAgbWVzc2FnZXNfMS5DLkJZRSxcbiAgICBtZXNzYWdlc18xLkMuQ0FOQ0VMLFxuICAgIG1lc3NhZ2VzXzEuQy5JTkZPLFxuICAgIG1lc3NhZ2VzXzEuQy5JTlZJVEUsXG4gICAgbWVzc2FnZXNfMS5DLk1FU1NBR0UsXG4gICAgbWVzc2FnZXNfMS5DLk5PVElGWSxcbiAgICBtZXNzYWdlc18xLkMuT1BUSU9OUyxcbiAgICBtZXNzYWdlc18xLkMuUFJBQ0ssXG4gICAgbWVzc2FnZXNfMS5DLlJFRkVSLFxuICAgIG1lc3NhZ2VzXzEuQy5SRUdJU1RFUixcbiAgICBtZXNzYWdlc18xLkMuU1VCU0NSSUJFXG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY29yZVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRzXzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHNcIik7XG52YXIgYWxsb3dlZF9tZXRob2RzXzEgPSByZXF1aXJlKFwiLi9hbGxvd2VkLW1ldGhvZHNcIik7XG4vKipcbiAqIFRoaXMgaXMgcG9ydGVkIGZyb20gVUEuQy5BQ0NFUFRFRF9CT0RZX1RZUEVTLlxuICogRklYTUU6IFRPRE86IFNob3VsZCBiZSBjb25maWd1cmFibGUvdmFyaWFibGUuXG4gKi9cbnZhciBhY2NlcHRlZEJvZHlUeXBlcyA9IFtcbiAgICBcImFwcGxpY2F0aW9uL3NkcFwiLFxuICAgIFwiYXBwbGljYXRpb24vZHRtZi1yZWxheVwiXG5dO1xuLyoqXG4gKiBVc2VyIEFnZW50IENvcmUuXG4gKiBAcmVtYXJrc1xuICogQ29yZSBkZXNpZ25hdGVzIHRoZSBmdW5jdGlvbnMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHR5cGVcbiAqIG9mIFNJUCBlbnRpdHksIGkuZS4sIHNwZWNpZmljIHRvIGVpdGhlciBhIHN0YXRlZnVsIG9yIHN0YXRlbGVzc1xuICogcHJveHksIGEgdXNlciBhZ2VudCBvciByZWdpc3RyYXIuICBBbGwgY29yZXMsIGV4Y2VwdCB0aG9zZSBmb3JcbiAqIHRoZSBzdGF0ZWxlc3MgcHJveHksIGFyZSB0cmFuc2FjdGlvbiB1c2Vycy5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNlxuICpcbiAqIFVBQyBDb3JlOiBUaGUgc2V0IG9mIHByb2Nlc3NpbmcgZnVuY3Rpb25zIHJlcXVpcmVkIG9mIGEgVUFDIHRoYXRcbiAqIHJlc2lkZSBhYm92ZSB0aGUgdHJhbnNhY3Rpb24gYW5kIHRyYW5zcG9ydCBsYXllcnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqXG4gKiBVQVMgQ29yZTogVGhlIHNldCBvZiBwcm9jZXNzaW5nIGZ1bmN0aW9ucyByZXF1aXJlZCBhdCBhIFVBUyB0aGF0XG4gKiByZXNpZGVzIGFib3ZlIHRoZSB0cmFuc2FjdGlvbiBhbmQgdHJhbnNwb3J0IGxheWVycy5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNlxuICogQHB1YmxpY1xuICovXG52YXIgVXNlckFnZW50Q29yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gY29uZmlndXJhdGlvbiAtIENvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gRGVsZWdhdGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVXNlckFnZW50Q29yZShjb25maWd1cmF0aW9uLCBkZWxlZ2F0ZSkge1xuICAgICAgICBpZiAoZGVsZWdhdGUgPT09IHZvaWQgMCkgeyBkZWxlZ2F0ZSA9IHt9OyB9XG4gICAgICAgIC8qKiBVQUNzLiAqL1xuICAgICAgICB0aGlzLnVzZXJBZ2VudENsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBVQVNzLiAqL1xuICAgICAgICB0aGlzLnVzZXJBZ2VudFNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5kaWFsb2dzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNvbmZpZ3VyYXRpb24ubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAudXNlci1hZ2VudC1jb3JlXCIpO1xuICAgIH1cbiAgICAvKiogRGVzdHJ1Y3Rvci4gKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfTtcbiAgICAvKiogUmVzZXQuICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlhbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChkaWFsb2cpIHsgcmV0dXJuIGRpYWxvZy5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLmRpYWxvZ3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzdWJzY3JpYmVyLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy51c2VyQWdlbnRDbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKHVhYykgeyByZXR1cm4gdWFjLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIHRoaXMudXNlckFnZW50Q2xpZW50cy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudFNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAodWFjKSB7IHJldHVybiB1YWMuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy51c2VyQWdlbnRTZXJ2ZXJzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50Q29yZS5wcm90b3R5cGUsIFwibG9nZ2VyRmFjdG9yeVwiLCB7XG4gICAgICAgIC8qKiBMb2dnZXIgZmFjdG9yeS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmxvZ2dlckZhY3Rvcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQWdlbnRDb3JlLnByb3RvdHlwZSwgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAvKiogVHJhbnNwb3J0LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udHJhbnNwb3J0QWNjZXNzb3IoKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZW5kIElOVklURS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIE91dGdvaW5nIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5pbnZpdGUgPSBmdW5jdGlvbiAocmVxdWVzdCwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1c2VyX2FnZW50c18xLkludml0ZVVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIE1FU1NBR0UuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHVzZXJfYWdlbnRzXzEuTWVzc2FnZVVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIFBVQkxJU0guXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHVzZXJfYWdlbnRzXzEuUHVibGlzaFVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIFJFR0lTVEVSLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gT3V0Z29pbmcgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHJlcXVlc3QsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdXNlcl9hZ2VudHNfMS5SZWdpc3RlclVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIFNVQlNDUklCRS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIE91dGdvaW5nIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAocmVxdWVzdCwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1c2VyX2FnZW50c18xLlN1YnNjcmliZVVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIE91dGdvaW5nIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdXNlcl9hZ2VudHNfMS5Vc2VyQWdlbnRDbGllbnQodHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIHRoaXMsIHJlcXVlc3QsIGRlbGVnYXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE91dGdvaW5nIHJlcXVlc3QgbWVzc2FnZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBtZXRob2QgLSBNZXRob2QuXG4gICAgICogQHBhcmFtIHJlcXVlc3RVUkkgLSBSZXF1ZXN0LVVSSS5cbiAgICAgKiBAcGFyYW0gZnJvbVVSSSAtIEZyb20gVVJJLlxuICAgICAqIEBwYXJhbSB0b1VSSSAtIFRvIFVSSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gZXh0cmFIZWFkZXJzIC0gRXh0cmEgaGVhZGVycyB0byBhZGQuXG4gICAgICogQHBhcmFtIGJvZHkgLSBNZXNzYWdlIGJvZHkuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWV0aG9kLCByZXF1ZXN0VVJJLCBmcm9tVVJJLCB0b1VSSSwgb3B0aW9ucywgZXh0cmFIZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzIGZyb20gdXNlciBhZ2VudCBjb25maWd1cmF0aW9uXG4gICAgICAgIHZhciBjYWxsSWRQcmVmaXggPSB0aGlzLmNvbmZpZ3VyYXRpb24uc2lwanNJZDtcbiAgICAgICAgdmFyIGZyb21EaXNwbGF5TmFtZSA9IHRoaXMuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZTtcbiAgICAgICAgdmFyIGZvcmNlUnBvcnQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udmlhRm9yY2VScG9ydDtcbiAgICAgICAgdmFyIGhhY2tWaWFUY3AgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFja1ZpYVRjcDtcbiAgICAgICAgdmFyIG9wdGlvblRhZ3MgPSB0aGlzLmNvbmZpZ3VyYXRpb24uc3VwcG9ydGVkT3B0aW9uVGFncy5zbGljZSgpO1xuICAgICAgICBpZiAobWV0aG9kID09PSBtZXNzYWdlc18xLkMuUkVHSVNURVIpIHtcbiAgICAgICAgICAgIG9wdGlvblRhZ3MucHVzaChcInBhdGhcIiwgXCJncnV1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUgJiYgKHRoaXMuY29uZmlndXJhdGlvbi5jb250YWN0LnB1YkdydXUgfHwgdGhpcy5jb25maWd1cmF0aW9uLmNvbnRhY3QudGVtcEdydXUpKSB7XG4gICAgICAgICAgICBvcHRpb25UYWdzLnB1c2goXCJncnV1XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3V0ZVNldCA9IHRoaXMuY29uZmlndXJhdGlvbi5yb3V0ZVNldDtcbiAgICAgICAgdmFyIHVzZXJBZ2VudFN0cmluZyA9IHRoaXMuY29uZmlndXJhdGlvbi51c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlO1xuICAgICAgICB2YXIgdmlhSG9zdCA9IHRoaXMuY29uZmlndXJhdGlvbi52aWFIb3N0O1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjYWxsSWRQcmVmaXg6IGNhbGxJZFByZWZpeCxcbiAgICAgICAgICAgIGZvcmNlUnBvcnQ6IGZvcmNlUnBvcnQsXG4gICAgICAgICAgICBmcm9tRGlzcGxheU5hbWU6IGZyb21EaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIGhhY2tWaWFUY3A6IGhhY2tWaWFUY3AsXG4gICAgICAgICAgICBvcHRpb25UYWdzOiBvcHRpb25UYWdzLFxuICAgICAgICAgICAgcm91dGVTZXQ6IHJvdXRlU2V0LFxuICAgICAgICAgICAgdXNlckFnZW50U3RyaW5nOiB1c2VyQWdlbnRTdHJpbmcsXG4gICAgICAgICAgICB2aWFIb3N0OiB2aWFIb3N0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBtZXJnZSBwcm92aWRlZCBvcHRpb25zIHdpdGggZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLk91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWV0aG9kLCByZXF1ZXN0VVJJLCBmcm9tVVJJLCB0b1VSSSwgcmVxdWVzdE9wdGlvbnMsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZSBmcm9tIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlSW5jb21pbmdSZXF1ZXN0RnJvbVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZVJlcXVlc3RGcm9tVHJhbnNwb3J0KG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIGluY29taW5nIHJlc3BvbnNlIG1lc3NhZ2UgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZSBmcm9tIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlSW5jb21pbmdSZXNwb25zZUZyb21UcmFuc3BvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnJlY2VpdmVSZXNwb25zZUZyb21UcmFuc3BvcnQobWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRlbGVzcyBVQVMgaXMgYSBVQVMgdGhhdCBkb2VzIG5vdCBtYWludGFpbiB0cmFuc2FjdGlvbiBzdGF0ZS5cbiAgICAgKiBJdCByZXBsaWVzIHRvIHJlcXVlc3RzIG5vcm1hbGx5LCBidXQgZGlzY2FyZHMgYW55IHN0YXRlIHRoYXQgd291bGRcbiAgICAgKiBvcmRpbmFyaWx5IGJlIHJldGFpbmVkIGJ5IGEgVUFTIGFmdGVyIGEgcmVzcG9uc2UgaGFzIGJlZW4gc2VudC4gIElmIGFcbiAgICAgKiBzdGF0ZWxlc3MgVUFTIHJlY2VpdmVzIGEgcmV0cmFuc21pc3Npb24gb2YgYSByZXF1ZXN0LCBpdCByZWdlbmVyYXRlc1xuICAgICAqIHRoZSByZXNwb25zZSBhbmQgcmUtc2VuZHMgaXQsIGp1c3QgYXMgaWYgaXQgd2VyZSByZXBseWluZyB0byB0aGUgZmlyc3RcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgcmVxdWVzdC4gQSBVQVMgY2Fubm90IGJlIHN0YXRlbGVzcyB1bmxlc3MgdGhlIHJlcXVlc3RcbiAgICAgKiBwcm9jZXNzaW5nIGZvciB0aGF0IG1ldGhvZCB3b3VsZCBhbHdheXMgcmVzdWx0IGluIHRoZSBzYW1lIHJlc3BvbnNlXG4gICAgICogaWYgdGhlIHJlcXVlc3RzIGFyZSBpZGVudGljYWwuIFRoaXMgcnVsZXMgb3V0IHN0YXRlbGVzcyByZWdpc3RyYXJzLFxuICAgICAqIGZvciBleGFtcGxlLiAgU3RhdGVsZXNzIFVBU3MgZG8gbm90IHVzZSBhIHRyYW5zYWN0aW9uIGxheWVyOyB0aGV5XG4gICAgICogcmVjZWl2ZSByZXF1ZXN0cyBkaXJlY3RseSBmcm9tIHRoZSB0cmFuc3BvcnQgbGF5ZXIgYW5kIHNlbmQgcmVzcG9uc2VzXG4gICAgICogZGlyZWN0bHkgdG8gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi43XG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgdG8gcmVwbHkgdG8uXG4gICAgICogQHBhcmFtIHN0YXR1c0NvZGUgLSBTdGF0dXMgY29kZSB0byByZXBseSB3aXRoLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlcGx5U3RhdGVsZXNzID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVzZXJBZ2VudCA9IHRoaXMuY29uZmlndXJhdGlvbi51c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlO1xuICAgICAgICB2YXIgc3VwcG9ydGVkID0gdGhpcy5jb25maWd1cmF0aW9uLnN1cHBvcnRlZE9wdGlvblRhZ3NSZXNwb25zZTtcbiAgICAgICAgb3B0aW9ucyA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgdXNlckFnZW50OiB1c2VyQWdlbnQsIHN1cHBvcnRlZDogc3VwcG9ydGVkIH0pO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBtZXNzYWdlc18xLmNvbnN0cnVjdE91dGdvaW5nUmVzcG9uc2UobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UubWVzc2FnZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNwb3J0IHJlamVjdHMsIGl0IFNIT1VMRCByZWplY3Qgd2l0aCBhIFRyYW5zcG9ydEVycm9yLlxuICAgICAgICAgICAgLy8gQnV0IHRoZSB0cmFuc3BvcnQgbWF5IGJlIGV4dGVybmFsIGNvZGUsIHNvIHdlIGFyZSBjYXJlZnVsLi4uXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlRyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCBzZW5kaW5nIHN0YXRlbGVzcyByZXBseSB0byBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIgcmVxdWVzdC5cIik7XG4gICAgICAgICAgICAvLyBUT0RPOiBDdXJyZW50bHkgdGhlcmUgaXMgbm8gaG9vayB0byBwcm92aWRlIG5vdGlmaWNhdGlvbiB0aGF0IGEgdHJhbnNwb3J0IGVycm9yIG9jY3VycmVkXG4gICAgICAgICAgICAvLyBhbmQgdGhyb3dpbmcgd291bGQgcmVzdWx0IGluIGFuIHVuY2F1Z2h0IGVycm9yIChpbiBwcm9taXNlKSwgc28gd2Ugc2lsZW50bHkgZWF0IHRoZSBlcnJvci5cbiAgICAgICAgICAgIC8vIEZ1cnRoZXJtb3JlLCBzaWxlbnRseSBlYXRpbmcgc3RhdGVsZXNzIHJlcGx5IHRyYW5zcG9ydCBlcnJvcnMgaXMgYXJndWFibHkgd2hhdCB3ZSB3YW50IHRvIGRvIGhlcmUuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbiBTZWN0aW9uIDE4LjIuMSwgcmVwbGFjZSB0aGUgbGFzdCBwYXJhZ3JhcGggd2l0aDpcbiAgICAgKlxuICAgICAqIE5leHQsIHRoZSBzZXJ2ZXIgdHJhbnNwb3J0IGF0dGVtcHRzIHRvIG1hdGNoIHRoZSByZXF1ZXN0IHRvIGFcbiAgICAgKiBzZXJ2ZXIgdHJhbnNhY3Rpb24uICBJdCBkb2VzIHNvIHVzaW5nIHRoZSBtYXRjaGluZyBydWxlcyBkZXNjcmliZWRcbiAgICAgKiBpbiBTZWN0aW9uIDE3LjIuMy4gIElmIGEgbWF0Y2hpbmcgc2VydmVyIHRyYW5zYWN0aW9uIGlzIGZvdW5kLCB0aGVcbiAgICAgKiByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGF0IHRyYW5zYWN0aW9uIGZvciBwcm9jZXNzaW5nLiAgSWYgbm8gbWF0Y2hcbiAgICAgKiBpcyBmb3VuZCwgdGhlIHJlcXVlc3QgaXMgcGFzc2VkIHRvIHRoZSBjb3JlLCB3aGljaCBtYXkgZGVjaWRlIHRvXG4gICAgICogY29uc3RydWN0IGEgbmV3IHNlcnZlciB0cmFuc2FjdGlvbiBmb3IgdGhhdCByZXF1ZXN0LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xMFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIGZyb20gdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0RnJvbVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIFdoZW4gYSByZXF1ZXN0IGlzIHJlY2VpdmVkIGZyb20gdGhlIG5ldHdvcmsgYnkgdGhlIHNlcnZlciwgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIG1hdGNoZWQgdG8gYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24uICBUaGlzIGlzIGFjY29tcGxpc2hlZCBpbiB0aGVcbiAgICAgICAgLy8gZm9sbG93aW5nIG1hbm5lci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHRvcG1vc3QgVmlhIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdFxuICAgICAgICAvLyBpcyBleGFtaW5lZC4gIElmIGl0IGlzIHByZXNlbnQgYW5kIGJlZ2lucyB3aXRoIHRoZSBtYWdpYyBjb29raWVcbiAgICAgICAgLy8gXCJ6OWhHNGJLXCIsIHRoZSByZXF1ZXN0IHdhcyBnZW5lcmF0ZWQgYnkgYSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gY29tcGxpYW50IHRvIHRoaXMgc3BlY2lmaWNhdGlvbi4gIFRoZXJlZm9yZSwgdGhlIGJyYW5jaCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gd2lsbCBiZSB1bmlxdWUgYWNyb3NzIGFsbCB0cmFuc2FjdGlvbnMgc2VudCBieSB0aGF0IGNsaWVudC4gIFRoZVxuICAgICAgICAvLyByZXF1ZXN0IG1hdGNoZXMgYSB0cmFuc2FjdGlvbiBpZjpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgMS4gdGhlIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHJlcXVlc3QgaXMgZXF1YWwgdG8gdGhlIG9uZSBpbiB0aGVcbiAgICAgICAgLy8gICAgICAgdG9wIFZpYSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QgdGhhdCBjcmVhdGVkIHRoZVxuICAgICAgICAvLyAgICAgICB0cmFuc2FjdGlvbiwgYW5kXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIDIuIHRoZSBzZW50LWJ5IHZhbHVlIGluIHRoZSB0b3AgVmlhIG9mIHRoZSByZXF1ZXN0IGlzIGVxdWFsIHRvIHRoZVxuICAgICAgICAvLyAgICAgICBvbmUgaW4gdGhlIHJlcXVlc3QgdGhhdCBjcmVhdGVkIHRoZSB0cmFuc2FjdGlvbiwgYW5kXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIDMuIHRoZSBtZXRob2Qgb2YgdGhlIHJlcXVlc3QgbWF0Y2hlcyB0aGUgb25lIHRoYXQgY3JlYXRlZCB0aGVcbiAgICAgICAgLy8gICAgICAgdHJhbnNhY3Rpb24sIGV4Y2VwdCBmb3IgQUNLLCB3aGVyZSB0aGUgbWV0aG9kIG9mIHRoZSByZXF1ZXN0XG4gICAgICAgIC8vICAgICAgIHRoYXQgY3JlYXRlZCB0aGUgdHJhbnNhY3Rpb24gaXMgSU5WSVRFLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIG1hdGNoaW5nIHJ1bGUgYXBwbGllcyB0byBib3RoIElOVklURSBhbmQgbm9uLUlOVklURSB0cmFuc2FjdGlvbnNcbiAgICAgICAgLy8gYWxpa2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIFRoZSBzZW50LWJ5IHZhbHVlIGlzIHVzZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2hpbmcgcHJvY2VzcyBiZWNhdXNlXG4gICAgICAgIC8vICAgIHRoZXJlIGNvdWxkIGJlIGFjY2lkZW50YWwgb3IgbWFsaWNpb3VzIGR1cGxpY2F0aW9uIG9mIGJyYW5jaFxuICAgICAgICAvLyAgICBwYXJhbWV0ZXJzIGZyb20gZGlmZmVyZW50IGNsaWVudHMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4zXG4gICAgICAgIHZhciB0cmFuc2FjdGlvbklkID0gbWVzc2FnZS52aWFCcmFuY2g7IC8vIEZJWE1FOiBDdXJyZW50bHkgb25seSB1c2luZyBydWxlIDEuLi5cbiAgICAgICAgdmFyIHVhcyA9IHRoaXMudXNlckFnZW50U2VydmVycy5nZXQodHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIC8vIFdoZW4gcmVjZWl2aW5nIGFuIEFDSyB0aGF0IG1hdGNoZXMgYW4gZXhpc3RpbmcgSU5WSVRFIHNlcnZlclxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBhbmQgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYnJhbmNoIHBhcmFtZXRlciBjb250YWluaW5nXG4gICAgICAgIC8vIHRoZSBtYWdpYyBjb29raWUgZGVmaW5lZCBpbiBSRkMgMzI2MSwgdGhlIG1hdGNoaW5nIHRyYW5zYWN0aW9uIE1VU1RcbiAgICAgICAgLy8gYmUgY2hlY2tlZCB0byBzZWUgaWYgaXQgaXMgaW4gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZS4gIElmIGl0IGlzLCB0aGVuXG4gICAgICAgIC8vIHRoZSBBQ0sgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHRyYW5zYWN0aW9uIHVzZXIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBiZWluZyBhYnNvcmJlZCBieSB0aGUgdHJhbnNhY3Rpb24gc3RhdGUgbWFjaGluZS4gIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgICAgIC8vIGFzIHJlcXVlc3RzIGZyb20gUkZDIDI1NDMgY2xpZW50cyB3aWxsIG5vdCBpbmNsdWRlIGEgdW5pcXVlIGJyYW5jaFxuICAgICAgICAvLyBwYXJhbWV0ZXIsIGFuZCB0aGUgbWVjaGFuaXNtcyBmb3IgY2FsY3VsYXRpbmcgdGhlIHRyYW5zYWN0aW9uIElEIGZyb21cbiAgICAgICAgLy8gc3VjaCBhIHJlcXVlc3Qgd2lsbCBiZSB0aGUgc2FtZSBmb3IgYm90aCBJTlZJVEUgYW5kIEFDS3MuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNlxuICAgICAgICAvLyBBbnkgQUNLcyByZWNlaXZlZCBmcm9tIHRoZSBuZXR3b3JrIHdoaWxlIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUgTVVTVCBiZVxuICAgICAgICAvLyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFRVIGFuZCBub3QgYWJzb3JiZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNy4xXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgaWYgKHVhcyAmJiB1YXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodWFzIGluc3RhbmNlb2YgdXNlcl9hZ2VudHNfMS5JbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIEFDS3MgbWF0Y2hpbmcgYW4gSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiB3aXRoIFJGQyAzMjYxIGNvbXBsaWFudCB1c2VyIGFnZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyAod291bGQgYmUgYSBicm9rZW4gQUNLIHRvIG5lZ2F0aXZlIGZpbmFsIHJlc3BvbnNlIG9yIHNvbWV0aGluZylcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlzIGFwcGFyZW50bHkgaG93IFJGQyAyNTQzIHVzZXIgYWdlbnRzIGRvIHRoaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGluZyB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IE5vdCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIFJGQyAyNTQzIChubyBzdXBwb3J0IGZvciBzdHJpY3Qtcm91dGluZykuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJEaXNjYXJkaW5nIG91dCBvZiBkaWFsb2cgQUNLIGFmdGVyIDJ4eCByZXNwb25zZSBzZW50IG9uIHRyYW5zYWN0aW9uIFwiICsgdHJhbnNhY3Rpb25JZCArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgQ0FOQ0VMIG1ldGhvZCByZXF1ZXN0cyB0aGF0IHRoZSBUVSBhdCB0aGUgc2VydmVyIHNpZGUgY2FuY2VsIGFcbiAgICAgICAgLy8gcGVuZGluZyB0cmFuc2FjdGlvbi4gIFRoZSBUVSBkZXRlcm1pbmVzIHRoZSB0cmFuc2FjdGlvbiB0byBiZVxuICAgICAgICAvLyBjYW5jZWxsZWQgYnkgdGFraW5nIHRoZSBDQU5DRUwgcmVxdWVzdCwgYW5kIHRoZW4gYXNzdW1pbmcgdGhhdCB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBtZXRob2QgaXMgYW55dGhpbmcgYnV0IENBTkNFTCBvciBBQ0sgYW5kIGFwcGx5aW5nIHRoZVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBtYXRjaGluZyBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTcuMi4zLiAgVGhlIG1hdGNoaW5nXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGlzIHRoZSBvbmUgdG8gYmUgY2FuY2VsbGVkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5DQU5DRUwpIHtcbiAgICAgICAgICAgIGlmICh1YXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIHRoZSBtZXRob2Qgb2YgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIGFzIGxvbmcgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gQ0FOQ0VMIG1hdGNoZWQgYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24sIHRoZSBVQVMgYW5zd2VycyB0aGUgQ0FOQ0VMXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBpdHNlbGYgd2l0aCBhIDIwMCAoT0spIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDIwMCB9KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHN0aWxsIGV4aXN0cywgdGhlIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIFVBUyBvbiByZWNlaXZpbmcgYSBDQU5DRUwgcmVxdWVzdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaGFzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBzZW50IGEgZmluYWwgcmVzcG9uc2UgZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0LiBJZiBpdCBoYXMsIHRoZSBDQU5DRUxcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGhhcyBubyBlZmZlY3Qgb24gdGhlIHByb2Nlc3Npbmcgb2YgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIG5vXG4gICAgICAgICAgICAgICAgLy8gZWZmZWN0IG9uIGFueSBzZXNzaW9uIHN0YXRlLCBhbmQgbm8gZWZmZWN0IG9uIHRoZSByZXNwb25zZXMgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0LiBJZiB0aGUgVUFTIGhhcyBub3QgaXNzdWVkIGEgZmluYWwgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIGl0cyBiZWhhdmlvciBkZXBlbmRzIG9uIHRoZSBtZXRob2Qgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgcmVxdWVzdC4gSWYgdGhlIG9yaWdpbmFsIHJlcXVlc3Qgd2FzIGFuIElOVklURSwgdGhlIFVBU1xuICAgICAgICAgICAgICAgIC8vIFNIT1VMRCBpbW1lZGlhdGVseSByZXNwb25kIHRvIHRoZSBJTlZJVEUgd2l0aCBhIDQ4NyAoUmVxdWVzdFxuICAgICAgICAgICAgICAgIC8vIFRlcm1pbmF0ZWQpLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICAgICAgICAgICAgaWYgKHVhcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHVhcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1YXMgaW5zdGFuY2VvZiB1c2VyX2FnZW50c18xLkludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLnJlY2VpdmVDYW5jZWwobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQSBDQU5DRUwgcmVxdWVzdCBoYXMgbm8gaW1wYWN0IG9uIHRoZSBwcm9jZXNzaW5nIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9ucyB3aXRoIGFueSBvdGhlciBtZXRob2QgZGVmaW5lZCBpbiB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIFVBUyBkaWQgbm90IGZpbmQgYSBtYXRjaGluZyB0cmFuc2FjdGlvbiBmb3IgdGhlIENBTkNFTFxuICAgICAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgcHJvY2VkdXJlIGFib3ZlLCBpdCBTSE9VTEQgcmVzcG9uZCB0byB0aGUgQ0FOQ0VMXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBhIDQ4MSAoQ2FsbCBMZWcvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4MSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIG1hdGNoaW5nIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBmb3VuZCwgdGhlIHJlcXVlc3QgaXMgcGFzc2VkIHRvIHRoYXRcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gZm9yIHByb2Nlc3NpbmcuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xMFxuICAgICAgICBpZiAodWFzKSB7XG4gICAgICAgICAgICB1YXMudHJhbnNhY3Rpb24ucmVjZWl2ZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHRoZSByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGUgY29yZSwgd2hpY2ggbWF5IGRlY2lkZSB0b1xuICAgICAgICAvLyBjb25zdHJ1Y3QgYSBuZXcgc2VydmVyIHRyYW5zYWN0aW9uIGZvciB0aGF0IHJlcXVlc3QuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xMFxuICAgICAgICB0aGlzLnJlY2VpdmVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVQUMgYW5kIFVBUyBwcm9jZWR1cmVzIGRlcGVuZCBzdHJvbmdseSBvbiB0d28gZmFjdG9ycy4gIEZpcnN0LCBiYXNlZFxuICAgICAqIG9uIHdoZXRoZXIgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2UgaXMgaW5zaWRlIG9yIG91dHNpZGUgb2YgYSBkaWFsb2csXG4gICAgICogYW5kIHNlY29uZCwgYmFzZWQgb24gdGhlIG1ldGhvZCBvZiBhIHJlcXVlc3QuICBEaWFsb2dzIGFyZSBkaXNjdXNzZWRcbiAgICAgKiB0aG9yb3VnaGx5IGluIFNlY3Rpb24gMTI7IHRoZXkgcmVwcmVzZW50IGEgcGVlci10by1wZWVyIHJlbGF0aW9uc2hpcFxuICAgICAqIGJldHdlZW4gdXNlciBhZ2VudHMgYW5kIGFyZSBlc3RhYmxpc2hlZCBieSBzcGVjaWZpYyBTSVAgbWV0aG9kcywgc3VjaFxuICAgICAqIGFzIElOVklURS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIDguMiBVQVMgQmVoYXZpb3JcbiAgICAgICAgLy8gVUFTcyBTSE9VTEQgcHJvY2VzcyB0aGUgcmVxdWVzdHMgaW4gdGhlIG9yZGVyIG9mIHRoZSBzdGVwcyB0aGF0XG4gICAgICAgIC8vIGZvbGxvdyBpbiB0aGlzIHNlY3Rpb24gKHRoYXQgaXMsIHN0YXJ0aW5nIHdpdGggYXV0aGVudGljYXRpb24sIHRoZW5cbiAgICAgICAgLy8gaW5zcGVjdGluZyB0aGUgbWV0aG9kLCB0aGUgaGVhZGVyIGZpZWxkcywgYW5kIHNvIG9uIHRocm91Z2hvdXQgdGhlXG4gICAgICAgIC8vIHJlbWFpbmRlciBvZiB0aGlzIHNlY3Rpb24pLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMlxuICAgICAgICAvLyA4LjIuMSBNZXRob2QgSW5zcGVjdGlvblxuICAgICAgICAvLyBPbmNlIGEgcmVxdWVzdCBpcyBhdXRoZW50aWNhdGVkIChvciBhdXRoZW50aWNhdGlvbiBpcyBza2lwcGVkKSwgdGhlXG4gICAgICAgIC8vIFVBUyBNVVNUIGluc3BlY3QgdGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdC4gIElmIHRoZSBVQVMgcmVjb2duaXplc1xuICAgICAgICAvLyBidXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbWV0aG9kIG9mIGEgcmVxdWVzdCwgaXQgTVVTVCBnZW5lcmF0ZSBhIDQwNVxuICAgICAgICAvLyAoTWV0aG9kIE5vdCBBbGxvd2VkKSByZXNwb25zZS4gIFByb2NlZHVyZXMgZm9yIGdlbmVyYXRpbmcgcmVzcG9uc2VzXG4gICAgICAgIC8vIGFyZSBkZXNjcmliZWQgaW4gU2VjdGlvbiA4LjIuNi4gIFRoZSBVQVMgTVVTVCBhbHNvIGFkZCBhbiBBbGxvd1xuICAgICAgICAvLyBoZWFkZXIgZmllbGQgdG8gdGhlIDQwNSAoTWV0aG9kIE5vdCBBbGxvd2VkKSByZXNwb25zZS4gIFRoZSBBbGxvd1xuICAgICAgICAvLyBoZWFkZXIgZmllbGQgTVVTVCBsaXN0IHRoZSBzZXQgb2YgbWV0aG9kcyBzdXBwb3J0ZWQgYnkgdGhlIFVBU1xuICAgICAgICAvLyBnZW5lcmF0aW5nIHRoZSBtZXNzYWdlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4xXG4gICAgICAgIGlmIChhbGxvd2VkX21ldGhvZHNfMS5BbGxvd2VkTWV0aG9kcy5pbmRleE9mKG1lc3NhZ2UubWV0aG9kKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBhbGxvd0hlYWRlciA9IFwiQWxsb3c6IFwiICsgYWxsb3dlZF9tZXRob2RzXzEuQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwNSxcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IFthbGxvd0hlYWRlcl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIDguMi4yIEhlYWRlciBJbnNwZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjJcbiAgICAgICAgaWYgKCFtZXNzYWdlLnJ1cmkpIHsgLy8gRklYTUU6IEEgcmVxdWVzdCBtZXNzYWdlIHNob3VsZCBhbHdheXMgaGF2ZSBhbiBydXJpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0LVVSSSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDguMi4yLjEgVG8gYW5kIFJlcXVlc3QtVVJJXG4gICAgICAgIC8vIElmIHRoZSBSZXF1ZXN0LVVSSSB1c2VzIGEgc2NoZW1lIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIFVBUywgaXQgU0hPVUxEXG4gICAgICAgIC8vIHJlamVjdCB0aGUgcmVxdWVzdCB3aXRoIGEgNDE2IChVbnN1cHBvcnRlZCBVUkkgU2NoZW1lKSByZXNwb25zZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuMi4xXG4gICAgICAgIGlmIChtZXNzYWdlLnJ1cmkuc2NoZW1lICE9PSBcInNpcFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE2IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIDguMi4yLjEgVG8gYW5kIFJlcXVlc3QtVVJJXG4gICAgICAgIC8vIElmIHRoZSBSZXF1ZXN0LVVSSSBkb2VzIG5vdCBpZGVudGlmeSBhbiBhZGRyZXNzIHRoYXQgdGhlXG4gICAgICAgIC8vIFVBUyBpcyB3aWxsaW5nIHRvIGFjY2VwdCByZXF1ZXN0cyBmb3IsIGl0IFNIT1VMRCByZWplY3RcbiAgICAgICAgLy8gdGhlIHJlcXVlc3Qgd2l0aCBhIDQwNCAoTm90IEZvdW5kKSByZXNwb25zZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuMi4xXG4gICAgICAgIHZhciBydXJpID0gbWVzc2FnZS5ydXJpO1xuICAgICAgICB2YXIgcnVyaU1hdGNoZXMgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgICAgICByZXR1cm4gISF1cmkgJiYgdXJpLnVzZXIgPT09IHJ1cmkudXNlcjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24uYW9yKSAmJlxuICAgICAgICAgICAgIShydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24uY29udGFjdC51cmkpIHx8XG4gICAgICAgICAgICAgICAgcnVyaU1hdGNoZXModGhpcy5jb25maWd1cmF0aW9uLmNvbnRhY3QucHViR3J1dSkgfHxcbiAgICAgICAgICAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24uY29udGFjdC50ZW1wR3J1dSkpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUmVxdWVzdC1VUkkgZG9lcyBub3QgcG9pbnQgdG8gdXMuXCIpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kICE9PSBtZXNzYWdlc18xLkMuQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwNCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyA4LjIuMi4xIFRvIGFuZCBSZXF1ZXN0LVVSSVxuICAgICAgICAvLyBPdGhlciBwb3RlbnRpYWwgc291cmNlcyBvZiByZWNlaXZlZCBSZXF1ZXN0LVVSSXMgaW5jbHVkZVxuICAgICAgICAvLyB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGRzIG9mIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgc2VudCBieSB0aGUgVUFcbiAgICAgICAgLy8gdGhhdCBlc3RhYmxpc2ggb3IgcmVmcmVzaCBkaWFsb2dzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4yLjFcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuSU5WSVRFKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzSGVhZGVyKFwiQ29udGFjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogXCJNaXNzaW5nIENvbnRhY3QgSGVhZGVyXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gOC4yLjIuMiBNZXJnZWQgUmVxdWVzdHNcbiAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaGFzIG5vIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkLCB0aGUgVUFTIGNvcmUgTVVTVFxuICAgICAgICAvLyBjaGVjayB0aGUgcmVxdWVzdCBhZ2FpbnN0IG9uZ29pbmcgdHJhbnNhY3Rpb25zLiAgSWYgdGhlIEZyb20gdGFnLFxuICAgICAgICAvLyBDYWxsLUlELCBhbmQgQ1NlcSBleGFjdGx5IG1hdGNoIHRob3NlIGFzc29jaWF0ZWQgd2l0aCBhbiBvbmdvaW5nXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uLCBidXQgdGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggdGhhdCB0cmFuc2FjdGlvbiAoYmFzZWRcbiAgICAgICAgLy8gb24gdGhlIG1hdGNoaW5nIHJ1bGVzIGluIFNlY3Rpb24gMTcuMi4zKSwgdGhlIFVBUyBjb3JlIFNIT1VMRFxuICAgICAgICAvLyBnZW5lcmF0ZSBhIDQ4MiAoTG9vcCBEZXRlY3RlZCkgcmVzcG9uc2UgYW5kIHBhc3MgaXQgdG8gdGhlIHNlcnZlclxuICAgICAgICAvLyB0cmFuc2FjdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgVGhlIHNhbWUgcmVxdWVzdCBoYXMgYXJyaXZlZCBhdCB0aGUgVUFTIG1vcmUgdGhhbiBvbmNlLCBmb2xsb3dpbmdcbiAgICAgICAgLy8gICAgZGlmZmVyZW50IHBhdGhzLCBtb3N0IGxpa2VseSBkdWUgdG8gZm9ya2luZy4gIFRoZSBVQVMgcHJvY2Vzc2VzXG4gICAgICAgIC8vICAgIHRoZSBmaXJzdCBzdWNoIHJlcXVlc3QgcmVjZWl2ZWQgYW5kIHJlc3BvbmRzIHdpdGggYSA0ODIgKExvb3BcbiAgICAgICAgLy8gICAgRGV0ZWN0ZWQpIHRvIHRoZSByZXN0IG9mIHRoZW0uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjIuMlxuICAgICAgICBpZiAoIW1lc3NhZ2UudG9UYWcpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbklkID0gbWVzc2FnZS52aWFCcmFuY2g7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXNlckFnZW50U2VydmVycy5oYXModHJhbnNhY3Rpb25JZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkUmVxdWVzdCA9IEFycmF5LmZyb20odGhpcy51c2VyQWdlbnRTZXJ2ZXJzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgICAgICAuc29tZShmdW5jdGlvbiAodWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1YXMudHJhbnNhY3Rpb24ucmVxdWVzdC5mcm9tVGFnID09PSBtZXNzYWdlLmZyb21UYWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy50cmFuc2FjdGlvbi5yZXF1ZXN0LmNhbGxJZCA9PT0gbWVzc2FnZS5jYWxsSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy50cmFuc2FjdGlvbi5yZXF1ZXN0LmNzZXEgPT09IG1lc3NhZ2UuY3NlcTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDgyIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDguMi4yLjMgUmVxdWlyZVxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4yLjNcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyA4LjIuMyBDb250ZW50IFByb2Nlc3NpbmdcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuM1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDguMi40IEFwcGx5aW5nIEV4dGVuc2lvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNFxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDguMi41IFByb2Nlc3NpbmcgdGhlIFJlcXVlc3RcbiAgICAgICAgLy8gQXNzdW1pbmcgYWxsIG9mIHRoZSBjaGVja3MgaW4gdGhlIHByZXZpb3VzIHN1YnNlY3Rpb25zIGFyZSBwYXNzZWQsXG4gICAgICAgIC8vIHRoZSBVQVMgcHJvY2Vzc2luZyBiZWNvbWVzIG1ldGhvZC1zcGVjaWZpYy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNVxuICAgICAgICAvLyBUaGUgVUFTIHdpbGwgcmVjZWl2ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci4gIElmIHRoZVxuICAgICAgICAvLyByZXF1ZXN0IGhhcyBhIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkLCB0aGUgVUFTIGNvcmUgY29tcHV0ZXMgdGhlXG4gICAgICAgIC8vIGRpYWxvZyBpZGVudGlmaWVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlcXVlc3QgYW5kIGNvbXBhcmVzIGl0IHdpdGhcbiAgICAgICAgLy8gZXhpc3RpbmcgZGlhbG9ncy4gIElmIHRoZXJlIGlzIGEgbWF0Y2gsIHRoaXMgaXMgYSBtaWQtZGlhbG9nIHJlcXVlc3QuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIFVBUyBmaXJzdCBhcHBsaWVzIHRoZSBzYW1lIHByb2Nlc3NpbmcgcnVsZXMgZm9yXG4gICAgICAgIC8vIHJlcXVlc3RzIG91dHNpZGUgb2YgYSBkaWFsb2csIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDguMi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9UYWcpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2ZUluc2lkZURpYWxvZ1JlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVPdXRzaWRlRGlhbG9nUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmNlIGEgZGlhbG9nIGhhcyBiZWVuIGVzdGFibGlzaGVkIGJldHdlZW4gdHdvIFVBcywgZWl0aGVyIG9mIHRoZW1cbiAgICAgKiBNQVkgaW5pdGlhdGUgbmV3IHRyYW5zYWN0aW9ucyBhcyBuZWVkZWQgd2l0aGluIHRoZSBkaWFsb2cuICBUaGUgVUFcbiAgICAgKiBzZW5kaW5nIHRoZSByZXF1ZXN0IHdpbGwgdGFrZSB0aGUgVUFDIHJvbGUgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFRoZVxuICAgICAqIFVBIHJlY2VpdmluZyB0aGUgcmVxdWVzdCB3aWxsIHRha2UgdGhlIFVBUyByb2xlLiAgTm90ZSB0aGF0IHRoZXNlIG1heVxuICAgICAqIGJlIGRpZmZlcmVudCByb2xlcyB0aGFuIHRoZSBVQXMgaGVsZCBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uIHRoYXRcbiAgICAgKiBlc3RhYmxpc2hlZCB0aGUgZGlhbG9nLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlY2VpdmVJbnNpZGVEaWFsb2dSZXF1ZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3RzIGFyZSBtYXRjaGVkIHRvIHN1Y2ggU1VCU0NSSUJFIHJlcXVlc3RzIGlmIHRoZXlcbiAgICAgICAgLy8gY29udGFpbiB0aGUgc2FtZSBcIkNhbGwtSURcIiwgYSBcIlRvXCIgaGVhZGVyIGZpZWxkIFwidGFnXCIgcGFyYW1ldGVyIHRoYXRcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgXCJGcm9tXCIgaGVhZGVyIGZpZWxkIFwidGFnXCIgcGFyYW1ldGVyIG9mIHRoZSBTVUJTQ1JJQkVcbiAgICAgICAgLy8gcmVxdWVzdCwgYW5kIHRoZSBzYW1lIFwiRXZlbnRcIiBoZWFkZXIgZmllbGQuICBSdWxlcyBmb3IgY29tcGFyaXNvbnMgb2ZcbiAgICAgICAgLy8gdGhlIFwiRXZlbnRcIiBoZWFkZXIgZmllbGRzIGFyZSBkZXNjcmliZWQgaW4gU2VjdGlvbiA4LjIuMS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjQuMVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5OT1RJRlkpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkV2ZW50XCIpO1xuICAgICAgICAgICAgaWYgKCFldmVudF8xIHx8ICFldmVudF8xLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogU3Vic2NyaWJlciBpZCBzaG91bGQgYWxzbyBtYXRjaGluZyBvbiBldmVudCBpZC5cbiAgICAgICAgICAgIHZhciBzdWJzY3JpYmVySWQgPSBtZXNzYWdlLmNhbGxJZCArIG1lc3NhZ2UudG9UYWcgKyBldmVudF8xLmV2ZW50O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmliZXIgPSB0aGlzLnN1YnNjcmliZXJzLmdldChzdWJzY3JpYmVySWQpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IHVzZXJfYWdlbnRzXzEuTm90aWZ5VXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIub25Ob3RpZnkodWFzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVxdWVzdHMgc2VudCB3aXRoaW4gYSBkaWFsb2csIGFzIGFueSBvdGhlciByZXF1ZXN0cywgYXJlIGF0b21pYy4gIElmXG4gICAgICAgIC8vIGEgcGFydGljdWxhciByZXF1ZXN0IGlzIGFjY2VwdGVkIGJ5IHRoZSBVQVMsIGFsbCB0aGUgc3RhdGUgY2hhbmdlc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggaXQgYXJlIHBlcmZvcm1lZC4gIElmIHRoZSByZXF1ZXN0IGlzIHJlamVjdGVkLCBub25lXG4gICAgICAgIC8vIG9mIHRoZSBzdGF0ZSBjaGFuZ2VzIGFyZSBwZXJmb3JtZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIE5vdGUgdGhhdCBzb21lIHJlcXVlc3RzLCBzdWNoIGFzIElOVklURXMsIGFmZmVjdCBzZXZlcmFsIHBpZWNlcyBvZlxuICAgICAgICAvLyAgICBzdGF0ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIFVBUyB3aWxsIHJlY2VpdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBJZiB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBoYXMgYSB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCwgdGhlIFVBUyBjb3JlIGNvbXB1dGVzIHRoZVxuICAgICAgICAvLyBkaWFsb2cgaWRlbnRpZmllciBjb3JyZXNwb25kaW5nIHRvIHRoZSByZXF1ZXN0IGFuZCBjb21wYXJlcyBpdCB3aXRoXG4gICAgICAgIC8vIGV4aXN0aW5nIGRpYWxvZ3MuICBJZiB0aGVyZSBpcyBhIG1hdGNoLCB0aGlzIGlzIGEgbWlkLWRpYWxvZyByZXF1ZXN0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICB2YXIgZGlhbG9nSWQgPSBtZXNzYWdlLmNhbGxJZCArIG1lc3NhZ2UudG9UYWcgKyBtZXNzYWdlLmZyb21UYWc7XG4gICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLmRpYWxvZ3MuZ2V0KGRpYWxvZ0lkKTtcbiAgICAgICAgaWYgKGRpYWxvZykge1xuICAgICAgICAgICAgLy8gW1NpcC1pbXBsZW1lbnRvcnNdIFJlZy4gU0lQIHJlaW52aXRlLCBVUERBVEUgYW5kIE9QVElPTlNcbiAgICAgICAgICAgIC8vIFlvdSBnb3QgdGhlIHF1ZXN0aW9uIHJpZ2h0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFuZCB5b3UgZ290IHRoZSByaWdodCBhbnN3ZXIgdG9vLiA6LSlcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIFRoYW5rcyxcbiAgICAgICAgICAgIC8vICAgUGF1bFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJvYmVydCBTcGFya3Mgd3JvdGU6XG4gICAgICAgICAgICAvLyA+IFNvIEkndmUgbG9zdCB0cmFjayBvZiB0aGUgcXVlc3Rpb24gZHVyaW5nIHRoZSBtdXNpbmcuXG4gICAgICAgICAgICAvLyA+XG4gICAgICAgICAgICAvLyA+IEkgX3RoaW5rXyB0aGUgZnVuZGFtZW50YWwgcXVlc3Rpb24gYmVpbmcgYXNrZWQgaXMgdGhpczpcbiAgICAgICAgICAgIC8vID5cbiAgICAgICAgICAgIC8vID4gSXMgYW4gZW5kcG9pbnQgcmVxdWlyZWQgdG8gcmVqZWN0ICh3aXRoIGEgNDgxKSBhbiBPUFRJT05TIHJlcXVlc3QgdGhhdFxuICAgICAgICAgICAgLy8gPiBhcnJpdmVzIHdpdGggYXQgdG8tdGFnIGJ1dCBkb2VzIG5vdCBtYXRjaCBhbnkgZXhpc3RpbmcgZGlhbG9nIHN0YXRlLlxuICAgICAgICAgICAgLy8gPiAoQXNzdW1pbmcgc29tZSBlYXJsaWVyIHJlcXVpcmVtZW50IGhhc24ndCBmb3JjZWQgYW5vdGhlciBlcnJvciBjb2RlKS4gT3JcbiAgICAgICAgICAgIC8vID4gaXMgaXQgT0sgaWYgaXQganVzdCBzZW5kc1xuICAgICAgICAgICAgLy8gPiBhIDIwMCBPSyBhbnlob3cuXG4gICAgICAgICAgICAvLyA+XG4gICAgICAgICAgICAvLyA+IE15IHRha2Ugb24gdGhlIGNvbGxlY3Rpb24gb2Ygc3BlY3MgaXMgdGhhdCBpdHMgX25vdF8gb2sgZm9yIGl0IHRvIHNlbmRcbiAgICAgICAgICAgIC8vID4gdGhlIDIwMCBPSyBhbnlob3cgYW5kIHRoYXQgaXQgaXMgcmVxdWlyZWQgdG8gc2VuZFxuICAgICAgICAgICAgLy8gPiB0aGUgNDgxLiBJIGJhc2UgdGhpcyBwcmltYXJpbHkgb24gdGhlc2Ugc2VudGVuY2VzIGZyb20gMTEuMiBpbiAzMjYxOlxuICAgICAgICAgICAgLy8gPlxuICAgICAgICAgICAgLy8gPiAgICBUaGUgcmVzcG9uc2UgdG8gYW4gT1BUSU9OUyBpcyBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgc3RhbmRhcmQgcnVsZXNcbiAgICAgICAgICAgIC8vID4gICAgZm9yIGEgU0lQIHJlc3BvbnNlIGFzIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDguMi42LiAgVGhlIHJlc3BvbnNlIGNvZGVcbiAgICAgICAgICAgIC8vID4gICAgY2hvc2VuIE1VU1QgYmUgdGhlIHNhbWUgdGhhdCB3b3VsZCBoYXZlIGJlZW4gY2hvc2VuIGhhZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gPiAgICBiZWVuIGFuIElOVklURS5cbiAgICAgICAgICAgIC8vID5cbiAgICAgICAgICAgIC8vID4gRGlkIEkgbWlzcyB0aGUgcG9pbnQgb2YgdGhlIHF1ZXN0aW9uP1xuICAgICAgICAgICAgLy8gPlxuICAgICAgICAgICAgLy8gPiBPbiBNYXkgMTUsIDIwMDgsIGF0IDEyOjQ4IFBNLCBQYXVsIEt5eml2YXQgd3JvdGU6XG4gICAgICAgICAgICAvLyA+XG4gICAgICAgICAgICAvLyA+PiBbSW5jbHVkaW5nIFJvYmVydCBpbiBob3BlcyBvZiBnZXR0aW5nIGhpcyBpbnNpZ2h0IG9uIHRoaXMuXVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9saXN0cy5jcy5jb2x1bWJpYS5lZHUvcGlwZXJtYWlsL3NpcC1pbXBsZW1lbnRvcnMvMjAwOC1NYXkvMDE5MTc4Lmh0bWxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBSZXF1ZXN0cyB0aGF0IGRvIG5vdCBjaGFuZ2UgaW4gYW55IHdheSB0aGUgc3RhdGUgb2YgYSBkaWFsb2cgbWF5IGJlXG4gICAgICAgICAgICAvLyByZWNlaXZlZCB3aXRoaW4gYSBkaWFsb2cgKGZvciBleGFtcGxlLCBhbiBPUFRJT05TIHJlcXVlc3QpLiAgVGhleSBhcmVcbiAgICAgICAgICAgIC8vIHByb2Nlc3NlZCBhcyBpZiB0aGV5IGhhZCBiZWVuIHJlY2VpdmVkIG91dHNpZGUgdGhlIGRpYWxvZy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5PUFRJT05TKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBhbGxvd2VkX21ldGhvZHNfMS5BbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBhY2NlcHRIZWFkZXIgPSBcIkFjY2VwdDogXCIgKyBhY2NlcHRlZEJvZHlUeXBlcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW2FsbG93SGVhZGVyLCBhY2NlcHRIZWFkZXJdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgaW5jb21pbmcgcmVxdWVzdCB0byB0aGUgZGlhbG9nIGZvciBmdXJ0aGVyIGhhbmRsaW5nLlxuICAgICAgICAgICAgZGlhbG9nLnJlY2VpdmVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBiZWhhdmlvcnMgb2YgYSBzdGF0ZWxlc3MgVUFTIGFyZSB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvLyAuLi5cbiAgICAgICAgLy8gbyAgQSBzdGF0ZWxlc3MgVUFTIE1VU1QgaWdub3JlIEFDSyByZXF1ZXN0cy5cbiAgICAgICAgLy8gLi4uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjdcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuQUNLKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGZpbmFsIHJlc3BvbnNlIHRvIGFuIElOVklURSB3YXMgc2VudCBzdGF0ZWxlc3NseSxcbiAgICAgICAgICAgIC8vIHRoZSBjb3JyZXNwb25kaW5nIEFDSzpcbiAgICAgICAgICAgIC8vIC0gd2lsbCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIC0gbWF5IGhhdmUgdGFnIGluIHRoZSBUbyBoZWFkZXIgZmllbGRcbiAgICAgICAgICAgIC8vIC0gbm90IG5vdCBtYXRjaCBhbnkgZXhpc3RpbmcgZGlhbG9nc1xuICAgICAgICAgICAgLy8gQWJzb3JiIHVubWF0Y2hlZCBBQ0tzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGhhcyBhIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkLCBidXQgdGhlIGRpYWxvZ1xuICAgICAgICAvLyBpZGVudGlmaWVyIGRvZXMgbm90IG1hdGNoIGFueSBleGlzdGluZyBkaWFsb2dzLCB0aGUgVUFTIG1heSBoYXZlXG4gICAgICAgIC8vIGNyYXNoZWQgYW5kIHJlc3RhcnRlZCwgb3IgaXQgbWF5IGhhdmUgcmVjZWl2ZWQgYSByZXF1ZXN0IGZvciBhXG4gICAgICAgIC8vIGRpZmZlcmVudCAocG9zc2libHkgZmFpbGVkKSBVQVMgKHRoZSBVQVNzIGNhbiBjb25zdHJ1Y3QgdGhlIFRvIHRhZ3NcbiAgICAgICAgLy8gc28gdGhhdCBhIFVBUyBjYW4gaWRlbnRpZnkgdGhhdCB0aGUgdGFnIHdhcyBmb3IgYSBVQVMgZm9yIHdoaWNoIGl0IGlzXG4gICAgICAgIC8vIHByb3ZpZGluZyByZWNvdmVyeSkuICBBbm90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgdGhlIGluY29taW5nXG4gICAgICAgIC8vIHJlcXVlc3QgaGFzIGJlZW4gc2ltcGx5IG1pcy1yb3V0ZWQuICBCYXNlZCBvbiB0aGUgVG8gdGFnLCB0aGUgVUFTIE1BWVxuICAgICAgICAvLyBlaXRoZXIgYWNjZXB0IG9yIHJlamVjdCB0aGUgcmVxdWVzdC4gIEFjY2VwdGluZyB0aGUgcmVxdWVzdCBmb3JcbiAgICAgICAgLy8gYWNjZXB0YWJsZSBUbyB0YWdzIHByb3ZpZGVzIHJvYnVzdG5lc3MsIHNvIHRoYXQgZGlhbG9ncyBjYW4gcGVyc2lzdFxuICAgICAgICAvLyBldmVuIHRocm91Z2ggY3Jhc2hlcy4gIFVBcyB3aXNoaW5nIHRvIHN1cHBvcnQgdGhpcyBjYXBhYmlsaXR5IG11c3RcbiAgICAgICAgLy8gdGFrZSBpbnRvIGNvbnNpZGVyYXRpb24gc29tZSBpc3N1ZXMgc3VjaCBhcyBjaG9vc2luZyBtb25vdG9uaWNhbGx5XG4gICAgICAgIC8vIGluY3JlYXNpbmcgQ1NlcSBzZXF1ZW5jZSBudW1iZXJzIGV2ZW4gYWNyb3NzIHJlYm9vdHMsIHJlY29uc3RydWN0aW5nXG4gICAgICAgIC8vIHRoZSByb3V0ZSBzZXQsIGFuZCBhY2NlcHRpbmcgb3V0LW9mLXJhbmdlIFJUUCB0aW1lc3RhbXBzIGFuZCBzZXF1ZW5jZVxuICAgICAgICAvLyBudW1iZXJzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgVUFTIHdpc2hlcyB0byByZWplY3QgdGhlIHJlcXVlc3QgYmVjYXVzZSBpdCBkb2VzIG5vdCB3aXNoIHRvXG4gICAgICAgIC8vIHJlY3JlYXRlIHRoZSBkaWFsb2csIGl0IE1VU1QgcmVzcG9uZCB0byB0aGUgcmVxdWVzdCB3aXRoIGEgNDgxXG4gICAgICAgIC8vIChDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KSBzdGF0dXMgY29kZSBhbmQgcGFzcyB0aGF0IHRvIHRoZVxuICAgICAgICAvLyBzZXJ2ZXIgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFzc3VtaW5nIGFsbCBvZiB0aGUgY2hlY2tzIGluIHRoZSBwcmV2aW91cyBzdWJzZWN0aW9ucyBhcmUgcGFzc2VkLFxuICAgICAqIHRoZSBVQVMgcHJvY2Vzc2luZyBiZWNvbWVzIG1ldGhvZC1zcGVjaWZpYy5cbiAgICAgKiAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlY2VpdmVPdXRzaWRlRGlhbG9nUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLkFDSzpcbiAgICAgICAgICAgICAgICAvLyBBYnNvcmIgc3RyYXkgb3V0IG9mIGRpYWxvZyBBQ0tzXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5CWUU6XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIEJZRSBkb2VzIG5vdCBtYXRjaCBhbiBleGlzdGluZyBkaWFsb2csIHRoZSBVQVMgY29yZSBTSE9VTERcbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIDQ4MSAoQ2FsbC9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdCkgcmVzcG9uc2UgYW5kIHBhc3NcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24uIFRoaXMgcnVsZSBtZWFucyB0aGF0IGEgQllFIHNlbnRcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHRhZ3MgYnkgYSBVQUMgd2lsbCBiZSByZWplY3RlZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1LjEuMlxuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5DQU5DRUw6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBvdXQgb2YgZGlhbG9nIHJlcXVlc3QgbWV0aG9kIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5JTkZPOlxuICAgICAgICAgICAgICAgIC8vIFVzZSBvZiB0aGUgSU5GTyBtZXRob2QgZG9lcyBub3QgY29uc3RpdHV0ZSBhIHNlcGFyYXRlIGRpYWxvZyB1c2FnZS5cbiAgICAgICAgICAgICAgICAvLyBJTkZPIG1lc3NhZ2VzIGFyZSBhbHdheXMgcGFydCBvZiwgYW5kIHNoYXJlIHRoZSBmYXRlIG9mLCBhbiBpbnZpdGVcbiAgICAgICAgICAgICAgICAvLyBkaWFsb2cgdXNhZ2UgW1JGQzUwNTddLiAgSU5GTyBtZXNzYWdlcyBjYW5ub3QgYmUgc2VudCBhcyBwYXJ0IG9mXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgZGlhbG9nIHVzYWdlcywgb3Igb3V0c2lkZSBhbiBleGlzdGluZyBkaWFsb2cuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwODYjc2VjdGlvbi0xXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwNSB9KTsgLy8gU2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuSU5WSVRFOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IHVzZXJfYWdlbnRzXzEuSW52aXRlVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25JbnZpdGUodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuTUVTU0FHRTpcbiAgICAgICAgICAgICAgICAvLyBNRVNTQUdFIHJlcXVlc3RzIGFyZSBkaXNjb3VyYWdlZCBpbnNpZGUgYSBkaWFsb2cuICBJbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBhcmUgcmVzdHJpY3RlZCBmcm9tIGNyZWF0aW5nIGEgdXNhZ2UgZm9yIHRoZSBwdXJwb3NlIG9mIGNhcnJ5aW5nIGFcbiAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZSBvZiBNRVNTQUdFIHJlcXVlc3RzICh0aG91Z2ggc29tZSBpbXBsZW1lbnRhdGlvbnMgdXNlIGl0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3YXksIGFnYWluc3QgdGhlIHN0YW5kYXJkIHJlY29tbWVuZGF0aW9uKS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTA1NyNzZWN0aW9uLTUuM1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyB1c2VyX2FnZW50c18xLk1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25NZXNzYWdlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25NZXNzYWdlKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLk5PVElGWTpcbiAgICAgICAgICAgICAgICAvLyBPYnNvbGV0ZWQgYnk6IFJGQyA2NjY1XG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IG5vbi1TVUJTQ1JJQkUgbWVjaGFuaXNtcyBhcmUgZGVmaW5lZCB0byBjcmVhdGUgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHBhcnRpZXMgZGVmaW5pbmcgdGhvc2UgbWVjaGFuaXNtcyB0b1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGNvcnJlbGF0aW9uIG9mIGEgTk9USUZZIG1lc3NhZ2UgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gaXMgcG9zc2libGUuICBEZXNpZ25lcnMgb2Ygc3VjaCBtZWNoYW5pc21zIGFyZSBhbHNvXG4gICAgICAgICAgICAgICAgLy8gd2FybmVkIHRvIG1ha2UgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHNlbmRpbmcgYSBOT1RJRlkgbWVzc2FnZSB0byBhXG4gICAgICAgICAgICAgICAgLy8gc3Vic2NyaWJlciB3aG8gaXMgYXdhcmUgb2YgdGhlIHN1YnNjcmlwdGlvbiwgYW5kIHNlbmRpbmcgYSBOT1RJRllcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHRvIGFuIHVuc3VzcGVjdGluZyBub2RlLiAgVGhlIGxhdHRlciBiZWhhdmlvciBpcyBpbnZhbGlkLCBhbmRcbiAgICAgICAgICAgICAgICAvLyBNVVNUIHJlY2VpdmUgYSBcIjQ4MSBTdWJzY3JpcHRpb24gZG9lcyBub3QgZXhpc3RcIiByZXNwb25zZSAodW5sZXNzXG4gICAgICAgICAgICAgICAgLy8gc29tZSBvdGhlciA0MDAtIG9yIDUwMC1jbGFzcyBlcnJvciBjb2RlIGlzIG1vcmUgYXBwbGljYWJsZSksIGFzXG4gICAgICAgICAgICAgICAgLy8gZGVzY3JpYmVkIGluIHNlY3Rpb24gMy4yLjQuICBJbiBvdGhlciB3b3Jkcywga25vd2xlZGdlIG9mIGFcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gbXVzdCBleGlzdCBpbiBib3RoIHRoZSBzdWJzY3JpYmVyIGFuZCB0aGUgbm90aWZpZXIgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyB2YWxpZCwgZXZlbiBpZiBpbnN0YWxsZWQgdmlhIGEgbm9uLVNVQlNDUklCRSBtZWNoYW5pc20uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjUjc2VjdGlvbi0zLjJcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBhcmUgc2VudCB0byBpbmZvcm0gc3Vic2NyaWJlcnMgb2YgY2hhbmdlcyBpbiBzdGF0ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRoZSBzdWJzY3JpYmVyIGhhcyBhIHN1YnNjcmlwdGlvbi4gIFN1YnNjcmlwdGlvbnMgYXJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0aGUgU1VCU0NSSUJFIG1ldGhvZC4gIEluIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbnMsIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gcG9zc2libGUgdGhhdCBvdGhlciBtZWFucyBvZiBzdWJzY3JpcHRpb24gY3JlYXRpb24gaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhpcyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGFsbG93IHRoZSBjcmVhdGlvbiBvZlxuICAgICAgICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbnMgZXhjZXB0IHRocm91Z2ggU1VCU0NSSUJFIHJlcXVlc3RzIGFuZCAoZm9yIGJhY2t3YXJkcy1cbiAgICAgICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5KSBSRUZFUiByZXF1ZXN0cyBbUkZDMzUxNV0uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi0zLjJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgdXNlcl9hZ2VudHNfMS5Ob3RpZnlVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSh1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0MDUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuT1BUSU9OUzpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTExLjJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxvd0hlYWRlciA9IFwiQWxsb3c6IFwiICsgYWxsb3dlZF9tZXRob2RzXzEuQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY2VwdEhlYWRlciA9IFwiQWNjZXB0OiBcIiArIGFjY2VwdGVkQm9keVR5cGVzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbYWxsb3dIZWFkZXIsIGFjY2VwdEhlYWRlcl1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuUkVGRVI6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuMlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyB1c2VyX2FnZW50c18xLlJlZmVyVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVmZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZmVyKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQwNSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5SRUdJU1RFUjpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjNcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgdXNlcl9hZ2VudHNfMS5SZWdpc3RlclVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZ2lzdGVyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWdpc3Rlcih1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0MDUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuU1VCU0NSSUJFOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4yXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IHVzZXJfYWdlbnRzXzEuU3Vic2NyaWJlVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uU3Vic2NyaWJlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25TdWJzY3JpYmUodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDgwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBvdXQgb2YgZGlhbG9nIHJlcXVlc3QgbWV0aG9kIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzcG9uc2VzIGFyZSBmaXJzdCBwcm9jZXNzZWQgYnkgdGhlIHRyYW5zcG9ydCBsYXllciBhbmQgdGhlbiBwYXNzZWRcbiAgICAgKiB1cCB0byB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBUaGUgdHJhbnNhY3Rpb24gbGF5ZXIgcGVyZm9ybXMgaXRzXG4gICAgICogcHJvY2Vzc2luZyBhbmQgdGhlbiBwYXNzZXMgdGhlIHJlc3BvbnNlIHVwIHRvIHRoZSBUVS4gIFRoZSBtYWpvcml0eVxuICAgICAqIG9mIHJlc3BvbnNlIHByb2Nlc3NpbmcgaW4gdGhlIFRVIGlzIG1ldGhvZCBzcGVjaWZpYy4gIEhvd2V2ZXIsIHRoZXJlXG4gICAgICogYXJlIHNvbWUgZ2VuZXJhbCBiZWhhdmlvcnMgaW5kZXBlbmRlbnQgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGZyb20gdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZUZyb21UcmFuc3BvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyA4LjEuMy4xIFRyYW5zYWN0aW9uIExheWVyIEVycm9yc1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjFcbiAgICAgICAgLy8gSGFuZGxlZCBieSB0cmFuc2FjdGlvbiBsYXllciBjYWxsYmFja3MuXG4gICAgICAgIC8vIDguMS4zLjIgVW5yZWNvZ25pemVkIFJlc3BvbnNlc1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjFcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyA4LjEuMy4zIFZpYXNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4zXG4gICAgICAgIGlmIChtZXNzYWdlLmdldEhlYWRlcnMoXCJ2aWFcIikubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk1vcmUgdGhhbiBvbmUgVmlhIGhlYWRlciBmaWVsZCBwcmVzZW50IGluIHRoZSByZXNwb25zZSwgZHJvcHBpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gOC4xLjMuNCBQcm9jZXNzaW5nIDN4eCBSZXNwb25zZXNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy40XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gOC4xLjMuNSBQcm9jZXNzaW5nIDR4eCBSZXNwb25zZXNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy41XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gV2hlbiB0aGUgdHJhbnNwb3J0IGxheWVyIGluIHRoZSBjbGllbnQgcmVjZWl2ZXMgYSByZXNwb25zZSwgaXQgaGFzIHRvXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBjbGllbnQgdHJhbnNhY3Rpb24gd2lsbCBoYW5kbGUgdGhlIHJlc3BvbnNlLCBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBwcm9jZXNzaW5nIG9mIFNlY3Rpb25zIDE3LjEuMSBhbmQgMTcuMS4yIGNhbiB0YWtlIHBsYWNlLiAgVGhlXG4gICAgICAgIC8vIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHRvcCBWaWEgaGVhZGVyIGZpZWxkIGlzIHVzZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gcHVycG9zZS4gIEEgcmVzcG9uc2UgbWF0Y2hlcyBhIGNsaWVudCB0cmFuc2FjdGlvbiB1bmRlciB0d29cbiAgICAgICAgLy8gY29uZGl0aW9uczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgMS4gIElmIHRoZSByZXNwb25zZSBoYXMgdGhlIHNhbWUgdmFsdWUgb2YgdGhlIGJyYW5jaCBwYXJhbWV0ZXIgaW5cbiAgICAgICAgLy8gICAgICAgIHRoZSB0b3AgVmlhIGhlYWRlciBmaWVsZCBhcyB0aGUgYnJhbmNoIHBhcmFtZXRlciBpbiB0aGUgdG9wXG4gICAgICAgIC8vICAgICAgICBWaWEgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIDIuICBJZiB0aGUgbWV0aG9kIHBhcmFtZXRlciBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgbWF0Y2hlcyB0aGVcbiAgICAgICAgLy8gICAgICAgIG1ldGhvZCBvZiB0aGUgcmVxdWVzdCB0aGF0IGNyZWF0ZWQgdGhlIHRyYW5zYWN0aW9uLiAgVGhlXG4gICAgICAgIC8vICAgICAgICBtZXRob2QgaXMgbmVlZGVkIHNpbmNlIGEgQ0FOQ0VMIHJlcXVlc3QgY29uc3RpdHV0ZXMgYVxuICAgICAgICAvLyAgICAgICAgZGlmZmVyZW50IHRyYW5zYWN0aW9uLCBidXQgc2hhcmVzIHRoZSBzYW1lIHZhbHVlIG9mIHRoZSBicmFuY2hcbiAgICAgICAgLy8gICAgICAgIHBhcmFtZXRlci5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjNcbiAgICAgICAgdmFyIHVzZXJBZ2VudENsaWVudElkID0gbWVzc2FnZS52aWFCcmFuY2ggKyBtZXNzYWdlLm1ldGhvZDtcbiAgICAgICAgdmFyIHVzZXJBZ2VudENsaWVudCA9IHRoaXMudXNlckFnZW50Q2xpZW50cy5nZXQodXNlckFnZW50Q2xpZW50SWQpO1xuICAgICAgICAvLyBUaGUgY2xpZW50IHRyYW5zcG9ydCB1c2VzIHRoZSBtYXRjaGluZyBwcm9jZWR1cmVzIG9mIFNlY3Rpb25cbiAgICAgICAgLy8gMTcuMS4zIHRvIGF0dGVtcHQgdG8gbWF0Y2ggdGhlIHJlc3BvbnNlIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uLiAgSWYgdGhlcmUgaXMgYSBtYXRjaCwgdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvXG4gICAgICAgIC8vIHRoYXQgdHJhbnNhY3Rpb24uICBPdGhlcndpc2UsIGFueSBlbGVtZW50IG90aGVyIHRoYW4gYSBzdGF0ZWxlc3NcbiAgICAgICAgLy8gcHJveHkgTVVTVCBzaWxlbnRseSBkaXNjYXJkIHRoZSByZXNwb25zZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjlcbiAgICAgICAgaWYgKHVzZXJBZ2VudENsaWVudCkge1xuICAgICAgICAgICAgdXNlckFnZW50Q2xpZW50LnRyYW5zYWN0aW9uLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJEaXNjYXJkaW5nIHVubWF0Y2hlZCBcIiArIG1lc3NhZ2Uuc3RhdHVzQ29kZSArIFwiIHJlc3BvbnNlIHRvIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiBcIiArIHVzZXJBZ2VudENsaWVudElkICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVXNlckFnZW50Q29yZTtcbn0oKSk7XG5leHBvcnRzLlVzZXJBZ2VudENvcmUgPSBVc2VyQWdlbnRDb3JlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIEJZRSBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBCeWVVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQnllVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ5ZVVzZXJBZ2VudENsaWVudChkaWFsb2csIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLkJZRSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgZGlhbG9nLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnllVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5CeWVVc2VyQWdlbnRDbGllbnQgPSBCeWVVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIEJZRSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBCeWVVc2VyQWdlbnRTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQnllVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ5ZVVzZXJBZ2VudFNlcnZlcihkaWFsb2csIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnllVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5CeWVVc2VyQWdlbnRTZXJ2ZXIgPSBCeWVVc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIENBTkNFTCBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBDYW5jZWxVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2FuY2VsVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmNlbFVzZXJBZ2VudENsaWVudChjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2FuY2VsVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5DYW5jZWxVc2VyQWdlbnRDbGllbnQgPSBDYW5jZWxVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnllLXVzZXItYWdlbnQtY2xpZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5ZS11c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jYW5jZWwtdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5mby11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmZvLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludml0ZS11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVzc2FnZS11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXNzYWdlLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vdGlmeS11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ub3RpZnktdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHVibGlzaC11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcmFjay11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcmFjay11c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZS1pbnZpdGUtdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmUtaW52aXRlLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlLXN1YnNjcmliZS11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZS1zdWJzY3JpYmUtdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVmZXItdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVmZXItdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVnaXN0ZXItdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVnaXN0ZXItdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3Vic2NyaWJlLXVzZXItYWdlbnQtY2xpZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N1YnNjcmliZS11c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogSU5GTyBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbmZvVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEluZm9Vc2VyQWdlbnRDbGllbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mb1VzZXJBZ2VudENsaWVudChkaWFsb2csIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLklORk8sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEluZm9Vc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLkluZm9Vc2VyQWdlbnRDbGllbnQgPSBJbmZvVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBJTkZPIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEluZm9Vc2VyQWdlbnRTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW5mb1VzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZvVXNlckFnZW50U2VydmVyKGRpYWxvZywgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbmZvVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5JbmZvVXNlckFnZW50U2VydmVyID0gSW5mb1VzZXJBZ2VudFNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZGlhbG9nc18xID0gcmVxdWlyZShcIi4uL2RpYWxvZ3NcIik7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4uL3Nlc3Npb25cIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogSU5WSVRFIFVBQy5cbiAqIEByZW1hcmtzXG4gKiAxMyBJbml0aWF0aW5nIGEgU2Vzc2lvblxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xM1xuICogMTMuMSBPdmVydmlld1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4xXG4gKiAxMy4yIFVBQyBQcm9jZXNzaW5nXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjJcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEludml0ZVVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZpdGVVc2VyQWdlbnRDbGllbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52aXRlVXNlckFnZW50Q2xpZW50KGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZmlybWVkRGlhbG9nQWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMuY29uZmlybWVkRGlhbG9ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMuZWFybHlEaWFsb2dzID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEludml0ZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIFVBQyBjb3JlIGNvbnNpZGVycyB0aGUgSU5WSVRFIHRyYW5zYWN0aW9uIGNvbXBsZXRlZCA2NCpUMSBzZWNvbmRzXG4gICAgICAgIC8vIGFmdGVyIHRoZSByZWNlcHRpb24gb2YgdGhlIGZpcnN0IDJ4eCByZXNwb25zZS4gIEF0IHRoaXMgcG9pbnQgYWxsIHRoZVxuICAgICAgICAvLyBlYXJseSBkaWFsb2dzIHRoYXQgaGF2ZSBub3QgdHJhbnNpdGlvbmVkIHRvIGVzdGFibGlzaGVkIGRpYWxvZ3MgYXJlXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQuICBPbmNlIHRoZSBJTlZJVEUgdHJhbnNhY3Rpb24gaXMgY29uc2lkZXJlZCBjb21wbGV0ZWQgYnlcbiAgICAgICAgLy8gdGhlIFVBQyBjb3JlLCBubyBtb3JlIG5ldyAyeHggcmVzcG9uc2VzIGFyZSBleHBlY3RlZCB0byBhcnJpdmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmLCBhZnRlciBhY2tub3dsZWRnaW5nIGFueSAyeHggcmVzcG9uc2UgdG8gYW4gSU5WSVRFLCB0aGUgVUFDIGRvZXNcbiAgICAgICAgLy8gbm90IHdhbnQgdG8gY29udGludWUgd2l0aCB0aGF0IGRpYWxvZywgdGhlbiB0aGUgVUFDIE1VU1QgdGVybWluYXRlXG4gICAgICAgIC8vIHRoZSBkaWFsb2cgYnkgc2VuZGluZyBhIEJZRSByZXF1ZXN0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDE1LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2dzLmZvckVhY2goZnVuY3Rpb24gKGVhcmx5RGlhbG9nKSB7IHJldHVybiBlYXJseURpYWxvZy5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5jbGVhcigpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBmb3IgdHJhbnNwb3J0IGVycm9yIHdoaWxlIHNlbmRpbmcgQUNLLlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRyYW5zcG9ydCBlcnJvclxuICAgICAqL1xuICAgIEludml0ZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vdCBpbiAnY2FsbGluZycgc3RhdGUsIHRoZSB0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgc2VuZGluZyBhbiBBQ0suXG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlVzZXIgYWdlbnQgY2xpZW50IHJlcXVlc3QgdHJhbnNwb3J0IGVycm9yIHdoaWxlIHNlbmRpbmcgQUNLLlwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9uY2UgdGhlIElOVklURSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24sIHRoZVxuICAgICAqIFVBQyB3YWl0cyBmb3IgcmVzcG9uc2VzIGZvciB0aGUgSU5WSVRFLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yXG4gICAgICogQHBhcmFtIGluY29taW5nUmVzcG9uc2UgLSBJbmNvbWluZyByZXNwb25zZSB0byBJTlZJVEUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBJbnZpdGVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBtZXNzYWdlLnN0YXR1c0NvZGUgPyBtZXNzYWdlLnN0YXR1c0NvZGUudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgIGlmICghc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugc3RhdHVzIGNvZGUgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgL14xMDAkLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25UcnlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblRyeWluZyh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIC8vIFplcm8sIG9uZSBvciBtdWx0aXBsZSBwcm92aXNpb25hbCByZXNwb25zZXMgbWF5IGFycml2ZSBiZWZvcmUgb25lIG9yXG4gICAgICAgICAgICAgICAgLy8gbW9yZSBmaW5hbCByZXNwb25zZXMgYXJlIHJlY2VpdmVkLiAgUHJvdmlzaW9uYWwgcmVzcG9uc2VzIGZvciBhblxuICAgICAgICAgICAgICAgIC8vIElOVklURSByZXF1ZXN0IGNhbiBjcmVhdGUgXCJlYXJseSBkaWFsb2dzXCIuICBJZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gaGFzIGEgdGFnIGluIHRoZSBUbyBmaWVsZCwgYW5kIGlmIHRoZSBkaWFsb2cgSUQgb2YgdGhlIHJlc3BvbnNlIGRvZXNcbiAgICAgICAgICAgICAgICAvLyBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgZGlhbG9nLCBvbmUgaXMgY29uc3RydWN0ZWQgdXNpbmcgdGhlIHByb2NlZHVyZXNcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIGluIFNlY3Rpb24gMTIuMS4yLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVhcmx5IGRpYWxvZyB3aWxsIG9ubHkgYmUgbmVlZGVkIGlmIHRoZSBVQUMgbmVlZHMgdG8gc2VuZCBhXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCB0byBpdHMgcGVlciB3aXRoaW4gdGhlIGRpYWxvZyBiZWZvcmUgdGhlIGluaXRpYWwgSU5WSVRFXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gY29tcGxldGVzLiAgSGVhZGVyIGZpZWxkcyBwcmVzZW50IGluIGEgcHJvdmlzaW9uYWxcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZSBhcmUgYXBwbGljYWJsZSBhcyBsb25nIGFzIHRoZSBkaWFsb2cgaXMgaW4gdGhlIGVhcmx5IHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gKGZvciBleGFtcGxlLCBhbiBBbGxvdyBoZWFkZXIgZmllbGQgaW4gYSBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIGRpYWxvZyB3aGlsZSB0aGlzIGlzIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVhcmx5IHN0YXRlKS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4xXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm92aXNpb25hbCB3aXRob3V0IHRvIHRhZywgbm8gZGlhbG9nIHRvIGNyZWF0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnRvVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm9uLTEwMCAxeHggSU5WSVRFIHJlc3BvbnNlIHJlY2VpdmVkIHdpdGhvdXQgYSB0byB0YWcsIGRyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGRpYWxvZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWxvZ1N0YXRlID0gZGlhbG9nc18xLkRpYWxvZy5pbml0aWFsRGlhbG9nU3RhdGVGb3JVc2VyQWdlbnRDbGllbnQodGhpcy5tZXNzYWdlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2ZSBleGlzdGluZyBlYXJseSBkaWFsb2cgb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhcmx5RGlhbG9nID0gdGhpcy5lYXJseURpYWxvZ3MuZ2V0KGRpYWxvZ1N0YXRlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlYXJseURpYWxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nID0gbmV3IGRpYWxvZ3NfMS5TZXNzaW9uRGlhbG9nKHRyYW5zYWN0aW9uLCB0aGlzLmNvcmUsIGRpYWxvZ1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzLnNldChlYXJseURpYWxvZy5pZCwgZWFybHlEaWFsb2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3Qgb3V0IG9mIG9yZGVyIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgd2hlcmUgdGhlIHJzZXEgdHJhY2tpbmcgaXMgZG9uZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlYXJseURpYWxvZy5yZWxpYWJsZVNlcXVlbmNlR3VhcmQobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCIxeHggSU5WSVRFIHJlbGlhYmxlIHJlc3BvbnNlIHJlY2VpdmVkIG91dCBvZiBvcmRlciwgZHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIGFuIElOVklURSwgdGhlIGFuc3dlciBNVVNUIGJlIGluIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsaWFibGUgbm9uLWZhaWx1cmUgbWVzc2FnZSBmcm9tIFVBUyBiYWNrIHRvIFVBQyB3aGljaCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWxhdGVkIHRvIHRoYXQgSU5WSVRFLiAgRm9yIHRoaXMgc3BlY2lmaWNhdGlvbiwgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSBmaW5hbCAyeHggcmVzcG9uc2UgdG8gdGhhdCBJTlZJVEUuICBUaGF0IHNhbWUgZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5zd2VyIE1BWSBhbHNvIGJlIHBsYWNlZCBpbiBhbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHNlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3IgdG8gdGhlIGFuc3dlci4gIFRoZSBVQUMgTVVTVCB0cmVhdCB0aGUgZmlyc3Qgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXNjcmlwdGlvbiBpdCByZWNlaXZlcyBhcyB0aGUgYW5zd2VyLCBhbmQgTVVTVCBpZ25vcmUgYW55XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gZGVzY3JpcHRpb25zIGluIHN1YnNlcXVlbnQgcmVzcG9uc2VzIHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIElOVklURS5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhcmx5RGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlEaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlEaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgcmVzcG9uc2UgdG8gZGVsZWdhdGUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uXzIgPSBlYXJseURpYWxvZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogc2Vzc2lvbl8yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByYWNrOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdQcmFja1JlcXVlc3QgPSBzZXNzaW9uXzIucHJhY2sodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGdvaW5nUHJhY2tSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIDJ4eCByZXNwb25zZXMgbWF5IGFycml2ZSBhdCB0aGUgVUFDIGZvciBhIHNpbmdsZSBJTlZJVEVcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGR1ZSB0byBhIGZvcmtpbmcgcHJveHkuICBFYWNoIHJlc3BvbnNlIGlzIGRpc3Rpbmd1aXNoZWQgYnlcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGFnIHBhcmFtZXRlciBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkLCBhbmQgZWFjaCByZXByZXNlbnRzIGFcbiAgICAgICAgICAgICAgICAvLyBkaXN0aW5jdCBkaWFsb2csIHdpdGggYSBkaXN0aW5jdCBkaWFsb2cgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWFsb2cgaWRlbnRpZmllciBpbiB0aGUgMnh4IHJlc3BvbnNlIG1hdGNoZXMgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgIC8vIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgZGlhbG9nIE1VU1QgYmUgdHJhbnNpdGlvbmVkIHRvXG4gICAgICAgICAgICAgICAgLy8gdGhlIFwiY29uZmlybWVkXCIgc3RhdGUsIGFuZCB0aGUgcm91dGUgc2V0IGZvciB0aGUgZGlhbG9nIE1VU1QgYmVcbiAgICAgICAgICAgICAgICAvLyByZWNvbXB1dGVkIGJhc2VkIG9uIHRoZSAyeHggcmVzcG9uc2UgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvblxuICAgICAgICAgICAgICAgIC8vIDEyLjIuMS4yLiAgT3RoZXJ3aXNlLCBhIG5ldyBkaWFsb2cgaW4gdGhlIFwiY29uZmlybWVkXCIgc3RhdGUgTVVTVCBiZVxuICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTIuMS4yLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZGlhbG9nIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhbG9nU3RhdGUgPSBkaWFsb2dzXzEuRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudENsaWVudCh0aGlzLm1lc3NhZ2UsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBDdXJyZW50bHkgb3VyIHRyYW5zYWN0aW9uIGxheWVyIGlzIGNhY2hpbmcgdGhlIDJ4eCBBQ0tzIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGluZyByZXRyYW5zbWlzc2lvbnMgb2YgdGhlIEFDSyB3aGljaCBpcyBhbiBhcHByb2FjaCB3aGljaCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdG8gc3BlYy4gSW4gYW55IGV2ZW50LCB0aGlzIGJsb2NrIGlzIGludGVuZGVkIHRvIHByb3ZpZGUgYSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjIGltcGxlbWVudGF0aW9uIG9mIEFDSyByZXRyYW5zbWlzc2lvbnMsIGJ1dCBpdCBzaG91bGQgbm90IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpdCBjdXJyZW50bHkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLmNvbmZpcm1lZERpYWxvZ3MuZ2V0KGRpYWxvZ1N0YXRlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpYWxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSB0aGUgQUNLIGhhcyBiZWVuIGNvbnN0cnVjdGVkLCB0aGUgcHJvY2VkdXJlcyBvZiBbNF0gYXJlIHVzZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZGVzdGluYXRpb24gYWRkcmVzcywgcG9ydCBhbmQgdHJhbnNwb3J0LiAgSG93ZXZlciwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGRpcmVjdGx5IGZvciB0cmFuc21pc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYXRoZXIgdGhhbiBhIGNsaWVudCB0cmFuc2FjdGlvbi4gIFRoaXMgaXMgYmVjYXVzZSB0aGUgVUFDIGNvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZXMgcmV0cmFuc21pc3Npb25zIG9mIHRoZSBBQ0ssIG5vdCB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBUaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFDSyBNVVNUIGJlIHBhc3NlZCB0byB0aGUgY2xpZW50IHRyYW5zcG9ydCBldmVyeSB0aW1lIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHJhbnNtaXNzaW9uIG9mIHRoZSAyeHggZmluYWwgcmVzcG9uc2UgdGhhdCB0cmlnZ2VyZWQgdGhlIEFDS1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyaXZlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRnb2luZ0Fja1JlcXVlc3QgPSB0aGlzLmNvbmZpcm1lZERpYWxvZ0Fja3MuZ2V0KGRpYWxvZ1N0YXRlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRnb2luZ0Fja1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCB0cmFuc2FjdGlvbiBub3QgaW5zdGFuY2Ugb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2tSZXNwb25zZShvdXRnb2luZ0Fja1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGlsbCB3YWl0aW5nIGZvciBhbiBBQ0ssIGRyb3AgdGhlIHJldHJhbnNtaXNzaW9uIG9mIHRoZSAyeHggZmluYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpYWxvZyBpZGVudGlmaWVyIGluIHRoZSAyeHggcmVzcG9uc2UgbWF0Y2hlcyB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgIC8vIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgZGlhbG9nIE1VU1QgYmUgdHJhbnNpdGlvbmVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlLCBhbmQgdGhlIHJvdXRlIHNldCBmb3IgdGhlIGRpYWxvZyBNVVNUIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY29tcHV0ZWQgYmFzZWQgb24gdGhlIDJ4eCByZXNwb25zZSB1c2luZyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIDEyLjIuMS4yLiBPdGhlcndpc2UsIGEgbmV3IGRpYWxvZyBpbiB0aGUgXCJjb25maXJtZWRcIiBzdGF0ZSBNVVNUIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTIuMS4yLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzLmdldChkaWFsb2dTdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jb25maXJtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cucmVjb21wdXRlUm91dGVTZXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5kZWxldGUoZGlhbG9nLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybWVkRGlhbG9ncy5zZXQoZGlhbG9nLmlkLCBkaWFsb2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZyA9IG5ldyBkaWFsb2dzXzEuU2Vzc2lvbkRpYWxvZyh0cmFuc2FjdGlvbiwgdGhpcy5jb3JlLCBkaWFsb2dTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZ3Muc2V0KGRpYWxvZy5pZCwgZGlhbG9nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiBhbiBJTlZJVEUsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGlhYmxlIG5vbi1mYWlsdXJlIG1lc3NhZ2UgZnJvbSBVQVMgYmFjayB0byBVQUMgd2hpY2ggaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVsYXRlZCB0byB0aGF0IElOVklURS4gIEZvciB0aGlzIHNwZWNpZmljYXRpb24sIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFLiAgVGhhdCBzYW1lIGV4YWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuc3dlciBNQVkgYWxzbyBiZSBwbGFjZWQgaW4gYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBzZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHByaW9yIHRvIHRoZSBhbnN3ZXIuICBUaGUgVUFDIE1VU1QgdHJlYXQgdGhlIGZpcnN0IHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRpb24gaXQgcmVjZWl2ZXMgYXMgdGhlIGFuc3dlciwgYW5kIE1VU1QgaWdub3JlIGFueVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGRlc2NyaXB0aW9ucyBpbiBzdWJzZXF1ZW50IHJlc3BvbnNlcyB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAvLyBJTlZJVEUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXNzaW9uIEluaXRpYXRlZCEgOilcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlc3Npb25fMyA9IGRpYWxvZztcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFVBQyBjb3JlIE1VU1QgZ2VuZXJhdGUgYW4gQUNLIHJlcXVlc3QgZm9yIGVhY2ggMnh4IHJlY2VpdmVkIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRyYW5zYWN0aW9uIGxheWVyLiAgVGhlIGhlYWRlciBmaWVsZHMgb2YgdGhlIEFDSyBhcmUgY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHNhbWUgd2F5IGFzIGZvciBhbnkgcmVxdWVzdCBzZW50IHdpdGhpbiBhIGRpYWxvZyAoc2VlIFNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gMTIpIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgQ1NlcSBhbmQgdGhlIGhlYWRlciBmaWVsZHMgcmVsYXRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbi4gIFRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIENTZXEgaGVhZGVyIGZpZWxkIE1VU1QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNhbWUgYXMgdGhlIElOVklURSBiZWluZyBhY2tub3dsZWRnZWQsIGJ1dCB0aGUgQ1NlcSBtZXRob2QgTVVTVFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBBQ0suICBUaGUgQUNLIE1VU1QgY29udGFpbiB0aGUgc2FtZSBjcmVkZW50aWFscyBhcyB0aGUgSU5WSVRFLiAgSWZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIDJ4eCBjb250YWlucyBhbiBvZmZlciAoYmFzZWQgb24gdGhlIHJ1bGVzIGFib3ZlKSwgdGhlIEFDSyBNVVNUXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhcnJ5IGFuIGFuc3dlciBpbiBpdHMgYm9keS4gIElmIHRoZSBvZmZlciBpbiB0aGUgMnh4IHJlc3BvbnNlIGlzIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHRhYmxlLCB0aGUgVUFDIGNvcmUgTVVTVCBnZW5lcmF0ZSBhIHZhbGlkIGFuc3dlciBpbiB0aGUgQUNLIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHNlbmQgYSBCWUUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiBzZXNzaW9uXzMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNrOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdBY2tSZXF1ZXN0ID0gc2Vzc2lvbl8zLmFjayhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29uZmlybWVkRGlhbG9nQWNrcy5zZXQoc2Vzc2lvbl8zLmlkLCBvdXRnb2luZ0Fja1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0Z29pbmdBY2tSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dGdvaW5nQWNrUmVxdWVzdCA9IHNlc3Npb25fMy5hY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybWVkRGlhbG9nQWNrcy5zZXQoc2Vzc2lvbl8zLmlkLCBvdXRnb2luZ0Fja1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgL14zWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIC8vIDEyLjMgVGVybWluYXRpb24gb2YgYSBEaWFsb2dcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluZGVwZW5kZW50IG9mIHRoZSBtZXRob2QsIGlmIGEgcmVxdWVzdCBvdXRzaWRlIG9mIGEgZGlhbG9nIGdlbmVyYXRlc1xuICAgICAgICAgICAgICAgIC8vIGEgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSwgYW55IGVhcmx5IGRpYWxvZ3MgY3JlYXRlZCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHRvIHRoYXQgcmVxdWVzdCBhcmUgdGVybWluYXRlZC4gIFRoZSBtZWNoYW5pc21cbiAgICAgICAgICAgICAgICAvLyBmb3IgdGVybWluYXRpbmcgY29uZmlybWVkIGRpYWxvZ3MgaXMgbWV0aG9kIHNwZWNpZmljLiAgSW4gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYXRpb24sIHRoZSBCWUUgbWV0aG9kIHRlcm1pbmF0ZXMgYSBzZXNzaW9uIGFuZCB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIGl0LiAgU2VlIFNlY3Rpb24gMTUgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4zXG4gICAgICAgICAgICAgICAgLy8gQWxsIGVhcmx5IGRpYWxvZ3MgYXJlIGNvbnNpZGVyZWQgdGVybWluYXRlZCB1cG9uIHJlY2VwdGlvbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBub24tMnh4IGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgaGF2aW5nIHJlY2VpdmVkIHRoZSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIHRoZSBVQUMgY29yZVxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVycyB0aGUgSU5WSVRFIHRyYW5zYWN0aW9uIGNvbXBsZXRlZC4gIFRoZSBJTlZJVEUgY2xpZW50XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gaGFuZGxlcyB0aGUgZ2VuZXJhdGlvbiBvZiBBQ0tzIGZvciB0aGUgcmVzcG9uc2UgKHNlZVxuICAgICAgICAgICAgICAgIC8vIFNlY3Rpb24gMTcpLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjNcbiAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChlYXJseURpYWxvZykgeyByZXR1cm4gZWFybHlEaWFsb2cuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIC8vIEEgM3h4IHJlc3BvbnNlIG1heSBjb250YWluIG9uZSBvciBtb3JlIENvbnRhY3QgaGVhZGVyIGZpZWxkIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGluZyBuZXcgYWRkcmVzc2VzIHdoZXJlIHRoZSBjYWxsZWUgbWlnaHQgYmUgcmVhY2hhYmxlLlxuICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIDN4eCByZXNwb25zZSAoc2VlIFNlY3Rpb24gMjEuMyksXG4gICAgICAgICAgICAgICAgLy8gdGhlIFVBQyBNQVkgY2hvb3NlIHRvIHRyeSB0aG9zZSBuZXcgYWRkcmVzc2VzLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZGlyZWN0KHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAvXls0LTZdWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIC8vIDEyLjMgVGVybWluYXRpb24gb2YgYSBEaWFsb2dcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluZGVwZW5kZW50IG9mIHRoZSBtZXRob2QsIGlmIGEgcmVxdWVzdCBvdXRzaWRlIG9mIGEgZGlhbG9nIGdlbmVyYXRlc1xuICAgICAgICAgICAgICAgIC8vIGEgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSwgYW55IGVhcmx5IGRpYWxvZ3MgY3JlYXRlZCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHRvIHRoYXQgcmVxdWVzdCBhcmUgdGVybWluYXRlZC4gIFRoZSBtZWNoYW5pc21cbiAgICAgICAgICAgICAgICAvLyBmb3IgdGVybWluYXRpbmcgY29uZmlybWVkIGRpYWxvZ3MgaXMgbWV0aG9kIHNwZWNpZmljLiAgSW4gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYXRpb24sIHRoZSBCWUUgbWV0aG9kIHRlcm1pbmF0ZXMgYSBzZXNzaW9uIGFuZCB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIGl0LiAgU2VlIFNlY3Rpb24gMTUgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4zXG4gICAgICAgICAgICAgICAgLy8gQWxsIGVhcmx5IGRpYWxvZ3MgYXJlIGNvbnNpZGVyZWQgdGVybWluYXRlZCB1cG9uIHJlY2VwdGlvbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBub24tMnh4IGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgaGF2aW5nIHJlY2VpdmVkIHRoZSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIHRoZSBVQUMgY29yZVxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVycyB0aGUgSU5WSVRFIHRyYW5zYWN0aW9uIGNvbXBsZXRlZC4gIFRoZSBJTlZJVEUgY2xpZW50XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gaGFuZGxlcyB0aGUgZ2VuZXJhdGlvbiBvZiBBQ0tzIGZvciB0aGUgcmVzcG9uc2UgKHNlZVxuICAgICAgICAgICAgICAgIC8vIFNlY3Rpb24gMTcpLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjNcbiAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChlYXJseURpYWxvZykgeyByZXR1cm4gZWFybHlEaWFsb2cuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIC8vIEEgc2luZ2xlIG5vbi0yeHggZmluYWwgcmVzcG9uc2UgbWF5IGJlIHJlY2VpdmVkIGZvciB0aGUgSU5WSVRFLiAgNHh4LFxuICAgICAgICAgICAgICAgIC8vIDV4eCBhbmQgNnh4IHJlc3BvbnNlcyBtYXkgY29udGFpbiBhIENvbnRhY3QgaGVhZGVyIGZpZWxkIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gaW5kaWNhdGluZyB0aGUgbG9jYXRpb24gd2hlcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBjYW4gYmUgZm91bmQuICBTdWJzZXF1ZW50IGZpbmFsIHJlc3BvbnNlcyAod2hpY2ggd291bGQgb25seSBhcnJpdmVcbiAgICAgICAgICAgICAgICAvLyB1bmRlciBlcnJvciBjb25kaXRpb25zKSBNVVNUIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuM1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlamVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZSBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4ZWN1dGluZyB3aGF0IHNob3VsZCBiZSBhbiB1bnJlYWNoYWJsZSBjb2RlIHBhdGggcmVjZWl2aW5nIFwiICsgc3RhdHVzQ29kZSArIFwiIHJlc3BvbnNlLlwiKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZpdGVVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLkludml0ZVVzZXJBZ2VudENsaWVudCA9IEludml0ZVVzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZGlhbG9nc18xID0gcmVxdWlyZShcIi4uL2RpYWxvZ3NcIik7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4uL2V4Y2VwdGlvbnNcIik7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4uL3Nlc3Npb25cIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIGFsbG93ZWRfbWV0aG9kc18xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnQtY29yZS9hbGxvd2VkLW1ldGhvZHNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBJTlZJVEUgVUFTLlxuICogQHJlbWFya3NcbiAqIDEzIEluaXRpYXRpbmcgYSBTZXNzaW9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzXG4gKiAxMy4xIE92ZXJ2aWV3XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjFcbiAqIDEzLjMgVUFTIFByb2Nlc3NpbmdcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuM1xuICogQHB1YmxpY1xuICovXG52YXIgSW52aXRlVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEludml0ZVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nKSB7XG4gICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDEzLjMuMS40IFRoZSBJTlZJVEUgaXMgQWNjZXB0ZWRcbiAgICAgKiBUaGUgVUFTIGNvcmUgZ2VuZXJhdGVzIGEgMnh4IHJlc3BvbnNlLiAgVGhpcyByZXNwb25zZSBlc3RhYmxpc2hlcyBhXG4gICAgICogZGlhbG9nLCBhbmQgdGhlcmVmb3JlIGZvbGxvd3MgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvbiAxMi4xLjEgaW5cbiAgICAgKiBhZGRpdGlvbiB0byB0aG9zZSBvZiBTZWN0aW9uIDguMi42LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFjY2VwdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMjAwIH07IH1cbiAgICAgICAgaWYgKCF0aGlzLmFjY2VwdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZUVycm9yKHRoaXMubWVzc2FnZS5tZXRob2QgKyBcIiBub3QgYWNjZXB0YWJsZSBpbiBzdGF0ZSBcIiArIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyByZXNwb25zZSBlc3RhYmxpc2hlcyBhIGRpYWxvZy4uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICAgIGlmICghdGhpcy5jb25maXJtZWREaWFsb2cpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZy5jb25maXJtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cgPSB0aGlzLmVhcmx5RGlhbG9nO1xuICAgICAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2cgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGRpYWxvZ3NfMS5EaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yVXNlckFnZW50U2VydmVyKHRoaXMubWVzc2FnZSwgdGhpcy50b1RhZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cgPSBuZXcgZGlhbG9nc18xLlNlc3Npb25EaWFsb2codHJhbnNhY3Rpb24sIHRoaXMuY29yZSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gYSBVQVMgcmVzcG9uZHMgdG8gYSByZXF1ZXN0IHdpdGggYSByZXNwb25zZSB0aGF0IGVzdGFibGlzaGVzIGFcbiAgICAgICAgLy8gZGlhbG9nIChzdWNoIGFzIGEgMnh4IHRvIElOVklURSksIHRoZSBVQVMgTVVTVCBjb3B5IGFsbCBSZWNvcmQtUm91dGVcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIHZhbHVlcyBmcm9tIHRoZSByZXF1ZXN0IGludG8gdGhlIHJlc3BvbnNlIChpbmNsdWRpbmcgdGhlXG4gICAgICAgIC8vIFVSSXMsIFVSSSBwYXJhbWV0ZXJzLCBhbmQgYW55IFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgcGFyYW1ldGVycyxcbiAgICAgICAgLy8gd2hldGhlciB0aGV5IGFyZSBrbm93biBvciB1bmtub3duIHRvIHRoZSBVQVMpIGFuZCBNVVNUIG1haW50YWluIHRoZVxuICAgICAgICAvLyBvcmRlciBvZiB0aG9zZSB2YWx1ZXMuICBUaGUgVUFTIE1VU1QgYWRkIGEgQ29udGFjdCBoZWFkZXIgZmllbGQgdG9cbiAgICAgICAgLy8gdGhlIHJlc3BvbnNlLiAgVGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIGNvbnRhaW5zIGFuIGFkZHJlc3Mgd2hlcmUgdGhlXG4gICAgICAgIC8vIFVBUyB3b3VsZCBsaWtlIHRvIGJlIGNvbnRhY3RlZCBmb3Igc3Vic2VxdWVudCByZXF1ZXN0cyBpbiB0aGUgZGlhbG9nXG4gICAgICAgIC8vICh3aGljaCBpbmNsdWRlcyB0aGUgQUNLIGZvciBhIDJ4eCByZXNwb25zZSBpbiB0aGUgY2FzZSBvZiBhbiBJTlZJVEUpLlxuICAgICAgICAvLyBHZW5lcmFsbHksIHRoZSBob3N0IHBvcnRpb24gb2YgdGhpcyBVUkkgaXMgdGhlIElQIGFkZHJlc3Mgb3IgRlFETiBvZlxuICAgICAgICAvLyB0aGUgaG9zdC4gIFRoZSBVUkkgcHJvdmlkZWQgaW4gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIE1VU1QgYmUgYSBTSVBcbiAgICAgICAgLy8gb3IgU0lQUyBVUkkuICBJZiB0aGUgcmVxdWVzdCB0aGF0IGluaXRpYXRlZCB0aGUgZGlhbG9nIGNvbnRhaW5lZCBhXG4gICAgICAgIC8vIFNJUFMgVVJJIGluIHRoZSBSZXF1ZXN0LVVSSSBvciBpbiB0aGUgdG9wIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGRcbiAgICAgICAgLy8gdmFsdWUsIGlmIHRoZXJlIHdhcyBhbnksIG9yIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBpZiB0aGVyZSB3YXMgbm9cbiAgICAgICAgLy8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCwgdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIGluIHRoZSByZXNwb25zZVxuICAgICAgICAvLyBNVVNUIGJlIGEgU0lQUyBVUkkuICBUaGUgVVJJIFNIT1VMRCBoYXZlIGdsb2JhbCBzY29wZSAodGhhdCBpcywgdGhlXG4gICAgICAgIC8vIHNhbWUgVVJJIGNhbiBiZSB1c2VkIGluIG1lc3NhZ2VzIG91dHNpZGUgdGhpcyBkaWFsb2cpLiAgVGhlIHNhbWUgd2F5LFxuICAgICAgICAvLyB0aGUgc2NvcGUgb2YgdGhlIFVSSSBpbiB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgb2YgdGhlIElOVklURSBpcyBub3RcbiAgICAgICAgLy8gbGltaXRlZCB0byB0aGlzIGRpYWxvZyBlaXRoZXIuICBJdCBjYW4gdGhlcmVmb3JlIGJlIHVzZWQgaW4gbWVzc2FnZXNcbiAgICAgICAgLy8gdG8gdGhlIFVBQyBldmVuIG91dHNpZGUgdGhpcyBkaWFsb2cuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgICAgIHZhciByZWNvcmRSb3V0ZUhlYWRlciA9IHRoaXMubWVzc2FnZVxuICAgICAgICAgICAgLmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGhlYWRlcikgeyByZXR1cm4gXCJSZWNvcmQtUm91dGU6IFwiICsgaGVhZGVyOyB9KTtcbiAgICAgICAgdmFyIGNvbnRhY3RIZWFkZXIgPSBcIkNvbnRhY3Q6IFwiICsgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uY29udGFjdC50b1N0cmluZygpO1xuICAgICAgICAvLyBBIDJ4eCByZXNwb25zZSB0byBhbiBJTlZJVEUgU0hPVUxEIGNvbnRhaW4gdGhlIEFsbG93IGhlYWRlciBmaWVsZCBhbmRcbiAgICAgICAgLy8gdGhlIFN1cHBvcnRlZCBoZWFkZXIgZmllbGQsIGFuZCBNQVkgY29udGFpbiB0aGUgQWNjZXB0IGhlYWRlciBmaWVsZC5cbiAgICAgICAgLy8gSW5jbHVkaW5nIHRoZXNlIGhlYWRlciBmaWVsZHMgYWxsb3dzIHRoZSBVQUMgdG8gZGV0ZXJtaW5lIHRoZVxuICAgICAgICAvLyBmZWF0dXJlcyBhbmQgZXh0ZW5zaW9ucyBzdXBwb3J0ZWQgYnkgdGhlIFVBUyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjYWxsLCB3aXRob3V0IHByb2JpbmcuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIG5vdCBiZSBoYXJkIGNvZGVkLlxuICAgICAgICB2YXIgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBTdXBwb3J0ZWQgaGVhZGVyIChzZWUgcmVwbHkoKSlcbiAgICAgICAgLy8gRklYTUU6IFRPRE86IEFjY2VwdCBoZWFkZXJcbiAgICAgICAgLy8gSWYgdGhlIElOVklURSByZXF1ZXN0IGNvbnRhaW5lZCBhbiBvZmZlciwgYW5kIHRoZSBVQVMgaGFkIG5vdCB5ZXRcbiAgICAgICAgLy8gc2VudCBhbiBhbnN3ZXIsIHRoZSAyeHggTVVTVCBjb250YWluIGFuIGFuc3dlci4gIElmIHRoZSBJTlZJVEUgZGlkXG4gICAgICAgIC8vIG5vdCBjb250YWluIGFuIG9mZmVyLCB0aGUgMnh4IE1VU1QgY29udGFpbiBhbiBvZmZlciBpZiB0aGUgVUFTIGhhZFxuICAgICAgICAvLyBub3QgeWV0IHNlbnQgYW4gb2ZmZXIuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgICAgaWYgKCFvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpcm1lZERpYWxvZy5zaWduYWxpbmdTdGF0ZSA9PT0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHRoaXMuY29uZmlybWVkRGlhbG9nLmFuc3dlcjsgLy8gcmVzZW5kIHRoZSBhbnN3ZXIgc2VudCBpbiBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBtdXN0IGhhdmUgYSBib2R5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMjAwO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzLmNvbmNhdChyZWNvcmRSb3V0ZUhlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goYWxsb3dIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGNvbnRhY3RIZWFkZXIpO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBfc3VwZXIucHJvdG90eXBlLmFjY2VwdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuY29uZmlybWVkRGlhbG9nO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCByZXNwb25zZSksIHsgc2Vzc2lvbjogc2Vzc2lvbiB9KTtcbiAgICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGVcbiAgICAgICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgICAgICAgLy8gT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgLy8gb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICAgICAgICAgIC8vIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAgICAgICAvLyBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgICAgICAgLy8gY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgIT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24ob3B0aW9ucy5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogMTMuMy4xLjEgUHJvZ3Jlc3NcbiAgICAgKiBJZiB0aGUgVUFTIGlzIG5vdCBhYmxlIHRvIGFuc3dlciB0aGUgaW52aXRhdGlvbiBpbW1lZGlhdGVseSwgaXQgY2FuXG4gICAgICogY2hvb3NlIHRvIGluZGljYXRlIHNvbWUga2luZCBvZiBwcm9ncmVzcyB0byB0aGUgVUFDIChmb3IgZXhhbXBsZSwgYW5cbiAgICAgKiBpbmRpY2F0aW9uIHRoYXQgYSBwaG9uZSBpcyByaW5naW5nKS4gIFRoaXMgaXMgYWNjb21wbGlzaGVkIHdpdGggYVxuICAgICAqIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGJldHdlZW4gMTAxIGFuZCAxOTkuICBUaGVzZSBwcm92aXNpb25hbFxuICAgICAqIHJlc3BvbnNlcyBlc3RhYmxpc2ggZWFybHkgZGlhbG9ncyBhbmQgdGhlcmVmb3JlIGZvbGxvdyB0aGUgcHJvY2VkdXJlc1xuICAgICAqIG9mIFNlY3Rpb24gMTIuMS4xIGluIGFkZGl0aW9uIHRvIHRob3NlIG9mIFNlY3Rpb24gOC4yLjYuICBBIFVBUyBNQVlcbiAgICAgKiBzZW5kIGFzIG1hbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIGFzIGl0IGxpa2VzLiAgRWFjaCBvZiB0aGVzZSBNVVNUXG4gICAgICogaW5kaWNhdGUgdGhlIHNhbWUgZGlhbG9nIElELiAgSG93ZXZlciwgdGhlc2Ugd2lsbCBub3QgYmUgZGVsaXZlcmVkXG4gICAgICogcmVsaWFibHkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVUFTIGRlc2lyZXMgYW4gZXh0ZW5kZWQgcGVyaW9kIG9mIHRpbWUgdG8gYW5zd2VyIHRoZSBJTlZJVEUsXG4gICAgICogaXQgd2lsbCBuZWVkIHRvIGFzayBmb3IgYW4gXCJleHRlbnNpb25cIiBpbiBvcmRlciB0byBwcmV2ZW50IHByb3hpZXNcbiAgICAgKiBmcm9tIGNhbmNlbGluZyB0aGUgdHJhbnNhY3Rpb24uICBBIHByb3h5IGhhcyB0aGUgb3B0aW9uIG9mIGNhbmNlbGluZ1xuICAgICAqIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhIGdhcCBvZiAzIG1pbnV0ZXMgYmV0d2VlbiByZXNwb25zZXMgaW4gYVxuICAgICAqIHRyYW5zYWN0aW9uLiAgVG8gcHJldmVudCBjYW5jZWxsYXRpb24sIHRoZSBVQVMgTVVTVCBzZW5kIGEgbm9uLTEwMFxuICAgICAqIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGF0IGV2ZXJ5IG1pbnV0ZSwgdG8gaGFuZGxlIHRoZSBwb3NzaWJpbGl0eSBvZlxuICAgICAqIGxvc3QgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjFcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFByb2dyZXNzIG9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIEludml0ZVVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDE4MCB9OyB9XG4gICAgICAgIGlmICghdGhpcy5wcm9ncmVzc2FibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZUVycm9yKHRoaXMubWVzc2FnZS5tZXRob2QgKyBcIiBub3QgcHJvZ3Jlc3NhYmxlIGluIHN0YXRlIFwiICsgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHJlc3BvbnNlIGVzdGFibGlzaGVzIGEgZGlhbG9nLi4uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgICAgaWYgKCF0aGlzLmVhcmx5RGlhbG9nKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKCEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBub3QgaW5zdGFuY2Ugb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXRlID0gZGlhbG9nc18xLkRpYWxvZy5pbml0aWFsRGlhbG9nU3RhdGVGb3JVc2VyQWdlbnRTZXJ2ZXIodGhpcy5tZXNzYWdlLCB0aGlzLnRvVGFnLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2cgPSBuZXcgZGlhbG9nc18xLlNlc3Npb25EaWFsb2codHJhbnNhY3Rpb24sIHRoaXMuY29yZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gYSBVQVMgcmVzcG9uZHMgdG8gYSByZXF1ZXN0IHdpdGggYSByZXNwb25zZSB0aGF0IGVzdGFibGlzaGVzIGFcbiAgICAgICAgLy8gZGlhbG9nIChzdWNoIGFzIGEgMnh4IHRvIElOVklURSksIHRoZSBVQVMgTVVTVCBjb3B5IGFsbCBSZWNvcmQtUm91dGVcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIHZhbHVlcyBmcm9tIHRoZSByZXF1ZXN0IGludG8gdGhlIHJlc3BvbnNlIChpbmNsdWRpbmcgdGhlXG4gICAgICAgIC8vIFVSSXMsIFVSSSBwYXJhbWV0ZXJzLCBhbmQgYW55IFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgcGFyYW1ldGVycyxcbiAgICAgICAgLy8gd2hldGhlciB0aGV5IGFyZSBrbm93biBvciB1bmtub3duIHRvIHRoZSBVQVMpIGFuZCBNVVNUIG1haW50YWluIHRoZVxuICAgICAgICAvLyBvcmRlciBvZiB0aG9zZSB2YWx1ZXMuICBUaGUgVUFTIE1VU1QgYWRkIGEgQ29udGFjdCBoZWFkZXIgZmllbGQgdG9cbiAgICAgICAgLy8gdGhlIHJlc3BvbnNlLiAgVGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIGNvbnRhaW5zIGFuIGFkZHJlc3Mgd2hlcmUgdGhlXG4gICAgICAgIC8vIFVBUyB3b3VsZCBsaWtlIHRvIGJlIGNvbnRhY3RlZCBmb3Igc3Vic2VxdWVudCByZXF1ZXN0cyBpbiB0aGUgZGlhbG9nXG4gICAgICAgIC8vICh3aGljaCBpbmNsdWRlcyB0aGUgQUNLIGZvciBhIDJ4eCByZXNwb25zZSBpbiB0aGUgY2FzZSBvZiBhbiBJTlZJVEUpLlxuICAgICAgICAvLyBHZW5lcmFsbHksIHRoZSBob3N0IHBvcnRpb24gb2YgdGhpcyBVUkkgaXMgdGhlIElQIGFkZHJlc3Mgb3IgRlFETiBvZlxuICAgICAgICAvLyB0aGUgaG9zdC4gIFRoZSBVUkkgcHJvdmlkZWQgaW4gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIE1VU1QgYmUgYSBTSVBcbiAgICAgICAgLy8gb3IgU0lQUyBVUkkuICBJZiB0aGUgcmVxdWVzdCB0aGF0IGluaXRpYXRlZCB0aGUgZGlhbG9nIGNvbnRhaW5lZCBhXG4gICAgICAgIC8vIFNJUFMgVVJJIGluIHRoZSBSZXF1ZXN0LVVSSSBvciBpbiB0aGUgdG9wIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGRcbiAgICAgICAgLy8gdmFsdWUsIGlmIHRoZXJlIHdhcyBhbnksIG9yIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBpZiB0aGVyZSB3YXMgbm9cbiAgICAgICAgLy8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCwgdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIGluIHRoZSByZXNwb25zZVxuICAgICAgICAvLyBNVVNUIGJlIGEgU0lQUyBVUkkuICBUaGUgVVJJIFNIT1VMRCBoYXZlIGdsb2JhbCBzY29wZSAodGhhdCBpcywgdGhlXG4gICAgICAgIC8vIHNhbWUgVVJJIGNhbiBiZSB1c2VkIGluIG1lc3NhZ2VzIG91dHNpZGUgdGhpcyBkaWFsb2cpLiAgVGhlIHNhbWUgd2F5LFxuICAgICAgICAvLyB0aGUgc2NvcGUgb2YgdGhlIFVSSSBpbiB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgb2YgdGhlIElOVklURSBpcyBub3RcbiAgICAgICAgLy8gbGltaXRlZCB0byB0aGlzIGRpYWxvZyBlaXRoZXIuICBJdCBjYW4gdGhlcmVmb3JlIGJlIHVzZWQgaW4gbWVzc2FnZXNcbiAgICAgICAgLy8gdG8gdGhlIFVBQyBldmVuIG91dHNpZGUgdGhpcyBkaWFsb2cuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgICAgIHZhciByZWNvcmRSb3V0ZUhlYWRlciA9IHRoaXMubWVzc2FnZVxuICAgICAgICAgICAgLmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGhlYWRlcikgeyByZXR1cm4gXCJSZWNvcmQtUm91dGU6IFwiICsgaGVhZGVyOyB9KTtcbiAgICAgICAgdmFyIGNvbnRhY3RIZWFkZXIgPSBcIkNvbnRhY3Q6IFwiICsgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uY29udGFjdDtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycy5jb25jYXQocmVjb3JkUm91dGVIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGNvbnRhY3RIZWFkZXIpO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBfc3VwZXIucHJvdG90eXBlLnByb2dyZXNzLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5lYXJseURpYWxvZztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVzcG9uc2UpLCB7IHNlc3Npb246IHNlc3Npb24gfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlXG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIC8vIE9uY2UgdGhlIFVBUyBoYXMgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgICAgICAvLyB0byB0aGUgaW5pdGlhbCBJTlZJVEUuICBUaGlzIG1lYW5zIHRoYXQgYSBVQVMgYmFzZWQgb24gdGhpc1xuICAgICAgICAgICAgLy8gc3BlY2lmaWNhdGlvbiBhbG9uZSBjYW4gbmV2ZXIgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgdW50aWxcbiAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgaWYgKHRoaXMuZWFybHlEaWFsb2cuc2lnbmFsaW5nU3RhdGUgIT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihvcHRpb25zLmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAxMy4zLjEuMiBUaGUgSU5WSVRFIGlzIFJlZGlyZWN0ZWRcbiAgICAgKiBJZiB0aGUgVUFTIGRlY2lkZXMgdG8gcmVkaXJlY3QgdGhlIGNhbGwsIGEgM3h4IHJlc3BvbnNlIGlzIHNlbnQuICBBXG4gICAgICogMzAwIChNdWx0aXBsZSBDaG9pY2VzKSwgMzAxIChNb3ZlZCBQZXJtYW5lbnRseSkgb3IgMzAyIChNb3ZlZFxuICAgICAqIFRlbXBvcmFyaWx5KSByZXNwb25zZSBTSE9VTEQgY29udGFpbiBhIENvbnRhY3QgaGVhZGVyIGZpZWxkXG4gICAgICogY29udGFpbmluZyBvbmUgb3IgbW9yZSBVUklzIG9mIG5ldyBhZGRyZXNzZXMgdG8gYmUgdHJpZWQuICBUaGVcbiAgICAgKiByZXNwb25zZSBpcyBwYXNzZWQgdG8gdGhlIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24sIHdoaWNoIHdpbGwgZGVhbFxuICAgICAqIHdpdGggaXRzIHJldHJhbnNtaXNzaW9ucy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS4yXG4gICAgICogQHBhcmFtIGNvbnRhY3RzIC0gQ29udGFjdHMgdG8gcmVkaXJlY3QgdG8uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZWRpcmVjdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKGNvbnRhY3RzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMzAyIH07IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVkaXJlY3QuY2FsbCh0aGlzLCBjb250YWN0cywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAxMy4zLjEuMyBUaGUgSU5WSVRFIGlzIFJlamVjdGVkXG4gICAgICogQSBjb21tb24gc2NlbmFyaW8gb2NjdXJzIHdoZW4gdGhlIGNhbGxlZSBpcyBjdXJyZW50bHkgbm90IHdpbGxpbmcgb3JcbiAgICAgKiBhYmxlIHRvIHRha2UgYWRkaXRpb25hbCBjYWxscyBhdCB0aGlzIGVuZCBzeXN0ZW0uICBBIDQ4NiAoQnVzeSBIZXJlKVxuICAgICAqIFNIT1VMRCBiZSByZXR1cm5lZCBpbiBzdWNoIGEgc2NlbmFyaW8uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjEuM1xuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVqZWN0IG9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIEludml0ZVVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiA0ODYgfTsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLkludml0ZVVzZXJBZ2VudFNlcnZlciA9IEludml0ZVVzZXJBZ2VudFNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogTUVTU0FHRSBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBNZXNzYWdlVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1lc3NhZ2VVc2VyQWdlbnRDbGllbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVVzZXJBZ2VudENsaWVudChjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZVVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuTWVzc2FnZVVzZXJBZ2VudENsaWVudCA9IE1lc3NhZ2VVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIE1FU1NBR0UgVUFTLlxuICogQHB1YmxpY1xuICovXG52YXIgTWVzc2FnZVVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZXNzYWdlVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLk1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIgPSBNZXNzYWdlVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIE5PVElGWSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBOb3RpZnlVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTm90aWZ5VXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdGlmeVVzZXJBZ2VudENsaWVudChkaWFsb2csIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLk5PVElGWSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm90aWZ5VXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5Ob3RpZnlVc2VyQWdlbnRDbGllbnQgPSBOb3RpZnlVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIE5PVElGWSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBOb3RpZnlVc2VyQWdlbnRTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTm90aWZ5VXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIE5PVElGWSBVQVMgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIGRpYWxvZ09yQ29yZSAtIERpYWxvZyBmb3IgaW4gZGlhbG9nIE5PVElGWSwgVXNlckFnZW50Q29yZSBmb3Igb3V0IG9mIGRpYWxvZyBOT1RJRlkgKGRlcHJlY2F0ZWQpLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgTk9USUZZIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOb3RpZnlVc2VyQWdlbnRTZXJ2ZXIoZGlhbG9nT3JDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXNlckFnZW50Q29yZSA9IGluc3RhbmNlT2ZEaWFsb2coZGlhbG9nT3JDb3JlKSA/XG4gICAgICAgICAgICBkaWFsb2dPckNvcmUudXNlckFnZW50Q29yZSA6XG4gICAgICAgICAgICBkaWFsb2dPckNvcmU7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIHVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3RpZnlVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLk5vdGlmeVVzZXJBZ2VudFNlcnZlciA9IE5vdGlmeVVzZXJBZ2VudFNlcnZlcjtcbmZ1bmN0aW9uIGluc3RhbmNlT2ZEaWFsb2cob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdC51c2VyQWdlbnRDb3JlICE9PSB1bmRlZmluZWQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogUFJBQ0sgVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgUHJhY2tVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJhY2tVc2VyQWdlbnRDbGllbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJhY2tVc2VyQWdlbnRDbGllbnQoZGlhbG9nLCBkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5QUkFDSywgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJhY2tVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlByYWNrVXNlckFnZW50Q2xpZW50ID0gUHJhY2tVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIFBSQUNLIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByYWNrVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByYWNrVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByYWNrVXNlckFnZW50U2VydmVyKGRpYWxvZywgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgd2l0aCBvZmZlci9hbnN3ZXIgaW4gYm9keVxuICAgICAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICBfdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIG9uIGEgMnh4IHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgUHJhY2tVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMjAwIH07IH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgd2l0aCBvZmZlci9hbnN3ZXIgaW4gYm9keVxuICAgICAgICAgICAgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG9wdGlvbnMuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYWNjZXB0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJhY2tVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLlByYWNrVXNlckFnZW50U2VydmVyID0gUHJhY2tVc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIFBVQkxJU0ggVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgUHVibGlzaFVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQdWJsaXNoVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFB1Ymxpc2hVc2VyQWdlbnRDbGllbnQoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFB1Ymxpc2hVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlB1Ymxpc2hVc2VyQWdlbnRDbGllbnQgPSBQdWJsaXNoVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIFJlLUlOVklURSBVQUMuXG4gKiBAcmVtYXJrc1xuICogMTQgTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb25cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTRcbiAqIDE0LjEgVUFDIEJlaGF2aW9yXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0LjFcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlSW52aXRlVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlSW52aXRlVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlSW52aXRlVXNlckFnZW50Q2xpZW50KGRpYWxvZywgZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkaWFsb2cuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXNzYWdlc18xLkMuSU5WSVRFLCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAvLyBGSVhNRTogVE9ETzogbmV4dCBsaW5lIG9idmlvdXNseSBuZWVkcyB0byBiZSBpbXByb3ZlZC4uLlxuICAgICAgICBkaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQgPSBfdGhpczsgLy8gbGV0IHRoZSBkaWFsb2cga25vdyByZS1pbnZpdGUgcmVxdWVzdCBzZW50XG4gICAgICAgIF90aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZUludml0ZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmF1dGhlbnRpY2F0aW9uR3VhcmQobWVzc2FnZSwgdGhpcy5kaWFsb2cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBtZXNzYWdlLnN0YXR1c0NvZGUgPyBtZXNzYWdlLnN0YXR1c0NvZGUudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgIGlmICghc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugc3RhdHVzIGNvZGUgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgL14xMDAkLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25UcnlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblRyeWluZyh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5kaWFsb2csXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmFjazogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgd2l0aCBvZmZlci9hbnN3ZXIgaW4gYm9keVxuICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25BY2NlcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuZGlhbG9nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNrOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRnb2luZ0Fja1JlcXVlc3QgPSBfdGhpcy5kaWFsb2cuYWNrKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRnb2luZ0Fja1JlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14zWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlUm9sbGJhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5yZWludml0ZVVzZXJBZ2VudENsaWVudCA9IHVuZGVmaW5lZDsgLy8gQUNLIHdhcyBoYW5kbGVkIGJ5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXls0LTZdWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlUm9sbGJhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5yZWludml0ZVVzZXJBZ2VudENsaWVudCA9IHVuZGVmaW5lZDsgLy8gQUNLIHdhcyBoYW5kbGVkIGJ5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVqZWN0KHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgVUEgcmVjZWl2ZXMgYSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIHRvIGEgcmUtSU5WSVRFLCB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJhbWV0ZXJzIE1VU1QgcmVtYWluIHVuY2hhbmdlZCwgYXMgaWYgbm8gcmUtSU5WSVRFIGhhZCBiZWVuIGlzc3VlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0LCBhcyBzdGF0ZWQgaW4gU2VjdGlvbiAxMi4yLjEuMiwgaWYgdGhlIG5vbi0yeHggZmluYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgYSA0ODEgKENhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpLCBvciBhIDQwOFxuICAgICAgICAgICAgICAgICAgICAvLyAoUmVxdWVzdCBUaW1lb3V0KSwgb3Igbm8gcmVzcG9uc2UgYXQgYWxsIGlzIHJlY2VpdmVkIGZvciB0aGUgcmUtXG4gICAgICAgICAgICAgICAgICAgIC8vIElOVklURSAodGhhdCBpcywgYSB0aW1lb3V0IGlzIHJldHVybmVkIGJ5IHRoZSBJTlZJVEUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uKSwgdGhlIFVBQyB3aWxsIHRlcm1pbmF0ZSB0aGUgZGlhbG9nLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIFVBQyByZWNlaXZlcyBhIDQ5MSByZXNwb25zZSB0byBhIHJlLUlOVklURSwgaXQgU0hPVUxEIHN0YXJ0IGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGltZXIgd2l0aCBhIHZhbHVlIFQgY2hvc2VuIGFzIGZvbGxvd3M6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDEuIElmIHRoZSBVQUMgaXMgdGhlIG93bmVyIG9mIHRoZSBDYWxsLUlEIG9mIHRoZSBkaWFsb2cgSURcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgKG1lYW5pbmcgaXQgZ2VuZXJhdGVkIHRoZSB2YWx1ZSksIFQgaGFzIGEgcmFuZG9tbHkgY2hvc2VuIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGJldHdlZW4gMi4xIGFuZCA0IHNlY29uZHMgaW4gdW5pdHMgb2YgMTAgbXMuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDIuIElmIHRoZSBVQUMgaXMgbm90IHRoZSBvd25lciBvZiB0aGUgQ2FsbC1JRCBvZiB0aGUgZGlhbG9nIElELCBUXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGhhcyBhIHJhbmRvbWx5IGNob3NlbiB2YWx1ZSBvZiBiZXR3ZWVuIDAgYW5kIDIgc2Vjb25kcyBpbiB1bml0c1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBvZiAxMCBtcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgdGltZXIgZmlyZXMsIHRoZSBVQUMgU0hPVUxEIGF0dGVtcHQgdGhlIHJlLUlOVklURSBvbmNlIG1vcmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IHN0aWxsIGRlc2lyZXMgZm9yIHRoYXQgc2Vzc2lvbiBtb2RpZmljYXRpb24gdG8gdGFrZSBwbGFjZS4gIEZvclxuICAgICAgICAgICAgICAgICAgICAvLyBleGFtcGxlLCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBodW5nIHVwIHdpdGggYSBCWUUsIHRoZSByZS1JTlZJVEVcbiAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgbm90IHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhlIGFib3ZlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZSBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVJbnZpdGVVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlJlSW52aXRlVXNlckFnZW50Q2xpZW50ID0gUmVJbnZpdGVVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIFJlLUlOVklURSBVQVMuXG4gKiBAcmVtYXJrc1xuICogMTQgTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb25cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTRcbiAqIDE0LjIgVUFTIEJlaGF2aW9yXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0LjJcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlSW52aXRlVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlSW52aXRlVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlSW52aXRlVXNlckFnZW50U2VydmVyKGRpYWxvZywgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgZGlhbG9nLnJlaW52aXRlVXNlckFnZW50U2VydmVyID0gX3RoaXM7XG4gICAgICAgIF90aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgb24gYSAyeHggcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBSZUludml0ZVVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAyMDAgfTsgfVxuICAgICAgICAvLyBGSVhNRTogVGhlIG5leHQgdHdvIGxpbmVzIFNIT1VMRCBnbyBhd2F5LCBidXQgSSBzdXBwb3NlIGl0J3MgdGVjaG5pY2FsbHkgaGFybWxlc3MuLi5cbiAgICAgICAgLy8gVGhlc2UgYXJlIGhlcmUgYmVjYXVzZSBzb21lIHZlcnNpb25zIG9mIFNJUC5qcyBwcmlvciB0byAwLjEzLjggc2V0IHRoZSByb3V0ZSBzZXRcbiAgICAgICAgLy8gb2YgYWxsIGluIGRpYWxvZyBBQ0tzIGJhc2VkIG9uIHRoZSBSZWNvcmQtUm91dGUgaGVhZGVycyBpbiB0aGUgYXNzb2NpYXRlZCAyeHhcbiAgICAgICAgLy8gcmVzcG9uc2UuIFdoaWxlIHRoaXMgd29ya2VkIGZvciBkaWFsb2cgZm9ybWluZyAyeHggcmVzcG9uc2VzLCBpdCB3YXMgdGVjaG5pY2FsbHlcbiAgICAgICAgLy8gYnJva2VuIGZvciByZS1JTlZJVEUgQUNLUyBhcyBpdCBvbmx5IHdvcmtlZCBpZiB0aGUgVUFTIHBvcHVsYXRlZCB0aGUgUmVjb3JkLVJvdXRlXG4gICAgICAgIC8vIGhlYWRlcnMgaW4gdGhlIHJlLUlOVklURSAyeHggcmVzcG9uc2UgKHdoaWNoIGlzIG5vdCByZXF1aXJlZCBhbmQgYSB3YXN0ZSBvZiBiYW5kd2lkdGhcbiAgICAgICAgLy8gYXMgdGhlIHNob3VsZCBiZSBpZ25vcmVkIGlmIHByZXNlbnQgaW4gcmUtSU5WSVRFIEFDS1MpIGFuZCB0aGUgVUFTIHBvcHVsYXRlZFxuICAgICAgICAvLyB0aGUgUmVjb3JkLVJvdXRlIGhlYWRlcnMgd2l0aCB0aGUgY29ycmVjdCB2YWx1ZXMgKHdvdWxkIGJlIHdlaXJkIG5vdCB0b28sIGJ1dC4uLikuXG4gICAgICAgIC8vIEFueXdheSwgZm9yIG5vdyB0aGUgdGVjaG5pY2FsbHkgdXNlbGVzcyBSZWNvcmQtUm91dGUgaGVhZGVycyBhcmUgYmVpbmcgYWRkZWRcbiAgICAgICAgLy8gdG8gbWFpbnRhaW4gXCJiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVwiIHdpdGggdGhlIG9sZGVyIGJyb2tlbiB2ZXJzaW9ucyBvZiBTSVAuanMuXG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMuY29uY2F0KHRoaXMuZGlhbG9nLnJvdXRlU2V0Lm1hcChmdW5jdGlvbiAocm91dGUpIHsgcmV0dXJuIFwiUmVjb3JkLVJvdXRlOiBcIiArIHJvdXRlOyB9KSk7XG4gICAgICAgIC8vIFNlbmQgYW5kIHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gX3N1cGVyLnByb3RvdHlwZS5hY2NlcHQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLmRpYWxvZztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVzcG9uc2UpLCB7IHNlc3Npb246IHNlc3Npb24gfSk7XG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIHdpdGggb2ZmZXIvYW5zd2VyIGluIGJvZHlcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihvcHRpb25zLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBkaWFsb2dcbiAgICAgICAgdGhpcy5kaWFsb2cucmVDb25maXJtKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgb24gYSAxeHggcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQcm9ncmVzcyBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBSZUludml0ZVVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDE4MCB9OyB9XG4gICAgICAgIC8vIFNlbmQgYW5kIHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gX3N1cGVyLnByb3RvdHlwZS5wcm9ncmVzcy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZGlhbG9nO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCByZXNwb25zZSksIHsgc2Vzc2lvbjogc2Vzc2lvbiB9KTtcbiAgICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGVcbiAgICAgICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgICAgICAgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG9wdGlvbnMuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRPRE86IE5vdCBZZXQgU3VwcG9ydGVkXG4gICAgICogQHBhcmFtIGNvbnRhY3RzIC0gQ29udGFjdHMgdG8gcmVkaXJlY3QgdG8uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZWRpcmVjdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBSZUludml0ZVVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAoY29udGFjdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAzMDIgfTsgfVxuICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVJvbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuZGlhbG9nLnJlaW52aXRlVXNlckFnZW50U2VydmVyID0gdW5kZWZpbmVkOyAvLyBBQ0sgd2lsbCBiZSBoYW5kbGVkIGJ5IHRyYW5zYWN0aW9uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQuXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogMy4xIEJhY2tncm91bmQgb24gUmUtSU5WSVRFIEhhbmRsaW5nIGJ5IFVBU3NcbiAgICAgKiBBbiBlcnJvciByZXNwb25zZSB0byBhIHJlLUlOVklURSBoYXMgdGhlIGZvbGxvd2luZyBzZW1hbnRpY3MuICBBc1xuICAgICAqIHNwZWNpZmllZCBpbiBTZWN0aW9uIDEyLjIuMiBvZiBSRkMgMzI2MSBbUkZDMzI2MV0sIGlmIGEgcmUtSU5WSVRFIGlzXG4gICAgICogcmVqZWN0ZWQsIG5vIHN0YXRlIGNoYW5nZXMgYXJlIHBlcmZvcm1lZC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjE0MSNzZWN0aW9uLTMuMVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVqZWN0IG9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFJlSW52aXRlVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDQ4OCB9OyB9XG4gICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlUm9sbGJhY2soKTtcbiAgICAgICAgdGhpcy5kaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgPSB1bmRlZmluZWQ7IC8vIEFDSyB3aWxsIGJlIGhhbmRsZWQgYnkgdHJhbnNhY3Rpb25cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVJbnZpdGVVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLlJlSW52aXRlVXNlckFnZW50U2VydmVyID0gUmVJbnZpdGVVc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogUmUtU1VCU0NSSUJFIFVBQy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50KGRpYWxvZywgZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkaWFsb2cuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXNzYWdlc18xLkMuU1VCU0NSSUJFLCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLndhaXROb3RpZnlTdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBQbGFjZWhvbGRlci4gTm90IHV0aWxpemVkIGN1cnJlbnRseS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIHJlc3BvbnNlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPj0gMjAwICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgLy8gIFRoZSBcIkV4cGlyZXNcIiBoZWFkZXIgZmllbGQgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXG4gICAgICAgICAgICAvLyAgcmVxdWVzdCBpbmRpY2F0ZXMgdGhlIGFjdHVhbCBkdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiB3aWxsXG4gICAgICAgICAgICAvLyAgcmVtYWluIGFjdGl2ZSAodW5sZXNzIHJlZnJlc2hlZCkuICBUaGUgcmVjZWl2ZWQgdmFsdWUgbWlnaHQgYmVcbiAgICAgICAgICAgIC8vICBzbWFsbGVyIHRoYW4gdGhlIHZhbHVlIGluZGljYXRlZCBpbiB0aGUgU1VCU0NSSUJFIHJlcXVlc3QgYnV0IGNhbm5vdFxuICAgICAgICAgICAgLy8gIGJlIGxhcmdlcjsgc2VlIFNlY3Rpb24gNC4yLjEgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjFcbiAgICAgICAgICAgIHZhciBleHBpcmVzID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJFeHBpcmVzXCIpO1xuICAgICAgICAgICAgaWYgKCFleHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkV4cGlyZXMgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCA9IE51bWJlcihleHBpcmVzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaWFsb2cuc3Vic2NyaXB0aW9uRXhwaXJlcyA+IHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5zdWJzY3JpcHRpb25FeHBpcmVzID0gc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXNDb2RlICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA+PSA0MDAgJiYgbWVzc2FnZS5zdGF0dXNDb2RlIDwgNzAwKSB7XG4gICAgICAgICAgICAvLyBJZiBhIFNVQlNDUklCRSByZXF1ZXN0IHRvIHJlZnJlc2ggYSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYSA0MDQsIDQwNSxcbiAgICAgICAgICAgIC8vIDQxMCwgNDE2LCA0ODAtNDg1LCA0ODksIDUwMSwgb3IgNjA0IHJlc3BvbnNlLCB0aGUgc3Vic2NyaWJlciBNVVNUXG4gICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgc3Vic2NyaXB0aW9uIHRlcm1pbmF0ZWQuICAoU2VlIFtSRkM1MDU3XSBmb3IgZnVydGhlclxuICAgICAgICAgICAgLy8gZGV0YWlscyBhbmQgbm90ZXMgYWJvdXQgdGhlIGVmZmVjdCBvZiBlcnJvciBjb2RlcyBvbiBkaWFsb2dzIGFuZFxuICAgICAgICAgICAgLy8gdXNhZ2VzIHdpdGhpbiBkaWFsb2csIHN1Y2ggYXMgc3Vic2NyaXB0aW9ucykuICBJZiB0aGUgc3Vic2NyaWJlclxuICAgICAgICAgICAgLy8gd2lzaGVzIHRvIHJlLXN1YnNjcmliZSB0byB0aGUgc3RhdGUsIGhlIGRvZXMgc28gYnkgY29tcG9zaW5nIGFuXG4gICAgICAgICAgICAvLyB1bnJlbGF0ZWQgaW5pdGlhbCBTVUJTQ1JJQkUgcmVxdWVzdCB3aXRoIGEgZnJlc2hseSBnZW5lcmF0ZWQgQ2FsbC1JRFxuICAgICAgICAgICAgLy8gYW5kIGEgbmV3LCB1bmlxdWUgXCJGcm9tXCIgdGFnIChzZWUgU2VjdGlvbiA0LjEuMi4xKS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAgICAgICAgdmFyIGVycm9yQ29kZXMgPSBbNDA0LCA0MDUsIDQxMCwgNDE2LCA0ODAsIDQ4MSwgNDgyLCA0ODMsIDQ4NCwgNDg1LCA0ODksIDUwMSwgNjA0XTtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGVzLmluZGV4T2YobWVzc2FnZS5zdGF0dXNDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgU1VCU0NSSUJFIHJlcXVlc3QgdG8gcmVmcmVzaCBhIHN1YnNjcmlwdGlvbiBmYWlscyB3aXRoIGFueSBlcnJvclxuICAgICAgICAgICAgLy8gY29kZSBvdGhlciB0aGFuIHRob3NlIGxpc3RlZCBhYm92ZSwgdGhlIG9yaWdpbmFsIHN1YnNjcmlwdGlvbiBpc1xuICAgICAgICAgICAgLy8gc3RpbGwgY29uc2lkZXJlZCB2YWxpZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBtb3N0IHJlY2VudGx5IGtub3duXG4gICAgICAgICAgICAvLyBcIkV4cGlyZXNcIiB2YWx1ZSBhcyBuZWdvdGlhdGVkIGJ5IHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIFNVQlNDUklCRVxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24sIG9yIGFzIGNvbW11bmljYXRlZCBieSBhIE5PVElGWSByZXF1ZXN0IGluIGl0c1xuICAgICAgICAgICAgLy8gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGQgXCJleHBpcmVzXCIgcGFyYW1ldGVyLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQgPSBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LXNlcnZlclwiKTtcbi8qKlxuICogUmUtU1VCU0NSSUJFIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlU3Vic2NyaWJlVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlU3Vic2NyaWJlVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlU3Vic2NyaWJlVXNlckFnZW50U2VydmVyKGRpYWxvZywgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZVN1YnNjcmliZVVzZXJBZ2VudFNlcnZlcjtcbn0odXNlcl9hZ2VudF9zZXJ2ZXJfMS5Vc2VyQWdlbnRTZXJ2ZXIpKTtcbmV4cG9ydHMuUmVTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXIgPSBSZVN1YnNjcmliZVVzZXJBZ2VudFNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBSRUZFUiBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWZlclVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWZlclVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZlclVzZXJBZ2VudENsaWVudChkaWFsb2csIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLlJFRkVSLCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWZlclVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuUmVmZXJVc2VyQWdlbnRDbGllbnQgPSBSZWZlclVzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LXNlcnZlclwiKTtcbi8qKlxuICogUkVGRVIgVUFTLlxuICogQHB1YmxpY1xuICovXG52YXIgUmVmZXJVc2VyQWdlbnRTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVmZXJVc2VyQWdlbnRTZXJ2ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogUkVGRVIgVUFTIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBkaWFsb2dPckNvcmUgLSBEaWFsb2cgZm9yIGluIGRpYWxvZyBSRUZFUiwgVXNlckFnZW50Q29yZSBmb3Igb3V0IG9mIGRpYWxvZyBSRUZFUi5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIFJFRkVSIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWZlclVzZXJBZ2VudFNlcnZlcihkaWFsb2dPckNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1c2VyQWdlbnRDb3JlID0gaW5zdGFuY2VPZlNlc3Npb25EaWFsb2coZGlhbG9nT3JDb3JlKSA/XG4gICAgICAgICAgICBkaWFsb2dPckNvcmUudXNlckFnZW50Q29yZSA6XG4gICAgICAgICAgICBkaWFsb2dPckNvcmU7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIHVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWZlclVzZXJBZ2VudFNlcnZlcjtcbn0odXNlcl9hZ2VudF9zZXJ2ZXJfMS5Vc2VyQWdlbnRTZXJ2ZXIpKTtcbmV4cG9ydHMuUmVmZXJVc2VyQWdlbnRTZXJ2ZXIgPSBSZWZlclVzZXJBZ2VudFNlcnZlcjtcbmZ1bmN0aW9uIGluc3RhbmNlT2ZTZXNzaW9uRGlhbG9nKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QudXNlckFnZW50Q29yZSAhPT0gdW5kZWZpbmVkO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBSRUdJU1RFUiBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWdpc3RlclVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWdpc3RlclVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWdpc3RlclVzZXJBZ2VudENsaWVudChjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVnaXN0ZXJVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlJlZ2lzdGVyVXNlckFnZW50Q2xpZW50ID0gUmVnaXN0ZXJVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIFJFR0lTVEVSIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlZ2lzdGVyVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlZ2lzdGVyVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZ2lzdGVyVXNlckFnZW50U2VydmVyKGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29yZSA9IGNvcmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlZ2lzdGVyVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5SZWdpc3RlclVzZXJBZ2VudFNlcnZlciA9IFJlZ2lzdGVyVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzdWJzY3JpcHRpb25fZGlhbG9nXzEgPSByZXF1aXJlKFwiLi4vZGlhbG9ncy9zdWJzY3JpcHRpb24tZGlhbG9nXCIpO1xudmFyIHN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4uL3N1YnNjcmlwdGlvblwiKTtcbnZhciB0aW1lcnNfMSA9IHJlcXVpcmUoXCIuLi90aW1lcnNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogU1VCU0NSSUJFIFVBQy5cbiAqIEByZW1hcmtzXG4gKiA0LjEuICBTdWJzY3JpYmVyIEJlaGF2aW9yXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMVxuICpcbiAqIFVzZXIgYWdlbnQgY2xpZW50IGZvciBpbnN0YWxsYXRpb24gb2YgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHBlciBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAqIFRPRE86IFN1cHBvcnQgZm9yIGluc3RhbGxhdGlvbiBvZiBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIG9uIGZvcmtlZCBTVUJTQ1JJQkUgcmVxdWVzdHMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudChjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBHZXQgZXZlbnQgZnJvbSByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICAgIHZhciBldmVudCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwiRXZlbnRcIik7XG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IHVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgZXhwaXJlcyBmcm9tIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgICAgdmFyIGV4cGlyZXMgPSBtZXNzYWdlLmdldEhlYWRlcihcIkV4cGlyZXNcIik7XG4gICAgICAgIGlmICghZXhwaXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwaXJlcyB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIC8vIEZJWE1FOiBTdWJzY3JpYmVyIGlkIHNob3VsZCBhbHNvIGJlIG1hdGNoaW5nIG9uIGV2ZW50IGlkLlxuICAgICAgICBfdGhpcy5zdWJzY3JpYmVySWQgPSBtZXNzYWdlLmNhbGxJZCArIG1lc3NhZ2UuZnJvbVRhZyArIGV2ZW50O1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzUmVxdWVzdGVkID0gX3RoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyA9IE51bWJlcihleHBpcmVzKTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uRXZlbnQgPSBldmVudDtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uU3RhdGUgPSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0O1xuICAgICAgICAvLyBTdGFydCB3YWl0aW5nIGZvciBhIE5PVElGWSB3ZSBjYW4gdXNlIHRvIGNyZWF0ZSBhIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgX3RoaXMud2FpdE5vdGlmeVN0YXJ0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKiBOb3RlIHRoYXQgVGltZXIgTiBtYXkgbGl2ZSBvbiB3YWl0aW5nIGZvciBhbiBpbml0aWFsIE5PVElGWSBhbmRcbiAgICAgKiB0aGUgZGVsZWdhdGUgbWF5IHN0aWxsIHJlY2VpdmUgdGhhdCBOT1RJRlkuIElmIHlvdSBkb24ndCB3YW50XG4gICAgICogdGhhdCBiZWhhdmlvciB0aGVuIGVpdGhlciBjbGVhciB0aGUgZGVsZWdhdGUgc28gdGhlIGRlbGVnYXRlXG4gICAgICogZG9lc24ndCBnZXQgY2FsbGVkIChhIDIwMCB3aWxsIGJlIHNlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIE5PVElGWSlcbiAgICAgKiBvciBjYWxsIGB3YWl0Tm90aWZ5U3RvcGAgd2hpY2ggd2lsbCBjbGVhciBUaW1lciBOIGFuZCByZW1vdmUgdGhpc1xuICAgICAqIFVBQyBmcm9tIHRoZSBjb3JlIChhIDQ4MSB3aWxsIGJlIHNlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIE5PVElGWSkuXG4gICAgICovXG4gICAgU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBvdXQgb2YgZGlhbG9nIE5PVElGWSBhc3NvY2lhdGVkIHdpdGggU1VCU0NSSUJFIHJlcXVlc3QuXG4gICAgICogVGhpcyBpcyB0aGUgZmlyc3QgTk9USUZZIHJlY2VpdmVkIGFmdGVyIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdWFzIC0gVXNlciBhZ2VudCBzZXJ2ZXIgaGFuZGxpbmcgdGhlIHN1YnNjcmlwdGlvbiBjcmVhdGluZyBOT1RJRlkuXG4gICAgICovXG4gICAgU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5vbk5vdGlmeSA9IGZ1bmN0aW9uICh1YXMpIHtcbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3RzIGFyZSBtYXRjaGVkIHRvIHN1Y2ggU1VCU0NSSUJFIHJlcXVlc3RzIGlmIHRoZXlcbiAgICAgICAgLy8gY29udGFpbiB0aGUgc2FtZSBcIkNhbGwtSURcIiwgYSBcIlRvXCIgaGVhZGVyIGZpZWxkIFwidGFnXCIgcGFyYW1ldGVyIHRoYXRcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgXCJGcm9tXCIgaGVhZGVyIGZpZWxkIFwidGFnXCIgcGFyYW1ldGVyIG9mIHRoZSBTVUJTQ1JJQkVcbiAgICAgICAgLy8gcmVxdWVzdCwgYW5kIHRoZSBzYW1lIFwiRXZlbnRcIiBoZWFkZXIgZmllbGQuICBSdWxlcyBmb3IgY29tcGFyaXNvbnMgb2ZcbiAgICAgICAgLy8gdGhlIFwiRXZlbnRcIiBoZWFkZXIgZmllbGRzIGFyZSBkZXNjcmliZWQgaW4gU2VjdGlvbiA4LjIuMS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjQuMVxuICAgICAgICB2YXIgZXZlbnQgPSB1YXMubWVzc2FnZS5wYXJzZUhlYWRlcihcIkV2ZW50XCIpLmV2ZW50O1xuICAgICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50ICE9PSB0aGlzLnN1YnNjcmlwdGlvbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIGV2ZW50LlwiKTtcbiAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3RzIE1VU1QgY29udGFpbiBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIGhlYWRlciBmaWVsZHMgdGhhdFxuICAgICAgICAvLyBpbmRpY2F0ZSB0aGUgc3RhdHVzIG9mIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvblN0YXRlID0gdWFzLm1lc3NhZ2UucGFyc2VIZWFkZXIoXCJTdWJzY3JpcHRpb24tU3RhdGVcIik7XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uU3RhdGUgfHwgIXN1YnNjcmlwdGlvblN0YXRlLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHN1YnNjcmlwdGlvbiBzdGF0ZS5cIik7XG4gICAgICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg5IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAgICAgICAgdmFyIHN0YXRlID0gc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGU7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYWN0aXZlXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSW52YWxpZCBzdWJzY3JpcHRpb24gc3RhdGUgXCIgKyBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlhbG9ncyB1c2FnZXMgYXJlIGNyZWF0ZWQgdXBvbiBjb21wbGV0aW9uIG9mIGEgTk9USUZZIHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIGZvciBhIG5ldyBzdWJzY3JpcHRpb24sIHVubGVzcyB0aGUgTk9USUZZIHJlcXVlc3QgY29udGFpbnMgYVxuICAgICAgICAvLyBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIG9mIFwidGVybWluYXRlZC5cIlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gXCJ0ZXJtaW5hdGVkXCIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBNVVNUIGJlIHByZXNlbnQgYW5kIGNvbnRhaW4gZXhhY3RseSBvbmUgU0lQXG4gICAgICAgICAgICAvLyBvciBTSVBTIFVSSSBpbiBhbnkgcmVxdWVzdCB0aGF0IGNhbiByZXN1bHQgaW4gdGhlIGVzdGFibGlzaG1lbnQgb2YgYVxuICAgICAgICAgICAgLy8gZGlhbG9nLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMS44XG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IHVhcy5tZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiKTtcbiAgICAgICAgICAgIGlmICghY29udGFjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgY29udGFjdC5cIik7XG4gICAgICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBydWxlcyBmb3IgcHJveHlpbmcgbm9uLUlOVklURSByZXF1ZXN0cyBhc1xuICAgICAgICAvLyBkZWZpbmVkIGluIFtSRkMzMjYxXSwgc3VjY2Vzc2Z1bCBTVUJTQ1JJQkUgcmVxdWVzdHMgd2lsbCByZWNlaXZlIG9ubHlcbiAgICAgICAgLy8gb25lIDIwMC1jbGFzcyByZXNwb25zZTsgaG93ZXZlciwgZHVlIHRvIGZvcmtpbmcsIHRoZSBzdWJzY3JpcHRpb24gbWF5XG4gICAgICAgIC8vIGhhdmUgYmVlbiBhY2NlcHRlZCBieSBtdWx0aXBsZSBub2Rlcy4gIFRoZSBzdWJzY3JpYmVyIE1VU1QgdGhlcmVmb3JlXG4gICAgICAgIC8vIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgTk9USUZZIHJlcXVlc3RzIHdpdGggXCJGcm9tOlwiIHRhZ3MgdGhhdCBkaWZmZXJcbiAgICAgICAgLy8gZnJvbSB0aGUgXCJUbzpcIiB0YWcgcmVjZWl2ZWQgaW4gdGhlIFNVQlNDUklCRSAyMDAtY2xhc3MgcmVzcG9uc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG11bHRpcGxlIE5PVElGWSByZXF1ZXN0cyBhcmUgcmVjZWl2ZWQgaW4gZGlmZmVyZW50IGRpYWxvZ3MgaW5cbiAgICAgICAgLy8gcmVzcG9uc2UgdG8gYSBzaW5nbGUgU1VCU0NSSUJFIHJlcXVlc3QsIGVhY2ggZGlhbG9nIHJlcHJlc2VudHMgYVxuICAgICAgICAvLyBkaWZmZXJlbnQgZGVzdGluYXRpb24gdG8gd2hpY2ggdGhlIFNVQlNDUklCRSByZXF1ZXN0IHdhcyBmb3JrZWQuXG4gICAgICAgIC8vIFN1YnNjcmliZXIgaGFuZGxpbmcgaW4gc3VjaCBzaXR1YXRpb25zIHZhcmllcyBieSBldmVudCBwYWNrYWdlOyBzZWVcbiAgICAgICAgLy8gU2VjdGlvbiA1LjQuOSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuNFxuICAgICAgICAvLyBFYWNoIGV2ZW50IHBhY2thZ2UgTVVTVCBzcGVjaWZ5IHdoZXRoZXIgZm9ya2VkIFNVQlNDUklCRSByZXF1ZXN0cyBhcmVcbiAgICAgICAgLy8gYWxsb3dlZCB0byBpbnN0YWxsIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHN1Y2ggYmVoYXZpb3IgaXMgbm90IGFsbG93ZWQsIHRoZSBmaXJzdCBwb3RlbnRpYWwgZGlhbG9nLVxuICAgICAgICAvLyBlc3RhYmxpc2hpbmcgbWVzc2FnZSB3aWxsIGNyZWF0ZSBhIGRpYWxvZy4gIEFsbCBzdWJzZXF1ZW50IE5PVElGWVxuICAgICAgICAvLyByZXF1ZXN0cyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIFNVQlNDUklCRSByZXF1ZXN0IChpLmUuLCBoYXZlXG4gICAgICAgIC8vIG1hdGNoaW5nIFwiVG9cIiwgXCJGcm9tXCIsIFwiQ2FsbC1JRFwiLCBhbmQgXCJFdmVudFwiIGhlYWRlciBmaWVsZHMsIGFzIHdlbGxcbiAgICAgICAgLy8gYXMgXCJGcm9tXCIgaGVhZGVyIGZpZWxkIFwidGFnXCIgcGFyYW1ldGVyIGFuZCBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkIFwiaWRcIlxuICAgICAgICAvLyBwYXJhbWV0ZXIpIGJ1dCB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgZGlhbG9nIHdvdWxkIGJlIHJlamVjdGVkIHdpdGggYVxuICAgICAgICAvLyA0ODEgcmVzcG9uc2UuICBOb3RlIHRoYXQgdGhlIDIwMC1jbGFzcyByZXNwb25zZSB0byB0aGUgU1VCU0NSSUJFXG4gICAgICAgIC8vIHJlcXVlc3QgY2FuIGFycml2ZSBhZnRlciBhIG1hdGNoaW5nIE5PVElGWSByZXF1ZXN0IGhhcyBiZWVuIHJlY2VpdmVkO1xuICAgICAgICAvLyBzdWNoIHJlc3BvbnNlcyBtaWdodCBub3QgY29ycmVsYXRlIHRvIHRoZSBzYW1lIGRpYWxvZyBlc3RhYmxpc2hlZCBieVxuICAgICAgICAvLyB0aGUgTk9USUZZIHJlcXVlc3QuICBFeGNlcHQgYXMgcmVxdWlyZWQgdG8gY29tcGxldGUgdGhlIFNVQlNDUklCRVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiwgc3VjaCBub24tbWF0Y2hpbmcgMjAwLWNsYXNzIHJlc3BvbnNlcyBhcmUgaWdub3JlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgaW5zdGFsbGluZyBvZiBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIGJ5IHdheSBvZiBhIHNpbmdsZSBmb3JrZWRcbiAgICAgICAgLy8gU1VCU0NSSUJFIHJlcXVlc3QgaXMgYWxsb3dlZCwgdGhlIHN1YnNjcmliZXIgZXN0YWJsaXNoZXMgYSBuZXcgZGlhbG9nXG4gICAgICAgIC8vIHRvd2FyZHMgZWFjaCBub3RpZmllciBieSByZXR1cm5pbmcgYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gZWFjaFxuICAgICAgICAvLyBOT1RJRlkgcmVxdWVzdC4gIEVhY2ggZGlhbG9nIGlzIHRoZW4gaGFuZGxlZCBhcyBpdHMgb3duIGVudGl0eSBhbmQgaXNcbiAgICAgICAgLy8gcmVmcmVzaGVkIGluZGVwZW5kZW50bHkgb2YgdGhlIG90aGVyIGRpYWxvZ3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyBhcmUgYWxsb3dlZCwgdGhlIGV2ZW50XG4gICAgICAgIC8vIHBhY2thZ2UgTVVTVCBzcGVjaWZ5IHdoZXRoZXIgbWVyZ2luZyBvZiB0aGUgbm90aWZpY2F0aW9ucyB0byBmb3JtIGFcbiAgICAgICAgLy8gc2luZ2xlIHN0YXRlIGlzIHJlcXVpcmVkLCBhbmQgaG93IHN1Y2ggbWVyZ2luZyBpcyB0byBiZSBwZXJmb3JtZWQuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpdCBpcyBwb3NzaWJsZSB0aGF0IHNvbWUgZXZlbnQgcGFja2FnZXMgbWF5IGJlIGRlZmluZWQgaW5cbiAgICAgICAgLy8gc3VjaCBhIHdheSB0aGF0IGVhY2ggZGlhbG9nIGlzIHRpZWQgdG8gYSBtdXR1YWxseSBleGNsdXNpdmUgc3RhdGVcbiAgICAgICAgLy8gdGhhdCBpcyB1bmFmZmVjdGVkIGJ5IHRoZSBvdGhlciBkaWFsb2dzOyB0aGlzIE1VU1QgYmUgY2xlYXJseSBzdGF0ZWRcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNS40LjlcbiAgICAgICAgLy8gKioqIE5PVEU6IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgb25seSBmb3IgZXZlbnQgcGFja2FnZXMgd2hpY2hcbiAgICAgICAgLy8gZG8gbm90IGFsbG93IGZvcmtlZCByZXF1ZXN0cyB0byBpbnN0YWxsIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMuXG4gICAgICAgIC8vIEFzIHN1Y2ggYW5kIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWNhdGlvbiwgd2Ugc3RvcCB3YWl0aW5nXG4gICAgICAgIC8vIGFuZCBhbnkgZnV0dXJlIE5PVElGWSByZXF1ZXN0cyB3aWxsIGJlIHJlamVjdGVkIHdpdGggYSA0ODEuXG4gICAgICAgIGlmICh0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIGFscmVhZHkgY3JlYXRlZC4gVGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIGluc3RhbGwgb2Ygc2luZ2xlIHN1YnNjcmlwdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdE5vdGlmeVN0b3AoKTtcbiAgICAgICAgLy8gVXBkYXRlIGV4cGlyZXMuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyA9XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25TdGF0ZS5leHBpcmVzID9cbiAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMsIE1hdGgubWF4KHN1YnNjcmlwdGlvblN0YXRlLmV4cGlyZXMsIDApKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzO1xuICAgICAgICAvLyBVcGRhdGUgc3Vic2NyaXB0aW9uIHN0YXRlLlxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgPSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5QZW5kaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFjdGl2ZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgPSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgPSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgc3RhdGUgXCIgKyBzdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaWFsb2dzIHVzYWdlcyBhcmUgY3JlYXRlZCB1cG9uIGNvbXBsZXRpb24gb2YgYSBOT1RJRlkgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gZm9yIGEgbmV3IHN1YnNjcmlwdGlvbiwgdW5sZXNzIHRoZSBOT1RJRlkgcmVxdWVzdCBjb250YWlucyBhXG4gICAgICAgIC8vIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgb2YgXCJ0ZXJtaW5hdGVkLlwiXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC40LjFcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIGRpYWxvZyB1c2FnZSBpcyBlc3RhYmxpc2hlZCBieSB0aGUgTk9USUZZIHJlcXVlc3QsIHRoZVxuICAgICAgICAgICAgLy8gcm91dGUgc2V0IGF0IHRoZSBzdWJzY3JpYmVyIGlzIHRha2VuIGZyb20gdGhlIE5PVElGWSByZXF1ZXN0IGl0c2VsZixcbiAgICAgICAgICAgIC8vIGFzIG9wcG9zZWQgdG8gdGhlIHJvdXRlIHNldCBwcmVzZW50IGluIHRoZSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gdGhlXG4gICAgICAgICAgICAvLyBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC40LjFcbiAgICAgICAgICAgIHZhciBkaWFsb2dTdGF0ZSA9IHN1YnNjcmlwdGlvbl9kaWFsb2dfMS5TdWJzY3JpcHRpb25EaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yU3Vic2NyaXB0aW9uKHRoaXMubWVzc2FnZSwgdWFzLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uIEluaXRpYXRlZCEgOilcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nID0gbmV3IHN1YnNjcmlwdGlvbl9kaWFsb2dfMS5TdWJzY3JpcHRpb25EaWFsb2codGhpcy5zdWJzY3JpcHRpb25FdmVudCwgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzLCB0aGlzLnN1YnNjcmlwdGlvblN0YXRlLCB0aGlzLmNvcmUsIGRpYWxvZ1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxlZ2F0ZS5cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB1YXM7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5kaWFsb2c7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KHsgcmVxdWVzdDogcmVxdWVzdCwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1YXMuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUud2FpdE5vdGlmeVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuTikge1xuICAgICAgICAgICAgLy8gQWRkIG91cnNlbHZlcyB0byB0aGUgY29yZSdzIHN1YnNjcmliZXIgbWFwLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIGNvcmUgdG8gcm91dGUgb3V0IG9mIGRpYWxvZyBOT1RJRlkgbWVzc2FnZXMgdG8gdXMuXG4gICAgICAgICAgICB0aGlzLmNvcmUuc3Vic2NyaWJlcnMuc2V0KHRoaXMuc3Vic2NyaWJlcklkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuTiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfTigpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfTik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUud2FpdE5vdGlmeVN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLk4pIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBvdXJzZWx2ZXMgdG8gdGhlIGNvcmUncyBzdWJzY3JpYmVyIG1hcC5cbiAgICAgICAgICAgIC8vIEFueSBmdXR1cmUgb3V0IG9mIGRpYWxvZyBOT1RJRlkgbWVzc2FnZXMgd2lsbCBiZSByZWplY3RlZCB3aXRoIGEgNDgxLlxuICAgICAgICAgICAgdGhpcy5jb3JlLnN1YnNjcmliZXJzLmRlbGV0ZSh0aGlzLnN1YnNjcmliZXJJZCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5OKTtcbiAgICAgICAgICAgIHRoaXMuTiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIHJlc3BvbnNlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPj0gMjAwICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgLy8gIFRoZSBcIkV4cGlyZXNcIiBoZWFkZXIgZmllbGQgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXG4gICAgICAgICAgICAvLyAgcmVxdWVzdCBpbmRpY2F0ZXMgdGhlIGFjdHVhbCBkdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiB3aWxsXG4gICAgICAgICAgICAvLyAgcmVtYWluIGFjdGl2ZSAodW5sZXNzIHJlZnJlc2hlZCkuICBUaGUgcmVjZWl2ZWQgdmFsdWUgbWlnaHQgYmVcbiAgICAgICAgICAgIC8vICBzbWFsbGVyIHRoYW4gdGhlIHZhbHVlIGluZGljYXRlZCBpbiB0aGUgU1VCU0NSSUJFIHJlcXVlc3QgYnV0IGNhbm5vdFxuICAgICAgICAgICAgLy8gIGJlIGxhcmdlcjsgc2VlIFNlY3Rpb24gNC4yLjEgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjFcbiAgICAgICAgICAgIC8vIFRoZSBcIkV4cGlyZXNcIiB2YWx1ZXMgcHJlc2VudCBpbiBTVUJTQ1JJQkUgMjAwLWNsYXNzIHJlc3BvbnNlcyBiZWhhdmVcbiAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIHdheSBhcyB0aGV5IGRvIGluIFJFR0lTVEVSIHJlc3BvbnNlczogdGhlIHNlcnZlciBNQVlcbiAgICAgICAgICAgIC8vIHNob3J0ZW4gdGhlIGludGVydmFsIGJ1dCBNVVNUIE5PVCBsZW5ndGhlbiBpdC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICBJZiB0aGUgZHVyYXRpb24gc3BlY2lmaWVkIGluIGEgU1VCU0NSSUJFIHJlcXVlc3QgaXMgdW5hY2NlcHRhYmx5XG4gICAgICAgICAgICAvLyAgICBzaG9ydCwgdGhlIG5vdGlmaWVyIG1heSBiZSBhYmxlIHRvIHNlbmQgYSA0MjMgcmVzcG9uc2UsIGFzXG4gICAgICAgICAgICAvLyAgICBkZXNjcmliZWQgZWFybGllciBpbiB0aGlzIHNlY3Rpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMjAwLWNsYXNzIHJlc3BvbnNlcyB0byBTVUJTQ1JJQkUgcmVxdWVzdHMgd2lsbCBub3QgZ2VuZXJhbGx5IGNvbnRhaW5cbiAgICAgICAgICAgIC8vIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYmV5b25kIHN1YnNjcmlwdGlvbiBkdXJhdGlvbjsgdGhlaXIgcHJpbWFyeVxuICAgICAgICAgICAgLy8gcHVycG9zZSBpcyB0byBzZXJ2ZSBhcyBhIHJlbGlhYmlsaXR5IG1lY2hhbmlzbS4gIFN0YXRlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGNvbW11bmljYXRlZCB2aWEgYSBzdWJzZXF1ZW50IE5PVElGWSByZXF1ZXN0IGZyb20gdGhlXG4gICAgICAgICAgICAvLyBub3RpZmllci5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4yLjEuMVxuICAgICAgICAgICAgdmFyIGV4cGlyZXMgPSBtZXNzYWdlLmdldEhlYWRlcihcIkV4cGlyZXNcIik7XG4gICAgICAgICAgICBpZiAoIWV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRXhwaXJlcyBoZWFkZXIgbWlzc2luZyBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBTVUJTQ1JJQkVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkID0gTnVtYmVyKGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25FeHBpcmVzUmVjZWl2ZWQgPiB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXNSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkV4cGlyZXMgaGVhZGVyIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRSB3aXRoIGEgaGlnaGVyIHZhbHVlIHRoYW4gdGhlIG9uZSBpbiB0aGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCA8IHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgPSBzdWJzY3JpcHRpb25FeHBpcmVzUmVjZWl2ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBOT1RJRlkgYXJyaXZlZCBiZWZvcmUgMjAwLWNsYXNzIHJlc3BvbnNlIGEgZGlhbG9nIG1heSBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICAgIC8vIFVwZGF0ZWQgdGhlIGRpYWxvZ3MgZXhwaXJhdGlvbiBvbmx5IGlmIHRoaXMgaW5kaWNhdGVzIGVhcmxpZXIgZXhwaXJhdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpYWxvZy5zdWJzY3JpcHRpb25FeHBpcmVzID4gdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nLnN1YnNjcmlwdGlvbkV4cGlyZXMgPSB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgJiYgbWVzc2FnZS5zdGF0dXNDb2RlID49IDMwMCAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPCA3MDApIHtcbiAgICAgICAgICAgIHRoaXMud2FpdE5vdGlmeVN0b3AoKTsgLy8gTm8gTk9USUZZIHdpbGwgYmUgc2VudCBhZnRlciBhIG5lZ2F0aXZlIGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUbyBlbnN1cmUgdGhhdCBzdWJzY3JpYmVycyBkbyBub3Qgd2FpdCBpbmRlZmluaXRlbHkgZm9yIGFcbiAgICAgKiBzdWJzY3JpcHRpb24gdG8gYmUgZXN0YWJsaXNoZWQsIGEgc3Vic2NyaWJlciBzdGFydHMgYSBUaW1lciBOLCBzZXQgdG9cbiAgICAgKiA2NCpUMSwgd2hlbiBpdCBzZW5kcyBhIFNVQlNDUklCRSByZXF1ZXN0LiAgSWYgdGhpcyBUaW1lciBOIGV4cGlyZXNcbiAgICAgKiBwcmlvciB0byB0aGUgcmVjZWlwdCBvZiBhIE5PVElGWSByZXF1ZXN0LCB0aGUgc3Vic2NyaWJlciBjb25zaWRlcnNcbiAgICAgKiB0aGUgc3Vic2NyaXB0aW9uIGZhaWxlZCwgYW5kIGNsZWFucyB1cCBhbnkgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqIHN1YnNjcmlwdGlvbiBhdHRlbXB0LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuNFxuICAgICAqL1xuICAgIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUudGltZXJfTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRpbWVyIE4gZXhwaXJlZCBmb3IgU1VCU0NSSUJFIHVzZXIgYWdlbnQgY2xpZW50LiBUaW1lZCBvdXQgd2FpdGluZyBmb3IgTk9USUZZLlwiKTtcbiAgICAgICAgdGhpcy53YWl0Tm90aWZ5U3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50ID0gU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBTVUJTQ1JJQkUgVUFTLlxuICogQHB1YmxpY1xuICovXG52YXIgU3Vic2NyaWJlVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN1YnNjcmliZVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXIoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3Vic2NyaWJlVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5TdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXIgPSBTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbi8qKlxuICogVXNlciBBZ2VudCBDbGllbnQgKFVBQykuXG4gKiBAcmVtYXJrc1xuICogQSB1c2VyIGFnZW50IGNsaWVudCBpcyBhIGxvZ2ljYWwgZW50aXR5XG4gKiB0aGF0IGNyZWF0ZXMgYSBuZXcgcmVxdWVzdCwgYW5kIHRoZW4gdXNlcyB0aGUgY2xpZW50XG4gKiB0cmFuc2FjdGlvbiBzdGF0ZSBtYWNoaW5lcnkgdG8gc2VuZCBpdC4gIFRoZSByb2xlIG9mIFVBQyBsYXN0c1xuICogb25seSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoYXQgdHJhbnNhY3Rpb24uICBJbiBvdGhlciB3b3JkcywgaWZcbiAqIGEgcGllY2Ugb2Ygc29mdHdhcmUgaW5pdGlhdGVzIGEgcmVxdWVzdCwgaXQgYWN0cyBhcyBhIFVBQyBmb3JcbiAqIHRoZSBkdXJhdGlvbiBvZiB0aGF0IHRyYW5zYWN0aW9uLiAgSWYgaXQgcmVjZWl2ZXMgYSByZXF1ZXN0XG4gKiBsYXRlciwgaXQgYXNzdW1lcyB0aGUgcm9sZSBvZiBhIHVzZXIgYWdlbnQgc2VydmVyIGZvciB0aGVcbiAqIHByb2Nlc3Npbmcgb2YgdGhhdCB0cmFuc2FjdGlvbi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNlxuICogQHB1YmxpY1xuICovXG52YXIgVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVzZXJBZ2VudENsaWVudCh0cmFuc2FjdGlvbkNvbnN0cnVjdG9yLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uQ29uc3RydWN0b3IgPSB0cmFuc2FjdGlvbkNvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLmNvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuY2hhbGxlbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gdGhpcy5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihcInNpcC51c2VyLWFnZW50LWNsaWVudFwiKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIFVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZSwgXCJsb2dnZXJGYWN0b3J5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLmxvZ2dlckZhY3Rvcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLCBcInRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgLyoqIFRoZSB0cmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTaW5jZSByZXF1ZXN0cyBvdGhlciB0aGFuIElOVklURSBhcmUgcmVzcG9uZGVkIHRvIGltbWVkaWF0ZWx5LCBzZW5kaW5nIGFcbiAgICAgKiBDQU5DRUwgZm9yIGEgbm9uLUlOVklURSByZXF1ZXN0IHdvdWxkIGFsd2F5cyBjcmVhdGUgYSByYWNlIGNvbmRpdGlvbi5cbiAgICAgKiBBIENBTkNFTCByZXF1ZXN0IFNIT1VMRCBOT1QgYmUgc2VudCB0byBjYW5jZWwgYSByZXF1ZXN0IG90aGVyIHRoYW4gSU5WSVRFLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4xXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDYW5jZWwgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICghdGhpcy50cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZS50bykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZS5mcm9tKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBwcm9jZWR1cmVzIGFyZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENBTkNFTCByZXF1ZXN0LiAgVGhlXG4gICAgICAgIC8vIFJlcXVlc3QtVVJJLCBDYWxsLUlELCBUbywgdGhlIG51bWVyaWMgcGFydCBvZiBDU2VxLCBhbmQgRnJvbSBoZWFkZXJcbiAgICAgICAgLy8gZmllbGRzIGluIHRoZSBDQU5DRUwgcmVxdWVzdCBNVVNUIGJlIGlkZW50aWNhbCB0byB0aG9zZSBpbiB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBiZWluZyBjYW5jZWxsZWQsIGluY2x1ZGluZyB0YWdzLiAgQSBDQU5DRUwgY29uc3RydWN0ZWQgYnkgYVxuICAgICAgICAvLyBjbGllbnQgTVVTVCBoYXZlIG9ubHkgYSBzaW5nbGUgVmlhIGhlYWRlciBmaWVsZCB2YWx1ZSBtYXRjaGluZyB0aGVcbiAgICAgICAgLy8gdG9wIFZpYSB2YWx1ZSBpbiB0aGUgcmVxdWVzdCBiZWluZyBjYW5jZWxsZWQuICBVc2luZyB0aGUgc2FtZSB2YWx1ZXNcbiAgICAgICAgLy8gZm9yIHRoZXNlIGhlYWRlciBmaWVsZHMgYWxsb3dzIHRoZSBDQU5DRUwgdG8gYmUgbWF0Y2hlZCB3aXRoIHRoZVxuICAgICAgICAvLyByZXF1ZXN0IGl0IGNhbmNlbHMgKFNlY3Rpb24gOS4yIGluZGljYXRlcyBob3cgc3VjaCBtYXRjaGluZyBvY2N1cnMpLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgbWV0aG9kIHBhcnQgb2YgdGhlIENTZXEgaGVhZGVyIGZpZWxkIE1VU1QgaGF2ZSBhIHZhbHVlXG4gICAgICAgIC8vIG9mIENBTkNFTC4gIFRoaXMgYWxsb3dzIGl0IHRvIGJlIGlkZW50aWZpZWQgYW5kIHByb2Nlc3NlZCBhcyBhXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGluIGl0cyBvd24gcmlnaHQgKFNlZSBTZWN0aW9uIDE3KS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi05LjFcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmNvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLkNBTkNFTCwgdGhpcy5tZXNzYWdlLnJ1cmksIHRoaXMubWVzc2FnZS5mcm9tLnVyaSwgdGhpcy5tZXNzYWdlLnRvLnVyaSwge1xuICAgICAgICAgICAgdG9UYWc6IHRoaXMubWVzc2FnZS50b1RhZyxcbiAgICAgICAgICAgIGZyb21UYWc6IHRoaXMubWVzc2FnZS5mcm9tVGFnLFxuICAgICAgICAgICAgY2FsbElkOiB0aGlzLm1lc3NhZ2UuY2FsbElkLFxuICAgICAgICAgICAgY3NlcTogdGhpcy5tZXNzYWdlLmNzZXFcbiAgICAgICAgfSwgb3B0aW9ucy5leHRyYUhlYWRlcnMpO1xuICAgICAgICAvLyBUT0RPOiBSZXZpc2l0IHRoaXMuXG4gICAgICAgIC8vIFRoZSBDQU5DRUwgbmVlZHMgdG8gdXNlIHRoZSBzYW1lIGJyYW5jaCBwYXJhbWV0ZXIgc28gdGhhdFxuICAgICAgICAvLyBpdCBtYXRjaGVzIHRoZSBJTlZJVEUgdHJhbnNhY3Rpb24sIGJ1dCB0aGlzIGlzIGEgaGFja3kgd2F5IHRvIGRvIHRoaXMuXG4gICAgICAgIC8vIE9yIGF0IHRoZSB2ZXJ5IGxlYXN0IG5vdCB3ZWxsIGRvY3VtZW50ZWQuIElmIHRoZSB0aGUgYnJhbmNoIHBhcmFtZXRlclxuICAgICAgICAvLyBpcyBzZXQgb24gdGhlIG91dGdvaW5nIHJlcXVlc3QsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIHVzZSBpdC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSB0cmFuc2FjdGlvbiB3aWxsIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICBtZXNzYWdlLmJyYW5jaCA9IHRoaXMubWVzc2FnZS5icmFuY2g7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UuaGVhZGVycy5Sb3V0ZSkge1xuICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJzLlJvdXRlID0gdGhpcy5tZXNzYWdlLmhlYWRlcnMuUm91dGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJSZWFzb25cIiwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBwcm92aXNpb25hbCByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCwgdGhlIENBTkNFTCByZXF1ZXN0IE1VU1RcbiAgICAgICAgLy8gTk9UIGJlIHNlbnQ7IHJhdGhlciwgdGhlIGNsaWVudCBNVVNUIHdhaXQgZm9yIHRoZSBhcnJpdmFsIG9mIGFcbiAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2UgYmVmb3JlIHNlbmRpbmcgdGhlIHJlcXVlc3QuIElmIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyByZXF1ZXN0IGhhcyBnZW5lcmF0ZWQgYSBmaW5hbCByZXNwb25zZSwgdGhlIENBTkNFTCBTSE9VTEQgTk9UIGJlXG4gICAgICAgIC8vIHNlbnQsIGFzIGl0IGlzIGFuIGVmZmVjdGl2ZSBuby1vcCwgc2luY2UgQ0FOQ0VMIGhhcyBubyBlZmZlY3Qgb25cbiAgICAgICAgLy8gcmVxdWVzdHMgdGhhdCBoYXZlIGFscmVhZHkgZ2VuZXJhdGVkIGEgZmluYWwgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4xXG4gICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgICAgICAgIHZhciB1YWMgPSBuZXcgVXNlckFnZW50Q2xpZW50KHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCB0aGlzLmNvcmUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmNlKFwic3RhdGVDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhbnNhY3Rpb24gJiYgX3RoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFjID0gbmV3IFVzZXJBZ2VudENsaWVudCh0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgX3RoaXMuY29yZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBhIDQwMSAoVW5hdXRob3JpemVkKSBvciA0MDcgKFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkKVxuICAgICAqIHJlc3BvbnNlIGlzIHJlY2VpdmVkLCB0aGUgVUFDIFNIT1VMRCBmb2xsb3cgdGhlIGF1dGhvcml6YXRpb25cbiAgICAgKiBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMjIuMiBhbmQgU2VjdGlvbiAyMi4zIHRvIHJldHJ5IHRoZSByZXF1ZXN0IHdpdGhcbiAgICAgKiBjcmVkZW50aWFscy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjVcbiAgICAgKiAyMiBVc2FnZSBvZiBIVFRQIEF1dGhlbnRpY2F0aW9uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0yMlxuICAgICAqIDIyLjEgRnJhbWV3b3JrXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0yMi4xXG4gICAgICogMjIuMiBVc2VyLXRvLVVzZXIgQXV0aGVudGljYXRpb25cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIyLjJcbiAgICAgKiAyMi4zIFByb3h5LXRvLVVzZXIgQXV0aGVudGljYXRpb25cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIyLjNcbiAgICAgKlxuICAgICAqIEZJWE1FOiBUaGlzIFwiZ3VhcmQgZm9yIGFuZCByZXRyeSB0aGUgcmVxdWVzdCB3aXRoIGNyZWRlbnRpYWxzXCJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBpcyBub3QgY29tcGxldGUgYW5kIGF0IGJlc3QgbWluaW1hbGx5IHBhc3NhYmxlLlxuICAgICAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBpbmNvbWluZyByZXNwb25zZSB0byBndWFyZC5cbiAgICAgKiBAcGFyYW0gZGlhbG9nIC0gSWYgZGVmaW5lZCwgdGhlIGRpYWxvZyB3aXRoaW4gd2hpY2ggdGhlIHJlc3BvbnNlIHdhcyByZWNlaXZlZC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwcm9ncmFtIGV4ZWN1dGlvbiBpcyB0byBjb250aW51ZSBpbiB0aGUgYnJhbmNoIGluIHF1ZXN0aW9uLlxuICAgICAqICAgICAgICAgIE90aGVyd2lzZSB0aGUgcmVxdWVzdCBpcyByZXRyaWVkIHdpdGggY3JlZGVudGlhbHMgYW5kIGN1cnJlbnQgcmVxdWVzdCBwcm9jZXNzaW5nIG11c3Qgc3RvcC5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLmF1dGhlbnRpY2F0aW9uR3VhcmQgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGlhbG9nKSB7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSA0MDEgKFVuYXV0aG9yaXplZCkgb3IgNDA3IChQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZClcbiAgICAgICAgLy8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQsIHRoZSBVQUMgU0hPVUxEIGZvbGxvdyB0aGUgYXV0aG9yaXphdGlvblxuICAgICAgICAvLyBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMjIuMiBhbmQgU2VjdGlvbiAyMi4zIHRvIHJldHJ5IHRoZSByZXF1ZXN0IHdpdGhcbiAgICAgICAgLy8gY3JlZGVudGlhbHMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuNVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gNDAxICYmIHN0YXR1c0NvZGUgIT09IDQwNykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGFuZCBwYXJzZSB0aGUgYXBwcm9wcmlhdGUgV1dXLUF1dGhlbnRpY2F0ZSBvciBQcm94eS1BdXRoZW50aWNhdGUgaGVhZGVyLlxuICAgICAgICB2YXIgY2hhbGxlbmdlO1xuICAgICAgICB2YXIgYXV0aG9yaXphdGlvbkhlYWRlck5hbWU7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJ3d3ctYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvbkhlYWRlck5hbWUgPSBcImF1dGhvcml6YXRpb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJwcm94eS1hdXRoZW50aWNhdGVcIik7XG4gICAgICAgICAgICBhdXRob3JpemF0aW9uSGVhZGVyTmFtZSA9IFwicHJveHktYXV0aG9yaXphdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZlcmlmeSBpdCBzZWVtcyBhIHZhbGlkIGNoYWxsZW5nZS5cbiAgICAgICAgaWYgKCFjaGFsbGVuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oc3RhdHVzQ29kZSArIFwiIHdpdGggd3Jvbmcgb3IgbWlzc2luZyBjaGFsbGVuZ2UsIGNhbm5vdCBhdXRoZW50aWNhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCBpbmZpbml0ZSBhdXRoZW50aWNhdGlvbnMuXG4gICAgICAgIGlmICh0aGlzLmNoYWxsZW5nZWQgJiYgKHRoaXMuc3RhbGUgfHwgY2hhbGxlbmdlLnN0YWxlICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihzdGF0dXNDb2RlICsgXCIgYXBwYXJlbnRseSBpbiBhdXRoZW50aWNhdGlvbiBsb29wLCBjYW5ub3QgYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGNyZWRlbnRpYWxzLlxuICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0aGlzLmNvcmUuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVbmFibGUgdG8gb2J0YWluIGNyZWRlbnRpYWxzLCBjYW5ub3QgYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjaGFsbGVuZ2UgaXMgcmVhbGx5IHZhbGlkLlxuICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMuYXV0aGVudGljYXRlKHRoaXMubWVzc2FnZSwgY2hhbGxlbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFsbGVuZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNoYWxsZW5nZS5zdGFsZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcmVzcG9uc2UgdG8gb3V0IG9mIGRpYWxvZyByZXF1ZXN0LCBhc3N1bWUgaW5jcmVtZW50aW5nIHRoZSBDU2VxIHdpbGwgc3VmZmljZS5cbiAgICAgICAgdmFyIGNzZXEgPSB0aGlzLm1lc3NhZ2UuY3NlcSArPSAxO1xuICAgICAgICAvLyBJZiByZXNwb25zZSB0byBpbiBkaWFsb2cgcmVxdWVzdCwgZ2V0IGEgdmFsaWQgbmV4dCBDU2VxIG51bWJlci5cbiAgICAgICAgaWYgKGRpYWxvZyAmJiBkaWFsb2cubG9jYWxTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgZGlhbG9nLmluY3JlbWVudExvY2FsU2VxdWVuY2VOdW1iZXIoKTtcbiAgICAgICAgICAgIGNzZXEgPSB0aGlzLm1lc3NhZ2UuY3NlcSA9IGRpYWxvZy5sb2NhbFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZS5zZXRIZWFkZXIoXCJjc2VxXCIsIGNzZXEgKyBcIiBcIiArIHRoaXMubWVzc2FnZS5tZXRob2QpO1xuICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKGF1dGhvcml6YXRpb25IZWFkZXJOYW1lLCB0aGlzLmNyZWRlbnRpYWxzLnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyBDYWxsaW5nIGluaXQgKGFnYWluKSB3aWxsIHN3YXAgb3V0IG91ciBleGlzdGluZyBjbGllbnQgdHJhbnNhY3Rpb24gd2l0aCBhIG5ldyBvbmUuXG4gICAgICAgIC8vIEZJWE1FOiBIQUNLOiBBbiBhc3N1bXB0aW9uIGlzIGJlaW5nIG1hZGUgaGVyZSB0aGF0IHRoZXJlIGlzIG5vdGhpbmcgdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSBjbGVhbmVkIHVwIGJleW9uZCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHdoaWNoIGlzIGJlaW5nIHJlcGxhY2VkLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gaXQgaXMgYXNzdW1lZCB0aGF0IG5vIGVhcmx5IGRpYWxvZ3MgaGF2ZSBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA4LjEuMy4xIFRyYW5zYWN0aW9uIExheWVyIEVycm9yc1xuICAgICAqIEluIHNvbWUgY2FzZXMsIHRoZSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIgd2lsbFxuICAgICAqIG5vdCBiZSBhIFNJUCBtZXNzYWdlLCBidXQgcmF0aGVyIGEgdHJhbnNhY3Rpb24gbGF5ZXIgZXJyb3IuICBXaGVuIGFcbiAgICAgKiB0aW1lb3V0IGVycm9yIGlzIHJlY2VpdmVkIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLCBpdCBNVVNUIGJlXG4gICAgICogdHJlYXRlZCBhcyBpZiBhIDQwOCAoUmVxdWVzdCBUaW1lb3V0KSBzdGF0dXMgY29kZSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgKiBJZiBhIGZhdGFsIHRyYW5zcG9ydCBlcnJvciBpcyByZXBvcnRlZCBieSB0aGUgdHJhbnNwb3J0IGxheWVyXG4gICAgICogKGdlbmVyYWxseSwgZHVlIHRvIGZhdGFsIElDTVAgZXJyb3JzIGluIFVEUCBvciBjb25uZWN0aW9uIGZhaWx1cmVzIGluXG4gICAgICogVENQKSwgdGhlIGNvbmRpdGlvbiBNVVNUIGJlIHRyZWF0ZWQgYXMgYSA1MDMgKFNlcnZpY2UgVW5hdmFpbGFibGUpXG4gICAgICogc3RhdHVzIGNvZGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4xXG4gICAgICovXG4gICAgVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVXNlciBhZ2VudCBjbGllbnQgcmVxdWVzdCB0aW1lZCBvdXQuIEdlbmVyYXRpbmcgaW50ZXJuYWwgNDA4IFJlcXVlc3QgVGltZW91dC5cIik7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IG1lc3NhZ2VzXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UoKTtcbiAgICAgICAgbWVzc2FnZS5zdGF0dXNDb2RlID0gNDA4O1xuICAgICAgICBtZXNzYWdlLnJlYXNvblBocmFzZSA9IFwiUmVxdWVzdCBUaW1lb3V0XCI7XG4gICAgICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiA4LjEuMy4xIFRyYW5zYWN0aW9uIExheWVyIEVycm9yc1xuICAgICAqIEluIHNvbWUgY2FzZXMsIHRoZSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIgd2lsbFxuICAgICAqIG5vdCBiZSBhIFNJUCBtZXNzYWdlLCBidXQgcmF0aGVyIGEgdHJhbnNhY3Rpb24gbGF5ZXIgZXJyb3IuICBXaGVuIGFcbiAgICAgKiB0aW1lb3V0IGVycm9yIGlzIHJlY2VpdmVkIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLCBpdCBNVVNUIGJlXG4gICAgICogdHJlYXRlZCBhcyBpZiBhIDQwOCAoUmVxdWVzdCBUaW1lb3V0KSBzdGF0dXMgY29kZSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgKiBJZiBhIGZhdGFsIHRyYW5zcG9ydCBlcnJvciBpcyByZXBvcnRlZCBieSB0aGUgdHJhbnNwb3J0IGxheWVyXG4gICAgICogKGdlbmVyYWxseSwgZHVlIHRvIGZhdGFsIElDTVAgZXJyb3JzIGluIFVEUCBvciBjb25uZWN0aW9uIGZhaWx1cmVzIGluXG4gICAgICogVENQKSwgdGhlIGNvbmRpdGlvbiBNVVNUIGJlIHRyZWF0ZWQgYXMgYSA1MDMgKFNlcnZpY2UgVW5hdmFpbGFibGUpXG4gICAgICogc3RhdHVzIGNvZGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4xXG4gICAgICogQHBhcmFtIGVycm9yIC0gVHJhbnNwb3J0IGVycm9yXG4gICAgICovXG4gICAgVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlVzZXIgYWdlbnQgY2xpZW50IHJlcXVlc3QgdHJhbnNwb3J0IGVycm9yLiBHZW5lcmF0aW5nIGludGVybmFsIDUwMyBTZXJ2aWNlIFVuYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgbWVzc2FnZXNfMS5JbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSgpO1xuICAgICAgICBtZXNzYWdlLnN0YXR1c0NvZGUgPSA1MDM7XG4gICAgICAgIG1lc3NhZ2UucmVhc29uUGhyYXNlID0gXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCI7XG4gICAgICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIHJlc3BvbnNlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBtZXNzYWdlLnN0YXR1c0NvZGUgPyBtZXNzYWdlLnN0YXR1c0NvZGUudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgIGlmICghc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugc3RhdHVzIGNvZGUgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgL14xMDAkLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25UcnlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblRyeWluZyh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcyh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQWNjZXB0KHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eM1swLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZGlyZWN0KHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eWzQtNl1bMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVqZWN0KHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXZSBhcmUgdGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgICAgIHZhciB1c2VyID0ge1xuICAgICAgICAgICAgbG9nZ2VyRmFjdG9yeTogdGhpcy5sb2dnZXJGYWN0b3J5LFxuICAgICAgICAgICAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25SZXF1ZXN0VGltZW91dCgpOyB9LFxuICAgICAgICAgICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZXJtaW5hdGVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNvcmUuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvcmUudXNlckFnZW50Q2xpZW50cy5kZWxldGUodXNlckFnZW50Q2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogSEFDSzogT3VyIHRyYW5zYWN0aW9uIG1heSBoYXZlIGJlZW4gc3dhcHBlZCBvdXQgd2l0aCBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zdCBhdXRoZW50aWNhdGlvbiAoc2VlIGFib3ZlKSwgc28gbWFrZSBzdXJlIHRvIG9ubHkgdG8gZGlzcG9zZSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBvdXJzZWx2ZXMgaWYgdGhpcyB0ZXJtaW5hdGluZyB0cmFuc2FjdGlvbiBpcyBvdXIgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uID09PSBfdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF90aGlzLm9uVHJhbnNwb3J0RXJyb3IoZXJyb3IpOyB9LFxuICAgICAgICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpOyB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiB3aXRoIHVzIGFzIHRoZSB1c2VyLlxuICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBuZXcgdGhpcy50cmFuc2FjdGlvbkNvbnN0cnVjdG9yKHRoaXMubWVzc2FnZSwgdGhpcy5jb3JlLnRyYW5zcG9ydCwgdXNlcik7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IHRyYW5zYWN0aW9uIHRvIHRoZSBjb3JlLlxuICAgICAgICB2YXIgdXNlckFnZW50Q2xpZW50SWQgPSB0cmFuc2FjdGlvbi5pZCArIHRyYW5zYWN0aW9uLnJlcXVlc3QubWV0aG9kO1xuICAgICAgICB0aGlzLmNvcmUudXNlckFnZW50Q2xpZW50cy5zZXQodXNlckFnZW50Q2xpZW50SWQsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFVzZXJBZ2VudENsaWVudDtcbn0oKSk7XG5leHBvcnRzLlVzZXJBZ2VudENsaWVudCA9IFVzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9leGNlcHRpb25zXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy91dGlsc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG4vKipcbiAqIFVzZXIgQWdlbnQgU2VydmVyIChVQVMpLlxuICogQHJlbWFya3NcbiAqIEEgdXNlciBhZ2VudCBzZXJ2ZXIgaXMgYSBsb2dpY2FsIGVudGl0eVxuICogdGhhdCBnZW5lcmF0ZXMgYSByZXNwb25zZSB0byBhIFNJUCByZXF1ZXN0LiAgVGhlIHJlc3BvbnNlXG4gKiBhY2NlcHRzLCByZWplY3RzLCBvciByZWRpcmVjdHMgdGhlIHJlcXVlc3QuICBUaGlzIHJvbGUgbGFzdHNcbiAqIG9ubHkgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGF0IHRyYW5zYWN0aW9uLiAgSW4gb3RoZXIgd29yZHMsIGlmXG4gKiBhIHBpZWNlIG9mIHNvZnR3YXJlIHJlc3BvbmRzIHRvIGEgcmVxdWVzdCwgaXQgYWN0cyBhcyBhIFVBUyBmb3JcbiAqIHRoZSBkdXJhdGlvbiBvZiB0aGF0IHRyYW5zYWN0aW9uLiAgSWYgaXQgZ2VuZXJhdGVzIGEgcmVxdWVzdFxuICogbGF0ZXIsIGl0IGFzc3VtZXMgdGhlIHJvbGUgb2YgYSB1c2VyIGFnZW50IGNsaWVudCBmb3IgdGhlXG4gKiBwcm9jZXNzaW5nIG9mIHRoYXQgdHJhbnNhY3Rpb24uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVc2VyQWdlbnRTZXJ2ZXIodHJhbnNhY3Rpb25Db25zdHJ1Y3RvciwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbkNvbnN0cnVjdG9yID0gdHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IHRoaXMubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAudXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4gICAgICAgIHRoaXMudG9UYWcgPSBtZXNzYWdlLnRvVGFnID8gbWVzc2FnZS50b1RhZyA6IHV0aWxzXzEubmV3VGFnKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24uZGlzcG9zZSgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUsIFwibG9nZ2VyRmFjdG9yeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5sb2dnZXJGYWN0b3J5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50U2VydmVyLnByb3RvdHlwZSwgXCJ0cmFuc2FjdGlvblwiLCB7XG4gICAgICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDIwMCB9OyB9XG4gICAgICAgIGlmICghdGhpcy5hY2NlcHRhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGVFcnJvcih0aGlzLm1lc3NhZ2UubWV0aG9kICsgXCIgbm90IGFjY2VwdGFibGUgaW4gc3RhdGUgXCIgKyB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCB8fCBzdGF0dXNDb2RlID4gMjk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IHRoaXMucmVwbHkob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuICAgIFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDE4MCB9OyB9XG4gICAgICAgIGlmICghdGhpcy5wcm9ncmVzc2FibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZUVycm9yKHRoaXMubWVzc2FnZS5tZXRob2QgKyBcIiBub3QgcHJvZ3Jlc3NhYmxlIGluIHN0YXRlIFwiICsgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAxMDEgfHwgc3RhdHVzQ29kZSA+IDE5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKGNvbnRhY3RzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMzAyIH07IH1cbiAgICAgICAgaWYgKCF0aGlzLnJlZGlyZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlRXJyb3IodGhpcy5tZXNzYWdlLm1ldGhvZCArIFwiIG5vdCByZWRpcmVjdGFibGUgaW4gc3RhdGUgXCIgKyB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCB8fCBzdGF0dXNDb2RlID4gMzk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWN0SGVhZGVycyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb250YWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWN0KSB7IHJldHVybiBjb250YWN0SGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyBjb250YWN0LnRvU3RyaW5nKCkpOyB9KTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLmNvbmNhdChjb250YWN0SGVhZGVycyk7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHRoaXMucmVwbHkob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuICAgIFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiA0ODAgfTsgfVxuICAgICAgICBpZiAoIXRoaXMucmVqZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlRXJyb3IodGhpcy5tZXNzYWdlLm1ldGhvZCArIFwiIG5vdCByZWplY3RhYmxlIGluIHN0YXRlIFwiICsgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCA0MDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnRyeWluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy50cnlpbmdhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGVFcnJvcih0aGlzLm1lc3NhZ2UubWV0aG9kICsgXCIgbm90IHRyeWluZ2FibGUgaW4gc3RhdGUgXCIgKyB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IHRoaXMucmVwbHkoeyBzdGF0dXNDb2RlOiAxMDAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBVQVMgZGlkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgdHJhbnNhY3Rpb24gZm9yIHRoZSBDQU5DRUxcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIHByb2NlZHVyZSBhYm92ZSwgaXQgU0hPVUxEIHJlc3BvbmQgdG8gdGhlIENBTkNFTFxuICAgICAqIHdpdGggYSA0ODEgKENhbGwgTGVnL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KS4gIElmIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdCBzdGlsbCBleGlzdHMsIHRoZSBiZWhhdmlvciBvZiB0aGUgVUFTIG9uXG4gICAgICogcmVjZWl2aW5nIGEgQ0FOQ0VMIHJlcXVlc3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGhhcyBhbHJlYWR5IHNlbnQgYVxuICAgICAqIGZpbmFsIHJlc3BvbnNlIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC4gIElmIGl0IGhhcywgdGhlIENBTkNFTFxuICAgICAqIHJlcXVlc3QgaGFzIG5vIGVmZmVjdCBvbiB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgbm9cbiAgICAgKiBlZmZlY3Qgb24gYW55IHNlc3Npb24gc3RhdGUsIGFuZCBubyBlZmZlY3Qgb24gdGhlIHJlc3BvbnNlcyBnZW5lcmF0ZWRcbiAgICAgKiBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3QuICBJZiB0aGUgVUFTIGhhcyBub3QgaXNzdWVkIGEgZmluYWwgcmVzcG9uc2VcbiAgICAgKiBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIGl0cyBiZWhhdmlvciBkZXBlbmRzIG9uIHRoZSBtZXRob2Qgb2YgdGhlXG4gICAgICogb3JpZ2luYWwgcmVxdWVzdC4gIElmIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdhcyBhbiBJTlZJVEUsIHRoZSBVQVNcbiAgICAgKiBTSE9VTEQgaW1tZWRpYXRlbHkgcmVzcG9uZCB0byB0aGUgSU5WSVRFIHdpdGggYSA0ODcgKFJlcXVlc3RcbiAgICAgKiBUZXJtaW5hdGVkKS4gIEEgQ0FOQ0VMIHJlcXVlc3QgaGFzIG5vIGltcGFjdCBvbiB0aGUgcHJvY2Vzc2luZyBvZlxuICAgICAqIHRyYW5zYWN0aW9ucyB3aXRoIGFueSBvdGhlciBtZXRob2QgZGVmaW5lZCBpbiB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi05LjJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIEluY29taW5nIENBTkNFTCByZXF1ZXN0LlxuICAgICAqL1xuICAgIFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucmVjZWl2ZUNhbmNlbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIE5vdGU6IEN1cnJlbnRseSBDQU5DRUwgaXMgYmVpbmcgaGFuZGxlZCBhcyBhIHNwZWNpYWwgY2FzZS5cbiAgICAgICAgLy8gTm8gVUFTIGlzIGNyZWF0ZWQgdG8gaGFuZGxlIHRoZSBDQU5DRUwgYW5kIHRoZSByZXNwb25zZSB0b1xuICAgICAgICAvLyBpdCBDQU5DRUwgaXMgYmVpbmcgaGFuZGxlZCBzdGF0ZWxlc3NseSBieSB0aGUgdXNlciBhZ2VudCBjb3JlLlxuICAgICAgICAvLyBBcyBzdWNoLCB0aGVyZSBpcyBjdXJyZW50bHkgbm8gd2F5IHRvIGV4dGVybmFsbHkgaW1wYWN0IHRoZVxuICAgICAgICAvLyByZXNwb25zZSB0byB0aGUgYSBDQU5DRUwgcmVxdWVzdC5cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkNhbmNlbChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUsIFwiYWNjZXB0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNhY3Rpb24gdHlwZS5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLCBcInByb2dyZXNzYWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDMyMCNzZWN0aW9uLTQuMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2FjdGlvbiB0eXBlLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUsIFwicmVkaXJlY3RhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zYWN0aW9uIHR5cGUuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50U2VydmVyLnByb3RvdHlwZSwgXCJyZWplY3RhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zYWN0aW9uIHR5cGUuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50U2VydmVyLnByb3RvdHlwZSwgXCJ0cnlpbmdhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zYWN0aW9uIHR5cGUuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGEgVUFTIHdpc2hlcyB0byBjb25zdHJ1Y3QgYSByZXNwb25zZSB0byBhIHJlcXVlc3QsIGl0IGZvbGxvd3NcbiAgICAgKiB0aGUgZ2VuZXJhbCBwcm9jZWR1cmVzIGRldGFpbGVkIGluIHRoZSBmb2xsb3dpbmcgc3Vic2VjdGlvbnMuXG4gICAgICogQWRkaXRpb25hbCBiZWhhdmlvcnMgc3BlY2lmaWMgdG8gdGhlIHJlc3BvbnNlIGNvZGUgaW4gcXVlc3Rpb24sIHdoaWNoXG4gICAgICogYXJlIG5vdCBkZXRhaWxlZCBpbiB0aGlzIHNlY3Rpb24sIG1heSBhbHNvIGJlIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogT25jZSBhbGwgcHJvY2VkdXJlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNyZWF0aW9uIG9mIGEgcmVzcG9uc2UgaGF2ZVxuICAgICAqIGJlZW4gY29tcGxldGVkLCB0aGUgVUFTIGhhbmRzIHRoZSByZXNwb25zZSBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiB0cmFuc2FjdGlvbiBmcm9tIHdoaWNoIGl0IHJlY2VpdmVkIHRoZSByZXF1ZXN0LlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjZcbiAgICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFN0YXR1cyBjb2RlIHRvIHJlcGx5IHdpdGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXBseSBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvVGFnICYmIG9wdGlvbnMuc3RhdHVzQ29kZSAhPT0gMTAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRvVGFnID0gdGhpcy50b1RhZztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVzZXJBZ2VudCA9IG9wdGlvbnMudXNlckFnZW50IHx8IHRoaXMuY29yZS5jb25maWd1cmF0aW9uLnVzZXJBZ2VudEhlYWRlckZpZWxkVmFsdWU7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydGVkID0gb3B0aW9ucy5zdXBwb3J0ZWQgfHwgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uc3VwcG9ydGVkT3B0aW9uVGFnc1Jlc3BvbnNlO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBtZXNzYWdlc18xLmNvbnN0cnVjdE91dGdvaW5nUmVzcG9uc2UodGhpcy5tZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2Uob3B0aW9ucy5zdGF0dXNDb2RlLCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG4gICAgVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXZSBhcmUgdGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgICAgIHZhciB1c2VyID0ge1xuICAgICAgICAgICAgbG9nZ2VyRmFjdG9yeTogdGhpcy5sb2dnZXJGYWN0b3J5LFxuICAgICAgICAgICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZXJtaW5hdGVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNvcmUuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvcmUudXNlckFnZW50U2VydmVycy5kZWxldGUodXNlckFnZW50U2VydmVySWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVsZWdhdGUgJiYgX3RoaXMuZGVsZWdhdGUub25UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxlZ2F0ZS5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlVzZXIgYWdlbnQgc2VydmVyIHJlc3BvbnNlIHRyYW5zcG9ydCBlcnJvci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gd2l0aCB1cyBhcyB0aGUgdXNlci5cbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gbmV3IHRoaXMudHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzLm1lc3NhZ2UsIHRoaXMuY29yZS50cmFuc3BvcnQsIHVzZXIpO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyB0cmFuc2FjdGlvbiB0byB0aGUgY29yZS5cbiAgICAgICAgdmFyIHVzZXJBZ2VudFNlcnZlcklkID0gdHJhbnNhY3Rpb24uaWQ7XG4gICAgICAgIHRoaXMuY29yZS51c2VyQWdlbnRTZXJ2ZXJzLnNldCh0cmFuc2FjdGlvbi5pZCwgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVXNlckFnZW50U2VydmVyO1xufSgpKTtcbmV4cG9ydHMuVXNlckFnZW50U2VydmVyID0gVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0c2xpbnQ6ZGlzYWJsZTppbnRlcmZhY2UtbmFtZVxuLy8gdHNsaW50OmRpc2FibGU6IHRyYWlsaW5nLWNvbW1hXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG4vLyB0c2xpbnQ6ZGlzYWJsZTogbWF4LWxpbmUtbGVuZ3RoXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb25seS1hcnJvdy1mdW5jdGlvbnNcbi8vIHRzbGludDpkaXNhYmxlOiBvbmUtdmFyaWFibGUtcGVyLWRlY2xhcmF0aW9uXG4vLyB0c2xpbnQ6ZGlzYWJsZTogbm8tY29uc2VjdXRpdmUtYmxhbmstbGluZXNcbi8vIHRzbGludDpkaXNhYmxlOiBhbGlnblxuLy8gdHNsaW50OmRpc2FibGU6IHJhZGl4XG4vLyB0c2xpbnQ6ZGlzYWJsZTogcXVvdGVtYXJrXG4vLyB0c2xpbnQ6ZGlzYWJsZTogc2VtaWNvbG9uXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwtc2hvcnRoYW5kXG4vLyB0c2xpbnQ6ZGlzYWJsZTogdmFyaWFibGUtbmFtZVxuLy8gdHNsaW50OmRpc2FibGU6IG5vLXZhci1rZXl3b3JkXG4vLyB0c2xpbnQ6ZGlzYWJsZTogd2hpdGVzcGFjZVxuLy8gdHNsaW50OmRpc2FibGU6IGN1cmx5XG4vLyB0c2xpbnQ6ZGlzYWJsZTogcHJlZmVyLWNvbnN0XG4vLyB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwta2V5LXF1b3Rlc1xuLy8gdHNsaW50OmRpc2FibGU6IG5vLXN0cmluZy1saXRlcmFsXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb25lLWxpbmVcbi8vIHRzbGludDpkaXNhYmxlOiBuby11bnVzZWQtZXhwcmVzc2lvblxuLy8gdHNsaW50OmRpc2FibGU6IHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlblxuLy8gdHNsaW50OmRpc2FibGU6IGFycm93LXJldHVybi1zaG9ydGhhbmRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLy8gR2VuZXJhdGVkIGJ5IFBFRy5qcyB2LiAwLjEwLjAgKHRzLXBlZ2pzIHBsdWdpbiB2LiAwLjIuNiApXG4vL1xuLy8gaHR0cHM6Ly9wZWdqcy5vcmcvICAgaHR0cHM6Ly9naXRodWIuY29tL21ldGFkZXZwcm8vdHMtcGVnanNcbnZhciBuYW1lX2FkZHJfaGVhZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9tZXNzYWdlcy9uYW1lLWFkZHItaGVhZGVyXCIpO1xudmFyIHVyaV8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvbWVzc2FnZXMvdXJpXCIpO1xudmFyIFN5bnRheEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN5bnRheEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICAgIF90aGlzLmZvdW5kID0gZm91bmQ7XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIF90aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIFN5bnRheEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZSA9IGZ1bmN0aW9uIChleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIlxcXFxcXFwiXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgZnVuY3Rpb24gKGNoKSB7IHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gXCJcXFxceFwiICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xhc3NFc2NhcGUocykge1xuICAgICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXS9nLCBcIlxcXFxdXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXi9nLCBcIlxcXFxeXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCJcXFxcLVwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csIGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiArIGhleChjaCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwZWN0YXRpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsaXRlcmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXCJcIiArIGxpdGVyYWxFc2NhcGUoZXhwZWN0YXRpb24udGV4dCkgKyBcIlxcXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWRQYXJ0cyA9IGV4cGVjdGF0aW9uLnBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNsYXNzRXNjYXBlKHBhcnRbMF0pICsgXCItXCIgKyBjbGFzc0VzY2FwZShwYXJ0WzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2xhc3NFc2NhcGUocGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyBcIl5cIiA6IFwiXCIpICsgZXNjYXBlZFBhcnRzICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbnkgY2hhcmFjdGVyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwib3RoZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQxKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRpb25zID0gZXhwZWN0ZWQxLm1hcChkZXNjcmliZUV4cGVjdGF0aW9uKTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnMuc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBcIiwgb3IgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kMSA/IFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShmb3VuZDEpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xuICAgIH07XG4gICAgcmV0dXJuIFN5bnRheEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5TeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcbiAgICB2YXIgcGVnJEZBSUxFRCA9IHt9O1xuICAgIHZhciBwZWckc3RhcnRSdWxlSW5kaWNlcyA9IHsgQ29udGFjdDogMTE5LCBOYW1lX0FkZHJfSGVhZGVyOiAxNTYsIFJlY29yZF9Sb3V0ZTogMTc2LCBSZXF1ZXN0X1Jlc3BvbnNlOiA4MSwgU0lQX1VSSTogNDUsIFN1YnNjcmlwdGlvbl9TdGF0ZTogMTg2LCBTdXBwb3J0ZWQ6IDE5MSwgUmVxdWlyZTogMTgyLCBWaWE6IDE5NCwgYWJzb2x1dGVVUkk6IDg0LCBDYWxsX0lEOiAxMTgsIENvbnRlbnRfRGlzcG9zaXRpb246IDEzMCwgQ29udGVudF9MZW5ndGg6IDEzNSwgQ29udGVudF9UeXBlOiAxMzYsIENTZXE6IDE0NiwgZGlzcGxheU5hbWU6IDEyMiwgRXZlbnQ6IDE0OSwgRnJvbTogMTUxLCBob3N0OiA1MiwgTWF4X0ZvcndhcmRzOiAxNTQsIE1pbl9TRTogMjEzLCBQcm94eV9BdXRoZW50aWNhdGU6IDE1NywgcXVvdGVkX3N0cmluZzogNDAsIFJlZmVyX1RvOiAxNzgsIFJlcGxhY2VzOiAxNzksIFNlc3Npb25fRXhwaXJlczogMjEwLCBzdHVuX1VSSTogMjE3LCBUbzogMTkyLCB0dXJuX1VSSTogMjIzLCB1dWlkOiAyMjYsIFdXV19BdXRoZW50aWNhdGU6IDIwOSwgY2hhbGxlbmdlOiAxNTgsIHNpcGZyYWc6IDIzMCwgUmVmZXJyZWRfQnk6IDIzMSB9O1xuICAgIHZhciBwZWckc3RhcnRSdWxlSW5kZXggPSAxMTk7XG4gICAgdmFyIHBlZyRjb25zdHMgPSBbXG4gICAgICAgIFwiXFxyXFxuXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXHJcXG5cIiwgZmFsc2UpLFxuICAgICAgICAvXlswLTldLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bYS16QS1aXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXlswLTlhLWZBLUZdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdLCBbXCJhXCIsIFwiZlwiXSwgW1wiQVwiLCBcIkZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXltcXDAtXFx4RkZdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxcMFwiLCBcIlxceEZGXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXCJdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiXFxcIlwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgXCIgXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIgXCIsIGZhbHNlKSxcbiAgICAgICAgXCJcXHRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcdFwiLCBmYWxzZSksXG4gICAgICAgIC9eW2EtekEtWjAtOV0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBbXCIwXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIFwiO1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiO1wiLCBmYWxzZSksXG4gICAgICAgIFwiL1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiL1wiLCBmYWxzZSksXG4gICAgICAgIFwiP1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiP1wiLCBmYWxzZSksXG4gICAgICAgIFwiOlwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiOlwiLCBmYWxzZSksXG4gICAgICAgIFwiQFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiQFwiLCBmYWxzZSksXG4gICAgICAgIFwiJlwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJlwiLCBmYWxzZSksXG4gICAgICAgIFwiPVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiPVwiLCBmYWxzZSksXG4gICAgICAgIFwiK1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiK1wiLCBmYWxzZSksXG4gICAgICAgIFwiJFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJFwiLCBmYWxzZSksXG4gICAgICAgIFwiLFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLFwiLCBmYWxzZSksXG4gICAgICAgIFwiLVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLVwiLCBmYWxzZSksXG4gICAgICAgIFwiX1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiX1wiLCBmYWxzZSksXG4gICAgICAgIFwiLlwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLlwiLCBmYWxzZSksXG4gICAgICAgIFwiIVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiIVwiLCBmYWxzZSksXG4gICAgICAgIFwiflwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiflwiLCBmYWxzZSksXG4gICAgICAgIFwiKlwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKlwiLCBmYWxzZSksXG4gICAgICAgIFwiJ1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJ1wiLCBmYWxzZSksXG4gICAgICAgIFwiKFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKFwiLCBmYWxzZSksXG4gICAgICAgIFwiKVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKVwiLCBmYWxzZSksXG4gICAgICAgIFwiJVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJVwiLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiIFwiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAnOic7IH0sXG4gICAgICAgIC9eWyEtfl0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiIVwiLCBcIn5cIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXltcXHg4MC1cXHVGRkZGXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJcXHg4MFwiLCBcIlxcdUZGRkZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXltcXHg4MC1cXHhCRl0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiXFx4ODBcIiwgXCJcXHhCRlwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIC9eW2EtZl0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcImZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICBcImBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImBcIiwgZmFsc2UpLFxuICAgICAgICBcIjxcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjxcIiwgZmFsc2UpLFxuICAgICAgICBcIj5cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj5cIiwgZmFsc2UpLFxuICAgICAgICBcIlxcXFxcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcXFxcIiwgZmFsc2UpLFxuICAgICAgICBcIltcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIltcIiwgZmFsc2UpLFxuICAgICAgICBcIl1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIl1cIiwgZmFsc2UpLFxuICAgICAgICBcIntcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIntcIiwgZmFsc2UpLFxuICAgICAgICBcIn1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIn1cIiwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIipcIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIvXCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiPVwiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIihcIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIpXCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiPlwiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIjxcIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIsXCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiO1wiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIjpcIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcXFwiXCI7IH0sXG4gICAgICAgIC9eWyEtJ10vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiIVwiLCBcIidcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXlsqLVtdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIipcIiwgXCJbXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFxdLX5dLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIl1cIiwgXCJ+XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgIH0sXG4gICAgICAgIC9eWyMtW10vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiI1wiLCBcIltcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXltcXDAtXFx0XS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJcXDBcIiwgXCJcXHRcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXltcXHgwQi1cXGZdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxceDBCXCIsIFwiXFxmXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFx4MEUtXFx4N0ZdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxceDBFXCIsIFwiXFx4N0ZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IHVyaV8xLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgdXJpXzEuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQsIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zLCBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5zY2hlbWU7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1NJUF9VUkknKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzaXBzXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJzaXBzXCIsIHRydWUpLFxuICAgICAgICBcInNpcFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic2lwXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodXJpX3NjaGVtZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHVyaV9zY2hlbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51c2VyID0gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQoKS5zbGljZSgwLCAtMSkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucGFzc3dvcmQgPSB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ2RvbWFpbic7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICAvXlthLXpBLVowLTlfXFwtXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFtcIjBcIiwgXCI5XCJdLCBcIl9cIiwgXCItXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXlthLXpBLVowLTlcXC1dLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiLVwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY2JztcbiAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiOjpcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjo6XCIsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY2JztcbiAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2NCc7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBcIjI1XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIyNVwiLCBmYWxzZSksXG4gICAgICAgIC9eWzAtNV0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMFwiLCBcIjVcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICBcIjJcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjJcIiwgZmFsc2UpLFxuICAgICAgICAvXlswLTRdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI0XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgXCIxXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIxXCIsIGZhbHNlKSxcbiAgICAgICAgL15bMS05XS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIxXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uIChwb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBwb3J0ID0gcGFyc2VJbnQocG9ydC5qb2luKCcnKSk7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucG9ydCA9IHBvcnQ7XG4gICAgICAgICAgICByZXR1cm4gcG9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0cmFuc3BvcnQ9XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0cmFuc3BvcnQ9XCIsIHRydWUpLFxuICAgICAgICBcInVkcFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidWRwXCIsIHRydWUpLFxuICAgICAgICBcInRjcFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidGNwXCIsIHRydWUpLFxuICAgICAgICBcInNjdHBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInNjdHBcIiwgdHJ1ZSksXG4gICAgICAgIFwidGxzXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0bHNcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWyd0cmFuc3BvcnQnXSA9IHRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBcInVzZXI9XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ1c2VyPVwiLCB0cnVlKSxcbiAgICAgICAgXCJwaG9uZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicGhvbmVcIiwgdHJ1ZSksXG4gICAgICAgIFwiaXBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImlwXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtcyA9IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ3VzZXInXSA9IHVzZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXRob2Q9XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJtZXRob2Q9XCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbWV0aG9kJ10gPSBtZXRob2Q7XG4gICAgICAgIH0sXG4gICAgICAgIFwidHRsPVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHRsPVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHR0bCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEucGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ3R0bCddID0gdHRsO1xuICAgICAgICB9LFxuICAgICAgICBcIm1hZGRyPVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibWFkZHI9XCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAobWFkZHIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydtYWRkciddID0gbWFkZHI7XG4gICAgICAgIH0sXG4gICAgICAgIFwibHJcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImxyXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbHInXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbcGFyYW0udG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGhuYW1lLCBodmFsdWUpIHtcbiAgICAgICAgICAgIGhuYW1lID0gaG5hbWUuam9pbignJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGh2YWx1ZSA9IGh2YWx1ZS5qb2luKCcnKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXSA9IFtodmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXS5wdXNoKGh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIC8vIGxvdHMgb2YgdGVzdHMgZmFpbCBpZiB0aGlzIGlzbid0IGd1YXJkZWQuLi5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1JlZmVyX1RvJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmkgPSBuZXcgdXJpXzEuVVJJKG9wdGlvbnMuZGF0YS5zY2hlbWUsIG9wdGlvbnMuZGF0YS51c2VyLCBvcHRpb25zLmRhdGEuaG9zdCwgb3B0aW9ucy5kYXRhLnBvcnQsIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zLCBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3Q7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIvL1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLy9cIiwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuc2NoZW1lID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiU0lQXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuc2lwX3ZlcnNpb24gPSB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiSU5WSVRFXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJJTlZJVEVcIiwgZmFsc2UpLFxuICAgICAgICBcIkFDS1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiQUNLXCIsIGZhbHNlKSxcbiAgICAgICAgXCJWWEFDSFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiVlhBQ0hcIiwgZmFsc2UpLFxuICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk9QVElPTlNcIiwgZmFsc2UpLFxuICAgICAgICBcIkJZRVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiQllFXCIsIGZhbHNlKSxcbiAgICAgICAgXCJDQU5DRUxcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIkNBTkNFTFwiLCBmYWxzZSksXG4gICAgICAgIFwiUkVHSVNURVJcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlJFR0lTVEVSXCIsIGZhbHNlKSxcbiAgICAgICAgXCJTVUJTQ1JJQkVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlNVQlNDUklCRVwiLCBmYWxzZSksXG4gICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJOT1RJRllcIiwgZmFsc2UpLFxuICAgICAgICBcIlJFRkVSXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJSRUZFUlwiLCBmYWxzZSksXG4gICAgICAgIFwiUFVCTElTSFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiUFVCTElTSFwiLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tZXRob2QgPSB0ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhLm1ldGhvZDtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHN0YXR1c19jb2RlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuc3RhdHVzX2NvZGUgPSBwYXJzZUludChzdGF0dXNfY29kZS5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWFzb25fcGhyYXNlID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXJbaWR4XS5wYXJzZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcilcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBuYW1lX2FkZHJfaGVhZGVyXzEuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKHsgJ3Bvc2l0aW9uJzogcGVnJGN1cnJQb3MsXG4gICAgICAgICAgICAgICAgJ29mZnNldCc6IGxvY2F0aW9uKCkuc3RhcnQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICdwYXJzZWQnOiBoZWFkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gdGV4dCgpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5TmFtZVswXSA9PT0gJ1xcXCInKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZS5zdWJzdHJpbmcoMSwgZGlzcGxheU5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJxXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJxXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAocSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEucGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbJ3EnXSA9IHE7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhwaXJlc1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZXhwaXJlc1wiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKGV4cGlyZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnBhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWydleHBpcmVzJ10gPSBleHBpcmVzO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZGVsdGFfc2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGRlbHRhX3NlY29uZHMuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBcIjBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjBcIiwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KCkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocGFyYW0sIHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS5wYXJhbXMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1twYXJhbS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcInJlbmRlclwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVuZGVyXCIsIHRydWUpLFxuICAgICAgICBcInNlc3Npb25cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInNlc3Npb25cIiwgdHJ1ZSksXG4gICAgICAgIFwiaWNvblwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiaWNvblwiLCB0cnVlKSxcbiAgICAgICAgXCJhbGVydFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYWxlcnRcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ0NvbnRlbnRfRGlzcG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnR5cGUgPSB0ZXh0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJoYW5kbGluZ1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiaGFuZGxpbmdcIiwgdHJ1ZSksXG4gICAgICAgIFwib3B0aW9uYWxcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm9wdGlvbmFsXCIsIHRydWUpLFxuICAgICAgICBcInJlcXVpcmVkXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyZXF1aXJlZFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gcGFyc2VJbnQobGVuZ3RoLmpvaW4oJycpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBcInRleHRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRleHRcIiwgdHJ1ZSksXG4gICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImltYWdlXCIsIHRydWUpLFxuICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhdWRpb1wiLCB0cnVlKSxcbiAgICAgICAgXCJ2aWRlb1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidmlkZW9cIiwgdHJ1ZSksXG4gICAgICAgIFwiYXBwbGljYXRpb25cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImFwcGxpY2F0aW9uXCIsIHRydWUpLFxuICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm1lc3NhZ2VcIiwgdHJ1ZSksXG4gICAgICAgIFwibXVsdGlwYXJ0XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJtdWx0aXBhcnRcIiwgdHJ1ZSksXG4gICAgICAgIFwieC1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIngtXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoY3NlcV92YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlID0gcGFyc2VJbnQoY3NlcV92YWx1ZS5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChleHBpcmVzKSB7IG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTsgb3B0aW9ucy5kYXRhID0gZXhwaXJlczsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGV2ZW50X3R5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ldmVudCA9IGV2ZW50X3R5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgbmFtZV9hZGRyX2hlYWRlcl8xLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNldFBhcmFtKCd0YWcnLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRhZ1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidGFnXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodGFnKSB7IG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTsgb3B0aW9ucy5kYXRhLnRhZyA9IHRhZzsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGZvcndhcmRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBwYXJzZUludChmb3J3YXJkcy5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChtaW5fZXhwaXJlcykgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YSA9IG1pbl9leHBpcmVzOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgbmFtZV9hZGRyX2hlYWRlcl8xLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlnZXN0XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJEaWdlc3RcIiwgdHJ1ZSksXG4gICAgICAgIFwicmVhbG1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlYWxtXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAocmVhbG0pIHsgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9OyBvcHRpb25zLmRhdGEucmVhbG0gPSByZWFsbTsgfSxcbiAgICAgICAgXCJkb21haW5cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImRvbWFpblwiLCB0cnVlKSxcbiAgICAgICAgXCJub25jZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibm9uY2VcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChub25jZSkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YS5ub25jZSA9IG5vbmNlOyB9LFxuICAgICAgICBcIm9wYXF1ZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwib3BhcXVlXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAob3BhcXVlKSB7IG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTsgb3B0aW9ucy5kYXRhLm9wYXF1ZSA9IG9wYXF1ZTsgfSxcbiAgICAgICAgXCJzdGFsZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic3RhbGVcIiwgdHJ1ZSksXG4gICAgICAgIFwidHJ1ZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHJ1ZVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YS5zdGFsZSA9IHRydWU7IH0sXG4gICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImZhbHNlXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTsgb3B0aW9ucy5kYXRhLnN0YWxlID0gZmFsc2U7IH0sXG4gICAgICAgIFwiYWxnb3JpdGhtXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhbGdvcml0aG1cIiwgdHJ1ZSksXG4gICAgICAgIFwibWQ1XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJNRDVcIiwgdHJ1ZSksXG4gICAgICAgIFwibWQ1LXNlc3NcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk1ENS1zZXNzXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwicW9wXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJxb3BcIiwgdHJ1ZSksXG4gICAgICAgIFwiYXV0aC1pbnRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImF1dGgtaW50XCIsIHRydWUpLFxuICAgICAgICBcImF1dGhcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImF1dGhcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChxb3BfdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5xb3AgfHwgKG9wdGlvbnMuZGF0YS5xb3AgPSBbXSk7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucW9wLnB1c2gocW9wX3ZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocmFja192YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlID0gcGFyc2VJbnQocmFja192YWx1ZS5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXJbaWR4XS5wYXJzZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcilcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBuYW1lX2FkZHJfaGVhZGVyXzEuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKHsgJ3Bvc2l0aW9uJzogcGVnJGN1cnJQb3MsXG4gICAgICAgICAgICAgICAgJ29mZnNldCc6IGxvY2F0aW9uKCkuc3RhcnQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICdwYXJzZWQnOiBoZWFkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgbmFtZV9hZGRyX2hlYWRlcl8xLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMuZGF0YS5yZXBsYWNlc19mcm9tX3RhZyAmJiBvcHRpb25zLmRhdGEucmVwbGFjZXNfdG9fdGFnKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgY2FsbF9pZDogb3B0aW9ucy5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcImZyb20tdGFnXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJmcm9tLXRhZ1wiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKGZyb21fdGFnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucmVwbGFjZXNfZnJvbV90YWcgPSBmcm9tX3RhZztcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0by10YWdcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRvLXRhZ1wiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHRvX3RhZykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZyA9IHRvX3RhZztcbiAgICAgICAgfSxcbiAgICAgICAgXCJlYXJseS1vbmx5XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJlYXJseS1vbmx5XCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuZWFybHlfb25seSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChoZWFkLCByKSB7IHJldHVybiByOyB9LFxuICAgICAgICBmdW5jdGlvbiAoaGVhZCwgdGFpbCkgeyByZXR1cm4gbGlzdChoZWFkLCB0YWlsKTsgfSxcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdSZXF1aXJlJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocnNlcV92YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlID0gcGFyc2VJbnQocnNlcV92YWx1ZS5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiYWN0aXZlXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhY3RpdmVcIiwgdHJ1ZSksXG4gICAgICAgIFwicGVuZGluZ1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicGVuZGluZ1wiLCB0cnVlKSxcbiAgICAgICAgXCJ0ZXJtaW5hdGVkXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0ZXJtaW5hdGVkXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuc3RhdGUgPSB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwicmVhc29uXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyZWFzb25cIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVhc29uID0gcmVhc29uO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXhwaXJlcykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmVzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZXhwaXJlcyA9IGV4cGlyZXM7XG4gICAgICAgIH0sXG4gICAgICAgIFwicmV0cnlfYWZ0ZXJcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJldHJ5X2FmdGVyXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAocmV0cnlfYWZ0ZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0cnlfYWZ0ZXIgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZXRyeV9hZnRlciA9IHJldHJ5X2FmdGVyO1xuICAgICAgICB9LFxuICAgICAgICBcImRlYWN0aXZhdGVkXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJkZWFjdGl2YXRlZFwiLCB0cnVlKSxcbiAgICAgICAgXCJwcm9iYXRpb25cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInByb2JhdGlvblwiLCB0cnVlKSxcbiAgICAgICAgXCJyZWplY3RlZFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVqZWN0ZWRcIiwgdHJ1ZSksXG4gICAgICAgIFwidGltZW91dFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidGltZW91dFwiLCB0cnVlKSxcbiAgICAgICAgXCJnaXZldXBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImdpdmV1cFwiLCB0cnVlKSxcbiAgICAgICAgXCJub3Jlc291cmNlXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJub3Jlc291cmNlXCIsIHRydWUpLFxuICAgICAgICBcImludmFyaWFudFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiaW52YXJpYW50XCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1N1cHBvcnRlZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgbmFtZV9hZGRyX2hlYWRlcl8xLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNldFBhcmFtKCd0YWcnLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInR0bFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHRsXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodmlhX3R0bF92YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnR0bCA9IHZpYV90dGxfdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwibWFkZHJcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm1hZGRyXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodmlhX21hZGRyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEubWFkZHIgPSB2aWFfbWFkZHI7XG4gICAgICAgIH0sXG4gICAgICAgIFwicmVjZWl2ZWRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlY2VpdmVkXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodmlhX3JlY2VpdmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucmVjZWl2ZWQgPSB2aWFfcmVjZWl2ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJhbmNoXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJicmFuY2hcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICh2aWFfYnJhbmNoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuYnJhbmNoID0gdmlhX2JyYW5jaDtcbiAgICAgICAgfSxcbiAgICAgICAgXCJycG9ydFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicnBvcnRcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZV9wb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlX3BvcnQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ycG9ydCA9IHJlc3BvbnNlX3BvcnQuam9pbignJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICh2aWFfcHJvdG9jb2wpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wcm90b2NvbCA9IHZpYV9wcm90b2NvbDtcbiAgICAgICAgfSxcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlVEUFwiLCB0cnVlKSxcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlRDUFwiLCB0cnVlKSxcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlRMU1wiLCB0cnVlKSxcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlNDVFBcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICh2aWFfdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudHJhbnNwb3J0ID0gdmlhX3RyYW5zcG9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICh2aWFfc2VudF9ieV9wb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucG9ydCA9IHBhcnNlSW50KHZpYV9zZW50X2J5X3BvcnQuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAodHRsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodHRsLmpvaW4oJycpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGRlbHRhU2Vjb25kcykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5kZWx0YVNlY29uZHMgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicmVmcmVzaGVyXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyZWZyZXNoZXJcIiwgZmFsc2UpLFxuICAgICAgICBcInVhc1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidWFzXCIsIGZhbHNlKSxcbiAgICAgICAgXCJ1YWNcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInVhY1wiLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWZyZXNoZXIgPSBlbmRwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGRlbHRhU2Vjb25kcykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnTWluX1NFJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IGRlbHRhU2Vjb25kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzdHVuc1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic3R1bnNcIiwgdHJ1ZSksXG4gICAgICAgIFwic3R1blwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic3R1blwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHNjaGVtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gaG9zdDtcbiAgICAgICAgfSxcbiAgICAgICAgXCI/dHJhbnNwb3J0PVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiP3RyYW5zcG9ydD1cIiwgZmFsc2UpLFxuICAgICAgICBcInR1cm5zXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0dXJuc1wiLCB0cnVlKSxcbiAgICAgICAgXCJ0dXJuXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0dXJuXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiUmVmZXJyZWQtQnlcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlJlZmVycmVkLUJ5XCIsIGZhbHNlKSxcbiAgICAgICAgXCJiXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJiXCIsIGZhbHNlKSxcbiAgICAgICAgXCJjaWRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImNpZFwiLCBmYWxzZSlcbiAgICBdO1xuICAgIHZhciBwZWckYnl0ZWNvZGUgPSBbXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyIFxcXCJcXFwiNiA3IVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjRcXFwiXFxcIlxcXCI1ITcjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNCRcXFwiXFxcIjUhNyVcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0JlxcXCJcXFwiNSE3J1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjsnLiMgJjsoXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNChcXFwiXFxcIjUhNylcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0KlxcXCJcXFwiNSE3K1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjIsXFxcIlxcXCI2LDctXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMi5cXFwiXFxcIjYuNy9cIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0MFxcXCJcXFwiNSE3MVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjIyXFxcIlxcXCI2MjczLlxceDg5ICYyNFxcXCJcXFwiNjQ3NS59ICYyNlxcXCJcXFwiNjY3Ny5xICYyOFxcXCJcXFwiNjg3OS5lICYyOlxcXCJcXFwiNjo3Oy5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjspLiMgJjssXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMkZcXFwiXFxcIjZGN0cufSAmMkhcXFwiXFxcIjZIN0kucSAmMkpcXFwiXFxcIjZKN0suZSAmMkxcXFwiXFxcIjZMN00uWSAmMk5cXFwiXFxcIjZON08uTSAmMlBcXFwiXFxcIjZQN1EuQSAmMlJcXFwiXFxcIjZSN1MuNSAmMlRcXFwiXFxcIjZUN1UuKSAmMlZcXFwiXFxcIjZWN1dcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTJYXFxcIlxcXCI2WDdZLzUjOyMvLCQ7Iy8jJCsjKSgjJyMoXFxcIicjJicjL1xcXCIhJiwpXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSUkOyQwIyo7JCYvLCM7IC8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi89IyQ7JC8mIzAjKjskJiYmIy8nJDhcXFwiOlpcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOy4uXFxcIiAmXFxcIlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOycuIyAmOygwKSo7Jy4jICY7KCYvPyMyOFxcXCJcXFwiNjg3OS8wJDsvLyckOCM6WyMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSUkOzIvJiMwIyo7MiYmJiMvZyMkJSQ7LjAjKjsuJi8sIzsyLyMkK1xcXCIpKFxcXCInIyYnIzA9KiUkOy4wIyo7LiYvLCM7Mi8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjRcXFxcXFxcIlxcXCI1ITddLiMgJjszXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNF5cXFwiXFxcIjUhN19cIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0YFxcXCJcXFwiNSE3YVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjshLikgJjRiXFxcIlxcXCI1ITdjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7KS5cXHg5NSAmMkZcXFwiXFxcIjZGN0cuXFx4ODkgJjJKXFxcIlxcXCI2SjdLLn0gJjJMXFxcIlxcXCI2TDdNLnEgJjJYXFxcIlxcXCI2WDdZLmUgJjJQXFxcIlxcXCI2UDdRLlkgJjJIXFxcIlxcXCI2SDdJLk0gJjJAXFxcIlxcXCI2QDdBLkEgJjJkXFxcIlxcXCI2ZDdlLjUgJjJSXFxcIlxcXCI2UjdTLikgJjJOXFxcIlxcXCI2TjdPL1xceDlFIzBcXHg5Qio7KS5cXHg5NSAmMkZcXFwiXFxcIjZGN0cuXFx4ODkgJjJKXFxcIlxcXCI2SjdLLn0gJjJMXFxcIlxcXCI2TDdNLnEgJjJYXFxcIlxcXCI2WDdZLmUgJjJQXFxcIlxcXCI2UDdRLlkgJjJIXFxcIlxcXCI2SDdJLk0gJjJAXFxcIlxcXCI2QDdBLkEgJjJkXFxcIlxcXCI2ZDdlLjUgJjJSXFxcIlxcXCI2UjdTLikgJjJOXFxcIlxcXCI2TjdPJiYmIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOykuXFx4ODkgJjJGXFxcIlxcXCI2RjdHLn0gJjJMXFxcIlxcXCI2TDdNLnEgJjJYXFxcIlxcXCI2WDdZLmUgJjJQXFxcIlxcXCI2UDdRLlkgJjJIXFxcIlxcXCI2SDdJLk0gJjJAXFxcIlxcXCI2QDdBLkEgJjJkXFxcIlxcXCI2ZDdlLjUgJjJSXFxcIlxcXCI2UjdTLikgJjJOXFxcIlxcXCI2TjdPL1xceDkyIzBcXHg4Rio7KS5cXHg4OSAmMkZcXFwiXFxcIjZGN0cufSAmMkxcXFwiXFxcIjZMN00ucSAmMlhcXFwiXFxcIjZYN1kuZSAmMlBcXFwiXFxcIjZQN1EuWSAmMkhcXFwiXFxcIjZIN0kuTSAmMkBcXFwiXFxcIjZAN0EuQSAmMmRcXFwiXFxcIjZkN2UuNSAmMlJcXFwiXFxcIjZSN1MuKSAmMk5cXFwiXFxcIjZON08mJiYjL1xcXCIhJiwpXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlRcXFwiXFxcIjZUN1UuXFx4RTMgJjJWXFxcIlxcXCI2VjdXLlxceEQ3ICYyZlxcXCJcXFwiNmY3Zy5cXHhDQiAmMmhcXFwiXFxcIjZoN2kuXFx4QkYgJjI6XFxcIlxcXCI2Ojc7LlxceEIzICYyRFxcXCJcXFwiNkQ3RS5cXHhBNyAmMjJcXFwiXFxcIjYyNzMuXFx4OUIgJjI4XFxcIlxcXCI2ODc5LlxceDhGICYyalxcXCJcXFwiNmo3ay5cXHg4MyAmOyYufSAmMjRcXFwiXFxcIjY0NzUucSAmMmxcXFwiXFxcIjZsN20uZSAmMm5cXFwiXFxcIjZuN28uWSAmMjZcXFwiXFxcIjY2NzcuTSAmMj5cXFwiXFxcIjY+Nz8uQSAmMnBcXFwiXFxcIjZwN3EuNSAmMnJcXFwiXFxcIjZyN3MuKSAmOycuIyAmOyhcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDspLlxcdTAxMkIgJjJGXFxcIlxcXCI2RjdHLlxcdTAxMUYgJjJKXFxcIlxcXCI2SjdLLlxcdTAxMTMgJjJMXFxcIlxcXCI2TDdNLlxcdTAxMDcgJjJYXFxcIlxcXCI2WDdZLlxceEZCICYyUFxcXCJcXFwiNlA3US5cXHhFRiAmMkhcXFwiXFxcIjZIN0kuXFx4RTMgJjJAXFxcIlxcXCI2QDdBLlxceEQ3ICYyZFxcXCJcXFwiNmQ3ZS5cXHhDQiAmMlJcXFwiXFxcIjZSN1MuXFx4QkYgJjJOXFxcIlxcXCI2TjdPLlxceEIzICYyVFxcXCJcXFwiNlQ3VS5cXHhBNyAmMlZcXFwiXFxcIjZWN1cuXFx4OUIgJjJmXFxcIlxcXCI2ZjdnLlxceDhGICYyaFxcXCJcXFwiNmg3aS5cXHg4MyAmMjhcXFwiXFxcIjY4NzkudyAmMmpcXFwiXFxcIjZqN2suayAmOyYuZSAmMjRcXFwiXFxcIjY0NzUuWSAmMmxcXFwiXFxcIjZsN20uTSAmMm5cXFwiXFxcIjZuN28uQSAmMjZcXFwiXFxcIjY2NzcuNSAmMnBcXFwiXFxcIjZwN3EuKSAmMnJcXFwiXFxcIjZyN3MvXFx1MDEzNCMwXFx1MDEzMSo7KS5cXHUwMTJCICYyRlxcXCJcXFwiNkY3Ry5cXHUwMTFGICYySlxcXCJcXFwiNko3Sy5cXHUwMTEzICYyTFxcXCJcXFwiNkw3TS5cXHUwMTA3ICYyWFxcXCJcXFwiNlg3WS5cXHhGQiAmMlBcXFwiXFxcIjZQN1EuXFx4RUYgJjJIXFxcIlxcXCI2SDdJLlxceEUzICYyQFxcXCJcXFwiNkA3QS5cXHhENyAmMmRcXFwiXFxcIjZkN2UuXFx4Q0IgJjJSXFxcIlxcXCI2UjdTLlxceEJGICYyTlxcXCJcXFwiNk43Ty5cXHhCMyAmMlRcXFwiXFxcIjZUN1UuXFx4QTcgJjJWXFxcIlxcXCI2VjdXLlxceDlCICYyZlxcXCJcXFwiNmY3Zy5cXHg4RiAmMmhcXFwiXFxcIjZoN2kuXFx4ODMgJjI4XFxcIlxcXCI2ODc5LncgJjJqXFxcIlxcXCI2ajdrLmsgJjsmLmUgJjI0XFxcIlxcXCI2NDc1LlkgJjJsXFxcIlxcXCI2bDdtLk0gJjJuXFxcIlxcXCI2bjdvLkEgJjI2XFxcIlxcXCI2Njc3LjUgJjJwXFxcIlxcXCI2cDdxLikgJjJyXFxcIlxcXCI2cjdzJiYmIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly8/IzJQXFxcIlxcXCI2UDdRLzAkOy8vJyQ4Izp0IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vPyMyNFxcXCJcXFwiNjQ3NS8wJDsvLyckOCM6dSMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvLz8jMj5cXFwiXFxcIjY+Nz8vMCQ7Ly8nJDgjOnYjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly8/IzJUXFxcIlxcXCI2VDdVLzAkOy8vJyQ4Izp3IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vPyMyVlxcXCJcXFwiNlY3Vy8wJDsvLyckOCM6eCMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJoXFxcIlxcXCI2aDdpLzAjOy8vJyQ4XFxcIjp5XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly82IzJmXFxcIlxcXCI2ZjdnLyckOFxcXCI6elxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vPyMyRFxcXCJcXFwiNkQ3RS8wJDsvLyckOCM6eyMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvLz8jMjJcXFwiXFxcIjYyNzMvMCQ7Ly8nJDgjOnwjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly8/IzI4XFxcIlxcXCI2ODc5LzAkOy8vJyQ4Izp9IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vMCM7Ji8nJDhcXFwiOn5cXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsmLzAjOy8vJyQ4XFxcIjp+XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7PS9UIyQ7Ry4pICY7Sy4jICY7RjAvKjtHLikgJjtLLiMgJjtGJi8sJDs+LyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0XFx4N0ZcXFwiXFxcIjUhN1xceDgwLkEgJjRcXHg4MVxcXCJcXFwiNSE3XFx4ODIuNSAmNFxceDgzXFxcIlxcXCI1ITdcXHg4NC4pICY7My4jICY7LlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlOy8vUSM7Ji9IJCQ7Si4jICY7SzApKjtKLiMgJjtLJi8sJDsmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjL1xcXCIhJiwpXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvL10jOyYvVCQlJDtKLiMgJjtLMCkqO0ouIyAmO0smL1xcXCIhJiwpLzEkOyYvKCQ4JDpcXHg4NSQhISkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Li5HICYyTFxcXCJcXFwiNkw3TS47ICY0XFx4ODZcXFwiXFxcIjUhN1xceDg3Li8gJjRcXHg4M1xcXCJcXFwiNSE3XFx4ODQuIyAmOzNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlMmpcXFwiXFxcIjZqN2svSiM0XFx4ODhcXFwiXFxcIjUhN1xceDg5LjUgJjRcXHg4QVxcXCJcXFwiNSE3XFx4OEIuKSAmNFxceDhDXFxcIlxcXCI1ITdcXHg4RC8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO04vTSMyOFxcXCJcXFwiNjg3OS8+JDtPLlxcXCIgJlxcXCIvMCQ7Uy8nJDgkOlxceDhFJCApKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtOL2QjMjhcXFwiXFxcIjY4NzkvVSQ7Ty5cXFwiICZcXFwiL0ckO1MvPiQ7Xy81JDtsLlxcXCIgJlxcXCIvJyQ4JjpcXHg4RiYgKSgmJyMoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHg5MFxcXCJcXFwiNSQ3XFx4OTEuKSAmM1xceDkyXFxcIlxcXCI1IzdcXHg5My8nIDghOlxceDk0ISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7UC9dIyUyOFxcXCJcXFwiNjg3OS8sIztSLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLzYkMjpcXFwiXFxcIjY6NzsvJyQ4IzpcXHg5NSMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJDsrLikgJjstLiMgJjtRLzIjMC8qOysuKSAmOy0uIyAmO1EmJiYjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMjxcXFwiXFxcIjY8Nz0ucSAmMj5cXFwiXFxcIjY+Nz8uZSAmMkBcXFwiXFxcIjZAN0EuWSAmMkJcXFwiXFxcIjZCN0MuTSAmMkRcXFwiXFxcIjZEN0UuQSAmMjJcXFwiXFxcIjYyNzMuNSAmMjZcXFwiXFxcIjY2NzcuKSAmMjRcXFwiXFxcIjY0NzVcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDsrLl8gJjstLlkgJjI8XFxcIlxcXCI2PDc9Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJCXFxcIlxcXCI2QjdDLikgJjJEXFxcIlxcXCI2RDdFMGUqOysuXyAmOy0uWSAmMjxcXFwiXFxcIjY8Nz0uTSAmMj5cXFwiXFxcIjY+Nz8uQSAmMkBcXFwiXFxcIjZAN0EuNSAmMkJcXFwiXFxcIjZCN0MuKSAmMkRcXFwiXFxcIjZEN0UmLyYgOCE6XFx4OTYhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1QvSiMlMjhcXFwiXFxcIjY4NzkvLCM7Xi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1UuKSAmO1xcXFwuIyAmO1gvJiA4ITpcXHg5NyEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkJTtWLzIjMkpcXFwiXFxcIjZKN0svIyQrXFxcIikoXFxcIicjJicjMDwqJTtWLzIjMkpcXFwiXFxcIjZKN0svIyQrXFxcIikoXFxcIicjJicjJi9EIztXLzskMkpcXFwiXFxcIjZKN0suXFxcIiAmXFxcIi8nJDgjOlxceDk4IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkNFxceDk5XFxcIlxcXCI1ITdcXHg5QS8sIzApKjRcXHg5OVxcXCJcXFwiNSE3XFx4OUEmJiYjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTQkXFxcIlxcXCI1ITclLz8jJDRcXHg5QlxcXCJcXFwiNSE3XFx4OUMwKSo0XFx4OUJcXFwiXFxcIjUhN1xceDlDJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlMmxcXFwiXFxcIjZsN20vPyM7WS82JDJuXFxcIlxcXCI2bjdvLyckOCM6XFx4OUQjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlO1ovXFx4QjMjMjhcXFwiXFxcIjY4NzkvXFx4QTQkO1ovXFx4OUIkMjhcXFwiXFxcIjY4NzkvXFx4OEMkO1ovXFx4ODMkMjhcXFwiXFxcIjY4NzkvdCQ7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCstKSgtJyMoLCcjKCsnIygqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNzkwICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvXFx4QTQjO1ovXFx4OUIkMjhcXFwiXFxcIjY4NzkvXFx4OEMkO1ovXFx4ODMkMjhcXFwiXFxcIjY4NzkvdCQ7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCssKSgsJyMoKycjKConIygpJyMoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTA2RjkgJiUyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9cXHg4QyM7Wi9cXHg4MyQyOFxcXCJcXFwiNjg3OS90JDtaL2skMjhcXFwiXFxcIjY4NzkvXFxcXCQ7Wi9TJDI4XFxcIlxcXCI2ODc5L0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKyopKConIygpJyMoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTA2N0EgJiUyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri90IztaL2skMjhcXFwiXFxcIjY4NzkvXFxcXCQ7Wi9TJDI4XFxcIlxcXCI2ODc5L0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKygpKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNjEzICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvXFxcXCM7Wi9TJDI4XFxcIlxcXCI2ODc5L0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKyYpKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDVDNCAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL0QjO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKyQpKCQnIygjJyMoXFxcIicjJicjLlxcdTA1OEQgJiUyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri8sIztbLyMkK1xcXCIpKFxcXCInIyYnIy5cXHUwNTZFICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFx1MDU0RiAmJTtaL1xceDlCIzJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL1xceDhDJDtaL1xceDgzJDI4XFxcIlxcXCI2ODc5L3QkO1ovayQyOFxcXCJcXFwiNjg3OS9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrKykoKycjKConIygpJyMoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTA0QzcgJiU7Wi9cXHhBQSMlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHg4MyQyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri90JDtaL2skMjhcXFwiXFxcIjY4NzkvXFxcXCQ7Wi9TJDI4XFxcIlxcXCI2ODc5L0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKyopKConIygpJyMoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTA0MzAgJiU7Wi9cXHhCOSMlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHg5MiQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9rJDJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCspKSgpJyMoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTAzOEEgJiU7Wi9cXHhDOCMlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhBMSQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi96JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1MkMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrKCkoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTAyRDUgJiU7Wi9cXHhENyMlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhCMCQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHg4OSQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9iJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLzskMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvLCQ7Wy8jJCsnKSgnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMjExICYlO1ovXFx4RkUjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4RDckJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4QjAkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4ODkkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvYiQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi87JDJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGLywkO1ovIyQrKCkoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTAxMjYgJiU7Wi9cXHUwMTFDIyUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceEY1JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceENFJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceEE3JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceDgwJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1kkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvMiQyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri8jJCsoKSgoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMvJiA4ITpcXHhBMCEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Iy9NIzsjLlxcXCIgJlxcXCIvPyQ7Iy5cXFwiICZcXFwiLzEkOyMuXFxcIiAmXFxcIi8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Wi87IzI4XFxcIlxcXCI2ODc5LywkO1ovIyQrIykoIycjKFxcXCInIyYnIy4jICY7XFxcXFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XS9vIzJKXFxcIlxcXCI2SjdLL2AkO10vVyQySlxcXCJcXFwiNko3Sy9IJDtdLz8kMkpcXFwiXFxcIjZKN0svMCQ7XS8nJDgnOlxceEExJyApKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJcXHhBMlxcXCJcXFwiNlxceEEyN1xceEEzLzIjNFxceEE0XFxcIlxcXCI1ITdcXHhBNS8jJCtcXFwiKShcXFwiJyMmJyMuXFx4OTggJiUyXFx4QTZcXFwiXFxcIjZcXHhBNjdcXHhBNy87IzRcXHhBOFxcXCJcXFwiNSE3XFx4QTkvLCQ7IS8jJCsjKSgjJyMoXFxcIicjJicjLmogJiUyXFx4QUFcXFwiXFxcIjZcXHhBQTdcXHhBQi81IzshLywkOyEvIyQrIykoIycjKFxcXCInIyYnIy5CICYlNFxceEFDXFxcIlxcXCI1ITdcXHhBRC8sIzshLyMkK1xcXCIpKFxcXCInIyYnIy4jICY7IVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlOyEuXFxcIiAmXFxcIi9bIzshLlxcXCIgJlxcXCIvTSQ7IS5cXFwiICZcXFwiLz8kOyEuXFxcIiAmXFxcIi8xJDshLlxcXCIgJlxcXCIvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjLycgOCE6XFx4QUUhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJCUyMlxcXCJcXFwiNjI3My8sIztgLyMkK1xcXCIpKFxcXCInIyYnIzA8KiUyMlxcXCJcXFwiNjI3My8sIztgLyMkK1xcXCIpKFxcXCInIyYnIyZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7YS5BICY7Yi47ICY7Yy41ICY7ZC4vICY7ZS4pICY7Zi4jICY7Z1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4QUZcXFwiXFxcIjUqN1xceEIwL2EjM1xceEIxXFxcIlxcXCI1IzdcXHhCMi5HICYzXFx4QjNcXFwiXFxcIjUjN1xceEI0LjsgJjNcXHhCNVxcXCJcXFwiNSQ3XFx4QjYuLyAmM1xceEI3XFxcIlxcXCI1IzdcXHhCOC4jICY7Ni8oJDhcXFwiOlxceEI5XFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEJBXFxcIlxcXCI1JTdcXHhCQi9JIzNcXHhCQ1xcXCJcXFwiNSU3XFx4QkQuLyAmM1xceEJFXFxcIlxcXCI1XFxcIjdcXHhCRi4jICY7Ni8oJDhcXFwiOlxceEMwXFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEMxXFxcIlxcXCI1JzdcXHhDMi8xIztcXHg5MC8oJDhcXFwiOlxceEMzXFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEM0XFxcIlxcXCI1JDdcXHhDNS8xIztcXHhGMC8oJDhcXFwiOlxceEM2XFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEM3XFxcIlxcXCI1JjdcXHhDOC8xIztULygkOFxcXCI6XFx4QzlcXFwiISApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4Q0FcXFwiXFxcIjVcXFwiN1xceENCL04jJTI+XFxcIlxcXCI2Pjc/LywjOzYvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvJyQ4XFxcIjpcXHhDQ1xcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO2gvUCMlMj5cXFwiXFxcIjY+Nz8vLCM7aS8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8pJDhcXFwiOlxceENEXFxcIlxcXCIhICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7ai8mIzAjKjtqJiYmIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkO2ovJiMwIyo7aiYmJiMvXFxcIiEmLClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7ay4pICY7Ky4jICY7LVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJsXFxcIlxcXCI2bDdtLmUgJjJuXFxcIlxcXCI2bjdvLlkgJjI0XFxcIlxcXCI2NDc1Lk0gJjI4XFxcIlxcXCI2ODc5LkEgJjI8XFxcIlxcXCI2PDc9LjUgJjJAXFxcIlxcXCI2QDdBLikgJjJCXFxcIlxcXCI2QjdDXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTI2XFxcIlxcXCI2Njc3L24jO20vZSQkJTI8XFxcIlxcXCI2PDc9LywjO20vIyQrXFxcIikoXFxcIicjJicjMDwqJTI8XFxcIlxcXCI2PDc9LywjO20vIyQrXFxcIikoXFxcIicjJicjJi8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtuL0EjMj5cXFwiXFxcIjY+Nz8vMiQ7by8pJDgjOlxceENFI1xcXCJcXFwiICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiQ7cC4pICY7Ky4jICY7LS8yIzAvKjtwLikgJjsrLiMgJjstJiYmI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiQ7cC4pICY7Ky4jICY7LTAvKjtwLikgJjsrLiMgJjstJlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJsXFxcIlxcXCI2bDdtLmUgJjJuXFxcIlxcXCI2bjdvLlkgJjI0XFxcIlxcXCI2NDc1Lk0gJjI2XFxcIlxcXCI2Njc3LkEgJjI4XFxcIlxcXCI2ODc5LjUgJjJAXFxcIlxcXCI2QDdBLikgJjJCXFxcIlxcXCI2QjdDXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceDkxLiMgJjtyXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5MC9HIzsnLz4kO3MvNSQ7Jy8sJDtcXHg4NC8jJCslKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7TS4jICY7dFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4N0YvRSMyOFxcXCJcXFwiNjg3OS82JDt1LiMgJjt4LyckOCM6XFx4Q0YjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7di4jICY7dy9KIyUyNlxcXCJcXFwiNjY3Ny8sIztcXHg4My8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlMlxceEQwXFxcIlxcXCI2XFx4RDA3XFx4RDEvOiM7XFx4ODAvMSQ7dy5cXFwiICZcXFwiLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlMjRcXFwiXFxcIjY0NzUvLCM7ey8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO3ovMyMkO3kwIyo7eSYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOyouKSAmOysuIyAmOy1cIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Ky5cXHg4RiAmOy0uXFx4ODkgJjIyXFxcIlxcXCI2MjczLn0gJjI2XFxcIlxcXCI2Njc3LnEgJjI4XFxcIlxcXCI2ODc5LmUgJjI6XFxcIlxcXCI2Ojc7LlkgJjI8XFxcIlxcXCI2PDc9Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJCXFxcIlxcXCI2QjdDLikgJjJEXFxcIlxcXCI2RDdFXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTt8L2UjJCUyNFxcXCJcXFwiNjQ3NS8sIzt8LyMkK1xcXCIpKFxcXCInIyYnIzA8KiUyNFxcXCJcXFwiNjQ3NS8sIzt8LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7fjAjKjt+Ji9lIyQlMjJcXFwiXFxcIjYyNzMvLCM7fS8jJCtcXFwiKShcXFwiJyMmJyMwPColMjJcXFwiXFxcIjYyNzMvLCM7fS8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiQ7fjAjKjt+JlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjsrLncgJjstLnEgJjI4XFxcIlxcXCI2ODc5LmUgJjI6XFxcIlxcXCI2Ojc7LlkgJjI8XFxcIlxcXCI2PDc9Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJCXFxcIlxcXCI2QjdDLikgJjJEXFxcIlxcXCI2RDdFXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSU7XFxcIi9cXHg4NyMkO1xcXCIuRyAmOyEuQSAmMkBcXFwiXFxcIjZAN0EuNSAmMkZcXFwiXFxcIjZGN0cuKSAmMkpcXFwiXFxcIjZKN0swTSo7XFxcIi5HICY7IS5BICYyQFxcXCJcXFwiNkA3QS41ICYyRlxcXCJcXFwiNkY3Ry4pICYySlxcXCJcXFwiNko3SyYvIyQrXFxcIikoXFxcIicjJicjLyYgOCE6XFx4RDIhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4ODEuIyAmO1xceDgyXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSU7Ty8yIzI6XFxcIlxcXCI2Ojc7LyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLywjO1MvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCJcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkOysuXFx4ODMgJjstLn0gJjJCXFxcIlxcXCI2QjdDLnEgJjJEXFxcIlxcXCI2RDdFLmUgJjIyXFxcIlxcXCI2MjczLlkgJjI4XFxcIlxcXCI2ODc5Lk0gJjI6XFxcIlxcXCI2Ojc7LkEgJjI8XFxcIlxcXCI2PDc9LjUgJjI+XFxcIlxcXCI2Pjc/LikgJjJAXFxcIlxcXCI2QDdBL1xceDhDIzBcXHg4OSo7Ky5cXHg4MyAmOy0ufSAmMkJcXFwiXFxcIjZCN0MucSAmMkRcXFwiXFxcIjZEN0UuZSAmMjJcXFwiXFxcIjYyNzMuWSAmMjhcXFwiXFxcIjY4NzkuTSAmMjpcXFwiXFxcIjY6NzsuQSAmMjxcXFwiXFxcIjY8Nz0uNSAmMj5cXFwiXFxcIjY+Nz8uKSAmMkBcXFwiXFxcIjZAN0EmJiYjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJDt5MCMqO3kmXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHg5MlxcXCJcXFwiNSM3XFx4RDMvcSMyNFxcXCJcXFwiNjQ3NS9iJCQ7IS8mIzAjKjshJiYmIy9MJDJKXFxcIlxcXCI2SjdLLz0kJDshLyYjMCMqOyEmJiYjLyckOCU6XFx4RDQlICkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEQ1XFxcIlxcXCI2XFx4RDU3XFx4RDZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4RDdcXFwiXFxcIjZcXHhENzdcXHhEOFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhEOVxcXCJcXFwiNlxceEQ5N1xceERBXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceERCXFxcIlxcXCI2XFx4REI3XFx4RENcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4RERcXFwiXFxcIjZcXHhERDdcXHhERVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhERlxcXCJcXFwiNlxceERGN1xceEUwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEUxXFxcIlxcXCI2XFx4RTE3XFx4RTJcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4RTNcXFwiXFxcIjZcXHhFMzdcXHhFNFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhFNVxcXCJcXFwiNlxceEU1N1xceEU2XCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEU3XFxcIlxcXCI2XFx4RTc3XFx4RThcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4RTlcXFwiXFxcIjZcXHhFOTdcXHhFQVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4ODUuWSAmO1xceDg2LlMgJjtcXHg4OC5NICY7XFx4ODkuRyAmO1xceDhBLkEgJjtcXHg4Qi47ICY7XFx4OEMuNSAmO1xceDhGLi8gJjtcXHg4RC4pICY7XFx4OEUuIyAmOzYvJiA4ITpcXHhFQiEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4ODQvRyM7Jy8+JDtcXHg5Mi81JDsnLywkO1xceDk0LyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OTMvJyA4ITpcXHhFQyEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOyEvNSM7IS8sJDshLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDsqLkEgJjsrLjsgJjstLjUgJjszLi8gJjs0LikgJjsnLiMgJjsoMEcqOyouQSAmOysuOyAmOy0uNSAmOzMuLyAmOzQuKSAmOycuIyAmOygmLyYgOCE6XFx4RUQhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEI2L1kjJCU7QS8sIztcXHhCNi8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7XFx4QjYvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOzkvTiMlMjpcXFwiXFxcIjY6NzsvLCM7OS8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8nJDhcXFwiOlxceEVFXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Oi5jICYlO1xceDk4L1kjJCU7QS8sIztcXHg5OC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7XFx4OTgvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyMvJiA4ITpcXHhFRiEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7TC4jICY7XFx4OTkvXSMkJTtCLywjO1xceDlCLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHg5Qi8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx4RjBcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5QS5cXFwiICZcXFwiLz4jO0AvNSQ7TS8sJDs/LyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSU7Ni9ZIyQlOy4vLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyMwNiolOy4vLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnIy4jICY7SC8nIDghOlxceEYxISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHg5Qy4pICY7XFx4OUQuIyAmO1xceEEwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhGMlxcXCJcXFwiNSE3XFx4RjMvOiM7PC8xJDtcXHg5Ri8oJDgjOlxceEY0IyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhGNVxcXCJcXFwiNSc3XFx4RjYvOiM7PC8xJDtcXHg5RS8oJDgjOlxceEY3IyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7IS8mIzAjKjshJiYmIy8nIDghOlxceEY4ISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyXFx4RjlcXFwiXFxcIjZcXHhGOTdcXHhGQS9vIyUySlxcXCJcXFwiNko3Sy9NIzshLlxcXCIgJlxcXCIvPyQ7IS5cXFwiICZcXFwiLzEkOyEuXFxcIiAmXFxcIi8jJCskKSgkJyMoIycjKFxcXCInIyYnIy5cXFwiICZcXFwiLyckOFxcXCI6XFx4RkJcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTs2L0ojJTs8LywjO1xceEExLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLykkOFxcXCI6XFx4RkNcXFwiXFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Ni4pICY7VC4jICY7SFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4QTMvWSMkJTtCLywjO1xceEE0LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBNC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4RkRcXFwiXFxcIjUmN1xceEZFLkcgJjNcXHhGRlxcXCJcXFwiNSc3XFx1MDEwMC47ICYzXFx1MDEwMVxcXCJcXFwiNSQ3XFx1MDEwMi4vICYzXFx1MDEwM1xcXCJcXFwiNSU3XFx1MDEwNC4jICY7Ni8mIDghOlxcdTAxMDUhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4QTUuIyAmO1xceEEwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTA2XFxcIlxcXCI1KDdcXHUwMTA3L00jOzwvRCQzXFx1MDEwOFxcXCJcXFwiNSg3XFx1MDEwOS4vICYzXFx1MDEwQVxcXCJcXFwiNSg3XFx1MDEwQi4jICY7Ni8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTs2L1kjJCU7QS8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7IS8mIzAjKjshJiYmIy8nIDghOlxcdTAxMEMhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhBOS8mIDghOlxcdTAxMEQhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEFBL2sjOzsvYiQ7XFx4QUYvWSQkJTtCLywjO1xceEIwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhCMC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEFCLiMgJjtcXHhBQ1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjNcXHUwMTBFXFxcIlxcXCI1JDdcXHUwMTBGLlMgJjNcXHUwMTEwXFxcIlxcXCI1JTdcXHUwMTExLkcgJjNcXHUwMTEyXFxcIlxcXCI1JTdcXHUwMTEzLjsgJjNcXHUwMTE0XFxcIlxcXCI1JTdcXHUwMTE1Li8gJjNcXHUwMTE2XFxcIlxcXCI1KzdcXHUwMTE3LiMgJjtcXHhBRFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjNcXHUwMTE4XFxcIlxcXCI1JzdcXHUwMTE5Li8gJjNcXHUwMTFBXFxcIlxcXCI1KTdcXHUwMTFCLiMgJjtcXHhBRFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjs2LiMgJjtcXHhBRVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDExQ1xcXCJcXFwiNVxcXCI3XFx1MDExRC8sIzs2LyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHhBRC4jICY7NlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ni81Izs8LywkO1xceEIxLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Ni4jICY7SFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4QjMvNSM7Li8sJDtcXHg5MC8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7IS8mIzAjKjshJiYmIy8nIDghOlxcdTAxMUUhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5RS8nIDghOlxcdTAxMUYhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhCNi9eIyQlO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIyYvKCQ4XFxcIjpcXHUwMTIwXFxcIiEhKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTs3L2UjJCUySlxcXCJcXFwiNko3Sy8sIzs3LyMkK1xcXCIpKFxcXCInIyYnIzA8KiUySlxcXCJcXFwiNko3Sy8sIzs3LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjL1xcXCIhJiwpXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtMLiMgJjtcXHg5OS9dIyQlO0IvLCM7XFx4QjgvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEI4LyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4XFxcIjpcXHUwMTIxXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHhCOS4jICY7XFx4QTBcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMjJcXFwiXFxcIjUjN1xcdTAxMjMvOiM7PC8xJDs2LygkOCM6XFx1MDEyNCMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTI1ISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OUUvJyA4ITpcXHUwMTI2ISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkO1xceDlBMCMqO1xceDlBJi94IztAL28kO00vZiQ7Py9dJCQlO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4JTpcXHUwMTI3JSApKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHhCRVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEyOFxcXCJcXFwiNSY3XFx1MDEyOS9rIzsuL2IkO1xceEMxL1kkJCU7QS8sIztcXHhDMS8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7XFx4QzEvIyQrXFxcIikoXFxcIicjJicjJi8jJCskKSgkJyMoIycjKFxcXCInIyYnIy4jICY7XFx4QkZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOzYvayM7Li9iJDtcXHhDMC9ZJCQlO0EvLCM7XFx4QzAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEMwLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOzYvOyM7PC8yJDs2LiMgJjtILyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4QzIuRyAmO1xceEM0LkEgJjtcXHhDNi47ICY7XFx4QzguNSAmO1xceEM5Li8gJjtcXHhDQS4pICY7XFx4Q0IuIyAmO1xceEMwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTJBXFxcIlxcXCI1JTdcXHUwMTJCLzUjOzwvLCQ7XFx4QzMvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7SS8nIDghOlxcdTAxMkMhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTJEXFxcIlxcXCI1JjdcXHUwMTJFL1xceDk3Izs8L1xceDhFJDtEL1xceDg1JDtcXHhDNS98JCQlJDsnLyYjMCMqOycmJiYjLywjO1xceEM1LyMkK1xcXCIpKFxcXCInIyYnIzBDKiUkOycvJiMwIyo7JyYmJiMvLCM7XFx4QzUvIyQrXFxcIikoXFxcIicjJicjJi8sJDtFLyMkKyYpKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7dC4jICY7d1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEyRlxcXCJcXFwiNSU3XFx1MDEzMC81Izs8LywkO1xceEM3LyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO0kvJyA4ITpcXHUwMTMxISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEzMlxcXCJcXFwiNSY3XFx1MDEzMy86Izs8LzEkO0kvKCQ4IzpcXHUwMTM0IyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTM1XFxcIlxcXCI1JTdcXHUwMTM2L10jOzwvVCQlM1xcdTAxMzdcXFwiXFxcIjUkN1xcdTAxMzgvJiA4ITpcXHUwMTM5ISApLjQgJiUzXFx1MDEzQVxcXCJcXFwiNSU3XFx1MDEzQi8mIDghOlxcdTAxM0MhICkvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEzRFxcXCJcXFwiNSk3XFx1MDEzRS9SIzs8L0kkM1xcdTAxM0ZcXFwiXFxcIjUjN1xcdTAxNDAuLyAmM1xcdTAxNDFcXFwiXFxcIjUoN1xcdTAxNDIuIyAmOzYvKCQ4IzpcXHUwMTQzIyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTQ0XFxcIlxcXCI1IzdcXHUwMTQ1L1xceDkzIzs8L1xceDhBJDtEL1xceDgxJCU7XFx4Q0MvZSMkJTJEXFxcIlxcXCI2RDdFLywjO1xceENDLyMkK1xcXCIpKFxcXCInIyYnIzA8KiUyRFxcXCJcXFwiNkQ3RS8sIztcXHhDQy8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnIy8sJDtFLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE0NlxcXCJcXFwiNSg3XFx1MDE0Ny4vICYzXFx1MDE0OFxcXCJcXFwiNSQ3XFx1MDE0OS4jICY7Ni8nIDghOlxcdTAxNEEhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTs2L1kjJCU7QS8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhDRi9HIzsuLz4kO1xceENGLzUkOy4vLCQ7XFx4OTAvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7IS8mIzAjKjshJiYmIy8nIDghOlxcdTAxNEIhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhEMS9dIyQlO0EvLCM7XFx4RDEvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEQxLyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4XFxcIjpcXHUwMTRDXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OTkvXSMkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx1MDE0RFxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO0wuTyAmO1xceDk5LkkgJiU7QC5cXFwiICZcXFwiLzojO3QvMSQ7Py5cXFwiICZcXFwiLyMkKyMpKCMnIyhcXFwiJyMmJyMvXSMkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx1MDE0RVxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEQ0L10jJCU7Qi8sIztcXHhENS8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4RDUvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxcdTAxNEZcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5Ni8mIDghOlxcdTAxNTAhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxNTFcXFwiXFxcIjUoN1xcdTAxNTIvOiM7PC8xJDs2LygkOCM6XFx1MDE1MyMhICkoIycjKFxcXCInIyYnIy5nICYlM1xcdTAxNTRcXFwiXFxcIjUmN1xcdTAxNTUvOiM7PC8xJDs2LygkOCM6XFx1MDE1NiMhICkoIycjKFxcXCInIyYnIy46ICYlM1xcdTAxNTdcXFwiXFxcIjUqN1xcdTAxNTgvJiA4ITpcXHUwMTU5ISApLiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlOzYvayMkJTtBLzIjOzYvKSQ4XFxcIjpcXHUwMTVBXFxcIlxcXCIkICkoXFxcIicjJicjMDwqJTtBLzIjOzYvKSQ4XFxcIjpcXHUwMTVBXFxcIlxcXCIkICkoXFxcIicjJicjJi8pJDhcXFwiOlxcdTAxNUJcXFwiXFxcIiEgKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8nIDghOlxcdTAxNUMhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhEOC9ZIyQlO0EvLCM7XFx4RDgvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEQ4LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5OS9ZIyQlO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7IS8mIzAjKjshJiYmIy8nIDghOlxcdTAxNUQhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhEQi9ZIyQlO0IvLCM7XFx4REMvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceERDLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTVFXFxcIlxcXCI1JjdcXHUwMTVGLjsgJjNcXHUwMTYwXFxcIlxcXCI1JzdcXHUwMTYxLi8gJjNcXHUwMTYyXFxcIlxcXCI1KjdcXHUwMTYzLiMgJjs2LyYgOCE6XFx1MDE2NCEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE2NVxcXCJcXFwiNSY3XFx1MDE2Ni86Izs8LzEkO1xceERELygkOCM6XFx1MDE2NyMhICkoIycjKFxcXCInIyYnIy59ICYlM1xceEY1XFxcIlxcXCI1JzdcXHhGNi86Izs8LzEkO1xceDlFLygkOCM6XFx1MDE2OCMhICkoIycjKFxcXCInIyYnIy5QICYlM1xcdTAxNjlcXFwiXFxcIjUrN1xcdTAxNkEvOiM7PC8xJDtcXHg5RS8oJDgjOlxcdTAxNkIjISApKCMnIyhcXFwiJyMmJyMuIyAmO1xceEEwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiM1xcdTAxNkNcXFwiXFxcIjUrN1xcdTAxNkQuayAmM1xcdTAxNkVcXFwiXFxcIjUpN1xcdTAxNkYuXyAmM1xcdTAxNzBcXFwiXFxcIjUoN1xcdTAxNzEuUyAmM1xcdTAxNzJcXFwiXFxcIjUnN1xcdTAxNzMuRyAmM1xcdTAxNzRcXFwiXFxcIjUmN1xcdTAxNzUuOyAmM1xcdTAxNzZcXFwiXFxcIjUqN1xcdTAxNzcuLyAmM1xcdTAxNzhcXFwiXFxcIjUpN1xcdTAxNzkuIyAmOzZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7MS5cXFwiICZcXFwiXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSU7Ni9rIyQlO0EvMiM7Ni8pJDhcXFwiOlxcdTAxNUFcXFwiXFxcIiQgKShcXFwiJyMmJyMwPColO0EvMiM7Ni8pJDhcXFwiOlxcdTAxNUFcXFwiXFxcIiQgKShcXFwiJyMmJyMmLykkOFxcXCI6XFx1MDE1QlxcXCJcXFwiISApKFxcXCInIyYnIy5cXFwiICZcXFwiLycgOCE6XFx1MDE3QSEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO0wuIyAmO1xceDk5L10jJCU7Qi8sIztcXHhFMS8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4RTEvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxcdTAxN0JcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEI5LiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RTMvWSMkJTtBLywjO1xceEUzLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhFMy8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RUEvayM7Li9iJDtcXHhFRC9ZJCQlO0IvLCM7XFx4RTQvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEU0LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4RTUuOyAmO1xceEU2LjUgJjtcXHhFNy4vICY7XFx4RTguKSAmO1xceEU5LiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE3Q1xcXCJcXFwiNSM3XFx1MDE3RC86Izs8LzEkO1xceEYwLygkOCM6XFx1MDE3RSMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE3RlxcXCJcXFwiNSU3XFx1MDE4MC86Izs8LzEkO1QvKCQ4IzpcXHUwMTgxIyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTgyXFxcIlxcXCI1KDdcXHUwMTgzL0YjOzwvPSQ7XFxcXC4pICY7WS4jICY7WC8oJDgjOlxcdTAxODQjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxODVcXFwiXFxcIjUmN1xcdTAxODYvOiM7PC8xJDs2LygkOCM6XFx1MDE4NyMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE4OFxcXCJcXFwiNSU3XFx1MDE4OS9BIzs8LzgkJDshMCMqOyEmLygkOCM6XFx1MDE4QSMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RUIvRyM7Oy8+JDs2LzUkOzsvLCQ7XFx4RUMvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHg5MlxcXCJcXFwiNSM3XFx4RDMuIyAmOzYvJyA4ITpcXHUwMThCISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4QjFcXFwiXFxcIjUjN1xcdTAxOEMuRyAmM1xceEIzXFxcIlxcXCI1IzdcXHUwMThELjsgJjNcXHhCN1xcXCJcXFwiNSM3XFx1MDE4RS4vICYzXFx4QjVcXFwiXFxcIjUkN1xcdTAxOEYuIyAmOzYvJyA4ITpcXHUwMTkwISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RUUvRCMlO0MvLCM7XFx4RUYvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtVLikgJjtcXFxcLiMgJjtYLyYgOCE6XFx1MDE5MSEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlOyEuXFxcIiAmXFxcIi9bIzshLlxcXCIgJlxcXCIvTSQ7IS5cXFwiICZcXFwiLz8kOyEuXFxcIiAmXFxcIi8xJDshLlxcXCIgJlxcXCIvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjLycgOCE6XFx1MDE5MiEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTshLz8jOyEuXFxcIiAmXFxcIi8xJDshLlxcXCIgJlxcXCIvIyQrIykoIycjKFxcXCInIyYnIy8nIDghOlxcdTAxOTMhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEJFXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5RS9eIyQlO0IvLCM7XFx4RjMvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEYzLyMkK1xcXCIpKFxcXCInIyYnIyYvKCQ4XFxcIjpcXHUwMTk0XFxcIiEhKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4RjQuIyAmO1xceEEwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJcXHUwMTk1XFxcIlxcXCI2XFx1MDE5NTdcXHUwMTk2L0wjOzwvQyQyXFx1MDE5N1xcXCJcXFwiNlxcdTAxOTc3XFx1MDE5OC4pICYyXFx1MDE5OVxcXCJcXFwiNlxcdTAxOTk3XFx1MDE5QS8oJDgjOlxcdTAxOUIjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDlFL14jJCU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8oJDhcXFwiOlxcdTAxOUNcXFwiISEpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ni81IzswLywkO1xceEY3LyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkOzIuKSAmOzQuIyAmOy4wLyo7Mi4pICY7NC4jICY7LiZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkOyUwIyo7JSZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEZBLzsjMjhcXFwiXFxcIjY4NzkvLCQ7XFx4RkIvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE5RFxcXCJcXFwiNSU3XFx1MDE5RS4pICYzXFx1MDE5RlxcXCJcXFwiNSQ3XFx1MDFBMC8nIDghOlxcdTAxQTEhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhGQy9KIyUyOFxcXCJcXFwiNjg3OS8sIzteLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFxcXC4pICY7WC4jICY7XFx4ODIvJyA4ITpcXHUwMUEyISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXFwiLlMgJjshLk0gJjJGXFxcIlxcXCI2RjdHLkEgJjJKXFxcIlxcXCI2SjdLLjUgJjJIXFxcIlxcXCI2SDdJLikgJjJOXFxcIlxcXCI2TjdPXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMkxcXFwiXFxcIjZMN00uXFx4OTUgJjJCXFxcIlxcXCI2QjdDLlxceDg5ICYyPFxcXCJcXFwiNjw3PS59ICYyUlxcXCJcXFwiNlI3Uy5xICYyVFxcXCJcXFwiNlQ3VS5lICYyVlxcXCJcXFwiNlY3Vy5ZICYyUFxcXCJcXFwiNlA3US5NICYyQFxcXCJcXFwiNkA3QS5BICYyRFxcXCJcXFwiNkQ3RS41ICYyMlxcXCJcXFwiNjI3My4pICYyPlxcXCJcXFwiNj43P1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx1MDEwMC9iIzI4XFxcIlxcXCI2ODc5L1MkO1xceEZCL0okJTJcXHUwMUEzXFxcIlxcXCI2XFx1MDFBMzdcXHUwMUE0LywjO1xceEVDLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMUE1XFxcIlxcXCI1JTdcXHUwMUE2LikgJjNcXHUwMUE3XFxcIlxcXCI1JDdcXHUwMUE4LycgOCE6XFx1MDFBMSEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEIxXFxcIlxcXCI1IzdcXHhCMi42ICYzXFx4QjNcXFwiXFxcIjUjN1xceEI0LiogJiQ7KzAjKjsrJi8nIDghOlxcdTAxQTkhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHUwMTA0L1xceDg3IzJGXFxcIlxcXCI2RjdHL3gkO1xcdTAxMDMvbyQyRlxcXCJcXFwiNkY3Ry9gJDtcXHUwMTAzL1ckMkZcXFwiXFxcIjZGN0cvSCQ7XFx1MDEwMy8/JDJGXFxcIlxcXCI2RjdHLzAkO1xcdTAxMDUvJyQ4KTpcXHUwMUFBKSApKCknIygoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOyMvPiM7Iy81JDsjLywkOyMvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xcdTAxMDMvLCM7XFx1MDEwMy8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xcdTAxMDMvNSM7XFx1MDEwMy8sJDtcXHUwMTAzLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO3EvVCMkO20wIyo7bSYvRCQlOyAvLCM7XFx4RjgvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyXFx1MDFBQlxcXCJcXFwiNlxcdTAxQUI3XFx1MDFBQy4pICYyXFx1MDFBRFxcXCJcXFwiNlxcdTAxQUQ3XFx1MDFBRS93IzswL24kO1xcdTAxMDgvZSQkJTtCLzIjO1xcdTAxMDkuIyAmO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA8KiU7Qi8yIztcXHUwMTA5LiMgJjtcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceDk5LiMgJjtMXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJcXHUwMUFGXFxcIlxcXCI2XFx1MDFBRjdcXHUwMUIwLzUjOzwvLCQ7XFx1MDEwQS8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtEL1MjOywvSiQyOlxcXCJcXFwiNjo3Oy87JDssLiMgJjtULywkO0UvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpXG4gICAgXTtcbiAgICB2YXIgcGVnJGN1cnJQb3MgPSAwO1xuICAgIHZhciBwZWckc2F2ZWRQb3MgPSAwO1xuICAgIHZhciBwZWckcG9zRGV0YWlsc0NhY2hlID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dO1xuICAgIHZhciBwZWckbWF4RmFpbFBvcyA9IDA7XG4gICAgdmFyIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB2YXIgcGVnJHNpbGVudEZhaWxzID0gMDtcbiAgICB2YXIgcGVnJHJlc3VsdDtcbiAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlSW5kaWNlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwZWckc3RhcnRSdWxlSW5kZXggPSBwZWckc3RhcnRSdWxlSW5kaWNlc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24sIGxvY2F0aW9uMSkge1xuICAgICAgICBsb2NhdGlvbjEgPSBsb2NhdGlvbjEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBsb2NhdGlvbjFcbiAgICAgICAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLCBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksIGxvY2F0aW9uMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMSkge1xuICAgICAgICBsb2NhdGlvbjEgPSBsb2NhdGlvbjEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBsb2NhdGlvbjFcbiAgICAgICAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24xKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbih0ZXh0MSwgaWdub3JlQ2FzZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdGV4dDogdGV4dDEsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJGNsYXNzRXhwZWN0YXRpb24ocGFydHMsIGludmVydGVkLCBpZ25vcmVDYXNlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiY2xhc3NcIiwgcGFydHM6IHBhcnRzLCBpbnZlcnRlZDogaW52ZXJ0ZWQsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJGFueUV4cGVjdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImFueVwiIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRlbmRFeHBlY3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdO1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgaWYgKGRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHtcbiAgICAgICAgICAgICAgICBwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgICAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgbGluZTogZGV0YWlscy5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAocCA8IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgc3RhcnRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHN0YXJ0UG9zKTtcbiAgICAgICAgdmFyIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZDEpIHtcbiAgICAgICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24xKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSwgW10sIFwiXCIsIGxvY2F0aW9uMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihleHBlY3RlZDEsIGZvdW5kLCBsb2NhdGlvbjEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UoZXhwZWN0ZWQxLCBmb3VuZCksIGV4cGVjdGVkMSwgZm91bmQsIGxvY2F0aW9uMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRkZWNvZGUocykge1xuICAgICAgICByZXR1cm4gcy5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApIC0gMzI7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VSdWxlKGluZGV4KSB7XG4gICAgICAgIHZhciBiYyA9IHBlZyRieXRlY29kZVtpbmRleF07XG4gICAgICAgIHZhciBpcCA9IDA7XG4gICAgICAgIHZhciBpcHMgPSBbXTtcbiAgICAgICAgdmFyIGVuZCA9IGJjLmxlbmd0aDtcbiAgICAgICAgdmFyIGVuZHMgPSBbXTtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB3aGlsZSAoaXAgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJjW2lwXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCAtPSBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoLTIsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHVzaChzdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBiY1tpcCArIDFdLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhzdGFjay5wb3AoKSwgcGVnJGN1cnJQb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDIgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckY29uc3RzW2JjW2lwICsgMV1dLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRGQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGJjW2lwICsgMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBiYy5zbGljZShpcCArIDQsIGlwICsgNCArIGJjW2lwICsgM10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIHBdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBiY1tpcCArIDJdLCBiY1tpcCArIDJdLCBwZWckY29uc3RzW2JjW2lwICsgMV1dLmFwcGx5KG51bGwsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJHBhcnNlUnVsZShiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGNvZGU6IFwiICsgYmNbaXBdICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBlbmRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlwID0gaXBzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH1cbiAgICBvcHRpb25zLmRhdGEgPSB7fTsgLy8gT2JqZWN0IHRvIHdoaWNoIGhlYWRlciBhdHRyaWJ1dGVzIHdpbGwgYmUgYXNzaWduZWQgZHVyaW5nIHBhcnNpbmdcbiAgICBmdW5jdGlvbiBsaXN0KGhlYWQsIHRhaWwpIHtcbiAgICAgICAgcmV0dXJuIFtoZWFkXS5jb25jYXQodGFpbCk7XG4gICAgfVxuICAgIHBlZyRyZXN1bHQgPSBwZWckcGFyc2VSdWxlKHBlZyRzdGFydFJ1bGVJbmRleCk7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBwZWckZmFpbChwZWckZW5kRXhwZWN0YXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBlZyRtYXhGYWlsUG9zKSA6IG51bGwsIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgICAgICA/IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zICsgMSlcbiAgICAgICAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MpKTtcbiAgICB9XG59XG5leHBvcnRzLnBhcnNlID0gcGVnJHBhcnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuZXhwb3J0cy5EaWdlc3RBdXRoZW50aWNhdGlvbiA9IGNvcmVfMS5EaWdlc3RBdXRoZW50aWNhdGlvbjtcbmV4cG9ydHMuR3JhbW1hciA9IGNvcmVfMS5HcmFtbWFyO1xuZXhwb3J0cy5JbmNvbWluZ1JlcXVlc3QgPSBjb3JlXzEuSW5jb21pbmdSZXF1ZXN0TWVzc2FnZTtcbmV4cG9ydHMuSW5jb21pbmdSZXNwb25zZSA9IGNvcmVfMS5JbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeSA9IGNvcmVfMS5Mb2dnZXJGYWN0b3J5O1xuZXhwb3J0cy5OYW1lQWRkckhlYWRlciA9IGNvcmVfMS5OYW1lQWRkckhlYWRlcjtcbmV4cG9ydHMuT3V0Z29pbmdSZXF1ZXN0ID0gY29yZV8xLk91dGdvaW5nUmVxdWVzdE1lc3NhZ2U7XG5leHBvcnRzLlBhcnNlciA9IGNvcmVfMS5QYXJzZXI7XG5leHBvcnRzLlRpbWVycyA9IGNvcmVfMS5UaW1lcnM7XG5leHBvcnRzLlVSSSA9IGNvcmVfMS5VUkk7XG52YXIgQ2xpZW50Q29udGV4dF8xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29udGV4dFwiKTtcbmV4cG9ydHMuQ2xpZW50Q29udGV4dCA9IENsaWVudENvbnRleHRfMS5DbGllbnRDb250ZXh0O1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xuZXhwb3J0cy5DID0gQ29uc3RhbnRzXzEuQztcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG5leHBvcnRzLkRpYWxvZ1N0YXR1cyA9IEVudW1zXzEuRGlhbG9nU3RhdHVzO1xuZXhwb3J0cy5TZXNzaW9uU3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzO1xuZXhwb3J0cy5UeXBlU3RyaW5ncyA9IEVudW1zXzEuVHlwZVN0cmluZ3M7XG5leHBvcnRzLlVBU3RhdHVzID0gRW51bXNfMS5VQVN0YXR1cztcbnZhciBFeGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25zXCIpO1xuZXhwb3J0cy5FeGNlcHRpb25zID0gRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnM7XG52YXIgUHVibGlzaENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1B1Ymxpc2hDb250ZXh0XCIpO1xuZXhwb3J0cy5QdWJsaXNoQ29udGV4dCA9IFB1Ymxpc2hDb250ZXh0XzEuUHVibGlzaENvbnRleHQ7XG52YXIgUmVmZXJDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9SZWZlckNvbnRleHRcIik7XG5leHBvcnRzLlJlZmVyQ2xpZW50Q29udGV4dCA9IFJlZmVyQ29udGV4dF8xLlJlZmVyQ2xpZW50Q29udGV4dDtcbmV4cG9ydHMuUmVmZXJTZXJ2ZXJDb250ZXh0ID0gUmVmZXJDb250ZXh0XzEuUmVmZXJTZXJ2ZXJDb250ZXh0O1xudmFyIFJlZ2lzdGVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vUmVnaXN0ZXJDb250ZXh0XCIpO1xuZXhwb3J0cy5SZWdpc3RlckNvbnRleHQgPSBSZWdpc3RlckNvbnRleHRfMS5SZWdpc3RlckNvbnRleHQ7XG52YXIgU2VydmVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vU2VydmVyQ29udGV4dFwiKTtcbmV4cG9ydHMuU2VydmVyQ29udGV4dCA9IFNlcnZlckNvbnRleHRfMS5TZXJ2ZXJDb250ZXh0O1xudmFyIFNlc3Npb25fMSA9IHJlcXVpcmUoXCIuL1Nlc3Npb25cIik7XG5leHBvcnRzLkludml0ZUNsaWVudENvbnRleHQgPSBTZXNzaW9uXzEuSW52aXRlQ2xpZW50Q29udGV4dDtcbmV4cG9ydHMuSW52aXRlU2VydmVyQ29udGV4dCA9IFNlc3Npb25fMS5JbnZpdGVTZXJ2ZXJDb250ZXh0O1xuZXhwb3J0cy5TZXNzaW9uID0gU2Vzc2lvbl8xLlNlc3Npb247XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdWJzY3JpcHRpb25cIik7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbjtcbnZhciBUcmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL1RyYW5zcG9ydFwiKTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0XzEuVHJhbnNwb3J0O1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4vY29yZS90cmFuc2FjdGlvbnNcIik7XG52YXIgVHJhbnNhY3Rpb25zID0ge1xuICAgIEludml0ZUNsaWVudFRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbixcbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbjogdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sXG4gICAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLFxuICAgIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvblxufTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25zID0gVHJhbnNhY3Rpb25zO1xudmFyIFVBXzEgPSByZXF1aXJlKFwiLi9VQVwiKTtcbmV4cG9ydHMubWFrZVVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uRnJvbVVBID0gVUFfMS5tYWtlVXNlckFnZW50Q29yZUNvbmZpZ3VyYXRpb25Gcm9tVUE7XG5leHBvcnRzLlVBID0gVUFfMS5VQTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG5leHBvcnRzLlV0aWxzID0gVXRpbHNfMS5VdGlscztcbnZhciBXZWIgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9XZWIvaW5kZXhcIikpO1xuZXhwb3J0cy5XZWIgPSBXZWI7XG52YXIgdmVyc2lvbiA9IENvbnN0YW50c18xLkMudmVyc2lvbjtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG52YXIgbmFtZSA9IFwic2lwLmpzXCI7XG5leHBvcnRzLm5hbWUgPSBuYW1lO1xudmFyIENvcmUgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb3JlL2luZGV4XCIpKTtcbmV4cG9ydHMuQ29yZSA9IENvcmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTElCUkFSWV9WRVJTSU9OID0gXCIwLjE1LjExXCI7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBDZGN0c0RldmljZSB9IGZyb20gJy4vbGliL2NkY3RzLWRldmljZSc7XG5leHBvcnQgeyBDZGN0c0RldmljZSB9O1xuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdlczYtZXZlbnQtZW1pdHRlcic7XG5cbmV4cG9ydCBjbGFzcyBDZGN0c0NhbGwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIC8qKlxuICAqIENyZWF0ZSBhIENkY3RzQ2FsbC4gTm9ybWFsbHkgY3JlYXRlZCBieSBDZGN0c0RldmljZS5cbiAgKlxuICAqIE9uY2UgYSBjYWxsIGlzIGNyZWF0ZWQsIHlvdSBjYW4gZWl0aGVyIG1ha2UgYSBjYWxsIHdpdGggYG1ha2VDYWxsKClgXG4gICogb3Igc2V0IHlvdXJzZWxmIHVwIHRvIHJlY2lldmUgYW4gaW5jb21pbmcgY2FsbCB3aXRoIGBpbmNvbWluZ0NhbGwoKWBcbiAgKlxuICAqIEBwYXJhbSB7VUF9IFVBIC0gQSBTSVAuanMgVXNlciBBZ2VudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBpbnZpdGVVcmkgLSBBIFByb3Blcmx5IGZvcm1hdHRlZCBTSVAuanMgaW52aXRlIFVSSSAoY3JlYXRlIHdpdGggU0lQLlVSSSlcbiAgKlxuICAqIEBlbWl0cyBDZGN0c0NhbGwjY29ubmVjdGluZ1xuICAqL1xuICBjb25zdHJ1Y3RvcihVQSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbXV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXR1cyA9ICdzdGFydGluZyc7XG4gICAgdGhpcy5fY2FsbFR5cGUgPSAnJztcbiAgICB0aGlzLlVBID0gVUE7XG4gICAgdGhpcy5fZG9jQm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgdGhpcy5hdWRpb0VsZW1lbnQgPSBmYWxzZTtcblxuICAgIHRoaXMuVUEuc3RhcnQoKTtcblxuICB9XG5cbiAgLyoqXG4gICogTWFrZSBhIGNhbGwgdG8gYSBwaG9uZSBudW1iZXJcbiAgKlxuICAqIEBwYXJhbSB7VVJJfSBpbnZpdGVVcmkgLSBBIFNJUC5qcyBVUkkgdGhhdCBpbmNsdWRlcyB0aGUgcGhvbmUgbnVtYmVyIHRvIGNvbm5lY3QgdG9cbiAgKi9cbiAgbWFrZUNhbGwoaW52aXRlVXJpKSB7XG4gICAgdGhpcy5fY2FsbFR5cGUgPSAnb3V0Z29pbmcnO1xuICAgIHRoaXMuX3Nlc3Npb24gPSB0aGlzLlVBLmludml0ZShpbnZpdGVVcmksIHRoaXMuX2dldEF1ZGlvRWxlbWVudCgpKTtcbiAgICB0aGlzLl9hdHRhdGNoU2Vzc2lvbkV2ZW50cyh0aGlzLl9zZXNzaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB1cCB0byBoYW5kbGUgYW4gaW5jb21pbmcgY2FsbC5cbiAgKiBUaGUgY2FsbGluZyBmdW5jdGlvbiB3aWxsIHRoZW4gYmUgYWJsZSB0byBhY2NlcHQgb3IgcmVqZWN0IHRoZSBjYWxsLlxuICAqXG4gICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uIC0gQSBTSVAuanMgU2Vzc2lvbiwgc3BlY2lmaWNhbGx5IG9mIHRoZSBTSVAuU2VydmVyQ29udGV4dCB0eXBlXG4gICovXG4gIGluY29taW5nQ2FsbChzZXNzaW9uKSB7XG4gICAgdGhpcy5fY2FsbFR5cGUgPSAnaW5jb21pbmcnO1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuX2F0dGF0Y2hTZXNzaW9uRXZlbnRzKCk7XG4gIH1cblxuXG4gIF9nZXRBdWRpb0VsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLmF1ZGlvRWxlbWVudCkge1xuICAgICAgY29uc29sZS5sb2coXCJ0aGlzLmF1ZGlvRWxlbWVudFwiLCB0aGlzLmF1ZGlvRWxlbWVudClcbiAgICAgIHRoaXMuYXVkaW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgIHRoaXMuYXVkaW9FbGVtZW50LmNsYXNzTmFtZSA9ICdjZGN0cy1zaXBqcy1yZW1vdGUtYXVkaW8nO1xuICAgICAgdGhpcy5fZG9jQm9keS5hcHBlbmRDaGlsZCh0aGlzLmF1ZGlvRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF1ZGlvRWxlbWVudDtcbiAgfVxuXG4gIF9hdHRhdGNoU2Vzc2lvbkV2ZW50cyhzZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgKiBjb25uZWN0aW5nIGV2ZW50OlxuICAgICpcbiAgICAqIEZpcmVkIGFzIHRoZSBzeXN0ZW0gc3RhcnRzIHRvIG1ha2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgKiBUaGlzIGlzIGFmdGVyIHRoZSB1c2VyTWVkaWEgKG1pY3JvcGhvbmUpIGhhcyBiZWVuIGFxdWlyZWQuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCNjb25uZWN0aW5nXG4gICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcImNvbm5lY3RpbmdcIiwgKCkgPT4geyB0aGlzLnRyaWdnZXIoXCJjb25uZWN0aW5nXCIpOyB0aGlzLl9zdGF0dXMgPSAnaW5pdGlhdGluZyc7IH0pO1xuXG4gICAgLyoqXG4gICAgKiBwcm9ncmVzcyBldmVudDpcbiAgICAqXG4gICAgKiBVc3VhbGx5IGZpcmVkIHR3aWNlIGR1cmluZyBjYWxsIGludGlhbGl6YXRpb24sIG9uY2UgZm9yIFRSWUlORyBhbmQgb25jZSBmb3IgUklOR0lORy5cbiAgICAqXG4gICAgKiBAZXZlbnQgQ2RjdHNDYWxsI3Byb2dyZXNzXG4gICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IHJlc3BvbnNlIC0gRGV0YWlscyBvZiB0aGUgcmVzcG9uc2VcbiAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJwcm9ncmVzc1wiLCAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09IDE4MyAmJiByZXNwb25zZS5ib2R5ICYmIHRoaXMuX3Nlc3Npb24uaGFzT2ZmZXIgJiYgIXRoaXMuX3Nlc3Npb24uZGlhbG9nKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UuaGFzSGVhZGVyKCdyZXF1aXJlJykgfHwgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyZXF1aXJlJykuaW5kZXhPZignMTAwcmVsJykgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5oYXNEZXNjcmlwdGlvbihyZXNwb25zZS5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKSkge1xuICAgICAgICAgICAgLy8gQGhhY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMvaXNzdWVzLzI0MlxuICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbi5zdGF0dXMgPSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19FQVJMWV9NRURJQVxuICAgICAgICAgICAgLy8gdGhpcy5fd2FpdGluZ0ZvckFwcGx5aW5nQW5zd2VyKHNlc3Npb24sIHJlc3BvbnNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UpXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAqIGFjY2VwdGVkIGV2ZW50OlxuICAgICpcbiAgICAqIEZpcmVkIHdoZW4gdGhlIGNhbGwgd2FzIGFjY2VwdGVkIGJ5IHRoZSBjYWxsZWUuIFRoZSBjYWxsIGlzIG5vdyBjb25uZWN0ZWQuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCNhY2NlcHRlZFxuICAgICogQHR5cGUge29iamVjdH1cbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhIC0gRGV0YWlscyBvZiB0aGUgcmVzcG9uc2VcbiAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJhY2NlcHRlZFwiLCAoZGF0YSkgPT4geyB0aGlzLnRyaWdnZXIoXCJhY2NlcHRlZFwiLCBkYXRhKSwgdGhpcy5fc3RhdHVzID0gJ2Nvbm5lY3RlZCc7IH0pO1xuXG4gICAgLyoqXG4gICAgKiBkdG1mIGV2ZW50OlxuICAgICpcbiAgICAqIFNlbnQgd2hlbiB0aGUgdXNlciBoYXMgc3VjY2Vzc2Z1bGx5IHNlbnQgYSBEVE1GIChrZXlwYWQpIHNpZ25hbC5cbiAgICAqXG4gICAgKiBAZXZlbnQgQ2RjdHNDYWxsI2R0bWZcbiAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVxdWVzdCAtIERldGFpbHMgb2YgdGhlIHJlcXVlc3RcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkdG1mIC0gdGhlIGtleShzKSB0aGF0IHdlcmUgc3VibWl0dGVkXG4gICAgKi9cbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwiZHRtZlwiLCAocmVxdWVzdCwgZHRtZikgPT4gdGhpcy50cmlnZ2VyKFwiZHRtZlwiLCByZXF1ZXN0LCBkdG1mKSk7XG5cbiAgICAvKipcbiAgICAqIG11dGVkIGV2ZW50OlxuICAgICpcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHN5c3RlbSBoYXMgc3VjY2Vzc2Z1bGx5IHJlc3BvbmRlZCB0byBhIG11dGUgcmVxdWVzdC5cbiAgICAqXG4gICAgKiBAZXZlbnQgQ2RjdHNDYWxsI211dGVkXG4gICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgLSBEZXRhaWxzIG9mIHRoZSByZXNwb25zZVxuICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcIm11dGVkXCIsIChkYXRhKSA9PiB0aGlzLnRyaWdnZXIoXCJtdXRlZFwiLCBkYXRhKSk7XG5cbiAgICAvKipcbiAgICAqIHVubXV0ZWQgZXZlbnRcbiAgICAqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBzeXN0ZW0gaGFzIHN1Y2Nlc3NmdWxseSByZXNwb25kZWQgdG8gYW4gdW5tdXRlIHJlcXVlc3QuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCN1bm11dGVkXG4gICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgLSBEZXRhaWxzIG9mIHRoZSByZXNwb25zZVxuICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcInVubXV0ZWRcIiwgKGRhdGEpID0+IHRoaXMudHJpZ2dlcihcInVubXV0ZWRcIiwgZGF0YSkpO1xuXG4gICAgLyoqXG4gICAgKiBjYW5jZWwgZXZlbnQ6XG4gICAgKlxuICAgICogRmlyZWQgd2hlbiB0aGUgY2FsbCB3YXMgdGVybWluYXRlZCBiZWZvcmUgZW5kIHRvIGVuZCBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCxcbiAgICAqIHVzdWFsbHkgYnkgdGhlIHVzZXIncyByZXF1ZXN0LlxuICAgICpcbiAgICAqIEBldmVudCBDZGN0c0NhbGwjY2FuY2VsXG4gICAgKi9cbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwiY2FuY2VsXCIsICgpID0+IHsgdGhpcy50cmlnZ2VyKFwiY2FuY2VsXCIpOyB0aGlzLl9zdGF0dXMgPSAnZW5kZWQnIH0pO1xuXG4gICAgLyoqXG4gICAgKiByZWZlciBldmVudFxuICAgICpcbiAgICAqIEBldmVudCBDZGN0c0NhbGwjcmVmZXJcbiAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2VcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBuZXdTZXNzaW9uXG4gICAgKi9cbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwicmVmZXJcIiwgKGNhbGxiYWNrLCByZXNwb25zZSwgbmV3U2Vzc2lvbikgPT4geyB0aGlzLnRyaWdnZXIoXCJyZWplY3RlZFwiKTsgfSk7XG5cbiAgICAvKipcbiAgICAqIHJlcGxhY2VkIGV2ZW50XG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCNyZXBsYWNlZFxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IG5ld1Nlc3Npb25cbiAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJyZXBsYWNlZFwiLCAobmV3U2Vzc2lvbikgPT4geyB0aGlzLnRyaWdnZXIoXCJyZWplY3RlZFwiLCBuZXdTZXNzaW9uKTsgfSk7XG5cbiAgICAvKipcbiAgICAqIHJlamVjdGVkIGV2ZW50XG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCNyZWplY3RlZFxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IHJlc3BvbnNlXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gY2F1c2VcbiAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJyZWplY3RlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcInJlamVjdGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7IHRoaXMuX3N0YXR1cyA9ICdlbmRlZCcgfSk7XG5cbiAgICAvKipcbiAgICAqIGZhaWxlZCBldmVudFxuICAgICpcbiAgICAqIEBldmVudCBDZGN0c0NhbGwjZmFpbGVkXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2VcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjYXVzZVxuICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcImZhaWxlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpOyB0aGlzLl9zdGF0dXMgPSAnZW5kZWQnIH0pO1xuXG4gICAgLyoqXG4gICAgKiB0ZXJtaW5hdGVkIGV2ZW50XG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCN0ZXJtaW5hdGVkXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2VcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjYXVzZVxuICAgICovXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcInRlcm1pbmF0ZWRcIiwgKG1lc3NhZ2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcInRlcm1pbmF0ZWRcIiwgbWVzc2FnZSwgY2F1c2UpOyB0aGlzLl9zdGF0dXMgPSAnZW5kZWQnOyB9KTtcblxuICAgIC8qKlxuICAgICogYnllIGV2ZW50XG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCNieWVcbiAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJieWVcIiwgKCkgPT4geyB0aGlzLnRyaWdnZXIoXCJieWVcIik7IHRoaXMuX3N0YXR1cyA9ICdlbmRlZCcgfSk7XG5cbiAgICAvKipcbiAgICAqIHVzZXJNZWRpYVJlcXVlc3QgZXZlbnQ6XG4gICAgKlxuICAgICogRmlyZWQgd2hlbiB0aGUgZXZlcnkgdGltZSB0aGUgc3lzdGVtIGNoZWNrcyB0byBzZWUgaWYgaXQgaGFzIG1pY3JvcGhvbmUgcGVybWlzc2lvbiBmcm9tIHRoZSB1c2VyLlxuICAgICogWW91IGNhbiB1c2UgdGhpcyB0byBkZXRlY3Qgd2hlbiB0aGUgYnJvd3NlcidzIFwiQWxsb3cgd2Vic2l0ZSB0byB1c2UgbWljcm9waG9uZVwiIGRpYWxvZyBpcyBvcGVuLFxuICAgICogYnV0IHlvdSB3aWxsIG5lZWQgdG8gYmUgc29tZXdoYXQgY2FyZWZ1bC4gVGhpcyBldmVudCB3aWxsIGZpcmUgZXZlbiBpZiB0aGUgdXNlciBhbHJlYWR5IGhhc1xuICAgICogZ2l2ZW4gcGVybWlzc2lvbiwgdGhlbiB3aWxsIGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEge0BsaW5rIENkY3RzQ2FsbCN1c2VyTWVkaWF9IGV2ZW50LlxuICAgICogSWYgeW91IHdpc2ggdG8gaGF2ZSB5b3VyIFVJIGRpc3BsYXkgc29tZSBzb3J0IG9mIFwiYXNraW5nIGZvciBwZXJtaXNzaW9uXCIgZWxlbWVudCwgeW91IG1heSBuZWVkIHRvXG4gICAgKiBkZWJvdW5jZSB0aGlzIGV2ZW50OyBsaXN0ZW5pbmcgZm9yIHtAbGluayBDZGN0c0NhbGwjdXNlck1lZGlhfSB0byBjYW5jZWwgeW91ciBVSSB1cGRhdGUuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzQ2FsbCN1c2VyTWVkaWFSZXF1ZXN0XG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gY29uc3RyYWludHNcbiAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24ub24oJ3RyYWNrQWRkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICB2YXIgcGMgPSBzZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucGVlckNvbm5lY3Rpb247XG4gICAgICAgIC8vIHZhciB0aGlzLmF1ZGlvRWxlbWVudCA9IHRoaXMuYXVkaW9FbGVtZW50O1xuICAgICAgICAvLyB0aGlzLmF1ZGlvRWxlbWVudC5jbGFzc05hbWUgPSAnY2RjdHMtc2lwanMtcmVtb3RlLWF1ZGlvJztcbiAgICAgICAgdmFyIHJlbW90ZVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICBwYy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICAgIHJlbW90ZVN0cmVhbS5hZGRUcmFjayhyZWNlaXZlci50cmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb24ucGFzc2VkT3B0aW9ucy5zcmNPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2Vzc2lvbi5wYXNzZWRPcHRpb25zLnNyY09iamVjdCA9IHJlbW90ZVN0cmVhbTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbi5wYXNzZWRPcHRpb25zLm1velNyY09iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZXNzaW9uLnBhc3NlZE9wdGlvbnMubW96U3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uLnBhc3NlZE9wdGlvbnMuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlc3Npb24ucGFzc2VkT3B0aW9ucy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlbW90ZVN0cmVhbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGF0dGFjaGluZyBzdHJlYW0gdG8gZWxlbWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLnBhc3NlZE9wdGlvbnMucGxheSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwidXNlck1lZGlhUmVxdWVzdFwiLCAoY29uc3RyYWludHMpID0+IHt0aGlzLnRyaWdnZXIoXCJ1c2VyTWVkaWFSZXF1ZXN0XCIsIGNvbnN0cmFpbnRzKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogdXNlck1lZGlhIGV2ZW50OlxuICAgIC8vICpcbiAgICAvLyAqIEZpcmVkIHdoZW4gdGhlIHN5c3RlbSBoYXMgYXF1aXJlZCBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgbWljcm9waG9uZS4gVGhpcyB3aWxsIGhhcHBlbiBlaXRoZXJcbiAgICAvLyAqIGltbWVkaWF0ZWx5IGFmdGVyIHtAbGluayBDZGN0c0NhbGwjdXNlck1lZGlhUmVxdWVzdH0gaWYgdGhlIHVzZXIgaGFzIHByZXZpb3VzbHkgZ2l2ZW4gcGVybWlzc2lvblxuICAgIC8vICogb3IgYWZ0ZXIgdGhlIHVzZXIgYXBwcm92ZXMgdGhlIHJlcXVlc3QuXG4gICAgLy8gKlxuICAgIC8vICogQGV2ZW50IENkY3RzQ2FsbCN1c2VyTWVkaWFcbiAgICAvLyAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzdHJlYW1cbiAgICAvLyAqL1xuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwidXNlck1lZGlhXCIsIChzdHJlYW0pID0+IHt0aGlzLnRyaWdnZXIoXCJ1c2VyTWVkaWFcIiwgc3RyZWFtKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogdXNlck1lZGlhRmFpbGVkIGV2ZW50OlxuICAgIC8vICpcbiAgICAvLyAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVmdXNlcyBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgbWljcm9waG9uZS4gVGhlcmUgaXMgbm8gd2F5IGJhY2sgZnJvbSB0aGlzXG4gICAgLy8gKiBleGNlcHQgZm9yIHRoZSB1c2VyIHRvIGdvIGludG8gYnJvd3NlciBzZXR0aW5ncyBhbmQgcmVtb3ZlIHRoZSBleGNlcHRpb24gZm9yIHlvdXIgc2l0ZS5cbiAgICAvLyAqXG4gICAgLy8gKiBAZXZlbnQgQ2RjdHNDYWxsI3VzZXJNZWRpYUZhaWxlZFxuICAgIC8vICogQHByb3BlcnR5IHtvYmplY3R9IGVycm9yXG4gICAgLy8gKi9cbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcInVzZXJNZWRpYUZhaWxlZFwiLCAoZXJyb3IpID0+IHt0aGlzLnRyaWdnZXIoXCJ1c2VyTWVkaWFGYWlsZWRcIiwgZXJyb3IpO30pO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gKiBpY2VHYXRoZXJpbmcgZXZlbnRcbiAgICAvLyAqXG4gICAgLy8gKiBAZXZlbnQgQ2RjdHNDYWxsI2ljZUdhdGhlcmluZ1xuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VHYXRoZXJpbmdcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUdhdGhlcmluZ1wiKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogaWNlQ2FuZGlkYXRlIGV2ZW50XG4gICAgLy8gKlxuICAgIC8vICogQGV2ZW50IENkY3RzQ2FsbCNpY2VDYW5kaWRhdGVcbiAgICAvLyAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjYW5kaWRhdGVcbiAgICAvLyAqL1xuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiaWNlQ2FuZGlkYXRlXCIsIChjYW5kaWRhdGUpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDYW5kaWRhdGVcIiwgY2FuZGlkYXRlKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogaWNlR2F0aGVyaW5nQ29tcGxldGUgZXZlbnRcbiAgICAvLyAqXG4gICAgLy8gKiBAZXZlbnQgQ2RjdHNDYWxsI2ljZUdhdGhlcmluZ0NvbXBsZXRlXG4gICAgLy8gKi9cbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImljZUdhdGhlcmluZ0NvbXBsZXRlXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VHYXRoZXJpbmdDb21wbGV0ZVwiKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogaWNlQ29ubmVjdGlvbiBldmVudFxuICAgIC8vICpcbiAgICAvLyAqIEBldmVudCBDZGN0c0NhbGwjaWNlQ29ubmVjdGlvblxuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDb25uZWN0aW9uXCIpO30pO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gKiBpY2VDb25uZWN0aW9uQ2hlY2tpbmcgZXZlbnRcbiAgICAvLyAqXG4gICAgLy8gKiBAZXZlbnQgQ2RjdHNDYWxsI2ljZUNvbm5lY3Rpb25DaGVja2luZ1xuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uQ2hlY2tpbmdcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUNvbm5lY3Rpb25DaGVja2luZ1wiKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogaWNlQ29ubmVjdGlvbkNvbm5lY3RlZCBldmVudFxuICAgIC8vICpcbiAgICAvLyAqIEBldmVudCBDZGN0c0NhbGwjaWNlQ29ubmVjdGlvbkNvbm5lY3RlZFxuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uQ29ubmVjdGVkXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDb25uZWN0aW9uQ29ubmVjdGVkXCIpO30pO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gKiBpY2VDb25uZWN0aW9uQ29tcGxldGVkIGV2ZW50XG4gICAgLy8gKlxuICAgIC8vICogQGV2ZW50IENkY3RzQ2FsbCNpY2VDb25uZWN0aW9uQ29tcGxldGVkXG4gICAgLy8gKi9cbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImljZUNvbm5lY3Rpb25Db21wbGV0ZWRcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUNvbm5lY3Rpb25Db21wbGV0ZWRcIik7fSk7XG5cbiAgICAvLyAvKipcbiAgICAvLyAqIGljZUNvbm5lY3Rpb25GYWlsZWQgZXZlbnRcbiAgICAvLyAqXG4gICAgLy8gKiBAZXZlbnQgQ2RjdHNDYWxsI2ljZUNvbm5lY3Rpb25GYWlsZWRcbiAgICAvLyAqL1xuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiaWNlQ29ubmVjdGlvbkZhaWxlZFwiLCAoKSA9PiB7dGhpcy50cmlnZ2VyKFwiaWNlQ29ubmVjdGlvbkZhaWxlZFwiKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCBldmVudFxuICAgIC8vICpcbiAgICAvLyAqIEBldmVudCBDZGN0c0NhbGwjaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZFxuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXCIpO30pO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gKiBpY2VDb25uZWN0aW9uQ2xvc2VkIGV2ZW50XG4gICAgLy8gKlxuICAgIC8vICogQGV2ZW50IENkY3RzQ2FsbCNpY2VDb25uZWN0aW9uQ2xvc2VkXG4gICAgLy8gKi9cbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImljZUNvbm5lY3Rpb25DbG9zZWRcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUNvbm5lY3Rpb25DbG9zZWRcIik7fSk7XG5cbiAgICAvLyAvKipcbiAgICAvLyAqIGdldERlc2NyaXB0aW9uIGV2ZW50XG4gICAgLy8gKlxuICAgIC8vICogQGV2ZW50IENkY3RzQ2FsbCNnZXREZXNjcmlwdGlvblxuICAgIC8vICogQHByb3BlcnR5IHtvYmplY3R9IHNkcFdyYXBwZXJcbiAgICAvLyAqL1xuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiZ2V0RGVzY3JpcHRpb25cIiwgKHNkcFdyYXBwZXIpID0+IHt0aGlzLnRyaWdnZXIoXCJnZXREZXNjcmlwdGlvblwiLCBzZHBXcmFwcGVyKTt9KTtcblxuICAgIC8vIC8qKlxuICAgIC8vICogc2V0RGVzY3JpcHRpb24gZXZlbnRcbiAgICAvLyAqXG4gICAgLy8gKiBAZXZlbnQgQ2RjdHNDYWxsI3NldERlc2NyaXB0aW9uXG4gICAgLy8gKiBAcHJvcGVydHkge29iamVjdH0gc2RwV3JhcHBlclxuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJzZXREZXNjcmlwdGlvblwiLCAoc2RwV3JhcHBlcikgPT4ge3RoaXMudHJpZ2dlcihcInNldERlc2NyaXB0aW9uXCIsIHNkcFdyYXBwZXIpO30pO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gKiBkYXRhQ2hhbm5lbCBldmVudFxuICAgIC8vICpcbiAgICAvLyAqIEBldmVudCBDZGN0c0NhbGwjZGF0YUNoYW5uZWxcbiAgICAvLyAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhQ2hhbm5lbFxuICAgIC8vICovXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJkYXRhQ2hhbm5lbFwiLCAoZGF0YUNoYW5uZWwpID0+IHt0aGlzLnRyaWdnZXIoXCJkYXRhQ2hhbm5lbFwiLCBkYXRhQ2hhbm5lbCk7fSk7XG5cbiAgICAvLyAvKipcbiAgICAvLyAqIGFkZFN0cmVhbSBldmVudFxuICAgIC8vICpcbiAgICAvLyAqIEBldmVudCBDZGN0c0NhbGwjYWRkU3RyZWFtXG4gICAgLy8gKiBAcHJvcGVydHkge29iamVjdH0gc3RyZWFtXG4gICAgLy8gKi9cbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImFkZFN0cmVhbVwiLCAoc3RyZWFtKSA9PiB7IHRoaXMudHJpZ2dlcihcImFkZFN0cmVhbVwiLCBzdHJlYW0pOyB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBpbmNvbWluZyBjYWxsLlxuICAgKiBXaGVuIGEgY2FsbCBpcyByZWNlaXZlZCBgQ2RjdHNEZXZpY2VgIHdpbGwgY3JlYXRlIGEgbmV3IGBDZGN0c0NhbGxgIGZvciB0aGUgc2Vzc2lvblxuICAgKiBhbmQgZW1pdCBhIGBpbmNvbWluZ0ludml0ZWAgZXZlbnQuXG4gICAqIFRoZSBuZXcgYENkY3RzQ2FsbGAgaXMgcGFzc2VkIGFsb25nIHdpdGggdGhlIGV2ZW50LiBDYWxsIGBhY2NlcHQoKWAgdG8gYWNjZXB0IHRoZSBjYWxsLlxuICAgKi9cbiAgYW5zd2VyKCkge1xuICAgIGlmICh0aGlzLl9jYWxsVHlwZSAhPT0gJ2luY29taW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcihcImFjY2VwdCgpIG1ldGhvZCBpcyBvbmx5IHZhbGlkIG9uIGluY29taW5nIGNhbGxzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Nlc3Npb24uYWNjZXB0KHtcbiAgICAgIG1lZGlhOiB7XG4gICAgICAgIGNvbnN0cmFpbnRzOiB7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSxcbiAgICAgICAgcmVuZGVyOiB7IHJlbW90ZTogdGhpcy5fZ2V0QXVkaW9FbGVtZW50KCkgfVxuICAgICAgfSxcbiAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB7XG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgdmlkZW86IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcjogeyByZW1vdGU6IHRoaXMuX2dldEF1ZGlvRWxlbWVudCgpIH1cbiAgICAgIH1cblxuICAgIH0pO1xuICAgIHRoaXMuX2F0dGF0Y2hTZXNzaW9uRXZlbnRzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlamVjdCBhbiBpbmNvbWluZyBjYWxsLlxuICAgKiBXaGVuIGEgY2FsbCBpcyByZWNlaXZlZCBgQ2RjdHNEZXZpY2VgIHdpbGwgY3JlYXRlIGEgbmV3IGBDZGN0c0NhbGxgIGZvciB0aGUgc2Vzc2lvblxuICAgKiBhbmQgZW1pdCBhIGBpbmNvbWluZ0ludml0ZWAgZXZlbnQuXG4gICAqIFRoZSBuZXcgYENkY3RzQ2FsbGAgaXMgcGFzc2VkIGFsb25nIHdpdGggdGhlIGV2ZW50LiBDYWxsIGByZWplY3QoKWAgdG8gcmVqZWN0IHRoZSBjYWxsLlxuICAgKi9cbiAgcmVqZWN0KCkge1xuICAgIGlmICh0aGlzLl9jYWxsVHlwZSAhPT0gJ2luY29taW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcihcInJlamVjdCgpIG1ldGhvZCBpcyBvbmx5IHZhbGlkIG9uIGluY29taW5nIGNhbGxzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXNzaW9uLnJlamVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZXF1ZXN0IG9iamVjdCBjb250YWlucyBtZXRhZGF0YSBhYm91dCB0aGUgY3VycmVudCBzZXNzaW9uLFxuICAgKiBpbmNsdWRpbmcgdGhlIHdobyB0aGUgY2FsbCBpcyBnb2luZyBgdG9gIGFuZCBpbiB0aGUgY2FzZSBvZiBpbmNvbWluZyBjYWxscyxcbiAgICogd2hvIHRoZSBjYWxsIGlzIGNvbWluZyBgZnJvbWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gcmVxdWVzdFxuICAgKi9cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgaWYgKCF0aGlzLl9zZXNzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhbGxUeXBlID09PSAnaW5jb21pbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbi50cmFuc2FjdGlvbi5yZXF1ZXN0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2FsbFR5cGUgPT09ICdvdXRnb2luZycpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uLnJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBJcyB0aGUgY2FsbCBzdGlsbCBpbml0aWF0aW5nP1xuICAqXG4gICogQHJldHVybiB7Qm9vbGVhbn0gaXNJbml0aWF0aW5nXG4gICovXG4gIGlzSW5pdGlhdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSAnaW5pdGlhdGluZyc7XG4gIH1cblxuICAvKipcbiAgKiBIYXMgdGhlIGNhbGwgY29ubmVjdGVkP1xuICAqXG4gICogQHJldHVybiB7Qm9vbGVhbn0gaXNDb25uZWN0ZWRcbiAgKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gJ2Nvbm5lY3RlZCc7XG4gIH1cblxuICAvKipcbiAgKiBIYXMgdGhlIGNhbGwgZW5kZWQ/XG4gICpcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBpc0VuZGVkXG4gICovXG4gIGlzRW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gJ2VuZGVkJztcbiAgfVxuXG4gIC8qKlxuICAqIElzIHRoaXMgYW4gaW5jb21pbmcgY2FsbD9cbiAgKlxuICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzSW5jb21pbmdcbiAgKi9cbiAgaXNJbmNvbWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbFR5cGUgPT09ICdpbmNvbWluZyc7XG4gIH1cblxuICAvKipcbiAgKiBJcyB0aGlzIGFuIG91dGdvaW5nIGNhbGw/XG4gICpcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBpc091dGdvaW5nXG4gICovXG4gIGlzT3V0Z29pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxUeXBlID09PSAnb3V0Z29pbmcnO1xuICB9XG5cbiAgLyoqXG4gICogRW5kIHRoZSBzZXNzaW9uXG4gICpcbiAgKiBAZW1pdHMgQ2RjdHNDYWxsI3Rlcm1pbmF0ZWRcbiAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIHRoaXMuX3Nlc3Npb24udGVybWluYXRlKCk7XG4gIH1cblxuICAvKipcbiAgKiBTaHV0ZG93biB0aGUgY29ubmVjdGlvbiB0byB0aGUgV2ViUlRDIHNlcnZlcnNcbiAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIENkY3RzRGV2aWNlLnN0b3BXUyBpbnN0ZWFkLlxuICAqL1xuICBzaHV0ZG93bigpIHtcbiAgICB0aGlzLlVBLnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAqIFRvZ2dsZSBtdXRlXG4gICpcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTXV0ZSAtIGlmIHRydWUgeW91IHdhbnQgbXV0ZSB0byBiZSBPTlxuICAqL1xuICBtdXRlKGlzTXV0ZSAvKmJvb2wqLykge1xuICAgIHRoaXMuX211dGUgPSBpc011dGU7XG4gICAgaWYgKHRoaXMuX211dGUpIHtcbiAgICAgIHRoaXMuX3Nlc3Npb24ubXV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXNzaW9uLnVubXV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFRvZ2dsZSBob2xkXG4gICpcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSG9sZCAtIGlmIHRydWUgeW91IHdhbnQgbXV0ZSB0byBiZSBPTlxuICAqL1xuICBob2xkKGlzSG9sZCAvKmJvb2wqLykge1xuICAgIGlmIChpc0hvbGQpIHtcbiAgICAgIHRoaXMuX3Nlc3Npb24uaG9sZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXNzaW9uLnVuaG9sZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIEN1cnJlbnQgbXV0ZSBzdGF0ZVxuICAqXG4gICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBjYWxsIGlzIG9uIG11dGVcbiAgKi9cbiAgaXNNdXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXV0ZTtcbiAgfVxuXG4gIC8qKlxuICAqIFNlbmQgcGhvbmUga2V5cGFkIHByZXNzZXMgKERUTUYgdG9uZXMpXG4gICpcbiAgKiBVc2VkIGFmdGVyIHRoZSBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAqXG4gICogQHBhcmFtIHtzdHJpbmd9IGRpZ2l0cyAtIGEgc3RyaW5nIGNvbnRhaW5nIGRpZ2l0cyAwLTksICosICNcbiAgKiBAZW1pdHMgQ2RjdHNDYWxsI2R0bWZcbiAgKi9cbiAgc2VuZERpZ2l0cyhkaWdpdHMpIHtcbiAgICB0aGlzLl9zZXNzaW9uLmR0bWYoZGlnaXRzKTtcbiAgfVxuXG4gIC8qKlxuICAqIFNlbmQgcGhvbmUga2V5cGFkIHByZXNzZXMgKERUTUYgdG9uZXMpXG4gICpcbiAgKiBVc2VkIGFmdGVyIHRoZSBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAqXG4gICogQHBhcmFtIHtzdHJpbmd9IGRpZ2l0cyAtIGEgc3RyaW5nIGNvbnRhaW5nIGRpZ2l0cyAwLTksICosICNcbiAgKiBAZW1pdHMgQ2RjdHNDYWxsI2R0bWZcbiAgKi9cbiAgcmVmZXIoZGlnaXRzKSB7XG4gICAgdGhpcy5fc2Vzc2lvbi5yZWZlcihkaWdpdHMpO1xuICB9XG5cbiAgLyoqXG4gICogVGhlIFwic2ltcGxlXCIgc3RhdHVzLlxuICAqXG4gICogQWxsIG9mIHRoZSBtYW55IHBoYXNlcyBvZiB0aGUgY2FsbCBib2lsZWQgZG93biBpbnRvIDMgc3RhdGVzOiBJbml0aWF0aW5nLCBDb25uZWN0ZWQgYW5kIEVuZGVkLlxuICAqXG4gICogQHJldHVybiB7c3RyaW5nfSBvbmUgb2YgaW5pdGlhdGluZywgY29ubmVjdGVkLCBlbmRlZFxuICAqL1xuICBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuXG4gIF93YWl0aW5nRm9yQXBwbHlpbmdBbnN3ZXIoc2Vzc2lvbiwgcmVzcG9uc2UpIHtcbiAgICBsZXQgaSA9IDEsXG4gICAgICBjbGVhclRpbWVyXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgaSsrXG4gICAgICBjbGVhclRpbWVyID0gc2V0VGltZW91dChjaGVjaywgMTApXG4gICAgICBpZiAoc2Vzc2lvbiAmJiBzZXNzaW9uLmhhc0Fuc3dlciB8fCBpID4gMTQpIHtcbiAgICAgICAgaWYgKHNlc3Npb24uaGFzQW5zd2VyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGNsZWFyVGltZXIpXG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMTUpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoY2xlYXJUaW1lcilcbiAgICAgICAgICBzZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKGVycm9yKVxuICAgICAgICAgICAgc2Vzc2lvbi5mYWlsZWQocmVzcG9uc2UsIEMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTilcbiAgICAgICAgICAgIHNlc3Npb24udGVybWluYXRlKHsgc3RhdHVzQ29kZTogNDg4LCByZWFzb25fcGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJyB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxMClcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBVQSwgUmVmZXJDbGllbnRDb250ZXh0IH0gZnJvbSAnc2lwLmpzJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXM2LWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgQ2RjdHNDYWxsIH0gZnJvbSAnLi9jZGN0cy1jYWxsJztcblxuLyoqXG4qIFJlcHJlc2VudHMgdGhlIHNvZnR3YXJlIHBob25lIHJ1bm5pbmcgaW4gYSB3ZWIgYnJvd3NlciBvciBvdGhlciBjb250ZXh0LlxuKlxuKiBAY2xhc3NcbiovXG5jbGFzcyBDZGN0c0RldmljZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IENkY3RzRGV2aWNlLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIE9iamVjdFxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuaG9zdCBUaGUgaG9zdCBuYW1lIG9yIElQIGFkZHJlc3Mgb2YgdGhlIFNJUCBzZXJ2ZXJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnBvcnQgVGhlIHBvcnQgb2YgdGhlIFNJUCBzZXJ2ZXJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLndzU2VydmVycyBVUkkocykgb2YgdGhlIFdlYlNvY2tldCBTZXJ2ZXJzLiBGb3JtYXQgYHdzczovLzEyMy4wLjAuMDo1MDY2YC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyBpcyBhbHNvIGFjY2VwdGVkLlxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudXNlcm5hbWUgVGhlIHVzZXJuYW1lIGZvciB0aGUgU0lQIHNlcnZlclxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcucGFzc3dvcmQgVGhlIHBhc3N3ZW9yZCBmb3IgdGhlIFNJUCBzZXJ2ZXJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRpc3BsYXlOYW1lIFRoZSBodW1hbiByZWFkYWJsZSBuYW1lIHBhc3NlZCBpbiB0aGUgZnJvbSBmaWVsZC4gV2lsbCBiZSB1c2VkIGZvciBDYWxsZXIgSURcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnN0dW5TZXJ2ZXJzIFVSSShzKSBmb3IgaG93IHRvIGNvbm5lY3QgdG8gdGhlIFNUVU4gc2VydmVycy4gRm9ybWF0IGBzdHVuOnN0dW4uY2RjdHMuY29tOjgwMDBgLiBBbiBhcnJheSBvZiBzdHJpbmdzIGlzIGFsc28gYWNjZXB0ZWQuXG4gICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy50dXJuU2VydmVycyBEZXRhaWxzIGZvciBob3cgdG8gY29ubmVjdCB0byB0aGUgVFVSTiBzZXJ2ZXJzLiBBbiBhcnJheSBvZiBvYmplY3RzIGlzIGFsc28gYWNjZXB0ZWQuXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50dXJuU2VydmVycy51cmxzIFVSSShzKSBmb3IgdGhlIFRVUk4gc2VydmVyKHMpLiBGb3JtYXQgYHR1cm46dHVybi5jZGN0cy5jb206ODAwMD90cmFuc3BvcnQ9dGNwYC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyBpcyBhbHNvIGFjY2VwdGVkLlxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudHVyblNlcnZlcnMudXNlcm5hbWUgVXNlcm5hbWUgdG8gYXV0aGVudGljYXRlIG9uIFRVUk4gc2VydmVyKHMpXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50dXJuU2VydmVycy5wYXNzd29yZCBQYXNzd29yZCB0byBhdXRoZW50aWNhdGUgb24gVFVSTiBzZXJ2ZXIocylcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnJlZ2lzdHJhclNlcnZlciBVUkkgZm9yIHRoZSByZWdpc3RyYXIgU2VydmVyLiBGb3JtYXQgYHNpcDoxMjMuMC4wLjA6NTA2NmBcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZy50cmFjZVNpcCBJZiB0cnVlLCBTSVAgdHJhY2VzIHdpbGwgYmUgbG9nZ2VkIHRvIHRoZSBkZXYgY29uc29sZS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxvZ0xldmVsIE9uZSBvZiBcImRlYnVnXCIsIFwibG9nXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwib2ZmXCIuICBkZWZhdWx0IGlzIFwibG9nXCJcblxuICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghY29uZmlnIHx8IHR5cGVvZiAoY29uZmlnKSAhPT0gJ29iamVjdCcpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNkY3RzRGV2aWNlOiBNaXNzaW5nIGNvbmZpZ1wiKTsgfVxuICAgIGlmICghY29uZmlnLmhvc3QpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNkY3RzRGV2aWNlOiBNaXNzaW5nICdob3N0JyBwYXJhbWV0ZXJcIik7IH1cbiAgICBpZiAoIWNvbmZpZy5wb3J0KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDZGN0c0RldmljZTogTWlzc2luZyAncG9ydCcgcGFyYW1ldGVyXCIpOyB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIHRoaXMuaG9zdCA9IGNvbmZpZy5ob3N0O1xuICAgIHRoaXMucG9ydCA9IGNvbmZpZy5wb3J0O1xuICAgIHRoaXMudXJpID0gYHNpcDoke2NvbmZpZy51c2VybmFtZX1AJHtjb25maWcuaG9zdH1gO1xuICAgIHRoaXMucGF0aCA9IGNvbmZpZy5wYXRoIHx8ICcnO1xuICAgIHRoaXMud3NTZXJ2ZXJzID0gYXJyYXlpZnkoY29uZmlnLndzU2VydmVycyk7XG4gICAgdGhpcy51c2VybmFtZSA9IGNvbmZpZy51c2VybmFtZTtcbiAgICB0aGlzLnBhc3N3b3JkID0gY29uZmlnLnBhc3N3b3JkO1xuICAgIHRoaXMuZGlzcGxheU5hbWUgPSBjb25maWcuZGlzcGxheU5hbWUgfHwgY29uZmlnLnVzZXJuYW1lO1xuICAgIHRoaXMuc3R1blNlcnZlcnMgPSBhcnJheWlmeShjb25maWcuc3R1blNlcnZlcnMpO1xuICAgIHRoaXMudHVyblNlcnZlcnMgPSBjb25maWcudHVyblNlcnZlcnM7XG4gICAgdGhpcy5yZWdpc3RyYXJTZXJ2ZXIgPSBjb25maWcucmVnaXN0cmFyU2VydmVyO1xuXG4gICAgdGhpcy5fdXNlckFnZW50ID0gbnVsbDtcblxuICAgIHRoaXMuX2Vuc3VyZUNvbm5lY3Rpdml0eVdpdGhTaXBTZXJ2ZXIoKTtcblxuICAgIC8vIGxldCB1cmkgPSBuZXcgU0lQLlVSSShcInNpcFwiLCB0aGlzLnVzZXJuYW1lLCB0aGlzLmhvc3QsIHRoaXMucG9ydCkudG9TdHJpbmcoKTtcblxuICAgIGxldCBzaXBVQUNvbmZpZyA9IHtcbiAgICAgIHVyaTogYHNpcDoke3RoaXMudXNlcm5hbWV9QCR7dGhpcy5ob3N0fWAsXG4gICAgICB0cmFuc3BvcnRPcHRpb25zOiB7IHdzU2VydmVyczogW2B3c3M6Ly8ke3RoaXMuaG9zdH06JHt0aGlzLnBvcnR9JHt0aGlzLnBhdGh9YF0gfSxcbiAgICAgIGF1dGhvcml6YXRpb25Vc2Vyc2lwOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMucGFzc3dvcmQsXG4gICAgICBkaXNwbGF5TmFtZTogdGhpcy5kaXNwbGF5TmFtZSxcbiAgICAgIC8vIHN0dW5TZXJ2ZXJzOiB0aGlzLnN0dW5TZXJ2ZXJzLFxuICAgICAgLy8gdHVyblNlcnZlcnM6IHRoaXMudHVyblNlcnZlcnMsXG4gICAgICAvLyByZWdpc3RyYXJTZXJ2ZXI6IHRoaXMucmVnaXN0cmFyU2VydmVyXG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczoge1xuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNvbmZpZy50cmFjZVNpcCkge1xuICAgICAgc2lwVUFDb25maWcudHJhY2VTaXAgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmxvZ0xldmVsKSB7XG4gICAgICBpZiAoY29uZmlnLmxvZ0xldmVsID09PSBcIm9mZlwiKSB7XG4gICAgICAgIHNpcFVBQ29uZmlnLmxvZyA9IHsgYnVpbHRpbkVuYWJsZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXBVQUNvbmZpZy5sb2cgPSB7IGxldmVsOiBjb25maWcubG9nTGV2ZWwgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXNlckFnZW50ID0gbmV3IFVBKHNpcFVBQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICogd3NDb25uZWN0aW5nIGV2ZW50XG4gICAgKlxuICAgICogRmlyZWQgd2hlbiB0aGUgZGV2aWNlIGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gdGhlIFdlYlNvY2tldCBzZXJ2ZXIuXG4gICAgKiBJZiB0aGUgY29ubmVjdGlvbiBkcm9wcywgdGhlIGRldmljZSB3aWxsIHRyeSB0byByZWNvbm5lY3QgYW5kIHRoaXMgZXZlbnQgd2lsbCBmaXJlIGFnYWluLlxuICAgICpcbiAgICAqIEBldmVudCBDZGN0c0RldmljZSN3c0Nvbm5lY3RpbmdcbiAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gYXR0ZW1wdHMgLSB0aGUgbnVtYmVyIG9mIGNvbm5lY3Rpb24gYXR0ZW1wdHMgdGhhdCBoYXZlIGJlZW4gbWFkZVxuICAgICovXG4gICAgdGhpcy5fdXNlckFnZW50Lm9uKFwiY29ubmVjdGluZ1wiLCAoYXJncykgPT4geyB0aGlzLnRyaWdnZXIoXCJ3c0Nvbm5lY3RpbmdcIiwgeyBhdHRlbXB0czogYXJncy5hdHRlbXB0cyB9KTsgfSk7XG5cbiAgICAvKipcbiAgICAqIHdzQ29ubmVjdGVkIGV2ZW50XG4gICAgKlxuICAgICogRmlyZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzRGV2aWNlI3dzQ29ubmVjdGVkXG4gICAgKi9cbiAgICB0aGlzLl91c2VyQWdlbnQub24oXCJjb25uZWN0ZWRcIiwgKCkgPT4geyB0aGlzLnRyaWdnZXIoXCJ3c0Nvbm5lY3RlZFwiKTsgfSk7XG5cbiAgICAvKipcbiAgICAqIHdzRGlzY29ubmVjdGVkIGV2ZW50XG4gICAgKlxuICAgICogRnJpZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlscy5cbiAgICAqXG4gICAgKiBAZXZlbnQgQ2RjdHNEZXZpY2Ujd3NEaXNjb25uZWN0ZWRcbiAgICAqL1xuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcImRpc2Nvbm5lY3RlZFwiLCAoKSA9PiB7IHRoaXMudHJpZ2dlcihcIndzRGlzY29ubmVjdGVkXCIpOyB9KTtcblxuICAgIC8qKlxuICAgICogcmVnaXN0ZXJlZCBldmVudFxuICAgICpcbiAgICAqIEZpcmVkIHdoZW4gYSB0aGUgZGV2aWNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIHRvIHJlY2lldmUgY2FsbHMuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzRGV2aWNlI3JlZ2lzdGVyZWRcbiAgICAqL1xuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcInJlZ2lzdGVyZWRcIiwgKCkgPT4geyB0aGlzLnRyaWdnZXIoXCJyZWdpc3RlcmVkXCIpOyB9KTtcblxuICAgIC8qKlxuICAgICogdW5yZWdpc3RlcmVkIGV2ZW50XG4gICAgKlxuICAgICogRmlyZWQgYXMgdGhlIHJlc3VsdCBvZiBhIGNhbGwgdG8gYHVucmVnaXN0ZXIoKWAgb3IgaWYgYSBwZXJpb2RpYyByZS1yZWdpc3RyYXRpb24gZmFpbHMuXG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzRGV2aWNlI3VucmVnaXN0ZXJlZFxuICAgICogQHR5cGUge29iamVjdH1cbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjYXVzZSAtIG51bGwgaWYgYHVucmVnaXN0ZXIoKWAgd2FzIGNhbGxlZCwgb3RoZXJ3aXNlIHNlZSBbU0lQanMgY2F1c2VzXXtAbGluayBodHRwOi8vc2lwanMuY29tL2FwaS8wLjE1LjAvY2F1c2VzL31cbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSByZXNwb25zZSAtIFRoZSBTSVAgbWVzc2FnZSB3aGljaCBjYXVzZWQgdGhlIGZhaWx1cmUsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcInVucmVnaXN0ZXJlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJ1bnJlZ2lzdGVyZWRcIiwgeyBjYXVzZTogY2F1c2UsIHJlc3BvbnNlOiByZXNwb25zZSB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICogcmVnaXN0cmF0aW9uRmFpbGVkIGV2ZW50XG4gICAgKlxuICAgICogRmlyZWQgd2hlbiBhIHJlZ2lzdHJhdGlvbiBhdHRlcG10IGZhaWxzLlxuICAgICpcbiAgICAqIEBldmVudCBDZGN0c0RldmljZSNyZWdpc3RyYXRpb25GYWlsZWRcbiAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gY2F1c2UgLSBzZWUgW1NJUGpzIGNhdXNlc117QGxpbmsgaHR0cDovL3NpcGpzLmNvbS9hcGkvMC4xNS4wL2NhdXNlcy99XG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2UgLSBUaGUgU0lQIG1lc3NhZ2Ugd2hpY2ggY2F1c2VkIHRoZSBmYWlsdXJlLCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICB0aGlzLl91c2VyQWdlbnQub24oXCJyZWdpc3RyYXRpb25GYWlsZWRcIiwgKGNhdXNlLCByZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKFwicmVnaXN0cmF0aW9uRmFpbGVkXCIsIHsgY2F1c2U6IGNhdXNlLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAqIGluY29taW5nSW52aXRlIGV2ZW50XG4gICAgKlxuICAgICogRmlyZWQgd2hlbiB0aGUgZGV2aWNlIHJlY2lldmVzIGFuIElOVklURSByZXF1ZXN0XG4gICAgKiBAZXZlbnQgQ2RjdHNEZXZpY2UjaW52aXRlXG4gICAgKiBAdHlwZSB7U2Vzc2lvbn1cbiAgICAqL1xuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcImludml0ZVwiLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgdGhpcy5fYWN0aXZlQ2FsbCA9IG5ldyBDZGN0c0NhbGwodGhpcy5fdXNlckFnZW50KTtcbiAgICAgIHRoaXMuX2FjdGl2ZUNhbGwuaW5jb21pbmdDYWxsKHNlc3Npb24pO1xuICAgICAgdGhpcy50cmlnZ2VyKFwiaW52aXRlXCIsIHtcbiAgICAgICAgaWQ6IHNlc3Npb24uaWQsXG4gICAgICAgIHBob25lTnVtYmVyOiBzZXNzaW9uLnJlbW90ZUlkZW50aXR5Ll9kaXNwbGF5TmFtZSxcbiAgICAgICAgc3RhdHVzOiBzZXNzaW9uLnN0YXR1cyxcbiAgICAgICAgdHlwZTogJ2luY29taW5nJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgKiBtZXNzYWdlIGV2ZW50XG4gICAgKlxuICAgICogQGV2ZW50IENkY3RzRGV2aWNlI21lc3NhZ2VcbiAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gbWVzc2FnZSAtIENvbnRhaW5zIHRoZSBTSVAgbWVzc2FnZSBzZW50IGFuZCBzZXJ2ZXIgY29udGV4dCBuZWNlc3NhcnkgdG8gcmVjZWl2ZSBhbmQgc2VuZCByZXBsaWVzLlxuICAgICovXG4gICAgdGhpcy5fdXNlckFnZW50Lm9uKFwibWVzc2FnZVwiLCAobWVzc2FnZSkgPT4geyB0aGlzLnRyaWdnZXIoXCJtZXNzYWdlXCIsIHsgbWVzc2FnZTogbWVzc2FnZSB9KTsgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAqIFN0YXJ0IHRoZSBjb25uZWN0aW9uIHRvIHRoZSBXZWJTb2NrZXQgc2VydmVyLCBhbmQgcmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgaWYgc3RvcHBlZC5cbiAgKiBZb3UgbmVlZCB0byBzdGFydCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYmVmb3JlIHlvdSBjYW4gc2VuZCBvciByZWNpZXZlIGNhbGxzLiBJZiB5b3VcbiAgKiB0cnkgdG8gYGluaXRpYXRlQ2FsbGAgd2l0aG91dCBmaXJzdCBzdGFydGluZyB0aGUgY29ubmVjdGlvbiwgaXQgd2lsbCBiZSBzdGFydGVkIGZvciB5b3UsXG4gICogYnV0IGl0IHdpbGwgbm90IGJlIHN0b3BwZWQgd2hlbiB0aGUgY2FsbCBpcyB0ZXJtaW5hdGVkLlxuICAqL1xuICBzdGFydFdTKCkge1xuICAgIHRoaXMuX3VzZXJBZ2VudC5zdGFydCgpO1xuICB9XG5cbiAgLyoqXG4gICogU3RvcCB0aGUgY29ubmVjdGlvbiB0byB0aGUgV2ViU29ja2V0IHNlcnZlciwgc2F2aW5nIHRoZSBzdGF0ZSBzbyBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXJcbiAgKiAoYnkgYHN0YXJ0YCkuXG4gICovXG4gIHN0b3BXUygpIHtcbiAgICB0aGlzLl91c2VyQWdlbnQuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICogU3RhdHVzIG9mIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAqXG4gICogQHJldHVybiB7Qm9vbGVhbn0gaXNDb25uZWN0ZWQgYHRydWVgIGlmIHRoZSBkZXZpY2UgaXMgY29ubmVjdGVkIHRvIHRoZSBXZWJTb2NrZXQgc2VydmVyLCBgZmFsc2VgIG90aGVyd2lzZVxuICAqL1xuICBpc1dTQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyQWdlbnQuaXNDb25uZWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAqIFJlZ2lzdGVyIHRoZSBkZXZpY2Ugd2l0aCB0aGUgU0lQIHNlcnZlciBzbyB0aGF0IGl0IGNhbiByZWNlaXZlIGluY29taW5nIGNhbGxzLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRpb25zLmV4dHJhSGVhZGVycyBTSVAgaGVhZGVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gZWFjaCBSRUdJU1RFUiByZXF1ZXN0LiBFYWNoIGhlYWRlciBpcyBzdHJpbmcgaW4gdGhlIGZvcm1hdCBgXCJYLUhlYWRlci1OYW1lOiBIZWFkZXItdmFsdWVcImAuXG4gICogQGVtaXRzIENkY3RzRGV2aWNlI3JlZ2lzdGVyZWRcbiAgKi9cbiAgcmVnaXN0ZXIob3B0aW9ucykge1xuICAgIHRoaXMuX3VzZXJBZ2VudC5yZWdpc3RlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAqIFVucmVnaXN0ZXIgdGhlIGRldmljZSBmcm9tIHRoZSBTSVAgc2VydmVyOyBpdCB3aWxsIG5vIGxvbmdlciByZWNpZXZlIGluY29taW5nIGNhbGxzLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuYWxsIFtPcHRpb25hbF0gLSBpZiBzZXQgJiBgdHJ1ZWAgaXQgd2lsbCB1bnJlZ2lzdGVyICphbGwqIGJpbmRpbmdzIGZvciB0aGUgU0lQIHVzZXIuXG4gICogQHBhcmFtIHtTdHJpbmdbXX0gb3B0aW9ucy5leHRyYUhlYWRlcnMgU0lQIGhlYWRlcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIGVhY2ggUkVHSVNURVIgcmVxdWVzdC4gRWFjaCBoZWFkZXIgaXMgc3RyaW5nIGluIHRoZSBmb3JtYXQgYFwiWC1IZWFkZXItTmFtZTogSGVhZGVyLXZhbHVlXCJgLlxuICAqIEBlbWl0cyBDZGN0c0RldmljZSN1bnJlZ2lzdGVyZWRcbiAgKi9cbiAgdW5yZWdpc3RlcihvcHRpb25zKSB7XG4gICAgdGhpcy5fdXNlckFnZW50LnJlZ2lzdGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICogU3RhdHVzIG9mIFNJUCByZWdpc3RyYXRpb25cbiAgKlxuICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzUmVnaXN0ZXJlZCBgdHJ1ZWAgaWYgdGhlIGRldmljZSBpcyByZWdpc3RlcmVkIHdpdGggdGhlIFNJUCBTZXJ2ZXIsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICovXG4gIGlzUmVnaXN0ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckFnZW50LmlzUmVnaXN0ZXJlZCgpO1xuICB9XG5cbiAgLyoqXG4gICogTWFrZSBhIHBob25lIGNhbGxcbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBwaG9uZU51bWJlciBUaGUgZGVzaW5hdGlvbiBwaG9uZSBudW1iZXIgdG8gY29ubmVjdCB0by4gSnVzdCBkaWdpdHMsIG5vIHB1bmN0dWF0aW9uLiBFeGFtcGxlIGBcIjEyMDY1NTUxMTExXCJgLlxuICAqIEByZXR1cm4ge0NkY3RzQ2FsbH0gYWN0aXZlQ2FsbCBLZWVwIGFuIGV5ZSBvbiB0aGUgY2FsbCdzIHN0YXRlIGJ5IGxpc3RlbmluZyB0byBldmVudHMgZW1pdHRlZCBieSBhY3RpdmVDYWxsXG4gICovXG4gIGluaXRpYXRlQ2FsbChwaG9uZU51bWJlcikge1xuICAgIC8vIGxldCB1cmkgPSBuZXcgU0lQLlVSSShcInNpcFwiLCBwaG9uZU51bWJlciwgdGhpcy5ob3N0LCB0aGlzLnBvcnQpLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5fYWN0aXZlQ2FsbCA9IG5ldyBDZGN0c0NhbGwodGhpcy5fdXNlckFnZW50KTtcbiAgICB0aGlzLl9hY3RpdmVDYWxsLm1ha2VDYWxsKHBob25lTnVtYmVyKVxuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJjYW5jZWxcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwiY2FuY2VsXCIsIGRhdGEpIH0pO1xuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJieWVcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwiYnllXCIsIGRhdGEpIH0pO1xuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJyZXBsYWNlZFwiLCAoZGF0YSkgPT4geyB0aGlzLnRyaWdnZXIoXCJyZXBsYWNlZFwiLCBkYXRhKSB9KTtcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwiZmFpbGVkXCIsIChyZXNwb25zZSwgY2F1c2UpID0+IHsgdGhpcy50cmlnZ2VyKFwiZmFpbGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7IH0pO1xuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJyZWplY3RlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcInJlamVjdGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7IH0pO1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVDYWxsO1xuICB9XG4gIC8qKlxuICAqIEFuc3dlciBwaG9uZSBjYWxsXG4gICpcbiAgKiBAcmV0dXJuIHtDZGN0c0NhbGx9IGFjdGl2ZUNhbGwgS2VlcCBhbiBleWUgb24gdGhlIGNhbGwncyBzdGF0ZSBieSBsaXN0ZW5pbmcgdG8gZXZlbnRzIGVtaXR0ZWQgYnkgYWN0aXZlQ2FsbFxuICAqL1xuICBhY2NlcHQoKSB7XG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5hY2NlcHQoKVxuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oJ3RyYWNrQWRkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGMgPSB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucGVlckNvbm5lY3Rpb247XG4gICAgICAvLyB2YXIgdGhpcy5hdWRpb0VsZW1lbnQgPSB0aGlzLmF1ZGlvRWxlbWVudDtcbiAgICAgIHZhciBwbGF5ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiY2RjdHMtc2lwanMtcmVtb3RlLWF1ZGlvXCIpWzBdO1xuICAgICAgLy8gdGhpcy5hdWRpb0VsZW1lbnQuY2xhc3NOYW1lID0gJ2NkY3RzLXNpcGpzLXJlbW90ZS1hdWRpbyc7XG4gICAgICB2YXIgcmVtb3RlU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICBwYy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICByZW1vdGVTdHJlYW0uYWRkVHJhY2socmVjZWl2ZXIudHJhY2spO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIHBsYXllci5zcmNPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBsYXllci5zcmNPYmplY3QgPSByZW1vdGVTdHJlYW07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbGF5ZXIubW96U3JjT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwbGF5ZXIubW96U3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGxheWVyLnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGxheWVyLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVtb3RlU3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBhdHRhY2hpbmcgc3RyZWFtIHRvIGVsZW1lbnQuJyk7XG4gICAgICB9XG4gICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNhbGw7XG4gICAgfSlcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwiY2FuY2VsXCIsIChkYXRhKSA9PiB7IHRoaXMudHJpZ2dlcihcImNhbmNlbFwiLCBkYXRhKSB9KTtcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwiYnllXCIsIChkYXRhKSA9PiB7IHRoaXMudHJpZ2dlcihcImJ5ZVwiLCBkYXRhKSB9KTtcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwicmVwbGFjZWRcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwicmVwbGFjZWRcIiwgZGF0YSkgfSk7XG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5vbihcImZhaWxlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpOyB9KTtcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwicmVqZWN0ZWRcIiwgKHJlc3BvbnNlLCBjYXVzZSkgPT4geyB0aGlzLnRyaWdnZXIoXCJyZWplY3RlZFwiLCByZXNwb25zZSwgY2F1c2UpOyB9KTtcbiAgICB0aGlzLnRyaWdnZXIoXCJhY2NlcHRlZFwiLCB7XG4gICAgICBpZDogdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5pZCxcbiAgICAgIHBob25lTnVtYmVyOiB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLnJlbW90ZUlkZW50aXR5LmRpc3BsYXlOYW1lLFxuICAgICAgc3RhcnRUaW1lOiB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLnN0YXJ0VGltZSA/IHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24uc3RhcnRUaW1lIDogbmV3IERhdGUoKSxcbiAgICAgIHN0YXR1czogdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5zdGF0dXMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGwgY3VycmVudGx5IGluIHByb2dyZXNzXG4gICpcbiAgKiBAcmV0dXJuIHtDZGN0c0NhbGx9IGFjdGl2ZUNhbGwgS2VlcCBhbiBleWUgb24gdGhlIGNhbGwncyBzdGF0ZSBieSBsaXN0ZW5pbmcgdG8gZXZlbnRzIGVtaXR0ZWQgYnkgYWN0aXZlQ2FsbFxuICAqL1xuICBhY3RpdmVDYWxsKCkgeyByZXR1cm4gdGhpcy5fYWN0aXZlQ2FsbDsgfVxuXG4gIC8qKlxuICAgKiBSZWZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGhvbmVOdW1iZXIgVGhlIHBob25lbnVtYmVyIGNhbiB0byByZWZlclxuICAgKi9cbiAgcmVmZXJOdW1iZXIocGhvbmVOdW1iZXIpIHtcbiAgICB0aGlzLl9yZWZlciA9IG5ldyBSZWZlckNsaWVudENvbnRleHQodGhpcy5fdXNlckFnZW50LCB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLCBwaG9uZU51bWJlcilcbiAgICB0aGlzLl9yZWZlci5yZWZlcigpXG4gICAgcmV0dXJuIHRoaXMuX3JlZmVyXG4gIH1cblxuICAvKipcbiAgICogaXNNdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTXV0ZWQgVGhlIGlzTXV0ZWQgY2FuIHRvIHJlZmVyXG4gICAqL1xuICBtdXRlKGlzTXV0ZSkge1xuICAgIHZhciBwYyA9IHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICB2YXIgYXVkaW9UcmFja3MgPSBwYy5nZXRMb2NhbFN0cmVhbXMoKVswXS5nZXRBdWRpb1RyYWNrcygpO1xuXG4gICAgLy8gaWYgTWVkaWFTdHJlYW0gaGFzIHJlZmVyZW5jZSB0byBtaWNyb3Bob25lXG4gICAgaWYgKGF1ZGlvVHJhY2tzWzBdKSB7XG4gICAgICBhdWRpb1RyYWNrc1swXS5lbmFibGVkID0gIWlzTXV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBjXG4gIH1cblxuICAvKipcbiAgICogaXNIb2xkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNIb2xkIFRoZSBpc011dGVkIGNhbiB0byByZWZlclxuICAgKi9cbiAgaG9sZChpc0hvbGQpIHtcbiAgICBpZiAoaXNIb2xkKSB7XG4gICAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLmhvbGQoKVxuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb25cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi51bmhvbGQoKVxuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb25cbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBFbmQgdGhlIHNlc3Npb25cbiAgKlxuICAqIEBlbWl0cyBUZWxueXhDYWxsI3Rlcm1pbmF0ZWRcbiAgKi9cbiAgcmVqZWN0KCkge1xuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24udGVybWluYXRlKCk7XG4gIH1cblxuXG4gIC8vIEVuc3VyZSB0aGF0IHdlIGNhbiBjb25uZWN0IHRvIHRoZSBTSVAgc2VydmVyLlxuICAvLyBEdWUgdG8gYSBidWcgaW4gY2hyb21lLCB3ZSBuZWVkIHRvIG9wZW4gYW4gaHR0cCBjb25uZWN0aW9uIHRvIHRoZSBTSVAgc2VydmVyXG4gIC8vIGJlZm9yZSB0cnlpbmcgdG8gY29ubmVjdCB2aWEgV2ViIFNvY2tldC5cbiAgLy9cbiAgLy8gIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMyOTg4NFxuICBfZW5zdXJlQ29ubmVjdGl2aXR5V2l0aFNpcFNlcnZlcigpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkZhaWxlZCBodHRwIGNvbm5lY3Rpb24gdG8gU0lQIHNlcnZlciBpcyBleHBlY3RlZC4gSXQgaXMgcmVsYXRlZCB0byBhIGNocm9tZSBidWcuXCIpO1xuICAgICAgfSk7XG4gICAgICB4aHIub3BlbihcIkdFVFwiLCBgaHR0cHM6Ly8ke3RoaXMuaG9zdH06JHt0aGlzLnBvcnR9YCwgdHJ1ZSk7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcuIElmIGFuIGVycm9yIG9jY3VycywgaXQncyBub3QgZ29pbmcgdG8gbWF0dGVyIGhlcmUuXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5aWZ5KGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICByZXR1cm4gaXRlbS5zbGljZSgwKTsgLy8gU2hhbGxvdyBDb3B5XG4gIH0gZWxzZSB7XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBhcnI7XG4gIH1cbn1cblxuXG5leHBvcnQgeyBDZGN0c0RldmljZSB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==